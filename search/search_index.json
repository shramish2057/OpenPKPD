{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenPKPD Documentation","text":"<p>OpenPKPD is a transparent, validated pharmacokinetics and pharmacodynamics (PK/PD) modeling infrastructure built for reproducibility and scientific rigor.</p> <ul> <li> <p> Comprehensive Models</p> <p>20+ PK/PD models including one/two/three-compartment, TMDD, indirect response, and disease progression</p> </li> <li> <p> Population Modeling</p> <p>Full IIV/IOV support with covariate effects and residual error models</p> </li> <li> <p> Clinical Trial Simulation</p> <p>Parallel, crossover, dose escalation designs with power analysis</p> </li> <li> <p> Validated &amp; Reproducible</p> <p>Deterministic golden artifacts with automated validation pipelines</p> </li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#multi-language-support","title":"Multi-Language Support","text":"<p>OpenPKPD provides native implementations in both Julia (high-performance core) and Python (data science integration):</p> PythonJuliaCLI <pre><code>import openpkpd\n\nopenpkpd.init_julia()\n\nresult = openpkpd.simulate_pk_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5\n)\n\nprint(f\"Cmax: {max(result['concentrations']):.2f} mg/L\")\n</code></pre> <pre><code>using OpenPKPDCore\n\nparams = OneCompOralParams(1.5, 5.0, 50.0)  # Ka, CL, V\ndoses = [DoseEvent(0.0, 100.0)]\nspec = ModelSpec(OneCompOral(), \"example\", params, doses)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nresult = simulate(spec, grid, solver)\nprintln(\"Cmax: $(maximum(result.conc)) mg/L\")\n</code></pre> <pre><code>openpkpd simulate \\\n  --model onecomp-oral \\\n  --params ka=1.5,cl=5.0,v=50.0 \\\n  --dose \"time=0,amount=100\" \\\n  --tspan 0,24 \\\n  --output result.json\n</code></pre>"},{"location":"#comprehensive-model-library","title":"Comprehensive Model Library","text":"Category Models PK Models One/Two/Three-compartment IV &amp; Oral, Transit absorption, Michaelis-Menten, TMDD, Parallel absorption, Enterohepatic recirculation, Autoinduction PD Models Direct Emax, Sigmoid Emax, Effect compartment, Indirect response (IRM 1-4), Transit PD, Disease progression, Tolerance Population IIV (log-normal), IOV, Power/Linear/Exponential covariates, Additive/Proportional/Combined residual error Analysis NCA (AUC, Cmax, t1/2, etc.), VPC (standard, pcVPC, stratified), Parameter estimation (FOCE, SAEM, Laplacian)"},{"location":"#reproducibility-first","title":"Reproducibility First","text":"<p>Every simulation produces deterministic, versioned artifacts:</p> <pre><code>{\n  \"metadata\": {\n    \"schema_version\": \"1.0.0\",\n    \"event_semantics_version\": \"1.0.0\",\n    \"solver_semantics_version\": \"1.0.0\",\n    \"timestamp\": \"2024-01-15T10:30:00Z\",\n    \"git_sha\": \"abc123...\"\n  },\n  \"model\": \"OneCompOral\",\n  \"parameters\": {\"Ka\": 1.5, \"CL\": 5.0, \"V\": 50.0},\n  \"results\": {...}\n}\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"PythonJuliaCLI <pre><code>pip install openpkpd\n</code></pre> <pre><code>using Pkg\nPkg.add(\"OpenPKPDCore\")\n</code></pre> <pre><code># After Python installation\npip install openpkpd\n\n# Verify installation\nopenpkpd --version\n</code></pre>"},{"location":"#your-first-simulation","title":"Your First Simulation","text":"PythonJulia <pre><code>import openpkpd\nfrom openpkpd import viz\n\n# Initialize Julia backend\nopenpkpd.init_julia()\n\n# Simulate one-compartment oral PK\nresult = openpkpd.simulate_pk_oral(\n    ka=1.5,      # Absorption rate constant (1/hr)\n    cl=5.0,      # Clearance (L/hr)\n    v=50.0,      # Volume of distribution (L)\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=0.5\n)\n\n# Access results\nprint(f\"Time points: {len(result['times'])}\")\nprint(f\"Cmax: {max(result['concentrations']):.2f} mg/L\")\n\n# Visualize\nviz.set_backend(\"matplotlib\")\nfig = viz.plot_conc_time(result, title=\"PK Profile\")\nfig.savefig(\"pk_profile.png\", dpi=300)\n</code></pre> <pre><code>using OpenPKPDCore\n\n# Define model parameters\nparams = OneCompOralParams(\n    Ka = 1.5,    # Absorption rate constant (1/hr)\n    CL = 5.0,    # Clearance (L/hr)\n    V = 50.0     # Volume of distribution (L)\n)\n\n# Define dosing\ndoses = [DoseEvent(0.0, 100.0)]\n\n# Create model specification\nspec = ModelSpec(OneCompOral(), \"first_sim\", params, doses)\n\n# Simulation settings\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Access results\nprintln(\"Time points: $(length(result.times))\")\nprintln(\"Cmax: $(maximum(result.conc)) mg/L\")\n</code></pre>"},{"location":"#population-simulation","title":"Population Simulation","text":"PythonJulia <pre><code># Simulate 100 subjects with inter-individual variability\npop_result = openpkpd.simulate_population_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},  # ~40%, 30%, 20% CV\n    seed=42\n)\n\n# Population summary\nprint(f\"Subjects: {pop_result['n_subjects']}\")\nprint(f\"Median Cmax: {max(pop_result['median']):.2f} mg/L\")\n</code></pre> <pre><code># Define omega matrix (IIV)\nomega = OmegaMatrix([\n    0.16 0.0  0.0;   # Ka: ~40% CV\n    0.0  0.09 0.0;   # CL: ~30% CV\n    0.0  0.0  0.04   # V:  ~20% CV\n])\n\n# Population specification\npop_spec = PopulationSpec(\n    spec,\n    n = 100,\n    omega = omega,\n    seed = 42\n)\n\n# Simulate population\npop_result = simulate_population(pop_spec, grid, solver)\n\n# Access summaries\nprintln(\"Subjects: $(length(pop_result.individuals))\")\nprintln(\"Median Cmax: $(maximum(pop_result.summaries[:conc].median)) mg/L\")\n</code></pre>"},{"location":"#non-compartmental-analysis","title":"Non-Compartmental Analysis","text":"PythonJulia <pre><code># Run NCA on concentration-time data\nnca_result = openpkpd.run_nca(\n    times=[0, 0.5, 1, 2, 4, 8, 12, 24],\n    concentrations=[0, 5.2, 8.1, 6.3, 3.8, 1.9, 0.9, 0.2],\n    dose=100.0,\n    route=\"oral\"\n)\n\nprint(f\"AUC0-inf: {nca_result['auc_inf']:.1f} mg*hr/L\")\nprint(f\"Cmax: {nca_result['cmax']:.2f} mg/L\")\nprint(f\"Tmax: {nca_result['tmax']:.1f} hr\")\nprint(f\"t1/2: {nca_result['half_life']:.1f} hr\")\n</code></pre> <pre><code># NCA analysis\nnca_result = run_nca(\n    times = [0, 0.5, 1, 2, 4, 8, 12, 24],\n    concentrations = [0, 5.2, 8.1, 6.3, 3.8, 1.9, 0.9, 0.2],\n    dose = 100.0,\n    route = :oral\n)\n\nprintln(\"AUC0-inf: $(nca_result.auc_inf) mg*hr/L\")\nprintln(\"Cmax: $(nca_result.cmax) mg/L\")\nprintln(\"Tmax: $(nca_result.tmax) hr\")\nprintln(\"t1/2: $(nca_result.half_life) hr\")\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#pharmacokinetic-models","title":"Pharmacokinetic Models","text":"<p>OpenPKPD implements standard PK models with validated ODE solvers:</p> Model Compartments Routes Key Parameters One-Compartment 1 IV, Oral CL, V, (Ka) Two-Compartment 2 IV, Oral CL, V1, Q, V2, (Ka) Three-Compartment 3 IV CL, V1, Q2, V2, Q3, V3 Michaelis-Menten 1 IV Vmax, Km, V TMDD 2-3 IV kon, koff, kint, Rtot <p> PK Models (Julia) |  PK Models (Python)</p>"},{"location":"#pharmacodynamic-models","title":"Pharmacodynamic Models","text":"<p>Direct and indirect response models for drug effects:</p> Model Type Equation Direct Emax Immediate \\(E = E_0 + \\frac{E_{max} \\cdot C}{EC_{50} + C}\\) Sigmoid Emax Immediate \\(E = E_0 + \\frac{E_{max} \\cdot C^n}{EC_{50}^n + C^n}\\) Effect Compartment Delayed \\(\\frac{dC_e}{dt} = k_{e0}(C_p - C_e)\\) Indirect Response Turnover \\(\\frac{dR}{dt} = k_{in} \\cdot (1 \\pm \\text{Drug}) - k_{out} \\cdot R\\) <p> PD Models (Julia) |  PD Models (Python)</p>"},{"location":"#population-modeling","title":"Population Modeling","text":"<p>Account for variability between and within individuals:</p> <ul> <li>Inter-Individual Variability (IIV): \\(\\theta_i = \\theta_{pop} \\cdot e^{\\eta_i}\\), where \\(\\eta_i \\sim N(0, \\omega^2)\\)</li> <li>Inter-Occasion Variability (IOV): \\(\\theta_{ij} = \\theta_i \\cdot e^{\\kappa_{ij}}\\)</li> <li>Covariate Effects: Power, linear, exponential relationships</li> <li>Residual Error: Additive, proportional, combined models</li> </ul> <p> Population (Julia) |  Population (Python)</p>"},{"location":"#visual-predictive-check-vpc","title":"Visual Predictive Check (VPC)","text":"<p>Model validation through simulation-based diagnostics:</p> <ul> <li>Standard VPC: Compare observed vs simulated percentiles</li> <li>Prediction-Corrected VPC: Normalize for variable dosing</li> <li>Stratified VPC: Separate analysis by covariate groups</li> <li>BLQ Handling: Multiple methods for below-quantification data</li> </ul> <p> VPC (Julia) |  VPC (Python)</p>"},{"location":"#clinical-trial-simulation","title":"Clinical Trial Simulation","text":"<p>Design and analyze virtual clinical trials:</p> <ul> <li>Parallel Designs: Standard two-arm comparisons</li> <li>Crossover Designs: 2x2, 3x3, replicate designs</li> <li>Dose Escalation: 3+3, mTPI, CRM, BOIN algorithms</li> <li>Power Analysis: Sample size calculation, BE studies</li> </ul> <p> Trials (Julia) |  Trials (Python)</p>"},{"location":"#parameter-estimation","title":"Parameter Estimation","text":"<p>Fit models to observed data:</p> <ul> <li>FOCE-I: First-Order Conditional Estimation with Interaction</li> <li>SAEM: Stochastic Approximation Expectation Maximization</li> <li>Laplacian: Laplacian approximation method</li> <li>Bootstrap: Uncertainty quantification</li> </ul> <p> Estimation (Julia) |  Estimation (Python)</p>"},{"location":"#visualization","title":"Visualization","text":"<p>Publication-quality plots with dual backend support:</p> <pre><code>from openpkpd import viz\n\n# Set backend: matplotlib (static) or plotly (interactive)\nviz.set_backend(\"matplotlib\")\n\n# 55+ visualization functions\nviz.plot_conc_time(result)           # PK profiles\nviz.plot_vpc(vpc_result)             # VPC plots\nviz.plot_goodness_of_fit(est_result) # GOF diagnostics\nviz.plot_forest(forest_data)         # Forest plots\n</code></pre> <p> Visualization</p>"},{"location":"#documentation-contents","title":"Documentation Contents","text":"<ul> <li> <p>:material-language-julia:{ .lg .middle } Julia Documentation</p> <p>High-performance core library with full model implementations</p> <p> Julia Docs</p> </li> <li> <p> Python Documentation</p> <p>Data science integration with visualization and analysis tools</p> <p> Python Docs</p> </li> <li> <p> Examples</p> <p>Working examples for all major features and use cases</p> <p> Examples</p> </li> <li> <p> Concepts</p> <p>Architecture, semantics, and reproducibility principles</p> <p> Concepts</p> </li> </ul>"},{"location":"#by-topic","title":"By Topic","text":"Topic Julia Python PK Models Models Models Population Population Population NCA NCA NCA Estimation Estimation Estimation VPC VPC VPC Clinical Trials Trials Trials Data Import Import Import Visualization - Viz"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    subgraph \"User Interfaces\"\n        CLI[CLI Tool]\n        PY[Python Package]\n        JL[Julia Package]\n    end\n\n    subgraph \"Core Engine\"\n        CORE[OpenPKPDCore.jl]\n        MODELS[Model Library]\n        SOLVERS[ODE Solvers]\n        POP[Population Engine]\n    end\n\n    subgraph \"Analysis\"\n        NCA[NCA Module]\n        VPC[VPC Module]\n        EST[Estimation]\n    end\n\n    subgraph \"Output\"\n        ARTIFACTS[JSON Artifacts]\n        PLOTS[Visualizations]\n        REPORTS[Reports]\n    end\n\n    CLI --&gt; CORE\n    PY --&gt; CORE\n    JL --&gt; CORE\n\n    CORE --&gt; MODELS\n    CORE --&gt; SOLVERS\n    CORE --&gt; POP\n\n    CORE --&gt; NCA\n    CORE --&gt; VPC\n    CORE --&gt; EST\n\n    NCA --&gt; ARTIFACTS\n    VPC --&gt; ARTIFACTS\n    EST --&gt; ARTIFACTS\n    CORE --&gt; PLOTS\n</code></pre>"},{"location":"#version-information","title":"Version Information","text":"<pre><code>OpenPKPD Version: 0.1.0\nEvent Semantics: 1.0.0\nSolver Semantics: 1.0.0\nArtifact Schema: 1.0.0\n</code></pre>"},{"location":"#compatibility","title":"Compatibility","text":"Component Version Notes Julia 1.9+ Core engine Python 3.10+ Python bindings NumPy 1.24+ Array operations Matplotlib 3.7+ Static plots Plotly 5.14+ Interactive plots"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: You're here!</li> <li>Examples: Working examples for all features</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>OpenPKPD is open source software released under the MIT License. See the repository for details.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>OpenPKPD is designed with transparency, reproducibility, and validation as core principles.</p>"},{"location":"architecture/#design-philosophy","title":"Design Philosophy","text":""},{"location":"architecture/#1-pure-data-specifications","title":"1. Pure Data Specifications","text":"<p>All simulation inputs are immutable data structures with no hidden state:</p> <pre><code># Everything needed is explicit in the spec\nspec = ModelSpec(\n    OneCompIVBolus(),           # Model type\n    \"my_model\",                 # Name\n    OneCompIVBolusParams(5, 50), # Parameters\n    [DoseEvent(0, 100)]         # Doses\n)\n</code></pre> <p>Benefits:</p> <ul> <li>Complete traceability in artifacts</li> <li>No side effects or global state</li> <li>Reproducible across versions</li> </ul>"},{"location":"architecture/#2-validated-models","title":"2. Validated Models","text":"<p>Every model implementation includes:</p> <ul> <li>Mathematical equations documented in code</li> <li>Parameter validation (constraints checked at simulation time)</li> <li>Unit tests against analytical solutions</li> <li>Golden artifacts for regression testing</li> </ul>"},{"location":"architecture/#3-semantic-versioning","title":"3. Semantic Versioning","text":"<p>Three independent version numbers track numerical behavior:</p> Version Scope Example Change Event Semantics Dose handling How doses at t=0 are applied Solver Semantics ODE solving Tolerance interpretation Artifact Schema JSON format Field names, structure <p>Version Bump Policy: Any change to numerical output requires a semantic version bump.</p>"},{"location":"architecture/#4-artifact-driven-validation","title":"4. Artifact-Driven Validation","text":"<p>Every simulation can produce a JSON artifact that:</p> <ul> <li>Contains complete inputs and outputs</li> <li>Includes semantic version fingerprint</li> <li>Can be replayed to verify reproducibility</li> </ul>"},{"location":"architecture/#system-architecture","title":"System Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        User Interfaces                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Julia API     \u2502   Python API    \u2502         CLI                 \u2502\n\u2502   (direct)      \u2502   (juliacall)   \u2502    (OpenPKPDCLI)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                 \u2502                     \u2502\n         \u25bc                 \u25bc                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     OpenPKPDCore                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Models    \u2502  \u2502   Engine    \u2502  \u2502    Serialization        \u2502 \u2502\n\u2502  \u2502  (PK/PD)    \u2502  \u2502  (Solver)   \u2502  \u2502    (JSON Artifacts)     \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Population  \u2502  \u2502 Sensitivity \u2502  \u2502    Analysis             \u2502 \u2502\n\u2502  \u2502 (IIV/IOV)   \u2502  \u2502 (Perturb)   \u2502  \u2502    (Metrics)            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  DifferentialEquations.jl                       \u2502\n\u2502                      (ODE Solver)                               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#module-structure","title":"Module Structure","text":""},{"location":"architecture/#core-coreopenpkpdcore","title":"Core (<code>core/OpenPKPDCore/</code>)","text":"<pre><code>src/\n\u251c\u2500\u2500 OpenPKPDCore.jl          # Module definition, exports\n\u251c\u2500\u2500 specs/\n\u2502   \u251c\u2500\u2500 specs.jl             # Core type definitions\n\u2502   \u251c\u2500\u2500 sensitivity.jl       # Perturbation types\n\u2502   \u2514\u2500\u2500 time_covariates.jl   # Time-varying covariate types\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 onecomp_iv_bolus.jl      # IV bolus model\n\u2502   \u251c\u2500\u2500 onecomp_oral_first_order.jl  # Oral model\n\u2502   \u2514\u2500\u2500 pk_interface.jl          # Common PK interface\n\u251c\u2500\u2500 pd/\n\u2502   \u251c\u2500\u2500 direct_emax.jl           # Direct Emax PD\n\u2502   \u2514\u2500\u2500 indirect_response_turnover.jl  # Indirect response PD\n\u251c\u2500\u2500 engine/\n\u2502   \u251c\u2500\u2500 events.jl            # Dose normalization\n\u2502   \u251c\u2500\u2500 callbacks.jl         # ODE callbacks\n\u2502   \u251c\u2500\u2500 solve.jl             # Main simulation\n\u2502   \u251c\u2500\u2500 pkpd.jl              # Sequential PKPD\n\u2502   \u251c\u2500\u2500 pkpd_coupled.jl      # Coupled PKPD\n\u2502   \u251c\u2500\u2500 population.jl        # Population simulation\n\u2502   \u251c\u2500\u2500 iov.jl               # Inter-occasion variability\n\u2502   \u251c\u2500\u2500 covariates.jl        # Covariate application\n\u2502   \u251c\u2500\u2500 time_covariates.jl   # Time-varying evaluation\n\u2502   \u251c\u2500\u2500 segment_sim.jl       # Segmented PK simulation\n\u2502   \u251c\u2500\u2500 segment_sim_pkpd.jl  # Segmented PKPD simulation\n\u2502   \u251c\u2500\u2500 sensitivity.jl       # Single sensitivity\n\u2502   \u251c\u2500\u2500 sensitivity_population.jl  # Population sensitivity\n\u2502   \u251c\u2500\u2500 sensitivity_metrics.jl     # Metric computation\n\u2502   \u251c\u2500\u2500 perturb.jl           # Perturbation application\n\u2502   \u251c\u2500\u2500 semantics.jl         # Event semantics\n\u2502   \u251c\u2500\u2500 solver_semantics.jl  # Solver semantics\n\u2502   \u2514\u2500\u2500 semantics_fingerprint.jl  # Version fingerprinting\n\u251c\u2500\u2500 serialization/\n\u2502   \u251c\u2500\u2500 schema.jl            # Schema version\n\u2502   \u251c\u2500\u2500 serialize.jl         # Single serialization\n\u2502   \u251c\u2500\u2500 deserialize.jl       # Single deserialization\n\u2502   \u251c\u2500\u2500 serialize_population.jl    # Population serialization\n\u2502   \u251c\u2500\u2500 deserialize_population.jl  # Population deserialization\n\u2502   \u251c\u2500\u2500 serialize_sensitivity.jl   # Sensitivity serialization\n\u2502   \u2514\u2500\u2500 deserialize_sensitivity.jl # Sensitivity deserialization\n\u2514\u2500\u2500 analysis/\n    \u2514\u2500\u2500 exposure.jl          # Cmax, AUC\n</code></pre>"},{"location":"architecture/#cli-cliopenpkpdcli","title":"CLI (<code>cli/OpenPKPDCLI/</code>)","text":"<pre><code>src/\n\u2514\u2500\u2500 OpenPKPDCLI.jl           # CLI commands\n</code></pre>"},{"location":"architecture/#python-pythonopenpkpd","title":"Python (<code>python/openpkpd/</code>)","text":"<pre><code>openpkpd/\n\u251c\u2500\u2500 __init__.py              # Package exports\n\u2514\u2500\u2500 bridge.py                # Julia-Python bridge\n</code></pre>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#single-simulation","title":"Single Simulation","text":"<pre><code>ModelSpec + SimGrid + SolverSpec\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502   validate   \u2502  Parameter constraints\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 normalize_   \u2502  Dose preprocessing\n     \u2502 doses_for_   \u2502  (t0 doses \u2192 u0)\n     \u2502 sim          \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  callbacks   \u2502  Dose callbacks for (t0,t1]\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502   solve      \u2502  DifferentialEquations.jl\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  extract     \u2502  States \u2192 Observations\n     \u2502  results     \u2502  Output grid alignment\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n        SimResult\n</code></pre>"},{"location":"architecture/#population-simulation","title":"Population Simulation","text":"<pre><code>PopulationSpec + SimGrid + SolverSpec\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  sample_iiv  \u2502  Generate \u03b7 per individual\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 apply_covs   \u2502  Static covariate effects\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 derive_occ   \u2502  Occasion boundaries\n     \u2502 (if IOV)     \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  For each individual:            \u2502\n     \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n     \u2502  \u2502 sample_iov (if IOV)        \u2502  \u2502\n     \u2502  \u2502 segment_boundaries         \u2502  \u2502\n     \u2502  \u2502 simulate_segmented_pk/pkpd \u2502  \u2502\n     \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502\n                    \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  compute_    \u2502  Mean, median, quantiles\n     \u2502  summary     \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n            \u25bc\n     PopulationResult\n</code></pre>"},{"location":"architecture/#type-hierarchy","title":"Type Hierarchy","text":""},{"location":"architecture/#model-kinds","title":"Model Kinds","text":"<pre><code>ModelKind (abstract)\n\u251c\u2500\u2500 OneCompIVBolus\n\u2514\u2500\u2500 OneCompOralFirstOrder\n\nPDModelKind (abstract)\n\u251c\u2500\u2500 DirectEmax\n\u2514\u2500\u2500 IndirectResponseTurnover\n</code></pre>"},{"location":"architecture/#random-effect-kinds","title":"Random Effect Kinds","text":"<pre><code>RandomEffectKind (abstract)\n\u2514\u2500\u2500 LogNormalIIV\n</code></pre>"},{"location":"architecture/#covariate-effect-kinds","title":"Covariate Effect Kinds","text":"<pre><code>CovariateEffectKind (abstract)\n\u251c\u2500\u2500 LinearCovariate\n\u251c\u2500\u2500 PowerCovariate\n\u2514\u2500\u2500 ExpCovariate\n</code></pre>"},{"location":"architecture/#time-covariate-kinds","title":"Time Covariate Kinds","text":"<pre><code>TimeCovariateKind (abstract)\n\u251c\u2500\u2500 StepTimeCovariate\n\u2514\u2500\u2500 LinearTimeCovariate\n</code></pre>"},{"location":"architecture/#perturbation-kinds","title":"Perturbation Kinds","text":"<pre><code>PerturbationKind (abstract)\n\u251c\u2500\u2500 RelativePerturbation\n\u2514\u2500\u2500 AbsolutePerturbation\n</code></pre>"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#adding-a-new-pk-model","title":"Adding a New PK Model","text":"<ol> <li>Create <code>src/models/newmodel.jl</code></li> <li>Define <code>NewModel &lt;: ModelKind</code></li> <li>Define <code>NewModelParams</code> struct</li> <li>Implement required interface:</li> <li><code>pk_validate(spec::ModelSpec{NewModel})</code></li> <li><code>pk_param_tuple(spec::ModelSpec{NewModel})</code></li> <li><code>pk_state_symbols(::NewModel)</code></li> <li><code>pk_u0(spec::ModelSpec{NewModel}, grid)</code></li> <li><code>pk_ode!(du, u, p, t, ::NewModel)</code></li> <li><code>pk_conc(u, p, ::NewModel)</code></li> <li><code>pk_dose_target_index(::NewModel)</code></li> <li>Add exports to <code>OpenPKPDCore.jl</code></li> <li>Add serialization support</li> <li>Add tests and golden artifacts</li> </ol>"},{"location":"architecture/#adding-a-new-pd-model","title":"Adding a New PD Model","text":"<ol> <li>Create <code>src/pd/newpd.jl</code></li> <li>Define <code>NewPD &lt;: PDModelKind</code></li> <li>Define <code>NewPDParams</code> struct</li> <li>Implement <code>validate(spec::PDSpec{NewPD})</code></li> <li>For direct models: implement <code>evaluate(spec, input_series)</code></li> <li>For dynamic models: implement ODE interface</li> <li>Add serialization support</li> </ol>"},{"location":"architecture/#adding-a-new-covariate-effect","title":"Adding a New Covariate Effect","text":"<ol> <li>Define <code>NewEffect &lt;: CovariateEffectKind</code></li> <li>Add dispatch in <code>apply_covariates</code></li> <li>Add serialization support</li> </ol>"},{"location":"architecture/#validation-strategy","title":"Validation Strategy","text":""},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<pre><code># test/models/test_onecomp_iv_bolus.jl\n@test simulate(...) produces expected analytical solution\n</code></pre>"},{"location":"architecture/#golden-artifacts","title":"Golden Artifacts","text":"<pre><code>validation/golden/\n\u251c\u2500\u2500 pk_iv_bolus.json\n\u251c\u2500\u2500 pk_oral_first_order.json\n\u251c\u2500\u2500 population_iv_bolus.json\n\u251c\u2500\u2500 pkpd_direct_emax.json\n\u2514\u2500\u2500 sensitivity_single.json\n</code></pre>"},{"location":"architecture/#replay-validation","title":"Replay Validation","text":"<pre><code>artifact = read_execution_json(\"golden.json\")\nresult = replay_execution(artifact)\n@test result matches stored_result\n</code></pre>"},{"location":"architecture/#ci-pipeline","title":"CI Pipeline","text":"<ol> <li>Run unit tests</li> <li>Generate fresh artifacts</li> <li>Replay all golden artifacts</li> <li>Compare against stored results</li> <li>Fail if any mismatch</li> </ol>"},{"location":"architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/#ode-solver","title":"ODE Solver","text":"<ul> <li>Uses DifferentialEquations.jl for production-quality solvers</li> <li>Default Tsit5 (5th order Runge-Kutta) for non-stiff problems</li> <li>Rosenbrock23 available for stiff problems</li> </ul>"},{"location":"architecture/#population-simulation_1","title":"Population Simulation","text":"<ul> <li>Sequential individual simulation (not parallel by default)</li> <li>Segmented simulation adds overhead for IOV/time-varying covariates</li> <li>Consider reducing population size for exploratory work</li> </ul>"},{"location":"architecture/#memory","title":"Memory","text":"<ul> <li>Each individual result stored separately</li> <li>Large populations with fine grids can consume significant memory</li> <li>Use sparse <code>saveat</code> grids when possible</li> </ul>"},{"location":"architecture/#thread-safety","title":"Thread Safety","text":"<ul> <li>All simulation functions are thread-safe</li> <li>No global mutable state</li> <li>Safe to run parallel simulations from different threads</li> </ul>"},{"location":"architecture/#dependencies","title":"Dependencies","text":""},{"location":"architecture/#julia","title":"Julia","text":"Package Purpose DifferentialEquations.jl ODE solving SciMLBase Scientific ML interface JSON Serialization ArgParse CLI parsing"},{"location":"architecture/#python","title":"Python","text":"Package Purpose juliacall Julia-Python bridge juliapkg Julia environment management"},{"location":"cli/","title":"CLI Reference","text":"<p>OpenPKPD provides a comprehensive command-line interface for PK/PD simulations, estimation, VPC, NCA, trial simulation, and model import.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>The CLI is located in <code>packages/cli/bin/openpkpd</code> and requires Julia with the OpenPKPDCore and OpenPKPDCLI packages.</p> <pre><code># Install dependencies\njulia --project=packages/core -e 'using Pkg; Pkg.instantiate()'\njulia --project=packages/cli -e 'using Pkg; Pkg.instantiate()'\n\n# Make executable\nchmod +x packages/cli/bin/openpkpd\n\n# Run CLI\n./packages/cli/bin/openpkpd &lt;command&gt; [options]\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#version","title":"version","text":"<p>Display version information for all OpenPKPD components.</p> <pre><code>./packages/cli/bin/openpkpd version\n</code></pre> <p>Output:</p> <pre><code>OpenPKPD 0.1.0\nEvent semantics: 1.0.0\nSolver semantics: 1.0.0\nArtifact schema: 1.0.0\n</code></pre>"},{"location":"cli/#simulate","title":"simulate","text":"<p>Run a PK/PD simulation from a JSON specification.</p> <pre><code>./packages/cli/bin/openpkpd simulate --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>Options:</p> Option Required Description <code>--spec</code> Yes Path to simulation specification JSON <code>--out</code> No Output path for result artifact <p>Example:</p> <pre><code>./packages/cli/bin/openpkpd simulate --spec simulation.json --out result.json\n</code></pre>"},{"location":"cli/#population","title":"population","text":"<p>Run a population simulation with IIV/IOV.</p> <pre><code>./packages/cli/bin/openpkpd population --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre>"},{"location":"cli/#estimate","title":"estimate","text":"<p>Run NLME parameter estimation (FOCE-I, SAEM, or Laplacian).</p> <pre><code>./packages/cli/bin/openpkpd estimate --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>Specification includes: observed data, model, estimation method, initial values, bounds.</p> <p>See Parameter Estimation for specification format.</p>"},{"location":"cli/#nca","title":"nca","text":"<p>Run non-compartmental analysis.</p> <pre><code>./packages/cli/bin/openpkpd nca --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>See NCA for specification format.</p>"},{"location":"cli/#vpc","title":"vpc","text":"<p>Compute Visual Predictive Check.</p> <pre><code>./packages/cli/bin/openpkpd vpc --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>See VPC for specification format.</p>"},{"location":"cli/#trial","title":"trial","text":"<p>Run clinical trial simulation.</p> <pre><code>./packages/cli/bin/openpkpd trial --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>Supports parallel, crossover, dose-escalation, and bioequivalence designs.</p> <p>See Trial Simulation for specification format.</p>"},{"location":"cli/#import","title":"import","text":"<p>Import models from NONMEM or Monolix.</p> <pre><code>./packages/cli/bin/openpkpd import --input &lt;path&gt; --format &lt;format&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>Options:</p> Option Required Description <code>--input</code> Yes Path to model file (.ctl or .mlxtran) <code>--format</code> Yes Format: <code>nonmem</code> or <code>monolix</code> <code>--out</code> No Output path for converted model <p>Examples:</p> <pre><code># Import NONMEM control file\n./packages/cli/bin/openpkpd import --input run001.ctl --format nonmem --out model.json\n\n# Import Monolix project\n./packages/cli/bin/openpkpd import --input project.mlxtran --format monolix --out model.json\n</code></pre> <p>See Model Import for details.</p>"},{"location":"cli/#sensitivity","title":"sensitivity","text":"<p>Run parameter sensitivity analysis.</p> <pre><code>./packages/cli/bin/openpkpd sensitivity --spec &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre>"},{"location":"cli/#metrics","title":"metrics","text":"<p>Compute PK/PD metrics from simulation results.</p> <pre><code>./packages/cli/bin/openpkpd metrics --artifact &lt;path&gt; --metrics &lt;list&gt;\n</code></pre> <p>Examples:</p> <pre><code>./packages/cli/bin/openpkpd metrics --artifact result.json --metrics cmax,tmax,auc\n</code></pre>"},{"location":"cli/#replay","title":"replay","text":"<p>Replay an execution artifact to verify reproducibility.</p> <pre><code>./packages/cli/bin/openpkpd replay --artifact &lt;path&gt; [--out &lt;output_path&gt;]\n</code></pre> <p>Options:</p> Option Required Description <code>--artifact</code> Yes Path to artifact JSON file <code>--out</code> No Path to write replayed artifact <p>Supported Artifact Types:</p> <ul> <li>Single execution (<code>artifact_type: \"single\"</code> or missing)</li> <li>Population execution (<code>artifact_type: \"population\"</code>)</li> <li>Single sensitivity (<code>artifact_type: \"sensitivity_single\"</code>)</li> <li>Population sensitivity (<code>artifact_type: \"sensitivity_population\"</code>)</li> <li>Estimation results (<code>artifact_type: \"estimation\"</code>)</li> </ul> <p>Examples:</p> <pre><code># Replay and verify\n./packages/cli/bin/openpkpd replay --artifact validation/golden/pk_iv_bolus.json\n\n# Replay and save output\n./packages/cli/bin/openpkpd replay --artifact my_simulation.json --out replayed.json\n\n# Replay population artifact\n./packages/cli/bin/openpkpd replay --artifact validation/golden/population_iv_bolus.json\n</code></pre>"},{"location":"cli/#validate-golden","title":"validate-golden","text":"<p>Run the full golden artifact validation suite.</p> <pre><code>./packages/cli/bin/openpkpd validate-golden\n</code></pre> <p>What It Does:</p> <ol> <li>Finds all golden artifacts in <code>validation/golden/</code></li> <li>Replays each artifact</li> <li>Compares replayed results to stored results</li> <li>Reports any discrepancies</li> </ol> <p>Output:</p> <pre><code>Validating golden artifacts...\n  pk_iv_bolus.json: PASS\n  pk_oral_first_order.json: PASS\n  population_iv_bolus.json: PASS\n  pkpd_direct_emax.json: PASS\n  sensitivity_single.json: PASS\n  ...\nAll golden artifacts validated successfully.\n</code></pre> <p>Exit Codes:</p> Code Meaning 0 All validations passed 1 One or more validations failed"},{"location":"cli/#help","title":"help","text":"<p>Display help for any command.</p> <pre><code>./packages/cli/bin/openpkpd help\n./packages/cli/bin/openpkpd help simulate\n./packages/cli/bin/openpkpd help estimate\n</code></pre>"},{"location":"cli/#artifact-format","title":"Artifact Format","text":"<p>All OpenPKPD artifacts are JSON files with a consistent structure.</p>"},{"location":"cli/#common-fields","title":"Common Fields","text":"<pre><code>{\n  \"artifact_schema_version\": \"1.0.0\",\n  \"semantics_fingerprint\": {\n    \"artifact_schema_version\": \"1.0.0\",\n    \"event_semantics_version\": \"1.0.0\",\n    \"solver_semantics_version\": \"1.0.0\"\n  }\n}\n</code></pre>"},{"location":"cli/#single-execution-artifact","title":"Single Execution Artifact","text":"<pre><code>{\n  \"artifact_schema_version\": \"1.0.0\",\n  \"execution_mode\": \"pk\",\n  \"model_spec\": {\n    \"kind\": \"OneCompIVBolus\",\n    \"name\": \"example\",\n    \"params\": {\"CL\": 5.0, \"V\": 50.0},\n    \"doses\": [{\"time\": 0.0, \"amount\": 100.0}]\n  },\n  \"grid\": {\n    \"t0\": 0.0,\n    \"t1\": 24.0,\n    \"saveat\": [0.0, 1.0, 2.0, ...]\n  },\n  \"solver\": {\n    \"alg\": \"Tsit5\",\n    \"reltol\": 1e-10,\n    \"abstol\": 1e-12,\n    \"maxiters\": 10000000\n  },\n  \"result\": {\n    \"t\": [0.0, 1.0, 2.0, ...],\n    \"states\": {\"A_central\": [...]},\n    \"observations\": {\"conc\": [...]},\n    \"metadata\": {...}\n  }\n}\n</code></pre>"},{"location":"cli/#population-artifact","title":"Population Artifact","text":"<pre><code>{\n  \"artifact_type\": \"population\",\n  \"population_spec\": {\n    \"base_model_spec\": {...},\n    \"iiv\": {\n      \"kind\": \"LogNormalIIV\",\n      \"omegas\": {\"CL\": 0.3, \"V\": 0.2},\n      \"seed\": 12345,\n      \"n\": 100\n    },\n    \"iov\": null,\n    \"covariate_model\": null,\n    \"covariates\": []\n  },\n  \"result\": {\n    \"individuals\": [...],\n    \"params\": [...],\n    \"summaries\": {\n      \"conc\": {\n        \"observation\": \"conc\",\n        \"probs\": [0.05, 0.95],\n        \"mean\": [...],\n        \"median\": [...],\n        \"quantiles\": {...}\n      }\n    },\n    \"metadata\": {...}\n  }\n}\n</code></pre>"},{"location":"cli/#integration-examples","title":"Integration Examples","text":""},{"location":"cli/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># .github/workflows/validate.yml\nname: Golden Validation\non: [push, pull_request]\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: julia-actions/setup-julia@v1\n      - run: julia --project=core/OpenPKPDCore -e 'using Pkg; Pkg.instantiate()'\n      - run: ./bin/openpkpd validate-golden\n</code></pre>"},{"location":"cli/#batch-replay","title":"Batch Replay","text":"<pre><code>#!/bin/bash\n# replay_all.sh - Replay all artifacts in a directory\n\nfor artifact in artifacts/*.json; do\n    echo \"Replaying: $artifact\"\n    ./bin/openpkpd replay --artifact \"$artifact\" --out \"replayed/$(basename $artifact)\"\ndone\n</code></pre>"},{"location":"cli/#compare-artifacts","title":"Compare Artifacts","text":"<pre><code># Generate new artifact\njulia --project=core/OpenPKPDCore my_simulation.jl\n\n# Compare with golden\ndiff &lt;(jq -S . validation/golden/pk_iv_bolus.json) &lt;(jq -S . my_artifact.json)\n</code></pre>"},{"location":"cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/#julia-not-found","title":"Julia Not Found","text":"<pre><code>Error: julia: command not found\n</code></pre> <p>Solution: Ensure Julia is installed and in your PATH.</p>"},{"location":"cli/#package-not-installed","title":"Package Not Installed","text":"<pre><code>Error: ArgumentError: Package OpenPKPDCore not found\n</code></pre> <p>Solution: Install dependencies:</p> <pre><code>julia --project=core/OpenPKPDCore -e 'using Pkg; Pkg.instantiate()'\njulia --project=cli/OpenPKPDCLI -e 'using Pkg; Pkg.instantiate()'\n</code></pre>"},{"location":"cli/#artifact-schema-mismatch","title":"Artifact Schema Mismatch","text":"<pre><code>Warning: Artifact schema version mismatch\n</code></pre> <p>Cause: Artifact was created with a different version of OpenPKPD.</p> <p>Solution: Re-generate the artifact or update your OpenPKPD installation.</p>"},{"location":"cli/#environment-variables","title":"Environment Variables","text":"Variable Description Default <code>JULIA_PROJECT</code> Julia project path Auto-detected <code>OPENPKPD_ROOT</code> Repository root Auto-detected"},{"location":"cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 General error 2 Invalid arguments 3 File not found 4 Validation failure"},{"location":"reproducibility/","title":"Reproducibility","text":"<p>OpenPKPD is designed for complete reproducibility of simulation results across time, platforms, and versions.</p>"},{"location":"reproducibility/#core-principles","title":"Core Principles","text":"<ol> <li>Deterministic Execution: Same inputs always produce identical outputs</li> <li>Complete Artifacts: All information needed to reproduce results is stored</li> <li>Semantic Versioning: Changes to numerical behavior are tracked and versioned</li> <li>Replay Validation: Artifacts can be replayed to verify reproducibility</li> </ol>"},{"location":"reproducibility/#execution-artifacts","title":"Execution Artifacts","text":"<p>Every simulation can be serialized to a JSON artifact containing everything needed for reproduction.</p>"},{"location":"reproducibility/#what-artifacts-contain","title":"What Artifacts Contain","text":"Component Description Model Specification Kind, parameters, doses Simulation Grid t0, t1, saveat times Solver Settings Algorithm, tolerances, max iterations Results Time series, states, observations Semantics Fingerprint Version information Metadata Engine version, settings snapshot"},{"location":"reproducibility/#creating-artifacts","title":"Creating Artifacts","text":"<p>Julia:</p> <pre><code>using OpenPKPDCore\n\nspec = ModelSpec(...)\ngrid = SimGrid(...)\nsolver = SolverSpec(...)\nresult = simulate(spec, grid, solver)\n\nwrite_execution_json(\n    \"my_simulation.json\";\n    model_spec=spec,\n    grid=grid,\n    solver=solver,\n    result=result\n)\n</code></pre> <p>Python:</p> <pre><code>import openpkpd\n\nopenpkpd.write_single_artifact(\n    \"my_simulation.json\",\n    model={...},\n    grid={...},\n    solver={...}\n)\n</code></pre>"},{"location":"reproducibility/#artifact-types","title":"Artifact Types","text":"Type Function Contents Single <code>write_execution_json</code> Single simulation Population <code>write_population_json</code> Population simulation Sensitivity (Single) <code>write_sensitivity_json</code> Single sensitivity analysis Sensitivity (Population) <code>write_population_sensitivity_json</code> Population sensitivity"},{"location":"reproducibility/#replay-system","title":"Replay System","text":"<p>Artifacts can be replayed to reproduce simulations.</p>"},{"location":"reproducibility/#replay-functions","title":"Replay Functions","text":"<pre><code># Read artifact\nartifact = read_execution_json(\"simulation.json\")\n\n# Replay single execution\nresult = replay_execution(artifact)\n\n# Replay population\nresult = replay_population_execution(artifact)\n\n# Replay sensitivity\nresult = replay_sensitivity_execution(artifact)\n\n# Replay population sensitivity\nresult = replay_population_sensitivity_execution(artifact)\n</code></pre>"},{"location":"reproducibility/#python-replay","title":"Python Replay","text":"<pre><code>import openpkpd\n\nresult = openpkpd.replay_artifact(\"simulation.json\")\n</code></pre>"},{"location":"reproducibility/#cli-replay","title":"CLI Replay","text":"<pre><code>./bin/openpkpd replay --artifact simulation.json\n./bin/openpkpd replay --artifact simulation.json --out replayed.json\n</code></pre>"},{"location":"reproducibility/#golden-artifacts","title":"Golden Artifacts","text":"<p>Golden artifacts are the regression contract for OpenPKPD.</p>"},{"location":"reproducibility/#location","title":"Location","text":"<pre><code>validation/golden/\n\u251c\u2500\u2500 pk_iv_bolus.json\n\u251c\u2500\u2500 pk_oral_first_order.json\n\u251c\u2500\u2500 pkpd_direct_emax.json\n\u251c\u2500\u2500 pkpd_indirect_coupled.json\n\u251c\u2500\u2500 population_iv_bolus.json\n\u251c\u2500\u2500 population_iov.json\n\u251c\u2500\u2500 population_covariates.json\n\u251c\u2500\u2500 population_time_varying.json\n\u251c\u2500\u2500 sensitivity_single.json\n\u2514\u2500\u2500 sensitivity_population.json\n</code></pre>"},{"location":"reproducibility/#purpose","title":"Purpose","text":"<ul> <li>Regression Testing: Verify numerical behavior hasn't changed</li> <li>Contract Documentation: Define expected outputs for given inputs</li> <li>Cross-Version Validation: Ensure compatibility across releases</li> </ul>"},{"location":"reproducibility/#generating-golden-artifacts","title":"Generating Golden Artifacts","text":"<pre><code># Run generation script\njulia validation/scripts/generate_golden_artifacts.jl\n</code></pre>"},{"location":"reproducibility/#validating-golden-artifacts","title":"Validating Golden Artifacts","text":"<pre><code># CLI validation\n./bin/openpkpd validate-golden\n\n# Script validation\njulia validation/scripts/run_golden_validation.jl\n</code></pre>"},{"location":"reproducibility/#validation-process","title":"Validation Process","text":""},{"location":"reproducibility/#what-validation-checks","title":"What Validation Checks","text":"<ol> <li>Artifact Readability: JSON parses correctly</li> <li>Schema Compliance: Required fields present</li> <li>Replay Success: Simulation runs without error</li> <li>Result Match: Replayed results match stored results</li> </ol>"},{"location":"reproducibility/#comparison-criteria","title":"Comparison Criteria","text":"<p>Results are compared with exact floating-point equality:</p> <pre><code>@test replayed.t == stored.t\n@test replayed.observations[:conc] == stored.observations[:conc]\n</code></pre>"},{"location":"reproducibility/#handling-failures","title":"Handling Failures","text":"<p>When validation fails:</p> <ol> <li>Bug: Fix the code, validation should pass</li> <li>Intentional Change:</li> <li>Bump semantic version</li> <li>Re-generate golden artifacts</li> <li>Document change</li> </ol>"},{"location":"reproducibility/#determinism-guarantees","title":"Determinism Guarantees","text":""},{"location":"reproducibility/#random-number-generation","title":"Random Number Generation","text":"<p>IIV and IOV use deterministic seeding:</p> <pre><code>iiv = IIVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.3),\n    UInt64(12345),  # Deterministic seed\n    100\n)\n</code></pre> <p>Guarantees:</p> <ul> <li>Same seed \u2192 same random sequence</li> <li>Independent of simulation order</li> <li>Reproducible across platforms</li> </ul>"},{"location":"reproducibility/#output-grid","title":"Output Grid","text":"<p>Results are aligned exactly to <code>saveat</code> times:</p> <pre><code>grid = SimGrid(0.0, 24.0, [0.0, 1.0, 2.0])\nresult = simulate(spec, grid, solver)\n\n# result.t is exactly [0.0, 1.0, 2.0]\n</code></pre>"},{"location":"reproducibility/#floating-point-precision","title":"Floating-Point Precision","text":"<ul> <li>IEEE 754 double precision throughout</li> <li>No intermediate rounding</li> <li>Full precision in artifacts</li> </ul>"},{"location":"reproducibility/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"reproducibility/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Golden Validation\non: [push, pull_request]\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - uses: julia-actions/setup-julia@v1\n        with:\n          version: '1.9'\n\n      - name: Install dependencies\n        run: |\n          julia --project=core/OpenPKPDCore -e 'using Pkg; Pkg.instantiate()'\n\n      - name: Run tests\n        run: |\n          julia --project=core/OpenPKPDCore -e 'using Pkg; Pkg.test()'\n\n      - name: Validate golden artifacts\n        run: |\n          ./bin/openpkpd validate-golden\n</code></pre>"},{"location":"reproducibility/#pre-commit-hook","title":"Pre-Commit Hook","text":"<pre><code>#!/bin/bash\n# .git/hooks/pre-commit\n\n# Validate golden artifacts before commit\n./bin/openpkpd validate-golden\nif [ $? -ne 0 ]; then\n    echo \"Golden validation failed. Commit aborted.\"\n    exit 1\nfi\n</code></pre>"},{"location":"reproducibility/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reproducibility/#results-dont-match-stored-values","title":"\"Results don't match stored values\"","text":"<p>Causes:</p> <ol> <li>Code change affected numerical output</li> <li>Tolerance settings changed</li> <li>Random seed handling changed</li> </ol> <p>Solutions:</p> <ul> <li>Review recent changes</li> <li>Check semantic versions</li> <li>Re-generate golden artifacts if intentional</li> </ul>"},{"location":"reproducibility/#artifact-cant-be-read","title":"\"Artifact can't be read\"","text":"<p>Causes:</p> <ol> <li>Corrupted JSON</li> <li>Schema version mismatch</li> <li>Missing required fields</li> </ol> <p>Solutions:</p> <ul> <li>Validate JSON syntax</li> <li>Check artifact schema version</li> <li>Regenerate artifact</li> </ul>"},{"location":"reproducibility/#replay-produces-different-results","title":"\"Replay produces different results\"","text":"<p>Causes:</p> <ol> <li>Semantic version mismatch</li> <li>Solver configuration differences</li> <li>Platform-specific floating-point behavior</li> </ol> <p>Solutions:</p> <ul> <li>Use same OpenPKPD version</li> <li>Match solver settings exactly</li> <li>Report platform-specific issues</li> </ul>"},{"location":"reproducibility/#best-practices","title":"Best Practices","text":""},{"location":"reproducibility/#1-always-save-artifacts","title":"1. Always Save Artifacts","text":"<pre><code># Save every important simulation\nwrite_execution_json(\"research/exp_001.json\"; ...)\n</code></pre>"},{"location":"reproducibility/#2-use-explicit-seeds","title":"2. Use Explicit Seeds","text":"<pre><code># Never rely on implicit randomness\niiv = IIVSpec(..., UInt64(42), n)  # Explicit seed\n</code></pre>"},{"location":"reproducibility/#3-use-high-precision","title":"3. Use High Precision","text":"<pre><code># Golden-standard tolerances\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n</code></pre>"},{"location":"reproducibility/#4-version-control-artifacts","title":"4. Version Control Artifacts","text":"<pre><code># Track golden artifacts in git\ngit add validation/golden/*.json\ngit commit -m \"Update golden artifacts for v1.1.0\"\n</code></pre>"},{"location":"reproducibility/#5-document-changes","title":"5. Document Changes","text":"<p>When numerical behavior changes:</p> <ol> <li>Update <code>CHANGELOG.md</code></li> <li>Bump appropriate semantic version</li> <li>Regenerate affected artifacts</li> <li>Update documentation</li> </ol>"},{"location":"reproducibility/#artifact-lifecycle","title":"Artifact Lifecycle","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Create    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502    Store    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   Replay    \u2502\n\u2502 Simulation  \u2502     \u2502  Artifact   \u2502     \u2502   Verify    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                   \u2502                   \u2502\n       \u25bc                   \u25bc                   \u25bc\n  SimResult           JSON File          SimResult\n  (in memory)       (persistent)        (reproduced)\n                          \u2502\n                          \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   Version   \u2502\n                    \u2502   Control   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reproducibility/#example-complete-reproducibility-workflow","title":"Example: Complete Reproducibility Workflow","text":"<pre><code>using OpenPKPDCore\n\n# 1. Define simulation (all parameters explicit)\nspec = ModelSpec(\n    OneCompIVBolus(),\n    \"reproducibility_example\",\n    OneCompIVBolusParams(5.0, 50.0),\n    [DoseEvent(0.0, 100.0)]\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# 2. Run simulation\nresult = simulate(spec, grid, solver)\n\n# 3. Save artifact\nwrite_execution_json(\n    \"reproducible_sim.json\";\n    model_spec=spec,\n    grid=grid,\n    solver=solver,\n    result=result\n)\n\n# 4. Later: replay and verify\nartifact = read_execution_json(\"reproducible_sim.json\")\nreplayed = replay_execution(artifact)\n\n# 5. Confirm exact match\n@assert result.t == replayed.t\n@assert result.observations[:conc] == replayed.observations[:conc]\nprintln(\"Reproducibility verified!\")\n</code></pre>"},{"location":"semantics/","title":"Semantics","text":"<p>OpenPKPD uses semantic versioning for numerical behavior to ensure reproducibility across versions.</p>"},{"location":"semantics/#version-constants","title":"Version Constants","text":"<p>Three independent version numbers track different aspects of system behavior:</p> <pre><code>OPENPKPD_VERSION = \"0.1.0\"           # Software version\nEVENT_SEMANTICS_VERSION = \"1.0.0\"    # Dose event handling\nSOLVER_SEMANTICS_VERSION = \"1.0.0\"   # ODE solver behavior\nARTIFACT_SCHEMA_VERSION = \"1.0.0\"    # JSON artifact format\n</code></pre>"},{"location":"semantics/#event-semantics-v100","title":"Event Semantics (v1.0.0)","text":"<p>Event semantics define how dose events are normalized and applied.</p>"},{"location":"semantics/#dose-normalization-rules","title":"Dose Normalization Rules","text":"<p>Given doses and simulation window <code>[t0, t1]</code>:</p> <ol> <li>Doses at t0: Added to initial state <code>u0</code></li> <li>Doses in (t0, t1]: Applied via ODE callbacks</li> <li>Doses outside [t0, t1]: Ignored</li> <li>Duplicate times: Summed together</li> </ol> <pre><code># Example: doses at [0, 0, 12] with t0=0, t1=24\n# - Doses at t=0 (100 + 50 = 150) \u2192 added to u0\n# - Dose at t=12 \u2192 callback\ndoses = [\n    DoseEvent(0.0, 100.0),\n    DoseEvent(0.0, 50.0),\n    DoseEvent(12.0, 75.0)\n]\n</code></pre>"},{"location":"semantics/#dose-target","title":"Dose Target","text":"<p>Each model defines which compartment receives doses:</p> Model Dose Target <code>OneCompIVBolus</code> Central (index 1) <code>OneCompOralFirstOrder</code> Gut (index 1)"},{"location":"semantics/#callback-timing","title":"Callback Timing","text":"<p>Doses in <code>(t0, t1]</code> are applied as preset time callbacks:</p> <ul> <li>Exact time precision (no interpolation)</li> <li>State discontinuity at dose time</li> <li>Solver restarts after callback</li> </ul>"},{"location":"semantics/#solver-semantics-v100","title":"Solver Semantics (v1.0.0)","text":"<p>Solver semantics define ODE solving behavior and defaults.</p>"},{"location":"semantics/#supported-algorithms","title":"Supported Algorithms","text":"Algorithm Type Use Case <code>Tsit5</code> Explicit Runge-Kutta (5th order) Non-stiff problems (default) <code>Rosenbrock23</code> Rosenbrock method Stiff problems"},{"location":"semantics/#tolerance-interpretation","title":"Tolerance Interpretation","text":"<ul> <li><code>reltol</code>: Relative error tolerance per step</li> <li><code>abstol</code>: Absolute error tolerance per step</li> <li>Error estimate: <code>err \u2264 abstol + reltol * |u|</code></li> </ul>"},{"location":"semantics/#golden-standard-settings","title":"Golden Standard Settings","text":"<p>For reproducibility, use:</p> <pre><code>solver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n</code></pre>"},{"location":"semantics/#output-grid-alignment","title":"Output Grid Alignment","text":"<p>Results are aligned exactly to <code>saveat</code> times:</p> <ul> <li>No interpolation artifacts</li> <li>Deterministic output regardless of internal step size</li> <li>Callback discontinuities preserved</li> </ul>"},{"location":"semantics/#state-continuity","title":"State Continuity","text":"<p>For segmented simulations (IOV, time-varying covariates):</p> <ul> <li>End state of segment N \u2192 initial state of segment N+1</li> <li>No discontinuity except at dose times</li> </ul>"},{"location":"semantics/#artifact-schema-v100","title":"Artifact Schema (v1.0.0)","text":"<p>Artifact schema defines the JSON structure for serialized simulations.</p>"},{"location":"semantics/#common-fields","title":"Common Fields","text":"<p>Every artifact contains:</p> <pre><code>{\n  \"artifact_schema_version\": \"1.0.0\",\n  \"semantics_fingerprint\": {\n    \"artifact_schema_version\": \"1.0.0\",\n    \"event_semantics_version\": \"1.0.0\",\n    \"solver_semantics_version\": \"1.0.0\"\n  }\n}\n</code></pre>"},{"location":"semantics/#artifact-types","title":"Artifact Types","text":"Type <code>artifact_type</code> Value Single execution <code>\"single\"</code> or absent Population <code>\"population\"</code> Sensitivity (single) <code>\"sensitivity_single\"</code> Sensitivity (population) <code>\"sensitivity_population\"</code>"},{"location":"semantics/#numeric-precision","title":"Numeric Precision","text":"<ul> <li>All floating-point values stored with full precision</li> <li>No rounding or truncation</li> <li>JSON uses IEEE 754 double representation</li> </ul>"},{"location":"semantics/#semantics-fingerprint","title":"Semantics Fingerprint","text":"<p>Every artifact includes a fingerprint for version tracking:</p> <pre><code>semantics_fingerprint() = Dict(\n    \"artifact_schema_version\" =&gt; ARTIFACT_SCHEMA_VERSION,\n    \"event_semantics_version\" =&gt; EVENT_SEMANTICS_VERSION,\n    \"solver_semantics_version\" =&gt; SOLVER_SEMANTICS_VERSION,\n)\n</code></pre>"},{"location":"semantics/#fingerprint-verification","title":"Fingerprint Verification","text":"<p>When replaying artifacts:</p> <ol> <li>Read stored fingerprint</li> <li>Compare to current versions</li> <li>Warn if mismatch (results may differ)</li> </ol>"},{"location":"semantics/#version-bump-policy","title":"Version Bump Policy","text":""},{"location":"semantics/#when-to-bump-event-semantics","title":"When to Bump Event Semantics","text":"<ul> <li>Change to dose normalization rules</li> <li>Change to dose application order</li> <li>Change to callback timing</li> <li>Change to dose target assignment</li> </ul>"},{"location":"semantics/#when-to-bump-solver-semantics","title":"When to Bump Solver Semantics","text":"<ul> <li>Change to default tolerances</li> <li>Change to algorithm selection logic</li> <li>Change to output grid alignment</li> <li>Change to segmentation behavior</li> </ul>"},{"location":"semantics/#when-to-bump-artifact-schema","title":"When to Bump Artifact Schema","text":"<ul> <li>Change to JSON field names</li> <li>Change to JSON structure</li> <li>Addition of required fields</li> <li>Removal of fields</li> </ul>"},{"location":"semantics/#process-for-bumping","title":"Process for Bumping","text":"<ol> <li>Identify Change: Document what behavior changes</li> <li>Bump Version: Increment appropriate version number</li> <li>Update Golden: Re-generate all affected golden artifacts</li> <li>Update Tests: Ensure tests pass with new behavior</li> <li>Document: Add entry to changelog</li> </ol>"},{"location":"semantics/#compatibility","title":"Compatibility","text":""},{"location":"semantics/#forward-compatibility","title":"Forward Compatibility","text":"<p>Newer OpenPKPD versions can replay older artifacts:</p> <ul> <li>Missing fields use defaults</li> <li>Schema upgrades are automatic</li> </ul>"},{"location":"semantics/#backward-compatibility","title":"Backward Compatibility","text":"<p>Older OpenPKPD versions may not replay newer artifacts:</p> <ul> <li>Unknown fields are ignored</li> <li>Missing required fields cause errors</li> </ul>"},{"location":"semantics/#cross-platform-compatibility","title":"Cross-Platform Compatibility","text":"<p>Same artifact should produce identical results on:</p> <ul> <li>Different operating systems</li> <li>Different Julia versions (\u22651.9)</li> <li>Different hardware architectures</li> </ul>"},{"location":"semantics/#iiviov-semantics","title":"IIV/IOV Semantics","text":""},{"location":"semantics/#random-number-generation","title":"Random Number Generation","text":"<ul> <li>Uses <code>Random.Xoshiro</code> PRNG</li> <li>Seed fully determines sequence</li> <li>Separate seeds for IIV and IOV</li> </ul>"},{"location":"semantics/#log-normal-transform","title":"Log-Normal Transform","text":"<pre><code>theta_i = theta_pop * exp(eta)\neta ~ Normal(0, omega^2)\n</code></pre>"},{"location":"semantics/#occasion-semantics-v1","title":"Occasion Semantics (v1)","text":"<p>Occasion boundaries derived from dose times:</p> <ol> <li><code>t0</code> always starts occasion 1</li> <li>Each unique dose time &gt; t0 starts new occasion</li> <li>Times sorted and deduplicated</li> <li>Only times in [t0, t1] considered</li> </ol>"},{"location":"semantics/#covariate-semantics","title":"Covariate Semantics","text":""},{"location":"semantics/#application-order","title":"Application Order","text":"<p>Covariate effects applied in declaration order:</p> <pre><code>effects = [\n    CovariateEffect(PowerCovariate(), :CL, :WT, 0.75, 70.0),\n    CovariateEffect(LinearCovariate(), :CL, :AGE, -0.01, 40.0)\n]\n# Applied: CL \u2192 (WT effect) \u2192 (AGE effect)\n</code></pre>"},{"location":"semantics/#time-varying-interpolation","title":"Time-Varying Interpolation","text":"<p>Step: Value from rightmost knot \u2264 t <pre><code>series.times = [0, 24, 48]\nseries.values = [1, 2, 3]\nvalue_at(15) = 1  # Uses knot at 0\nvalue_at(24) = 2  # Uses knot at 24\n</code></pre></p> <p>Linear: Interpolate between knots <pre><code>value_at(12) = 1.5  # Interpolate 0\u219224\n</code></pre></p>"},{"location":"semantics/#sensitivity-semantics","title":"Sensitivity Semantics","text":""},{"location":"semantics/#perturbation-application","title":"Perturbation Application","text":"<p>Perturbations applied in declaration order:</p> <pre><code>plan.perturbations = [\n    Perturbation(RelativePerturbation(), :CL, 0.1),\n    Perturbation(AbsolutePerturbation(), :V, 5.0)\n]\n# Applied: CL \u2192 CL * 1.1, then V \u2192 V + 5\n</code></pre>"},{"location":"semantics/#metric-computation","title":"Metric Computation","text":"<p>All metrics computed element-wise on output series:</p> <pre><code>max_abs_delta = max(|base[i] - pert[i]|)\nmax_rel_delta = max(|base[i] - pert[i]| / |base[i]|)\nl2_norm_delta = sqrt(sum((base[i] - pert[i])^2))\n</code></pre>"},{"location":"semantics/#examples","title":"Examples","text":""},{"location":"semantics/#verifying-semantics-match","title":"Verifying Semantics Match","text":"<pre><code>using OpenPKPDCore\n\n# Check current versions\nprintln(\"Event semantics: \", EVENT_SEMANTICS_VERSION)\nprintln(\"Solver semantics: \", SOLVER_SEMANTICS_VERSION)\nprintln(\"Artifact schema: \", ARTIFACT_SCHEMA_VERSION)\n\n# Check artifact fingerprint\nartifact = read_execution_json(\"my_artifact.json\")\nfingerprint = artifact[\"semantics_fingerprint\"]\n\nif fingerprint[\"event_semantics_version\"] != EVENT_SEMANTICS_VERSION\n    @warn \"Event semantics version mismatch\"\nend\n</code></pre>"},{"location":"semantics/#ensuring-reproducibility","title":"Ensuring Reproducibility","text":"<pre><code># Use explicit, high-precision settings\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Use deterministic seeds\niiv = IIVSpec(LogNormalIIV(), omegas, UInt64(12345), n)\n\n# Save artifact for future validation\nwrite_execution_json(\"reproducible.json\"; ...)\n</code></pre>"},{"location":"sensitivity/","title":"Sensitivity Analysis","text":"<p>OpenPKPD provides tools for analyzing how parameter changes affect model outputs, essential for understanding model behavior and identifying critical parameters.</p>"},{"location":"sensitivity/#overview","title":"Overview","text":"<p>Sensitivity analysis answers questions like:</p> <ul> <li>How much does concentration change if clearance increases by 10%?</li> <li>Which parameters have the largest impact on drug exposure?</li> <li>How does population variability affect therapeutic outcomes?</li> </ul> <p>OpenPKPD supports both single-subject and population-level sensitivity analysis.</p>"},{"location":"sensitivity/#perturbation-types","title":"Perturbation Types","text":""},{"location":"sensitivity/#relative-perturbation","title":"Relative Perturbation","text":"<p>Changes parameter by a fraction of its base value:</p> \\[\\theta_{new} = \\theta_{base} \\cdot (1 + \\delta)\\] <pre><code>RelativePerturbation()\n</code></pre> <p>Example: <code>delta = 0.1</code> increases parameter by 10%</p>"},{"location":"sensitivity/#absolute-perturbation","title":"Absolute Perturbation","text":"<p>Changes parameter by a fixed amount:</p> \\[\\theta_{new} = \\theta_{base} + \\delta\\] <pre><code>AbsolutePerturbation()\n</code></pre> <p>Example: <code>delta = 1.0</code> increases parameter by 1 unit</p>"},{"location":"sensitivity/#perturbation-specification","title":"Perturbation Specification","text":""},{"location":"sensitivity/#single-perturbation","title":"Single Perturbation","text":"<pre><code>struct Perturbation{K&lt;:PerturbationKind}\n    kind::K           # RelativePerturbation or AbsolutePerturbation\n    param::Symbol     # Parameter to perturb\n    delta::Float64    # Change magnitude\nend\n</code></pre>"},{"location":"sensitivity/#perturbation-plan","title":"Perturbation Plan","text":"<p>A plan groups multiple perturbations to be applied together:</p> <pre><code>struct PerturbationPlan\n    name::String\n    perturbations::Vector{Perturbation}  # Applied in sequence\nend\n</code></pre>"},{"location":"sensitivity/#sensitivity-metrics","title":"Sensitivity Metrics","text":"<p>OpenPKPD computes three metrics comparing base and perturbed output series:</p> <pre><code>struct SensitivityMetric\n    max_abs_delta::Float64   # Maximum |base - pert|\n    max_rel_delta::Float64   # Maximum |base - pert| / |base|\n    l2_norm_delta::Float64   # sqrt(sum((base - pert)^2))\nend\n</code></pre> Metric Formula Use Case <code>max_abs_delta</code> \\(\\max\\|y_{base} - y_{pert}\\|\\) Maximum deviation <code>max_rel_delta</code> \\(\\max\\frac{\\|y_{base} - y_{pert}\\|}{\\|y_{base}\\|}\\) Relative impact <code>l2_norm_delta</code> \\(\\sqrt{\\sum(y_{base} - y_{pert})^2}\\) Overall deviation"},{"location":"sensitivity/#single-subject-sensitivity","title":"Single-Subject Sensitivity","text":""},{"location":"sensitivity/#function","title":"Function","text":"<pre><code>run_sensitivity(spec, grid, solver; plan, observation=:conc)\n</code></pre> Parameter Description <code>spec</code> Model specification <code>grid</code> Simulation grid <code>solver</code> Solver specification <code>plan</code> Perturbation plan <code>observation</code> Output to analyze (default <code>:conc</code>)"},{"location":"sensitivity/#result-structure","title":"Result Structure","text":"<pre><code>struct SensitivityResult\n    plan::PerturbationPlan\n    observation::Symbol\n    base_metric_series::Vector{Float64}\n    pert_metric_series::Vector{Float64}\n    metrics::SensitivityMetric\n    metadata::Dict{String, Any}\nend\n</code></pre>"},{"location":"sensitivity/#example-cl-sensitivity","title":"Example: CL Sensitivity","text":"<pre><code>using OpenPKPDCore\n\n# Define model\nparams = OneCompIVBolusParams(5.0, 50.0)\nspec = ModelSpec(\n    OneCompIVBolus(),\n    \"sensitivity_example\",\n    params,\n    [DoseEvent(0.0, 100.0)]\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Perturbation plan: 10% increase in CL\nplan = PerturbationPlan(\n    \"CL_10pct_increase\",\n    [Perturbation(RelativePerturbation(), :CL, 0.1)]\n)\n\n# Run sensitivity analysis\nresult = run_sensitivity(spec, grid, solver; plan=plan, observation=:conc)\n\nprintln(\"Base concentrations: \", result.base_metric_series)\nprintln(\"Perturbed concentrations: \", result.pert_metric_series)\nprintln(\"Max absolute delta: \", result.metrics.max_abs_delta)\nprintln(\"Max relative delta: \", result.metrics.max_rel_delta)\nprintln(\"L2 norm delta: \", result.metrics.l2_norm_delta)\n</code></pre>"},{"location":"sensitivity/#example-multiple-parameter-perturbation","title":"Example: Multiple Parameter Perturbation","text":"<pre><code># Perturbation plan: increase CL by 10% and decrease V by 5%\nplan = PerturbationPlan(\n    \"CL_up_V_down\",\n    [\n        Perturbation(RelativePerturbation(), :CL, 0.1),   # +10% CL\n        Perturbation(RelativePerturbation(), :V, -0.05)  # -5% V\n    ]\n)\n\nresult = run_sensitivity(spec, grid, solver; plan=plan)\n</code></pre>"},{"location":"sensitivity/#example-absolute-perturbation","title":"Example: Absolute Perturbation","text":"<pre><code># Perturbation plan: increase CL by 1 L/h\nplan = PerturbationPlan(\n    \"CL_plus_1\",\n    [Perturbation(AbsolutePerturbation(), :CL, 1.0)]\n)\n\nresult = run_sensitivity(spec, grid, solver; plan=plan)\n</code></pre>"},{"location":"sensitivity/#population-sensitivity","title":"Population Sensitivity","text":"<p>Population sensitivity analysis evaluates how parameter perturbations affect population-level summaries (mean, quantiles).</p>"},{"location":"sensitivity/#function_1","title":"Function","text":"<pre><code>run_population_sensitivity(pop, grid, solver; plan, observation=:conc, probs=[0.05, 0.95])\n</code></pre> Parameter Description <code>pop</code> Population specification <code>grid</code> Simulation grid <code>solver</code> Solver specification <code>plan</code> Perturbation plan <code>observation</code> Output to analyze (default <code>:conc</code>) <code>probs</code> Quantile probabilities (default <code>[0.05, 0.95]</code>)"},{"location":"sensitivity/#result-structure_1","title":"Result Structure","text":"<pre><code>struct PopulationSensitivityResult\n    plan::PerturbationPlan\n    observation::Symbol\n    probs::Vector{Float64}\n    base_summary_mean::Vector{Float64}\n    pert_summary_mean::Vector{Float64}\n    base_quantiles::Dict{Float64, Vector{Float64}}\n    pert_quantiles::Dict{Float64, Vector{Float64}}\n    metrics_mean::SensitivityMetric\n    metadata::Dict{String, Any}\nend\n</code></pre>"},{"location":"sensitivity/#example-population-cl-sensitivity","title":"Example: Population CL Sensitivity","text":"<pre><code>using OpenPKPDCore\n\n# Define population\nparams = OneCompIVBolusParams(5.0, 50.0)\nbase_spec = ModelSpec(\n    OneCompIVBolus(),\n    \"pop_sens\",\n    params,\n    [DoseEvent(0.0, 100.0)]\n)\n\niiv = IIVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.3, :V =&gt; 0.2),\n    UInt64(12345),\n    100\n)\n\npop = PopulationSpec(base_spec, iiv, nothing, nothing, [])\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Perturbation plan: 20% increase in typical CL\nplan = PerturbationPlan(\n    \"CL_20pct\",\n    [Perturbation(RelativePerturbation(), :CL, 0.2)]\n)\n\n# Run population sensitivity\nresult = run_population_sensitivity(\n    pop, grid, solver;\n    plan=plan,\n    observation=:conc,\n    probs=[0.05, 0.50, 0.95]\n)\n\nprintln(\"Base mean: \", result.base_summary_mean)\nprintln(\"Perturbed mean: \", result.pert_summary_mean)\nprintln(\"Mean metrics: \", result.metrics_mean)\n\n# Compare quantiles\nprintln(\"Base 5th percentile: \", result.base_quantiles[0.05])\nprintln(\"Pert 5th percentile: \", result.pert_quantiles[0.05])\n</code></pre>"},{"location":"sensitivity/#helper-functions","title":"Helper Functions","text":""},{"location":"sensitivity/#apply-single-perturbation","title":"Apply Single Perturbation","text":"<pre><code>new_params = apply_perturbation(params, perturbation)\n</code></pre>"},{"location":"sensitivity/#apply-perturbation-plan","title":"Apply Perturbation Plan","text":"<pre><code>new_params = apply_plan(params, plan)\n</code></pre>"},{"location":"sensitivity/#compute-metrics","title":"Compute Metrics","text":"<pre><code>metrics = compute_metrics(base_series, pert_series)\n</code></pre>"},{"location":"sensitivity/#sensitivity-analysis-workflow","title":"Sensitivity Analysis Workflow","text":""},{"location":"sensitivity/#1-define-baseline-model","title":"1. Define Baseline Model","text":"<pre><code>params = OneCompIVBolusParams(5.0, 50.0)\nspec = ModelSpec(OneCompIVBolus(), \"baseline\", params, [DoseEvent(0.0, 100.0)])\n</code></pre>"},{"location":"sensitivity/#2-create-perturbation-plans","title":"2. Create Perturbation Plans","text":"<pre><code>plans = [\n    PerturbationPlan(\"CL+10%\", [Perturbation(RelativePerturbation(), :CL, 0.1)]),\n    PerturbationPlan(\"CL-10%\", [Perturbation(RelativePerturbation(), :CL, -0.1)]),\n    PerturbationPlan(\"V+10%\", [Perturbation(RelativePerturbation(), :V, 0.1)]),\n    PerturbationPlan(\"V-10%\", [Perturbation(RelativePerturbation(), :V, -0.1)]),\n]\n</code></pre>"},{"location":"sensitivity/#3-run-sensitivity-for-each-plan","title":"3. Run Sensitivity for Each Plan","text":"<pre><code>results = Dict{String, SensitivityResult}()\nfor plan in plans\n    results[plan.name] = run_sensitivity(spec, grid, solver; plan=plan)\nend\n</code></pre>"},{"location":"sensitivity/#4-analyze-results","title":"4. Analyze Results","text":"<pre><code>println(\"Parameter Sensitivity Summary:\")\nprintln(\"=\" ^ 50)\nfor (name, res) in results\n    println(\"$name:\")\n    println(\"  Max absolute delta: $(res.metrics.max_abs_delta)\")\n    println(\"  Max relative delta: $(res.metrics.max_rel_delta)\")\n    println()\nend\n</code></pre>"},{"location":"sensitivity/#serialization","title":"Serialization","text":"<p>Sensitivity results can be saved to JSON artifacts.</p>"},{"location":"sensitivity/#single-sensitivity-artifact","title":"Single Sensitivity Artifact","text":"<pre><code>write_sensitivity_json(\n    \"sensitivity_result.json\";\n    model_spec=spec,\n    grid=grid,\n    solver=solver,\n    result=result\n)\n</code></pre>"},{"location":"sensitivity/#population-sensitivity-artifact","title":"Population Sensitivity Artifact","text":"<pre><code>write_population_sensitivity_json(\n    \"pop_sensitivity_result.json\";\n    population_spec=pop,\n    grid=grid,\n    solver=solver,\n    result=result\n)\n</code></pre>"},{"location":"sensitivity/#replay-sensitivity-artifact","title":"Replay Sensitivity Artifact","text":"<pre><code>artifact = read_execution_json(\"sensitivity_result.json\")\nreplayed = replay_sensitivity_execution(artifact)\n</code></pre>"},{"location":"sensitivity/#complete-example-parameter-ranking","title":"Complete Example: Parameter Ranking","text":"<pre><code>using OpenPKPDCore\n\n# Model setup\nparams = OneCompOralFirstOrderParams(1.5, 5.0, 50.0)\nspec = ModelSpec(\n    OneCompOralFirstOrder(),\n    \"oral_sensitivity\",\n    params,\n    [DoseEvent(0.0, 200.0)]\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Parameter perturbations (all +10%)\nparam_names = [:Ka, :CL, :V]\nsensitivity_results = Dict{Symbol, Float64}()\n\nfor param in param_names\n    plan = PerturbationPlan(\n        \"$(param)_sensitivity\",\n        [Perturbation(RelativePerturbation(), param, 0.1)]\n    )\n    result = run_sensitivity(spec, grid, solver; plan=plan)\n    sensitivity_results[param] = result.metrics.max_rel_delta\nend\n\n# Rank parameters by sensitivity\nsorted_params = sort(collect(sensitivity_results), by=x-&gt;x[2], rev=true)\n\nprintln(\"Parameter Sensitivity Ranking (10% perturbation):\")\nprintln(\"=\" ^ 50)\nfor (i, (param, sens)) in enumerate(sorted_params)\n    println(\"$i. $param: max relative delta = $(round(sens, digits=4))\")\nend\n</code></pre>"},{"location":"sensitivity/#best-practices","title":"Best Practices","text":"<ol> <li>Use Relative Perturbations for comparing parameters with different scales</li> <li>Match Perturbation Size to expected variability (e.g., IIV omega values)</li> <li>Consider Multiple Metrics - max_abs for safety margins, max_rel for proportional impact</li> <li>Population Sensitivity for understanding variability-parameter interactions</li> <li>Document Plans with meaningful names for reproducibility</li> </ol>"},{"location":"examples/","title":"OpenPKPD Examples","text":"<p>Comprehensive examples covering all OpenPKPD features across Julia, Python, and CLI interfaces.</p>"},{"location":"examples/#quick-navigation","title":"Quick Navigation","text":"Category Description Languages Quickstart Get started in 5 minutes Julia, Python, CLI Models All 12 PK/PD models Julia, Python, CLI Population IIV, IOV, covariates Julia, Python, CLI Estimation FOCE-I, SAEM, diagnostics Julia, Python NCA Non-compartmental analysis Julia, Python VPC Visual Predictive Checks Julia, Python, CLI Trial Clinical trial simulation Julia, Python, CLI Import NONMEM/Monolix import Julia, Python, CLI Data CDISC data import Julia, Python Visualization Plotting and figures Python Sensitivity Parameter sensitivity Julia, Python, CLI Reproducibility Artifacts and replay Julia, Python, CLI"},{"location":"examples/#end-to-end-use-cases","title":"End-to-End Use Cases","text":"<p>Complete workflows from data to analysis:</p> Use Case Description FIH Dose Exploration First-in-human dose selection PKPD Biomarker Biomarker turnover modeling NONMEM Migration Migrate NONMEM models to OpenPKPD Theophylline Analysis Real-world PK analysis Bioequivalence Study Complete BE workflow Population PKPD Full population analysis"},{"location":"examples/#real-world-validation","title":"Real-World Validation","text":"<p>Validation against published datasets:</p> Study Dataset Features Theophylline SD Single dose PK NCA, estimation Theophylline MD Multiple dose PK Population, VPC Warfarin PKPD PK/PD model Indirect response"},{"location":"examples/#quickstart","title":"Quickstart","text":""},{"location":"examples/#julia-5-minutes","title":"Julia (5 minutes)","text":"<pre><code>using OpenPKPDCore\n\n# Create a one-compartment IV bolus model\nmodel = create_model_spec(\"OneCompIVBolus\",\n    params = Dict(\"CL\" =&gt; 5.0, \"V\" =&gt; 50.0),\n    doses = [DoseEvent(time=0.0, amount=100.0)]\n)\n\n# Simulate\ngrid = SimulationGrid(t0=0.0, t1=24.0, saveat=0:0.5:24)\nresult = simulate(model, grid)\n\n# Extract metrics\nprintln(\"Cmax: \", maximum(result.observations[\"conc\"]))\n</code></pre>"},{"location":"examples/#python-5-minutes","title":"Python (5 minutes)","text":"<pre><code>from openpkpd import simulate, create_model_spec\n\n# Create model\nmodel = create_model_spec(\"OneCompIVBolus\",\n    params={\"CL\": 5.0, \"V\": 50.0},\n    doses=[{\"time\": 0.0, \"amount\": 100.0}]\n)\n\n# Simulate\nresult = simulate(model, t_end=24.0, saveat=0.5)\n\n# Extract metrics\nprint(f\"Cmax: {max(result['observations']['conc'])}\")\n</code></pre>"},{"location":"examples/#cli-5-minutes","title":"CLI (5 minutes)","text":"<pre><code># Run simulation\n./bin/openpkpd simulate --spec quickstart/spec.json --out result.json\n\n# Compute metrics\n./bin/openpkpd metrics --artifact result.json --metrics cmax,tmax,auc\n</code></pre>"},{"location":"examples/#models-reference","title":"Models Reference","text":""},{"location":"examples/#pk-models","title":"PK Models","text":"Model Compartments Administration Key Parameters OneCompIVBolus 1 IV Bolus CL, V OneCompIVInfusion 1 IV Infusion CL, V, duration OneCompOralFirstOrder 1 Oral Ka, CL, V TwoCompIVBolus 2 IV Bolus CL, V1, Q, V2 TwoCompOral 2 Oral Ka, CL, V1, Q, V2 ThreeCompIVBolus 3 IV Bolus CL, V1, Q2, V2, Q3, V3 TransitAbsorption 1 + transit Oral Ktr, n, CL, V MichaelisMentenElimination 1 IV Vmax, Km, V"},{"location":"examples/#pkpd-models","title":"PKPD Models","text":"Model Response Type Key Parameters DirectEmax Direct effect Emax, EC50, E0 SigmoidEmax Sigmoidal Emax, EC50, gamma, E0 BiophaseEquilibration Effect compartment Emax, EC50, Ke0 IndirectResponse Turnover Kin, Kout, Imax/Smax, IC50/SC50"},{"location":"examples/#population-modeling","title":"Population Modeling","text":""},{"location":"examples/#iiv-inter-individual-variability","title":"IIV (Inter-Individual Variability)","text":"<pre><code># Log-normal IIV on CL and V\npop_spec = create_population_spec(\n    base_model = model,\n    iiv = LogNormalIIV(\n        omegas = Dict(\"CL\" =&gt; 0.3, \"V\" =&gt; 0.2),\n        seed = 12345\n    ),\n    n = 100\n)\nresult = simulate_population(pop_spec, grid)\n</code></pre>"},{"location":"examples/#covariates","title":"Covariates","text":"<pre><code># Weight-based allometric scaling\ncovariate_model = create_covariate_model(\n    effects = [\n        CovariateEffect(:WT, :CL, :power, exponent=0.75, reference=70.0),\n        CovariateEffect(:WT, :V, :power, exponent=1.0, reference=70.0)\n    ]\n)\n</code></pre>"},{"location":"examples/#feature-examples","title":"Feature Examples","text":""},{"location":"examples/#parameter-estimation-foce-i","title":"Parameter Estimation (FOCE-I)","text":"<pre><code># Estimate parameters from observed data\nconfig = EstimationConfig(\n    method = FOCEI(),\n    theta_init = [5.0, 50.0, 1.5],\n    theta_lower = [0.1, 1.0, 0.1],\n    theta_upper = [100.0, 500.0, 10.0],\n    omega_init = [0.09, 0.04, 0.16]\n)\nresult = estimate(observed_data, model_spec, config)\n</code></pre>"},{"location":"examples/#visual-predictive-check-vpc","title":"Visual Predictive Check (VPC)","text":"<pre><code># Generate VPC\nvpc_result = compute_vpc(\n    observed_data,\n    pop_spec,\n    n_simulations = 500,\n    quantiles = [0.05, 0.5, 0.95]\n)\n</code></pre>"},{"location":"examples/#non-compartmental-analysis-nca","title":"Non-Compartmental Analysis (NCA)","text":"<pre><code># Compute NCA metrics\nnca_result = compute_nca(\n    times = observed_times,\n    concentrations = observed_conc,\n    dose = 100.0,\n    route = :oral\n)\n# Returns: Cmax, Tmax, AUC_0_t, AUC_0_inf, t_half, CL_F, Vz_F\n</code></pre>"},{"location":"examples/#trial-simulation","title":"Trial Simulation","text":"<pre><code># Simulate bioequivalence study\ntrial_spec = TrialSpec(\n    design = CrossoverDesign(periods=2, sequences=2, washout=7),\n    arm_specs = [\n        ArmSpec(treatment=\"Reference\", n=12),\n        ArmSpec(treatment=\"Test\", n=12)\n    ],\n    endpoints = [BioequivalenceEndpoint(metric=:AUC, acceptance=[0.8, 1.25])]\n)\nresult = simulate_trial(trial_spec, model_spec)\n</code></pre>"},{"location":"examples/#directory-structure","title":"Directory Structure","text":"<pre><code>docs/examples/\n\u251c\u2500\u2500 README.md                    # This file\n\u251c\u2500\u2500 quickstart/                  # Getting started\n\u251c\u2500\u2500 models/                      # All PK/PD models\n\u2502   \u251c\u2500\u2500 pk/                      # PK models (8)\n\u2502   \u2514\u2500\u2500 pkpd/                    # PKPD models (4)\n\u251c\u2500\u2500 population/                  # Population modeling\n\u251c\u2500\u2500 estimation/                  # Parameter estimation\n\u251c\u2500\u2500 nca/                         # Non-compartmental analysis\n\u251c\u2500\u2500 vpc/                         # Visual Predictive Checks\n\u251c\u2500\u2500 trial/                       # Trial simulation\n\u251c\u2500\u2500 import/                      # Model import\n\u2502   \u251c\u2500\u2500 nonmem/                  # NONMEM import\n\u2502   \u2514\u2500\u2500 monolix/                 # Monolix import\n\u251c\u2500\u2500 data/                        # Data import\n\u2502   \u2514\u2500\u2500 cdisc/                   # CDISC format\n\u251c\u2500\u2500 visualization/               # Plotting\n\u251c\u2500\u2500 sensitivity/                 # Sensitivity analysis\n\u251c\u2500\u2500 reproducibility/             # Artifacts and replay\n\u251c\u2500\u2500 use_cases/                   # End-to-end workflows\n\u2514\u2500\u2500 real_world_validation/       # Published datasets\n</code></pre>"},{"location":"examples/#running-examples","title":"Running Examples","text":""},{"location":"examples/#run-all-examples","title":"Run All Examples","text":"<pre><code># Run all example validation\n./docs/examples/run_all.sh\n\n# Run specific category\njulia --project=core/OpenPKPDCore docs/examples/models/run_all.jl\npython docs/examples/estimation/run_all.py\n</code></pre>"},{"location":"examples/#validate-outputs","title":"Validate Outputs","text":"<pre><code># Validate against expected outputs\njulia --project=core/OpenPKPDCore docs/examples/validate_outputs.jl\n</code></pre>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<ol> <li>Each example should be in its own directory</li> <li>Include Julia, Python, and CLI versions where applicable</li> <li>Add expected output files for CI validation</li> <li>Include a README.md explaining the example</li> <li>Follow the naming convention: <code>01_descriptive_name/</code></li> </ol> <p>See the CONTRIBUTING guide for guidelines.</p>"},{"location":"examples/data/","title":"Data Import Examples","text":"<p>Examples demonstrating import of clinical data in CDISC and custom formats.</p>"},{"location":"examples/data/#cdisc-domains","title":"CDISC Domains","text":"Domain Description Use PC Pharmacokinetic Concentrations Observed PK data EX Exposure Dosing records DM Demographics Subject characteristics VS Vital Signs Covariates (weight, etc.) LB Lab Results Biomarkers, renal function"},{"location":"examples/data/#examples","title":"Examples","text":"Example Description Directory Basic PC/EX Standard PK data import 01_basic_pc_ex With Infusion Infusion data from EXDUR 02_with_infusion XPT Format SAS transport files 03_xpt_format"},{"location":"examples/data/#basic-usage","title":"Basic Usage","text":"<pre><code>from openpkpd.data import load_cdisc\n\n# Load from CSV files\ndata = load_cdisc(\n    pc=\"pc.csv\",\n    ex=\"ex.csv\",\n    dm=\"dm.csv\"\n)\n\n# Access as OpenPKPD format\nprint(f\"Subjects: {len(data.subjects)}\")\nprint(f\"Observations: {len(data.observations)}\")\nprint(f\"Doses: {len(data.doses)}\")\n</code></pre>"},{"location":"examples/data/#cdisc-to-openpkpd-mapping","title":"CDISC to OpenPKPD Mapping","text":""},{"location":"examples/data/#pc-domain","title":"PC Domain","text":"CDISC Variable OpenPKPD USUBJID subject_id PCTPTNUM / PCELTM time PCSTRESN dv PCSPEC compartment PCLLOQ lloq"},{"location":"examples/data/#ex-domain","title":"EX Domain","text":"CDISC Variable OpenPKPD USUBJID subject_id EXSTDTC + EXSTTM dose_time EXDOSE amount EXDUR duration (for infusion) EXROUTE route"},{"location":"examples/data/#dm-domain","title":"DM Domain","text":"CDISC Variable OpenPKPD USUBJID subject_id AGE covariates.age SEX covariates.sex RACE covariates.race"},{"location":"examples/data/#see-also","title":"See Also","text":"<ul> <li>Model Import - NONMEM/Monolix import</li> <li>Population Examples - Using covariates</li> </ul>"},{"location":"examples/data/cdisc/01_basic_pc_ex/","title":"Basic CDISC PC/EX Import","text":"<p>Import pharmacokinetic data from standard CDISC PC (concentrations) and EX (exposure) domains.</p>"},{"location":"examples/data/cdisc/01_basic_pc_ex/#data-structure","title":"Data Structure","text":""},{"location":"examples/data/cdisc/01_basic_pc_ex/#pc-domain-pharmacokinetic-concentrations","title":"PC Domain (Pharmacokinetic Concentrations)","text":"<ul> <li>USUBJID: Subject identifier</li> <li>PCTPTNUM: Nominal time</li> <li>PCSTRESN: Numeric result</li> <li>PCSTAT: Status (if BLQ)</li> <li>PCLLOQ: Lower limit of quantification</li> </ul>"},{"location":"examples/data/cdisc/01_basic_pc_ex/#ex-domain-exposure","title":"EX Domain (Exposure)","text":"<ul> <li>USUBJID: Subject identifier</li> <li>EXSTDTC: Start datetime</li> <li>EXDOSE: Dose amount</li> <li>EXROUTE: Route of administration</li> </ul>"},{"location":"examples/data/cdisc/01_basic_pc_ex/#files","title":"Files","text":"File Description pc.csv PC domain data ex.csv EX domain data dm.csv DM domain data load.py Python loader load.jl Julia loader"},{"location":"examples/data/cdisc/01_basic_pc_ex/#usage","title":"Usage","text":"<pre><code>from openpkpd.data import load_cdisc\n\ndata = load_cdisc(pc=\"pc.csv\", ex=\"ex.csv\", dm=\"dm.csv\")\n</code></pre>"},{"location":"examples/data/cdisc/02_with_infusion/","title":"CDISC Infusion Data Import","text":"<p>Import pharmacokinetic data with IV infusion dosing using EXDUR field.</p>"},{"location":"examples/data/cdisc/02_with_infusion/#key-fields","title":"Key Fields","text":""},{"location":"examples/data/cdisc/02_with_infusion/#ex-domain-for-infusion","title":"EX Domain for Infusion","text":"<ul> <li>EXDOSE: Dose amount</li> <li>EXDOSU: Dose units</li> <li>EXDUR: Infusion duration (e.g., \"PT1H\" for 1 hour)</li> <li>EXROUTE: INTRAVENOUS</li> </ul>"},{"location":"examples/data/cdisc/02_with_infusion/#files","title":"Files","text":"File Description ex.csv EX domain with EXDUR load.py Python loader <p>Note: This example reuses PC data from the basic example.</p>"},{"location":"examples/data/cdisc/02_with_infusion/#infusion-handling","title":"Infusion Handling","text":"<pre><code># EXDUR format: ISO 8601 duration\n# PT1H = 1 hour infusion\n# PT30M = 30 minute infusion\n# PT2H30M = 2.5 hour infusion\n\ndata = load_cdisc(pc=\"pc.csv\", ex=\"ex.csv\")\n\n# Infusion detected from EXDUR\nfor dose in data.doses:\n    print(f\"Dose: {dose.amount} mg, Duration: {dose.duration} h\")\n</code></pre>"},{"location":"examples/data/cdisc/03_xpt_format/","title":"CDISC XPT Format Import","text":"<p>Import pharmacokinetic data from SAS transport (.xpt) files.</p>"},{"location":"examples/data/cdisc/03_xpt_format/#xpt-format","title":"XPT Format","text":"<p>XPT (SAS Transport) is the standard format for CDISC submission packages: - Binary format specified by FDA - Contains datasets in SAS transport format - Common in regulatory submissions</p>"},{"location":"examples/data/cdisc/03_xpt_format/#files","title":"Files","text":"File Description load.py Python XPT loader"},{"location":"examples/data/cdisc/03_xpt_format/#usage","title":"Usage","text":"<pre><code>from openpkpd.data import load_cdisc_xpt\n\n# Load from XPT files\ndata = load_cdisc_xpt(\n    pc=\"pc.xpt\",\n    ex=\"ex.xpt\",\n    dm=\"dm.xpt\"\n)\n</code></pre>"},{"location":"examples/data/cdisc/03_xpt_format/#dependencies","title":"Dependencies","text":"<ul> <li><code>pyreadstat</code> or <code>pandas</code> with SAS support</li> <li>XPT files must be valid SAS transport format</li> </ul>"},{"location":"examples/estimation/","title":"Parameter Estimation Examples","text":"<p>Examples demonstrating non-linear mixed effects (NLME) parameter estimation.</p>"},{"location":"examples/estimation/#estimation-methods","title":"Estimation Methods","text":"Method Description Best For FOCE-I First-Order Conditional Estimation with Interaction Most PK/PD models, standard choice SAEM Stochastic Approximation Expectation Maximization Complex models, multi-modal posteriors Laplacian Laplace approximation Sparse data, categorical outcomes"},{"location":"examples/estimation/#examples","title":"Examples","text":"Example Description Directory FOCE-I Basic One-compartment estimation 01_foce_onecomp SAEM Two-Comp Two-compartment with SAEM 02_saem_twocomp Laplacian Sparse pediatric data 03_laplacian_sparse Diagnostics GOF, CWRES, ETAs 04_estimation_diagnostics Model Comparison AIC/BIC selection 05_model_comparison"},{"location":"examples/estimation/#estimation-workflow","title":"Estimation Workflow","text":"<pre><code>1. Data Preparation\n   \u251c\u2500\u2500 Format observed data (CDISC or custom)\n   \u2514\u2500\u2500 Define dosing events\n\n2. Model Specification\n   \u251c\u2500\u2500 Choose structural model\n   \u251c\u2500\u2500 Define IIV structure\n   \u2514\u2500\u2500 Specify residual error model\n\n3. Initial Values\n   \u251c\u2500\u2500 Set \u03b8\u2080 (fixed effects)\n   \u251c\u2500\u2500 Set \u03a9\u2080 (random effects variance)\n   \u2514\u2500\u2500 Set \u03c3\u2080 (residual error)\n\n4. Run Estimation\n   \u251c\u2500\u2500 Choose method (FOCE-I, SAEM, Laplacian)\n   \u2514\u2500\u2500 Set convergence criteria\n\n5. Evaluate Results\n   \u251c\u2500\u2500 Convergence diagnostics\n   \u251c\u2500\u2500 Parameter estimates \u00b1 SE\n   \u251c\u2500\u2500 Goodness-of-fit plots\n   \u2514\u2500\u2500 Model selection (AIC/BIC)\n</code></pre>"},{"location":"examples/estimation/#key-parameters","title":"Key Parameters","text":""},{"location":"examples/estimation/#estimation-configuration","title":"Estimation Configuration","text":"<pre><code>config = EstimationConfig(\n    method = FOCEI(),\n    # Fixed effects\n    theta_init = [5.0, 50.0, 1.5],\n    theta_lower = [0.1, 1.0, 0.1],\n    theta_upper = [100.0, 500.0, 10.0],\n    # Random effects\n    omega_init = [0.09, 0.04, 0.16],\n    omega_fixed = [false, false, false],\n    # Residual error\n    sigma_init = [0.01],\n    # Algorithm settings\n    maxiter = 500,\n    tol = 1e-6\n)\n</code></pre>"},{"location":"examples/estimation/#error-models","title":"Error Models","text":"Model Formula Use Case Additive Y = F + \u03b5 Low concentrations Proportional Y = F \u00d7 (1 + \u03b5) Wide concentration range Combined Y = F \u00d7 (1 + \u03b5\u2081) + \u03b5\u2082 Best of both"},{"location":"examples/estimation/#output-interpretation","title":"Output Interpretation","text":""},{"location":"examples/estimation/#parameter-estimates","title":"Parameter Estimates","text":"<pre><code>Parameter   Estimate    SE        RSE%      95% CI\nCL          5.23        0.31      5.9       [4.62, 5.84]\nV           48.7        3.2       6.6       [42.4, 55.0]\nKa          1.42        0.18      12.7      [1.07, 1.77]\n\u03c9_CL        0.32        0.04      12.5      [0.24, 0.40]\n\u03c9_V         0.21        0.03      14.3      [0.15, 0.27]\n\u03c3_prop      0.12        0.01      8.3       [0.10, 0.14]\n</code></pre>"},{"location":"examples/estimation/#objective-function","title":"Objective Function","text":"<ul> <li>OFV (Objective Function Value): -2 \u00d7 log-likelihood</li> <li>Lower OFV = better fit</li> <li>\u0394OFV &gt; 3.84 (df=1, \u03b1=0.05) = significant improvement</li> </ul>"},{"location":"examples/estimation/#common-issues","title":"Common Issues","text":"Issue Symptom Solution Non-convergence Max iterations reached Better initial values, simpler model Boundary estimates \u03c9 \u2192 0 or \u2192 \u221e Fix parameter, check data High RSE SE &gt; 50% More data, simpler model Poor GOF Systematic bias Check structural model"},{"location":"examples/estimation/#see-also","title":"See Also","text":"<ul> <li>Population Examples - Population simulation</li> <li>VPC - Visual Predictive Checks</li> <li>NCA - Non-compartmental analysis</li> </ul>"},{"location":"examples/estimation/01_foce_onecomp/","title":"FOCE-I One-Compartment Estimation","text":"<p>Parameter estimation using FOCE-I method on simulated oral PK data.</p>"},{"location":"examples/estimation/01_foce_onecomp/#model","title":"Model","text":"<p>Structural: <pre><code>dA_depot/dt = -Ka \u00d7 A_depot\ndA_central/dt = Ka \u00d7 A_depot - CL/V \u00d7 A_central\n</code></pre></p> <p>Statistical: <pre><code>CL_i = \u03b8_CL \u00d7 exp(\u03b7_CL,i)\nV_i  = \u03b8_V \u00d7 exp(\u03b7_V,i)\nKa_i = \u03b8_Ka \u00d7 exp(\u03b7_Ka,i)\n\nY_ij = F_ij \u00d7 (1 + \u03b5_ij)   # Proportional error\n</code></pre></p>"},{"location":"examples/estimation/01_foce_onecomp/#data","title":"Data","text":"<p>Simulated data for 30 subjects: - 100 mg oral dose at t=0 - Sampling at 0.5, 1, 2, 4, 6, 8, 12, 24h - True parameters: CL=5, V=50, Ka=1.5 - IIV: \u03c9_CL=0.3, \u03c9_V=0.2, \u03c9_Ka=0.4</p>"},{"location":"examples/estimation/01_foce_onecomp/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia estimation <code>python.py</code> Python estimation <code>data.csv</code> Observed data <code>expected_results.json</code> Expected parameter estimates"},{"location":"examples/estimation/02_saem_twocomp/","title":"SAEM Two-Compartment Estimation","text":"<p>Parameter estimation using SAEM algorithm for a two-compartment model.</p>"},{"location":"examples/estimation/02_saem_twocomp/#method","title":"Method","text":"<p>SAEM (Stochastic Approximation Expectation Maximization) is useful for: - Complex models with many parameters - Multi-modal posterior distributions - Models where FOCE may struggle</p>"},{"location":"examples/estimation/02_saem_twocomp/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Example</li> </ul>"},{"location":"examples/estimation/03_laplacian_sparse/","title":"Laplacian Estimation for Sparse Data","text":"<p>Parameter estimation using Laplace approximation for sparse pediatric data.</p>"},{"location":"examples/estimation/03_laplacian_sparse/#use-case","title":"Use Case","text":"<p>Laplacian estimation is ideal for: - Sparse sampling designs - Pediatric populations with limited samples - Binary or categorical outcomes</p>"},{"location":"examples/estimation/03_laplacian_sparse/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Example</li> <li>SAEM Example</li> </ul>"},{"location":"examples/estimation/04_estimation_diagnostics/","title":"Estimation Diagnostics","text":"<p>Goodness-of-fit and diagnostic evaluation after parameter estimation.</p>"},{"location":"examples/estimation/04_estimation_diagnostics/#diagnostic-plots","title":"Diagnostic Plots","text":"<ul> <li>DV vs PRED</li> <li>DV vs IPRED</li> <li>CWRES vs Time</li> <li>CWRES vs PRED</li> <li>ETA distributions</li> <li>QQ plots</li> </ul>"},{"location":"examples/estimation/04_estimation_diagnostics/#see-also","title":"See Also","text":"<ul> <li>Visualization Examples</li> </ul>"},{"location":"examples/estimation/05_model_comparison/","title":"Model Comparison","text":"<p>Comparing models using AIC/BIC and likelihood ratio tests.</p>"},{"location":"examples/estimation/05_model_comparison/#criteria","title":"Criteria","text":"Criterion Formula Use AIC -2LL + 2k General comparison BIC -2LL + k*ln(n) Large sample sizes LRT \u0394OFV vs \u03c7\u00b2 Nested models"},{"location":"examples/estimation/05_model_comparison/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Example</li> </ul>"},{"location":"examples/import/","title":"Model Import Examples","text":"<p>Examples demonstrating import of models from NONMEM and Monolix.</p>"},{"location":"examples/import/#supported-formats","title":"Supported Formats","text":"Source Format Import Function NONMEM .ctl, .mod <code>import_nonmem()</code> Monolix .mlxtran <code>import_monolix()</code>"},{"location":"examples/import/#nonmem-examples","title":"NONMEM Examples","text":"Example ADVAN Description Directory ADVAN1 1-comp IV One-compartment IV bolus 01_advan1_onecomp ADVAN2 1-comp Oral One-compartment first-order absorption 02_advan2_oral ADVAN4 2-comp IV Two-compartment IV bolus 03_advan4_twocomp"},{"location":"examples/import/#monolix-examples","title":"Monolix Examples","text":"Example Model Description Directory pk1cpt 1-comp Oral One-compartment with Ka 01_pk1cpt_oral pk2cpt 2-comp IV Two-compartment IV 02_pk2cpt_iv"},{"location":"examples/import/#import-workflow","title":"Import Workflow","text":"<pre><code>from openpkpd import import_nonmem, import_monolix\n\n# Import NONMEM model\nmodel = import_nonmem(\"run001.ctl\")\n\n# Import Monolix project\nmodel = import_monolix(\"project.mlxtran\")\n\n# Use imported model\nresult = simulate(model.spec, t_end=24.0)\n</code></pre>"},{"location":"examples/import/#what-gets-imported","title":"What Gets Imported","text":"Component NONMEM Monolix Structural model ADVAN/TRANS Structural model Fixed effects (THETA) Yes Yes Random effects (OMEGA) Yes Yes Residual error (SIGMA) Yes Yes Covariate model $COV block Covariate section Initial estimates Yes Yes"},{"location":"examples/import/#validation","title":"Validation","text":"<p>Each import example includes: 1. Original source file 2. Import script 3. Expected OpenPKPD specification 4. Validation by comparing simulations</p>"},{"location":"examples/import/#see-also","title":"See Also","text":"<ul> <li>Data Import - CDISC data import</li> <li>Models - OpenPKPD model specifications</li> </ul>"},{"location":"examples/import/monolix/01_pk1cpt_oral/","title":"Monolix pk1cpt Import","text":"<p>Import a one-compartment oral model from Monolix project.</p>"},{"location":"examples/import/monolix/01_pk1cpt_oral/#monolix-model","title":"Monolix Model","text":"<ul> <li>Structural: lib:oral1_1cpt_kaVCl</li> <li>Parameters: ka=1.5 1/h, V=50.0 L, Cl=5.0 L/h</li> <li>IIV: ka, V, Cl (log-normal)</li> <li>Error: Combined</li> </ul>"},{"location":"examples/import/monolix/01_pk1cpt_oral/#files","title":"Files","text":"File Description project.mlxtran Monolix project file convert.py Python conversion expected.json Expected OpenPKPD spec"},{"location":"examples/import/monolix/01_pk1cpt_oral/#conversion","title":"Conversion","text":"<pre><code>from openpkpd import import_monolix\n\nmodel = import_monolix(\"project.mlxtran\")\nprint(model.spec)\n</code></pre>"},{"location":"examples/import/monolix/01_pk1cpt_oral/#parameter-mapping","title":"Parameter Mapping","text":"Monolix OpenPKPD ka_pop params.Ka V_pop params.V Cl_pop params.CL omega_ka iiv.omegas.Ka omega_V iiv.omegas.V omega_Cl iiv.omegas.CL"},{"location":"examples/import/monolix/02_pk2cpt_iv/","title":"Monolix pk2cpt Import","text":"<p>Import a two-compartment IV model from Monolix project.</p>"},{"location":"examples/import/monolix/02_pk2cpt_iv/#monolix-model","title":"Monolix Model","text":"<ul> <li>Structural: lib:bolus2_2cpt_ClV1QV2</li> <li>Parameters: Cl=5.0 L/h, V1=10.0 L, Q=2.0 L/h, V2=20.0 L</li> <li>IIV: Cl, V1 (log-normal)</li> <li>Error: Proportional</li> </ul>"},{"location":"examples/import/monolix/02_pk2cpt_iv/#files","title":"Files","text":"File Description project.mlxtran Monolix project file convert.py Python conversion expected.json Expected OpenPKPD spec"},{"location":"examples/import/monolix/02_pk2cpt_iv/#parameter-mapping","title":"Parameter Mapping","text":"Monolix OpenPKPD Cl_pop params.CL V1_pop params.V1 Q_pop params.Q V2_pop params.V2"},{"location":"examples/import/nonmem/01_advan1_onecomp/","title":"NONMEM ADVAN1 Import","text":"<p>Import a one-compartment IV bolus model from NONMEM control file.</p>"},{"location":"examples/import/nonmem/01_advan1_onecomp/#nonmem-model","title":"NONMEM Model","text":"<ul> <li>ADVAN: 1 (One-compartment)</li> <li>TRANS: 2 (CL, V parameterization)</li> <li>Parameters: CL=5.0 L/h, V=50.0 L</li> <li>IIV: CL (30% CV), V (25% CV)</li> <li>Error: Proportional (10% CV)</li> </ul>"},{"location":"examples/import/nonmem/01_advan1_onecomp/#files","title":"Files","text":"File Description run001.ctl NONMEM control file convert.py Python conversion convert.jl Julia conversion expected.json Expected OpenPKPD spec"},{"location":"examples/import/nonmem/01_advan1_onecomp/#conversion","title":"Conversion","text":"<pre><code>from openpkpd import import_nonmem\n\nmodel = import_nonmem(\"run001.ctl\")\nprint(model.spec)  # OpenPKPD ModelSpec\n</code></pre>"},{"location":"examples/import/nonmem/01_advan1_onecomp/#parameter-mapping","title":"Parameter Mapping","text":"NONMEM OpenPKPD THETA(1) = CL params.CL THETA(2) = V params.V OMEGA(1,1) iiv.omegas.CL OMEGA(2,2) iiv.omegas.V SIGMA(1,1) error.proportional"},{"location":"examples/import/nonmem/02_advan2_oral/","title":"NONMEM ADVAN2 Import","text":"<p>Import a one-compartment oral model with first-order absorption from NONMEM.</p>"},{"location":"examples/import/nonmem/02_advan2_oral/#nonmem-model","title":"NONMEM Model","text":"<ul> <li>ADVAN: 2 (One-compartment with first-order absorption)</li> <li>TRANS: 2 (CL, V, Ka parameterization)</li> <li>Parameters: Ka=1.5 1/h, CL=5.0 L/h, V=50.0 L</li> <li>IIV: Ka (40% CV), CL (30% CV), V (25% CV)</li> <li>Error: Combined (additive + proportional)</li> </ul>"},{"location":"examples/import/nonmem/02_advan2_oral/#files","title":"Files","text":"File Description run002.ctl NONMEM control file convert.py Python conversion expected.json Expected OpenPKPD spec"},{"location":"examples/import/nonmem/02_advan2_oral/#parameter-mapping","title":"Parameter Mapping","text":"NONMEM OpenPKPD THETA(1) = Ka params.Ka THETA(2) = CL params.CL THETA(3) = V params.V OMEGA(1,1) iiv.omegas.Ka OMEGA(2,2) iiv.omegas.CL OMEGA(3,3) iiv.omegas.V"},{"location":"examples/import/nonmem/03_advan4_twocomp/","title":"NONMEM ADVAN4 Import","text":"<p>Import a two-compartment IV bolus model from NONMEM.</p>"},{"location":"examples/import/nonmem/03_advan4_twocomp/#nonmem-model","title":"NONMEM Model","text":"<ul> <li>ADVAN: 4 (Two-compartment)</li> <li>TRANS: 4 (CL, V1, Q, V2 parameterization)</li> <li>Parameters: CL=5.0 L/h, V1=10.0 L, Q=2.0 L/h, V2=20.0 L</li> <li>IIV: CL (30% CV), V1 (25% CV)</li> <li>Error: Proportional (15% CV)</li> </ul>"},{"location":"examples/import/nonmem/03_advan4_twocomp/#files","title":"Files","text":"File Description run003.ctl NONMEM control file convert.py Python conversion expected.json Expected OpenPKPD spec"},{"location":"examples/import/nonmem/03_advan4_twocomp/#parameter-mapping","title":"Parameter Mapping","text":"NONMEM OpenPKPD THETA(1) = CL params.CL THETA(2) = V1 params.V1 THETA(3) = Q params.Q THETA(4) = V2 params.V2"},{"location":"examples/models/","title":"Model Examples","text":"<p>Complete examples for all OpenPKPD PK and PK/PD models.</p>"},{"location":"examples/models/#pk-models","title":"PK Models","text":"Model Description Directory OneCompIVBolus One-compartment IV bolus 01_onecomp_iv_bolus OneCompIVInfusion One-compartment IV infusion 02_onecomp_iv_infusion OneCompOralFirstOrder One-compartment oral (first-order absorption) 03_onecomp_oral TwoCompIVBolus Two-compartment IV bolus 04_twocomp_iv TwoCompOral Two-compartment oral 05_twocomp_oral ThreeCompIVBolus Three-compartment IV bolus 06_threecomp_iv TransitAbsorption Transit compartment absorption 07_transit_absorption MichaelisMentenElimination Saturable (nonlinear) elimination 08_michaelis_menten"},{"location":"examples/models/#pkpd-models","title":"PK/PD Models","text":"Model Description Directory DirectEmax Direct Emax response 01_direct_emax SigmoidEmax Sigmoidal Emax response 02_sigmoid_emax BiophaseEquilibration Effect compartment model 03_biophase_equilibration IndirectResponse Indirect response (turnover) 04_indirect_response"},{"location":"examples/models/#file-structure","title":"File Structure","text":"<p>Each model directory contains:</p> <pre><code>01_model_name/\n\u251c\u2500\u2500 README.md       # Model equations, parameters, typical values\n\u251c\u2500\u2500 julia.jl        # Julia implementation\n\u251c\u2500\u2500 python.py       # Python implementation\n\u2514\u2500\u2500 cli.json        # CLI specification\n</code></pre>"},{"location":"examples/models/#running-examples","title":"Running Examples","text":""},{"location":"examples/models/#all-models-julia","title":"All Models (Julia)","text":"<pre><code>julia --project=core/OpenPKPDCore docs/examples/models/run_all.jl\n</code></pre>"},{"location":"examples/models/#single-model","title":"Single Model","text":"<pre><code># Julia\njulia --project=core/OpenPKPDCore docs/examples/models/pk/01_onecomp_iv_bolus/julia.jl\n\n# Python\npython docs/examples/models/pk/01_onecomp_iv_bolus/python.py\n\n# CLI\n./bin/openpkpd simulate --spec docs/examples/models/pk/01_onecomp_iv_bolus/cli.json\n</code></pre>"},{"location":"examples/models/#model-selection-guide","title":"Model Selection Guide","text":""},{"location":"examples/models/#by-administration-route","title":"By Administration Route","text":"Route Single Compartment Multi-Compartment IV Bolus OneCompIVBolus TwoCompIVBolus, ThreeCompIVBolus IV Infusion OneCompIVInfusion TwoCompIVInfusion Oral OneCompOralFirstOrder TwoCompOral Oral (complex) TransitAbsorption -"},{"location":"examples/models/#by-elimination-type","title":"By Elimination Type","text":"Elimination Model Linear (first-order) OneCompIVBolus, TwoCompIVBolus, etc. Nonlinear (saturable) MichaelisMentenElimination"},{"location":"examples/models/#by-pd-response","title":"By PD Response","text":"Response Type Model Use Case Direct, hyperbolic DirectEmax Immediate response, receptor binding Direct, sigmoidal SigmoidEmax Steep dose-response, threshold effects Delayed BiophaseEquilibration Effect compartment, hysteresis Indirect IndirectResponse Enzyme/receptor turnover, biomarkers"},{"location":"examples/models/#parameter-conventions","title":"Parameter Conventions","text":""},{"location":"examples/models/#pk-parameters","title":"PK Parameters","text":"Parameter Description Typical Units CL Clearance L/h V, V1 Central volume L Q Inter-compartmental clearance L/h V2, V3 Peripheral volumes L Ka Absorption rate constant 1/h Ktr Transit rate constant 1/h Vmax Maximum elimination rate mg/h Km Michaelis constant mg/L"},{"location":"examples/models/#pd-parameters","title":"PD Parameters","text":"Parameter Description Typical Units E0 Baseline effect varies Emax Maximum effect varies EC50 Concentration at 50% Emax mg/L gamma Hill coefficient dimensionless Ke0 Effect compartment rate constant 1/h Kin Zero-order production rate units/h Kout First-order elimination rate 1/h IC50/SC50 Concentration for 50% inhibition/stimulation mg/L"},{"location":"examples/models/pk/01_onecomp_iv_bolus/","title":"One-Compartment IV Bolus Model","text":"<p>The simplest pharmacokinetic model for intravenous administration.</p>"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#model-schematic","title":"Model Schematic","text":"<pre><code>Dose (IV Bolus)\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Central   \u2502\n\u2502      V      \u2502\u2500\u2500\u2500\u2500 CL \u2500\u2500\u2500\u2500\u25b6 Elimination\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#differential-equation","title":"Differential Equation","text":"<pre><code>dA_central/dt = -CL/V \u00d7 A_central\n</code></pre> <p>With initial condition: <code>A_central(0) = Dose</code></p>"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#observation","title":"Observation","text":"<pre><code>Conc = A_central / V\n</code></pre>"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units CL Clearance 1-50 L/h V Volume of distribution 10-500 L"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#example-values","title":"Example Values","text":"Parameter Value Rationale CL 5.0 L/h Moderate hepatic clearance V 50.0 L Roughly total body water Dose 100 mg Single 100mg IV bolus"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#analytical-solution","title":"Analytical Solution","text":"<pre><code>C(t) = (Dose/V) \u00d7 exp(-CL/V \u00d7 t)\n</code></pre>"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#derived-parameters","title":"Derived Parameters","text":"Parameter Formula Example Value k CL/V 0.1 h\u207b\u00b9 t\u00bd ln(2)/k 6.93 h Cmax Dose/V 2.0 mg/L AUC\u2080\u208b\u221e Dose/CL 20 mg\u00b7h/L"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/01_onecomp_iv_bolus/#running","title":"Running","text":"<pre><code># Julia\njulia --project=core/OpenPKPDCore julia.jl\n\n# Python\npython python.py\n\n# CLI\n./bin/openpkpd simulate --spec cli.json\n</code></pre>"},{"location":"examples/models/pk/02_onecomp_iv_infusion/","title":"One-Compartment IV Infusion Model","text":"<p>One-compartment model with constant-rate intravenous infusion.</p>"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#model-schematic","title":"Model Schematic","text":"<pre><code>Infusion (Rate = Dose/Duration)\n         \u2502\n         \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502   Central   \u2502\n    \u2502      V      \u2502\u2500\u2500\u2500\u2500 CL \u2500\u2500\u2500\u2500\u25b6 Elimination\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#differential-equation","title":"Differential Equation","text":"<p>During infusion (0 \u2264 t \u2264 T_inf): <pre><code>dA_central/dt = Rate - CL/V \u00d7 A_central\n</code></pre></p> <p>After infusion (t &gt; T_inf): <pre><code>dA_central/dt = -CL/V \u00d7 A_central\n</code></pre></p> <p>Where <code>Rate = Dose / T_inf</code></p>"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units CL Clearance 1-50 L/h V Volume of distribution 10-500 L duration Infusion duration 0.5-4 h"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#example-values","title":"Example Values","text":"Parameter Value Rationale CL 5.0 L/h Moderate clearance V 50.0 L Total body water Dose 100 mg Total infusion dose Duration 1.0 h 1-hour infusion"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#derived-parameters","title":"Derived Parameters","text":"Parameter Formula Example Value Rate Dose/Duration 100 mg/h Css Rate/CL 20 mg/L (if continued) t\u00bd ln(2)\u00d7V/CL 6.93 h"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#key-features","title":"Key Features","text":"<ul> <li>Cmax occurs at end of infusion (t = T_inf)</li> <li>Lower Cmax compared to bolus for same dose</li> <li>Useful for drugs with narrow therapeutic window</li> <li>Rate-limiting can reduce infusion reactions</li> </ul>"},{"location":"examples/models/pk/02_onecomp_iv_infusion/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/03_onecomp_oral/","title":"One-Compartment Oral First-Order Absorption Model","text":"<p>One-compartment model with first-order absorption from an oral dose.</p>"},{"location":"examples/models/pk/03_onecomp_oral/#model-schematic","title":"Model Schematic","text":"<pre><code>Oral Dose\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Ka      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Gut   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502   Central   \u2502\n\u2502  (A_d)  \u2502             \u2502      V      \u2502\u2500\u2500\u2500\u2500 CL \u2500\u2500\u2500\u2500\u25b6 Elimination\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pk/03_onecomp_oral/#differential-equations","title":"Differential Equations","text":"<pre><code>dA_depot/dt = -Ka \u00d7 A_depot\ndA_central/dt = Ka \u00d7 A_depot - CL/V \u00d7 A_central\n</code></pre> <p>With initial conditions: <code>A_depot(0) = Dose \u00d7 F</code>, <code>A_central(0) = 0</code></p>"},{"location":"examples/models/pk/03_onecomp_oral/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units Ka Absorption rate constant 0.1-5.0 1/h CL Clearance 1-50 L/h V Volume of distribution 10-500 L F Bioavailability 0.1-1.0 -"},{"location":"examples/models/pk/03_onecomp_oral/#example-values","title":"Example Values","text":"Parameter Value Rationale Ka 1.5 1/h Moderate absorption CL 5.0 L/h Moderate clearance V 50.0 L Total body water Dose 100 mg Oral tablet F 1.0 Assumed 100%"},{"location":"examples/models/pk/03_onecomp_oral/#key-features","title":"Key Features","text":"<ul> <li>Absorption phase followed by elimination phase</li> <li>Tmax occurs when absorption rate = elimination rate</li> <li>\"Flip-flop\" kinetics possible when Ka &lt; k</li> </ul>"},{"location":"examples/models/pk/03_onecomp_oral/#derived-parameters","title":"Derived Parameters","text":"Parameter Formula Example Value k CL/V 0.1 h\u207b\u00b9 Tmax ln(Ka/k)/(Ka-k) 1.79 h Cmax (F\u00d7Dose/V)\u00d7(Ka/(Ka-k))\u00d7[exp(-k\u00d7Tmax)-exp(-Ka\u00d7Tmax)] 1.43 mg/L t\u00bd ln(2)/k 6.93 h"},{"location":"examples/models/pk/03_onecomp_oral/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/04_twocomp_iv/","title":"Two-Compartment IV Bolus Model","text":"<p>Two-compartment model with rapid distribution to peripheral tissues.</p>"},{"location":"examples/models/pk/04_twocomp_iv/#model-schematic","title":"Model Schematic","text":"<pre><code>IV Bolus\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Q      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Central   \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 Peripheral  \u2502\n\u2502     V1      \u2502            \u2502     V2      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502\n       \u2502 CL\n       \u25bc\n   Elimination\n</code></pre>"},{"location":"examples/models/pk/04_twocomp_iv/#differential-equations","title":"Differential Equations","text":"<pre><code>dA_central/dt = Q/V2 \u00d7 A_peripheral - Q/V1 \u00d7 A_central - CL/V1 \u00d7 A_central\ndA_peripheral/dt = Q/V1 \u00d7 A_central - Q/V2 \u00d7 A_peripheral\n</code></pre>"},{"location":"examples/models/pk/04_twocomp_iv/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units CL Clearance 1-50 L/h V1 Central volume 5-100 L Q Inter-compartmental clearance 1-50 L/h V2 Peripheral volume 10-500 L"},{"location":"examples/models/pk/04_twocomp_iv/#example-values","title":"Example Values","text":"Parameter Value Rationale CL 5.0 L/h Moderate clearance V1 10.0 L Plasma/blood volume Q 10.0 L/h Rapid distribution V2 40.0 L Tissue distribution Dose 100 mg IV bolus"},{"location":"examples/models/pk/04_twocomp_iv/#key-features","title":"Key Features","text":"<ul> <li>Bi-exponential decline (\u03b1 and \u03b2 phases)</li> <li>\u03b1 phase: distribution + elimination</li> <li>\u03b2 phase: terminal elimination</li> <li>V1 + V2 = Vss (volume at steady-state)</li> </ul>"},{"location":"examples/models/pk/04_twocomp_iv/#derived-parameters","title":"Derived Parameters","text":"Parameter Formula Description Vss V1 + V2 Steady-state volume \u03b1, \u03b2 Macro rate constants Eigenvalues t\u00bd\u03b1 ln(2)/\u03b1 Distribution half-life t\u00bd\u03b2 ln(2)/\u03b2 Terminal half-life"},{"location":"examples/models/pk/04_twocomp_iv/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/05_twocomp_oral/","title":"Two-Compartment Oral Model","text":"<p>Two-compartment model with first-order oral absorption.</p>"},{"location":"examples/models/pk/05_twocomp_oral/#model-schematic","title":"Model Schematic","text":"<pre><code>Oral Dose\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Ka      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Q      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Gut   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502   Central   \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502 Peripheral  \u2502\n\u2502  (A_d)  \u2502             \u2502     V1      \u2502            \u2502     V2      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u2502 CL\n                               \u25bc\n                          Elimination\n</code></pre>"},{"location":"examples/models/pk/05_twocomp_oral/#differential-equations","title":"Differential Equations","text":"<pre><code>dA_depot/dt = -Ka \u00d7 A_depot\ndA_central/dt = Ka \u00d7 A_depot + Q/V2 \u00d7 A_peripheral - Q/V1 \u00d7 A_central - CL/V1 \u00d7 A_central\ndA_peripheral/dt = Q/V1 \u00d7 A_central - Q/V2 \u00d7 A_peripheral\n</code></pre>"},{"location":"examples/models/pk/05_twocomp_oral/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units Ka Absorption rate constant 0.1-5.0 1/h CL Clearance 1-50 L/h V1 Central volume 5-100 L Q Inter-compartmental clearance 1-50 L/h V2 Peripheral volume 10-500 L"},{"location":"examples/models/pk/05_twocomp_oral/#example-values","title":"Example Values","text":"Parameter Value Rationale Ka 1.5 1/h Moderate absorption CL 5.0 L/h Moderate clearance V1 10.0 L Central compartment Q 10.0 L/h Rapid distribution V2 40.0 L Tissue distribution Dose 100 mg Oral dose"},{"location":"examples/models/pk/05_twocomp_oral/#key-features","title":"Key Features","text":"<ul> <li>Tri-exponential profile (absorption + \u03b1 + \u03b2 phases)</li> <li>Distribution occurs during absorption</li> <li>Common for lipophilic drugs with significant tissue binding</li> </ul>"},{"location":"examples/models/pk/05_twocomp_oral/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/06_threecomp_iv/","title":"Three-Compartment IV Bolus Model","text":"<p>Three-compartment model for drugs with complex tissue distribution.</p>"},{"location":"examples/models/pk/06_threecomp_iv/#model-schematic","title":"Model Schematic","text":"<pre><code>                  IV Bolus\n                      \u2502\n                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Q2  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Q3  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Peripheral  \u2502\u25c4\u2500\u2500\u2500\u2500\u25b6\u2502   Central   \u2502\u25c4\u2500\u2500\u2500\u2500\u25b6\u2502 Peripheral  \u2502\n\u2502   Shallow   \u2502      \u2502     V1      \u2502      \u2502    Deep     \u2502\n\u2502     V2      \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502     V3      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502 CL\n                            \u25bc\n                       Elimination\n</code></pre>"},{"location":"examples/models/pk/06_threecomp_iv/#differential-equations","title":"Differential Equations","text":"<pre><code>dA_central/dt = Q2/V2 \u00d7 A_shallow - Q2/V1 \u00d7 A_central\n              + Q3/V3 \u00d7 A_deep - Q3/V1 \u00d7 A_central\n              - CL/V1 \u00d7 A_central\n\ndA_shallow/dt = Q2/V1 \u00d7 A_central - Q2/V2 \u00d7 A_shallow\n\ndA_deep/dt = Q3/V1 \u00d7 A_central - Q3/V3 \u00d7 A_deep\n</code></pre>"},{"location":"examples/models/pk/06_threecomp_iv/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units CL Clearance 1-50 L/h V1 Central volume 5-50 L Q2 Shallow distribution clearance 5-100 L/h V2 Shallow peripheral volume 10-200 L Q3 Deep distribution clearance 0.1-10 L/h V3 Deep peripheral volume 50-1000 L"},{"location":"examples/models/pk/06_threecomp_iv/#example-values","title":"Example Values","text":"Parameter Value Rationale CL 5.0 L/h Moderate clearance V1 10.0 L Plasma volume Q2 20.0 L/h Rapid shallow distribution V2 20.0 L Well-perfused tissues Q3 2.0 L/h Slow deep distribution V3 100.0 L Poorly perfused tissues/fat Dose 100 mg IV bolus"},{"location":"examples/models/pk/06_threecomp_iv/#key-features","title":"Key Features","text":"<ul> <li>Tri-exponential decline (\u03b1, \u03b2, \u03b3 phases)</li> <li>\u03b1 phase: rapid distribution</li> <li>\u03b2 phase: slow distribution</li> <li>\u03b3 phase: terminal elimination</li> <li>Vss = V1 + V2 + V3</li> </ul>"},{"location":"examples/models/pk/06_threecomp_iv/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/07_transit_absorption/","title":"Transit Compartment Absorption Model","text":"<p>Model with transit compartments for delayed/complex oral absorption.</p>"},{"location":"examples/models/pk/07_transit_absorption/#model-schematic","title":"Model Schematic","text":"<pre><code>Oral Dose\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Ktr   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Ktr   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Ktr   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  Ka   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Transit 1\u2502 \u2500\u2500\u2500\u2500\u25b6 \u2502Transit 2\u2502 \u2500\u2500\u2500\u2500\u25b6 \u2502Transit 3\u2502 \u2500\u2500\u2500\u2500\u25b6 \u2502  ... n  \u2502 \u2500\u2500\u2500\u2500\u25b6\u2502   Central   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502      V      \u2502\n                                                                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                               \u2502 CL\n                                                                               \u25bc\n                                                                          Elimination\n</code></pre>"},{"location":"examples/models/pk/07_transit_absorption/#key-equations","title":"Key Equations","text":"<p>The transit model uses n identical transit compartments with rate constant Ktr:</p> <pre><code>dA\u2081/dt = -Ktr \u00d7 A\u2081\ndA\u1d62/dt = Ktr \u00d7 A\u1d62\u208b\u2081 - Ktr \u00d7 A\u1d62   (for i = 2 to n)\ndA_central/dt = Ktr \u00d7 A\u2099 - CL/V \u00d7 A_central\n</code></pre> <p>Mean Transit Time (MTT): <pre><code>MTT = (n + 1) / Ktr\n</code></pre></p>"},{"location":"examples/models/pk/07_transit_absorption/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units Ktr Transit rate constant 0.5-5.0 1/h n Number of transit compartments 1-10 - CL Clearance 1-50 L/h V Volume of distribution 10-500 L"},{"location":"examples/models/pk/07_transit_absorption/#example-values","title":"Example Values","text":"Parameter Value Rationale Ktr 2.0 1/h MTT \u2248 2h with n=3 n 3 3 transit compartments CL 5.0 L/h Moderate clearance V 50.0 L Total body water Dose 100 mg Oral dose"},{"location":"examples/models/pk/07_transit_absorption/#key-features","title":"Key Features","text":"<ul> <li>Delayed Tmax compared to first-order absorption</li> <li>Sharper peak than first-order absorption</li> <li>More physiologically realistic for enteric-coated tablets</li> <li>Flexible: adjusting n and Ktr can model various profiles</li> </ul>"},{"location":"examples/models/pk/07_transit_absorption/#use-cases","title":"Use Cases","text":"<ul> <li>Enteric-coated formulations</li> <li>Extended-release tablets</li> <li>Drugs with gastric emptying delay</li> <li>Complex absorption profiles</li> </ul>"},{"location":"examples/models/pk/07_transit_absorption/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pk/08_michaelis_menten/","title":"Michaelis-Menten Elimination Model","text":"<p>One-compartment model with saturable (nonlinear) elimination kinetics.</p>"},{"location":"examples/models/pk/08_michaelis_menten/#model-schematic","title":"Model Schematic","text":"<pre><code>IV Bolus\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Central   \u2502\n\u2502      V      \u2502\u2500\u2500\u2500\u2500 Vmax/(Km + C) \u2500\u2500\u2500\u2500\u25b6 Saturable Elimination\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pk/08_michaelis_menten/#differential-equation","title":"Differential Equation","text":"<pre><code>dA_central/dt = -Vmax \u00d7 A_central / (Km \u00d7 V + A_central)\n</code></pre> <p>Or in terms of concentration:</p> <pre><code>dC/dt = -Vmax \u00d7 C / (Km + C) / V\n</code></pre>"},{"location":"examples/models/pk/08_michaelis_menten/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units Vmax Maximum elimination rate 10-1000 mg/h Km Michaelis constant 1-100 mg/L V Volume of distribution 10-500 L"},{"location":"examples/models/pk/08_michaelis_menten/#example-values","title":"Example Values","text":"Parameter Value Rationale Vmax 50.0 mg/h Maximum enzyme capacity Km 10.0 mg/L Half-saturation concentration V 50.0 L Total body water Dose 500 mg High dose to show saturation"},{"location":"examples/models/pk/08_michaelis_menten/#key-features","title":"Key Features","text":"<ul> <li>At low C (C &lt;&lt; Km): First-order kinetics, CL \u2248 Vmax/Km</li> <li>At high C (C &gt;&gt; Km): Zero-order kinetics, rate \u2248 Vmax</li> <li>Nonlinear PK: AUC not proportional to dose</li> <li>Examples: phenytoin, ethanol, aspirin (high dose)</li> </ul>"},{"location":"examples/models/pk/08_michaelis_menten/#derived-parameters","title":"Derived Parameters","text":"Parameter Formula Description CLint Vmax/Km Intrinsic clearance (at low C) t\u00bd (low C) 0.693 \u00d7 V \u00d7 Km / Vmax Half-life at low concentrations"},{"location":"examples/models/pk/08_michaelis_menten/#use-cases","title":"Use Cases","text":"<ul> <li>Drugs with capacity-limited metabolism</li> <li>High-dose regimens</li> <li>Therapeutic drug monitoring</li> <li>Phenytoin dosing optimization</li> </ul>"},{"location":"examples/models/pk/08_michaelis_menten/#clinical-implications","title":"Clinical Implications","text":"<ol> <li>Dose escalation: Small dose increases can cause large concentration changes</li> <li>Steady-state: Takes longer to reach at higher doses</li> <li>Drug interactions: Enzyme inhibitors have greater effect when near saturation</li> </ol>"},{"location":"examples/models/pk/08_michaelis_menten/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pkpd/01_direct_emax/","title":"Direct Emax PD Model","text":"<p>PK/PD model with direct, hyperbolic concentration-effect relationship.</p>"},{"location":"examples/models/pkpd/01_direct_emax/#model-schematic","title":"Model Schematic","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     PK      \u2502\u2500\u2500\u2500\u2500 Conc \u2500\u2500\u2500\u2500\u2510\n\u2502 OneCompIVBolus             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502   Direct Effect     \u2502\n                      \u2502                     \u2502\n                      \u2502 E = E0 + Emax \u00d7 C   \u2502\n                      \u2502       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500    \u2502\n                      \u2502        EC50 + C     \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pkpd/01_direct_emax/#pd-equation","title":"PD Equation","text":"<pre><code>Effect = E0 + (Emax \u00d7 C) / (EC50 + C)\n</code></pre> <p>Where: - E0 = baseline effect - Emax = maximum effect above baseline - EC50 = concentration producing 50% of Emax - C = drug concentration</p>"},{"location":"examples/models/pkpd/01_direct_emax/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units E0 Baseline effect 0-100 varies Emax Maximum effect 0-100 varies EC50 Potency (C for 50% Emax) 0.1-100 mg/L"},{"location":"examples/models/pkpd/01_direct_emax/#pk-parameters","title":"PK Parameters","text":"Parameter Description Units CL Clearance L/h V Volume L"},{"location":"examples/models/pkpd/01_direct_emax/#example-values","title":"Example Values","text":"Parameter Value Rationale E0 0 No baseline effect Emax 100 Maximum response = 100 units EC50 1.0 mg/L Moderate potency CL 5.0 L/h Moderate clearance V 50.0 L Total body water"},{"location":"examples/models/pkpd/01_direct_emax/#key-features","title":"Key Features","text":"<ul> <li>Immediate response (no hysteresis)</li> <li>Hyperbolic saturation curve</li> <li>Effect at C = EC50 is E0 + Emax/2</li> <li>Effect at C &gt;&gt; EC50 approaches E0 + Emax</li> </ul>"},{"location":"examples/models/pkpd/01_direct_emax/#use-cases","title":"Use Cases","text":"<ul> <li>Receptor binding studies</li> <li>Enzyme inhibition</li> <li>Blood pressure lowering</li> <li>Biomarkers with rapid equilibration</li> </ul>"},{"location":"examples/models/pkpd/01_direct_emax/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pkpd/02_sigmoid_emax/","title":"Sigmoid Emax (Hill) PD Model","text":"<p>PK/PD model with sigmoidal concentration-effect relationship.</p>"},{"location":"examples/models/pkpd/02_sigmoid_emax/#model-schematic","title":"Model Schematic","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     PK      \u2502\u2500\u2500\u2500\u2500 Conc \u2500\u2500\u2500\u2500\u2510\n\u2502 OneCompIVBolus             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502   Sigmoid Effect (Hill)   \u2502\n                      \u2502                           \u2502\n                      \u2502 E = E0 + Emax \u00d7 C^\u03b3       \u2502\n                      \u2502       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n                      \u2502       EC50^\u03b3 + C^\u03b3        \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pkpd/02_sigmoid_emax/#pd-equation","title":"PD Equation","text":"<pre><code>Effect = E0 + (Emax \u00d7 C^\u03b3) / (EC50^\u03b3 + C^\u03b3)\n</code></pre> <p>Where: - E0 = baseline effect - Emax = maximum effect - EC50 = concentration at 50% effect - \u03b3 (gamma) = Hill coefficient (sigmoidicity factor)</p>"},{"location":"examples/models/pkpd/02_sigmoid_emax/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units E0 Baseline effect 0-100 varies Emax Maximum effect 0-100 varies EC50 Potency 0.1-100 mg/L gamma Hill coefficient 0.5-5 -"},{"location":"examples/models/pkpd/02_sigmoid_emax/#hill-coefficient-interpretation","title":"Hill Coefficient Interpretation","text":"\u03b3 Value Curve Shape Interpretation &lt; 1 Shallow Negative cooperativity = 1 Hyperbolic No cooperativity (= Emax) &gt; 1 Steep Positive cooperativity &gt;&gt; 1 Switch-like Threshold effect"},{"location":"examples/models/pkpd/02_sigmoid_emax/#example-values","title":"Example Values","text":"Parameter Value Rationale E0 0 No baseline Emax 100 100% max effect EC50 1.0 mg/L Moderate potency gamma 2.0 Positive cooperativity"},{"location":"examples/models/pkpd/02_sigmoid_emax/#key-features","title":"Key Features","text":"<ul> <li>Steeper dose-response than simple Emax</li> <li>Common for drugs with cooperative binding</li> <li>Can model all-or-none responses (high \u03b3)</li> </ul>"},{"location":"examples/models/pkpd/02_sigmoid_emax/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pkpd/03_biophase_equilibration/","title":"Biophase Equilibration (Effect Compartment) Model","text":"<p>PK/PD model with delayed effect due to distribution to an effect site.</p>"},{"location":"examples/models/pkpd/03_biophase_equilibration/#model-schematic","title":"Model Schematic","text":"<pre><code>IV Bolus\n    \u2502\n    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Ke0      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Central   \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 \u2502   Effect    \u2502\n\u2502      V      \u2502              \u2502 Compartment \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502    (Ce)     \u2502\n       \u2502                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 CL                         \u2502\n       \u25bc                            \u25bc\n   Elimination              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502 E = E0 + Emax\u00d7Ce\u2502\n                            \u2502     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2502\n                            \u2502     EC50 + Ce   \u2502\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pkpd/03_biophase_equilibration/#differential-equations","title":"Differential Equations","text":"<p>PK: <pre><code>dA_central/dt = -CL/V \u00d7 A_central\n</code></pre></p> <p>Effect Compartment: <pre><code>dCe/dt = Ke0 \u00d7 (Cp - Ce)\n</code></pre></p> <p>PD: <pre><code>Effect = E0 + Emax \u00d7 Ce / (EC50 + Ce)\n</code></pre></p>"},{"location":"examples/models/pkpd/03_biophase_equilibration/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units Ke0 Effect site equilibration rate 0.1-5 1/h E0 Baseline effect 0-100 varies Emax Maximum effect 0-100 varies EC50 Effect site EC50 0.1-100 mg/L"},{"location":"examples/models/pkpd/03_biophase_equilibration/#example-values","title":"Example Values","text":"Parameter Value Rationale CL 5.0 L/h Moderate clearance V 50.0 L Central volume Ke0 0.5 1/h 1.4h equilibration half-life E0 0 No baseline Emax 100 Maximum response EC50 1.0 mg/L Effect site potency"},{"location":"examples/models/pkpd/03_biophase_equilibration/#key-features","title":"Key Features","text":"<ul> <li>Counter-clockwise hysteresis: Effect lags behind concentration</li> <li>t\u00bdke0 = ln(2)/Ke0: Time for effect compartment to equilibrate</li> <li>Peak effect occurs after peak concentration</li> <li>Effect persists longer than plasma concentration</li> </ul>"},{"location":"examples/models/pkpd/03_biophase_equilibration/#use-cases","title":"Use Cases","text":"<ul> <li>CNS-active drugs (BBB penetration delay)</li> <li>Anesthetics (propofol, remifentanil)</li> <li>Sedatives/hypnotics</li> <li>Analgesics</li> </ul>"},{"location":"examples/models/pkpd/03_biophase_equilibration/#hysteresis-interpretation","title":"Hysteresis Interpretation","text":"<p>When plotting Effect vs Concentration: - Counter-clockwise loop: Effect delayed (biophase model) - Clockwise loop: Tolerance development</p>"},{"location":"examples/models/pkpd/03_biophase_equilibration/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/models/pkpd/04_indirect_response/","title":"Indirect Response (Turnover) Model","text":"<p>PK/PD model for drugs that affect the synthesis or degradation of a response variable.</p>"},{"location":"examples/models/pkpd/04_indirect_response/#model-schematic","title":"Model Schematic","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     PK      \u2502\u2500\u2500\u2500\u2500 Conc \u2500\u2500\u2500\u2500\u2510\n\u2502 OneCompIVBolus             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n                             \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502 Inhibition/Stimulation  \u2502\n                      \u2502  of Kin or Kout         \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  \u2502\n                                  \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502   Response Variable     \u2502\n                      \u2502   dR/dt = Kin - Kout\u00d7R  \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"examples/models/pkpd/04_indirect_response/#four-types-of-indirect-response-models","title":"Four Types of Indirect Response Models","text":"Type Drug Effect Example IRM-I Inhibition of Kin Corticosteroids on cortisol IRM-II Inhibition of Kout Warfarin on clotting factors IRM-III Stimulation of Kin EPO on RBC production IRM-IV Stimulation of Kout Diuretics on sodium excretion"},{"location":"examples/models/pkpd/04_indirect_response/#differential-equations","title":"Differential Equations","text":"<p>Response: <pre><code>dR/dt = Kin \u00d7 (1 - I(C)) - Kout \u00d7 R    (IRM-I: inhibit production)\ndR/dt = Kin - Kout \u00d7 (1 - I(C)) \u00d7 R    (IRM-II: inhibit loss)\ndR/dt = Kin \u00d7 (1 + S(C)) - Kout \u00d7 R    (IRM-III: stimulate production)\ndR/dt = Kin - Kout \u00d7 (1 + S(C)) \u00d7 R    (IRM-IV: stimulate loss)\n</code></pre></p> <p>Where: - <code>I(C) = Imax \u00d7 C / (IC50 + C)</code> (inhibition function) - <code>S(C) = Smax \u00d7 C / (SC50 + C)</code> (stimulation function)</p>"},{"location":"examples/models/pkpd/04_indirect_response/#parameters","title":"Parameters","text":"Parameter Description Typical Range Units Kin Zero-order production rate 0.1-100 units/h Kout First-order loss rate 0.01-1 1/h Imax/Smax Maximum inhibition/stimulation 0.1-1 - IC50/SC50 Potency for effect 0.1-100 mg/L"},{"location":"examples/models/pkpd/04_indirect_response/#example-values-irm-i","title":"Example Values (IRM-I)","text":"Parameter Value Rationale CL 5.0 L/h Drug clearance V 50.0 L Drug volume Kin 10 units/h Production rate Kout 0.1 1/h Loss rate (t\u00bd = 6.9h) Imax 0.9 90% max inhibition IC50 1.0 mg/L Potency"},{"location":"examples/models/pkpd/04_indirect_response/#key-features","title":"Key Features","text":"<ul> <li>Baseline: R\u2080 = Kin/Kout</li> <li>Response half-life: t\u00bd_R = ln(2)/Kout</li> <li>Delayed response (not immediate)</li> <li>Rebound possible after drug washout</li> </ul>"},{"location":"examples/models/pkpd/04_indirect_response/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/nca/","title":"Non-Compartmental Analysis (NCA)","text":"<p>Examples demonstrating NCA metrics computation from concentration-time data.</p>"},{"location":"examples/nca/#computed-metrics","title":"Computed Metrics","text":"Metric Description Units Cmax Maximum concentration mg/L Tmax Time of maximum concentration h AUC_0_t AUC from 0 to last observation mg\u00b7h/L AUC_0_inf AUC extrapolated to infinity mg\u00b7h/L t_half Terminal half-life h CL_F Apparent clearance L/h Vz_F Apparent volume L MRT Mean residence time h"},{"location":"examples/nca/#examples","title":"Examples","text":"Example Description Directory Basic NCA Single subject NCA 01_basic_nca Population NCA Summary statistics 02_population_nca"},{"location":"examples/nca/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Compute NCA metrics\nresult = compute_nca(\n    times = [0, 0.5, 1, 2, 4, 8, 12, 24],\n    concentrations = [2.0, 1.8, 1.5, 1.2, 0.8, 0.4, 0.2, 0.05],\n    dose = 100.0,\n    route = :iv\n)\n\nprintln(\"Cmax: $(result.cmax)\")\nprintln(\"AUC_0_inf: $(result.auc_0_inf)\")\nprintln(\"t_half: $(result.t_half)\")\n</code></pre> <pre><code>from openpkpd.nca import compute_nca\n\nresult = compute_nca(\n    times=[0, 0.5, 1, 2, 4, 8, 12, 24],\n    concentrations=[2.0, 1.8, 1.5, 1.2, 0.8, 0.4, 0.2, 0.05],\n    dose=100.0,\n    route=\"iv\"\n)\n</code></pre>"},{"location":"examples/nca/01_basic_nca/","title":"Basic NCA Analysis","text":"<p>Single-subject non-compartmental analysis computing standard PK metrics.</p>"},{"location":"examples/nca/01_basic_nca/#computed-metrics","title":"Computed Metrics","text":"Metric Description Cmax Maximum concentration Tmax Time of maximum AUC_0_t AUC to last observation AUC_0_inf AUC extrapolated to infinity t_half Terminal half-life CL/F Apparent clearance Vz/F Apparent volume"},{"location":"examples/nca/01_basic_nca/#files","title":"Files","text":"File Description julia.jl Julia implementation python.py Python implementation"},{"location":"examples/nca/02_population_nca/","title":"Population NCA Analysis","text":"<p>Non-compartmental analysis across multiple subjects with summary statistics.</p>"},{"location":"examples/nca/02_population_nca/#features","title":"Features","text":"<ul> <li>Individual subject NCA metrics</li> <li>Population summary (mean, SD, CV%)</li> <li>Geometric mean for log-normal parameters</li> </ul>"},{"location":"examples/nca/02_population_nca/#see-also","title":"See Also","text":"<ul> <li>Basic NCA</li> </ul>"},{"location":"examples/population/","title":"Population Modeling Examples","text":"<p>Examples demonstrating inter-individual variability (IIV), inter-occasion variability (IOV), and covariate modeling.</p>"},{"location":"examples/population/#examples","title":"Examples","text":"Example Description Directory Basic IIV Log-normal inter-individual variability 01_basic_iiv IOV Inter-occasion variability 02_iov Static Covariates Weight and age effects 03_static_covariates Time-Varying Covariates Creatinine clearance over time 04_time_varying_covariates Complex Model Multiple covariates, IIV, correlations 05_complex_covariate_model"},{"location":"examples/population/#concepts","title":"Concepts","text":""},{"location":"examples/population/#inter-individual-variability-iiv","title":"Inter-Individual Variability (IIV)","text":"<p>IIV describes differences between subjects:</p> <pre><code>\u03b8\u1d62 = \u03b8_pop \u00d7 exp(\u03b7\u1d62)\n</code></pre> <p>Where: - \u03b8\u1d62 = individual parameter - \u03b8_pop = population typical value - \u03b7\u1d62 ~ N(0, \u03c9\u00b2)</p>"},{"location":"examples/population/#inter-occasion-variability-iov","title":"Inter-Occasion Variability (IOV)","text":"<p>IOV describes within-subject variability across occasions:</p> <pre><code>\u03b8\u1d62\u2c7c = \u03b8_pop \u00d7 exp(\u03b7\u1d62 + \u03ba\u2c7c)\n</code></pre> <p>Where: - \u03ba\u2c7c ~ N(0, \u03c0\u00b2) is the occasion-specific random effect</p>"},{"location":"examples/population/#covariate-models","title":"Covariate Models","text":"<p>Covariates explain part of the variability:</p> <p>Power model (weight on CL): <pre><code>CL = CL_pop \u00d7 (WT/70)^0.75 \u00d7 exp(\u03b7_CL)\n</code></pre></p> <p>Linear model (age on V): <pre><code>V = V_pop \u00d7 (1 + \u03b8_age \u00d7 (AGE - 40)) \u00d7 exp(\u03b7_V)\n</code></pre></p> <p>Categorical (sex on CL): <pre><code>CL = CL_pop \u00d7 \u03b8_sex^SEX \u00d7 exp(\u03b7_CL)\n</code></pre></p>"},{"location":"examples/population/#file-structure","title":"File Structure","text":"<p>Each example contains: <pre><code>01_example/\n\u251c\u2500\u2500 README.md       # Detailed explanation\n\u251c\u2500\u2500 julia.jl        # Julia implementation\n\u251c\u2500\u2500 python.py       # Python implementation\n\u2514\u2500\u2500 cli.json        # CLI specification (if applicable)\n</code></pre></p>"},{"location":"examples/population/#running-examples","title":"Running Examples","text":"<pre><code># Julia\njulia --project=core/OpenPKPDCore docs/examples/population/01_basic_iiv/julia.jl\n\n# Python\npython docs/examples/population/01_basic_iiv/python.py\n</code></pre>"},{"location":"examples/population/#key-parameters","title":"Key Parameters","text":""},{"location":"examples/population/#omega-interpretation","title":"Omega (\u03c9) Interpretation","text":"\u03c9\u00b2 \u03c9 (SD) CV% Interpretation 0.01 0.1 ~10% Low variability 0.09 0.3 ~30% Moderate variability 0.25 0.5 ~50% High variability 0.49 0.7 ~70% Very high variability <p>Note: For log-normal, CV \u2248 \u03c9 for \u03c9 &lt; 0.5</p>"},{"location":"examples/population/#common-covariate-exponents","title":"Common Covariate Exponents","text":"Covariate Parameter Exponent Rationale Weight CL 0.75 Allometric scaling Weight V 1.0 Linear scaling Age CL -0.01 to -0.02 Linear decline CrCL CL 0.5-1.0 Renal function Sex CL 0.8-1.2 Categorical"},{"location":"examples/population/#see-also","title":"See Also","text":"<ul> <li>Parameter Estimation - Estimate population parameters</li> <li>VPC - Validate population models</li> <li>Models - Available structural models</li> </ul>"},{"location":"examples/population/01_basic_iiv/","title":"Basic Inter-Individual Variability (IIV)","text":"<p>Population simulation with log-normal IIV on PK parameters.</p>"},{"location":"examples/population/01_basic_iiv/#model","title":"Model","text":"<pre><code>\u03b8\u1d62 = \u03b8_pop \u00d7 exp(\u03b7\u1d62)\n\nWhere \u03b7\u1d62 ~ N(0, \u03c9\u00b2)\n</code></pre>"},{"location":"examples/population/01_basic_iiv/#parameters","title":"Parameters","text":"Parameter Population \u03c9 (SD) CV% CL 5.0 L/h 0.3 ~30% V 50.0 L 0.2 ~20%"},{"location":"examples/population/01_basic_iiv/#what-this-example-shows","title":"What This Example Shows","text":"<ol> <li>Generate 100 virtual subjects</li> <li>Each subject has individual CL and V values</li> <li>Simulate PK for all subjects</li> <li>Compute population summaries (mean, median, 5th/95th percentiles)</li> </ol>"},{"location":"examples/population/01_basic_iiv/#expected-variability","title":"Expected Variability","text":"<p>With \u03c9_CL = 0.3: - 95% of subjects have CL between ~2.7 and ~9.2 L/h - This is 0.55\u00d7 to 1.8\u00d7 the typical value</p>"},{"location":"examples/population/01_basic_iiv/#files","title":"Files","text":"File Description <code>julia.jl</code> Julia implementation <code>python.py</code> Python implementation <code>cli.json</code> CLI specification"},{"location":"examples/population/02_iov/","title":"Inter-Occasion Variability (IOV)","text":"<p>Population simulation with both IIV and IOV for multiple dosing occasions.</p>"},{"location":"examples/population/02_iov/#model","title":"Model","text":"<pre><code>\u03b8\u1d62\u2c7c = \u03b8_pop \u00d7 exp(\u03b7\u1d62 + \u03ba\u2c7c)\n\nWhere:\n- \u03b7\u1d62 ~ N(0, \u03c9\u00b2)  (between-subject)\n- \u03ba\u2c7c ~ N(0, \u03c0\u00b2)  (between-occasion)\n</code></pre>"},{"location":"examples/population/02_iov/#parameters","title":"Parameters","text":"Parameter Population \u03c9 (IIV) \u03c0 (IOV) CL 5.0 L/h 0.3 0.15 V 50.0 L 0.2 0.1"},{"location":"examples/population/02_iov/#what-this-example-shows","title":"What This Example Shows","text":"<ol> <li>50 subjects with 3 dosing occasions each</li> <li>Each subject has consistent IIV across occasions</li> <li>Additional IOV varies by occasion</li> <li>Demonstrates within-subject variability</li> </ol>"},{"location":"examples/population/02_iov/#use-cases","title":"Use Cases","text":"<ul> <li>Multiple dose studies</li> <li>Crossover bioequivalence</li> <li>Chronic therapy monitoring</li> </ul>"},{"location":"examples/population/03_static_covariates/","title":"Static Covariates","text":"<p>Population simulation with weight and age effects on PK parameters.</p>"},{"location":"examples/population/03_static_covariates/#model","title":"Model","text":"<p>Weight on CL and V (allometric): <pre><code>CL = CL_pop \u00d7 (WT/70)^0.75\nV  = V_pop \u00d7 (WT/70)^1.0\n</code></pre></p> <p>Age on CL (linear decline): <pre><code>CL = CL_adj \u00d7 (1 - 0.01 \u00d7 (AGE - 40))\n</code></pre></p>"},{"location":"examples/population/03_static_covariates/#covariate-distribution","title":"Covariate Distribution","text":"Covariate Distribution Range Weight Normal(70, 15) 40-120 kg Age Normal(50, 15) 18-80 years"},{"location":"examples/population/03_static_covariates/#what-this-example-shows","title":"What This Example Shows","text":"<ol> <li>Generate realistic covariate distributions</li> <li>Apply covariate effects to parameters</li> <li>Residual IIV after covariate adjustment</li> <li>Variance explained by covariates</li> </ol>"},{"location":"examples/population/04_time_varying_covariates/","title":"Time-Varying Covariates","text":"<p>Population simulation with covariates that change over time (e.g., renal function).</p>"},{"location":"examples/population/04_time_varying_covariates/#model","title":"Model","text":"<p>Creatinine clearance (CrCL) affecting drug clearance: <pre><code>CL(t) = CL_pop \u00d7 (CrCL(t)/100)^0.5 \u00d7 exp(\u03b7_CL)\n</code></pre></p>"},{"location":"examples/population/04_time_varying_covariates/#use-cases","title":"Use Cases","text":"<ul> <li>Critically ill patients (changing renal function)</li> <li>Chronic therapy (disease progression)</li> <li>Drug interactions (enzyme induction over time)</li> </ul>"},{"location":"examples/population/05_complex_covariate_model/","title":"Complex Covariate Model","text":"<p>Full population model with multiple covariates, IIV, correlations, and residual error.</p>"},{"location":"examples/population/05_complex_covariate_model/#model","title":"Model","text":"<pre><code>CL = CL_pop \u00d7 (WT/70)^0.75 \u00d7 (CrCL/100)^0.5 \u00d7 \u03b8_sex^SEX \u00d7 exp(\u03b7_CL)\nV  = V_pop \u00d7 (WT/70)^1.0 \u00d7 exp(\u03b7_V)\nKa = Ka_pop \u00d7 exp(\u03b7_Ka)\n\nWhere:\n- \u03b7 ~ MVN(0, \u03a9)  with correlation between \u03b7_CL and \u03b7_V\n- \u03b5 ~ N(0, \u03c3\u00b2)   residual error\n</code></pre>"},{"location":"examples/population/05_complex_covariate_model/#covariates","title":"Covariates","text":"Covariate Effect On Type Value Weight CL, V Power 0.75, 1.0 CrCL CL Power 0.5 Sex CL Categorical 0.85 (female)"},{"location":"examples/population/05_complex_covariate_model/#omega-matrix-with-correlations","title":"Omega Matrix (with correlations)","text":"<pre><code>        CL    V     Ka\nCL   [ 0.09  0.02  0    ]\nV    [ 0.02  0.04  0    ]\nKa   [ 0     0     0.16 ]\n</code></pre> <p>Correlation CL-V \u2248 0.33</p>"},{"location":"examples/quickstart/","title":"Quickstart Examples","text":"<p>Get started with OpenPKPD in 5 minutes. These examples demonstrate a basic one-compartment IV bolus simulation.</p>"},{"location":"examples/quickstart/#files","title":"Files","text":"File Description <code>julia_first_simulation.jl</code> Julia quickstart <code>python_first_simulation.py</code> Python quickstart <code>cli_first_simulation.sh</code> CLI quickstart <code>spec.json</code> CLI specification file"},{"location":"examples/quickstart/#what-youll-learn","title":"What You'll Learn","text":"<ol> <li>Create a basic PK model specification</li> <li>Configure simulation parameters</li> <li>Run the simulation</li> <li>Extract key metrics (Cmax, Tmax, AUC)</li> </ol>"},{"location":"examples/quickstart/#the-model","title":"The Model","text":"<p>One-Compartment IV Bolus</p> <pre><code>Dose (100 mg IV)\n     \u2502\n     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Central   \u2502\n\u2502   V = 50 L  \u2502\u2500\u2500\u2500\u2500 CL = 5 L/h \u2500\u2500\u2500\u2500\u25b6 Elimination\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters: - CL = 5 L/h (clearance) - V = 50 L (volume of distribution) - Dose = 100 mg at t=0</p> <p>Expected Results: - Cmax = 2.0 mg/L (at t=0) - AUC\u2080\u208b\u2082\u2084 \u2248 18.1 mg\u00b7h/L - t\u00bd \u2248 6.9 h</p>"},{"location":"examples/quickstart/#running-the-examples","title":"Running the Examples","text":""},{"location":"examples/quickstart/#julia","title":"Julia","text":"<pre><code>julia --project=core/OpenPKPDCore docs/examples/quickstart/julia_first_simulation.jl\n</code></pre>"},{"location":"examples/quickstart/#python","title":"Python","text":"<pre><code>source packages/python/.venv/bin/activate\npython docs/examples/quickstart/python_first_simulation.py\n</code></pre>"},{"location":"examples/quickstart/#cli","title":"CLI","text":"<pre><code>./bin/openpkpd simulate --spec docs/examples/quickstart/spec.json --out result.json\n./bin/openpkpd metrics --artifact result.json --metrics cmax,tmax,auc\n</code></pre>"},{"location":"examples/quickstart/#next-steps","title":"Next Steps","text":"<p>After completing the quickstart:</p> <ol> <li>Explore Models: See models for all available PK/PD models</li> <li>Add Variability: See population for IIV and covariates</li> <li>Fit to Data: See estimation for parameter estimation</li> <li>Real Analysis: See use_cases for complete workflows</li> </ol>"},{"location":"examples/real_world_validation/SOURCE/","title":"theo_md provenance","text":"<p>This dataset is <code>theo_md</code> distributed by the R package <code>nlmixr2data</code>.</p> <p>Description: - Starts with day 1 theophylline concentrations from the nlme/NONMEM teaching dataset - Later observations are simulated under a once-daily regimen as described by nlmixr2data</p> <p>Columns include: - ID, TIME, DV, AMT, EVID, CMT, WT</p>"},{"location":"examples/real_world_validation/datasets/theophylline_theo_md/SOURCE/","title":"theo_md provenance","text":"<p>This dataset is <code>theo_md</code> distributed by the R package <code>nlmixr2data</code>.</p>"},{"location":"examples/real_world_validation/datasets/theophylline_theo_md/SOURCE/#description","title":"Description","text":"<ul> <li>Starts with day 1 theophylline concentrations from the nlme/NONMEM teaching dataset</li> <li>Later observations are simulated under a once-daily regimen as described by nlmixr2data</li> </ul>"},{"location":"examples/real_world_validation/datasets/theophylline_theo_md/SOURCE/#columns","title":"Columns","text":"<ul> <li>ID: Subject identifier</li> <li>TIME: Time since first dose (hours)</li> <li>DV: Dependent variable (concentration, mg/L)</li> <li>AMT: Dose amount</li> <li>EVID: Event ID (0=observation, 1=dose)</li> <li>CMT: Compartment</li> <li>WT: Body weight (kg)</li> </ul>"},{"location":"examples/real_world_validation/datasets/theophylline_theo_sd/","title":"Theophylline theo_sd real-world validation","text":"<p>Dataset: - <code>theo_sd</code> from nlmixr2data (GPL &gt;= 3) - Columns: ID, TIME, DV, AMT, EVID, CMT, WT</p> <p>Design realism addressed: 1. Missing DV rows are ignored (kept for audit, excluded from RMSE). 2. Duplicate observation times are supported. 3. AMT ambiguity is handled explicitly:    - If AMT is small (typical mg/kg scale), dose_mg = AMT * WT    - Else dose_mg = AMT    This rule is recorded in artifact metadata. 4. Optional WT covariate scaling scenario:    - CL_i = CL_ref * (WT/70)^0.75    - V_i = V_ref * (WT/70)^1.0    This is simulation-only, no fitting.</p> <p>Outputs: - Per subject artifacts for:   - fixed params (no WT scaling)   - WT scaled params - Metrics JSON capturing RMSE for each scenario.</p>"},{"location":"examples/real_world_validation/datasets/theophylline_theo_sd/SOURCE/","title":"theo_sd provenance","text":"<p>This dataset is the <code>theo_sd</code> dataset distributed by the R package <code>nlmixr2data</code>.</p> <p>Description: - Day 1 concentrations from the theophylline data used in nlme/NONMEM teaching examples. - Columns include: ID, TIME (hr), DV (mg/L), AMT (mg), EVID, CMT, WT (kg).</p> <p>Upstream references: - nlmixr2data documentation for theo_sd - nlmixr tutorial/vignette describing use and context</p>"},{"location":"examples/real_world_validation/datasets/warfarin_nlmixr2data/","title":"Warfarin PK/PD real-world validation","text":"<p>Dataset: - nlmixr2data::warfarin (GPL &gt;= 3) - dv holds either PK concentration or PD endpoint value - dvid indicates endpoint identity</p> <p>Purpose: - Stress mixed PK/PD observations, dosing records, and deterministic replay. - Validate that coupled PKPD simulation can be compared against interleaved real observations.</p> <p>Model: - PK: 1-comp oral first-order - PD: indirect response turnover driven by concentration</p> <p>Approach: - No fitting. - Fixed parameters chosen solely to generate stable, reproducible predictions. - Compare predictions to observed rows by endpoint (dvid). - Report descriptive RMSE per subject and endpoint.</p> <p>Outputs: - One coupled artifact per subject - Metrics JSON per subject: rmse_pk, rmse_pd</p>"},{"location":"examples/real_world_validation/datasets/warfarin_nlmixr2data/SOURCE/","title":"warfarin provenance","text":"<p>This dataset is <code>warfarin</code> from the R package <code>nlmixr2data</code>.</p> <p>Format: - 519 rows, 9 columns - id (n=32), time (h), amt (mg), dv (warfarin concentration mg/L or PCA measurement),   dvid (endpoint identifier), evid, wt (kg), age (yr), sex (factor)</p> <p>Source reference noted in dataset docs: Funaki T, Holford N, Fujita S (2018). Population PKPD analysis using nlmixr2 and NONMEM.</p>"},{"location":"examples/real_world_validation/studies/theophylline_theo_md/","title":"Theophylline theo_md Multiple-Dose Validation","text":""},{"location":"examples/real_world_validation/studies/theophylline_theo_md/#dataset","title":"Dataset","text":"<ul> <li>Source: <code>theo_md</code> from nlmixr2data (GPL &gt;= 3)</li> <li>Columns: ID, TIME, DV, AMT, EVID, CMT, WT</li> </ul>"},{"location":"examples/real_world_validation/studies/theophylline_theo_md/#purpose","title":"Purpose","text":"<p>Stress test event handling and replay under multiple-dose designs: - Multiple dosing records per subject - Mixed dose and observation records - Long time horizons - Duplicated times and missing DV tolerance</p>"},{"location":"examples/real_world_validation/studies/theophylline_theo_md/#model","title":"Model","text":"<p>One-compartment oral PK with first-order absorption.</p> <p>Fixed parameters (no fitting): | Parameter | Value | Unit | |-----------|-------|------| | Ka | 1.59 | 1/hr | | CL | 2.75 | L/hr | | V | 31.8 | L |</p>"},{"location":"examples/real_world_validation/studies/theophylline_theo_md/#dose-handling","title":"Dose Handling","text":"<ul> <li>All records with AMT &gt; 0 are interpreted as dosing events</li> <li>Dose unit rule is explicit and recorded in metadata:</li> <li>If AMT &lt; 50: treat as mg/kg and multiply by WT</li> <li>Else: treat as mg</li> </ul>"},{"location":"examples/real_world_validation/studies/theophylline_theo_md/#outputs","title":"Outputs","text":"<ul> <li>One execution artifact per subject: <code>subj_&lt;id&gt;.json</code></li> <li>Metrics JSON with per-subject: id, wt, dose_unit_rule, dose_events, rmse</li> </ul>"},{"location":"examples/real_world_validation/studies/theophylline_theo_md/#running","title":"Running","text":"<pre><code># From repository root\njulia docs/examples/real_world_validation/datasets/theophylline_theo_md/run.jl\njulia docs/examples/real_world_validation/datasets/theophylline_theo_md/validate.jl\n</code></pre>"},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/","title":"Theophylline theo_sd Real-World Validation","text":""},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/#dataset","title":"Dataset","text":"<ul> <li>Source: <code>theo_sd</code> from nlmixr2data (GPL &gt;= 3)</li> <li>Columns: ID, TIME, DV, AMT, EVID, CMT, WT</li> </ul>"},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/#design-realism-addressed","title":"Design Realism Addressed","text":"<ol> <li> <p>Missing DV rows: Ignored in RMSE calculation (kept for audit, excluded from metric).</p> </li> <li> <p>Duplicate observation times: Supported via unique grid with mapping back to all observations.</p> </li> <li> <p>AMT ambiguity: Handled explicitly with deterministic rule:</p> </li> <li>If AMT &lt; 50 (typical mg/kg scale): <code>dose_mg = AMT * WT</code></li> <li>Otherwise: <code>dose_mg = AMT</code></li> <li> <p>Rule is recorded in artifact metadata as <code>dose_unit_rule</code></p> </li> <li> <p>WT covariate scaling scenario: Two simulation modes:</p> </li> <li>Fixed: CL = 2.75 L/hr, V = 31.8 L (population typical)</li> <li>WT-scaled:<ul> <li><code>CL_i = CL_ref * (WT/70)^0.75</code></li> <li><code>V_i = V_ref * (WT/70)^1.0</code></li> </ul> </li> </ol> <p>This is simulation-only validation (no fitting).</p>"},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/#model-parameters","title":"Model Parameters","text":"Parameter Value Unit Ka 1.59 1/hr CL_ref 2.75 L/hr V_ref 31.8 L WT_ref 70.0 kg"},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/#outputs","title":"Outputs","text":"<p>Per subject (12 subjects total): - <code>subj_&lt;id&gt;_fixed.json</code> - Fixed parameter artifact - <code>subj_&lt;id&gt;_wt_scaled.json</code> - WT-scaled parameter artifact</p> <p>Metrics JSON with per-subject: - <code>id</code>, <code>wt</code>, <code>dose_mg</code> - <code>dose_unit_rule</code> - How AMT was interpreted - <code>rmse_fixed</code> - RMSE for fixed params - <code>rmse_wt_scaled</code> - RMSE for WT-scaled params</p>"},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/#running","title":"Running","text":"<pre><code># From repository root\njulia docs/examples/real_world_validation/datasets/theophylline_theo_sd/run.jl\n\n# Copy to expected (first time or when regenerating)\nrm -f docs/examples/real_world_validation/studies/theophylline_theo_sd/expected/*.json\ncp docs/examples/real_world_validation/studies/theophylline_theo_sd/output/*.json \\\n   docs/examples/real_world_validation/studies/theophylline_theo_sd/expected/\n\n# Validate\njulia docs/examples/real_world_validation/datasets/theophylline_theo_sd/validate.jl\n</code></pre>"},{"location":"examples/real_world_validation/studies/theophylline_theo_sd/#validation","title":"Validation","text":"<ul> <li>Metrics compared with strict tolerance (1e-12)</li> <li>All artifacts replayed and compared</li> <li>Both fixed and WT-scaled scenarios validated</li> </ul>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/","title":"Warfarin PKPD Real-World Validation","text":""},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#dataset","title":"Dataset","text":"<ul> <li>Source: <code>warfarin</code> from nlmixr2data (GPL &gt;= 3)</li> <li>Drug: Warfarin (oral anticoagulant)</li> <li>Subjects: 32 subjects</li> <li>Endpoints:</li> <li>PK: Plasma concentration (<code>cp</code>)</li> <li>PD: Prothrombin complex activity (<code>pca</code>)</li> </ul>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#columns","title":"Columns","text":"Column Description id Subject identifier time Time (hours) amt Dose amount (mg) dv Dependent variable dvid Endpoint type (cp=concentration, pca=PD response) evid Event ID (1=dose, 0=observation) wt Body weight (kg) age Age (years) sex Sex (male/female)"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#model","title":"Model","text":""},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#pk-component","title":"PK Component","text":"<ul> <li>Model: One-compartment oral (ADVAN2)</li> <li>Parameters:   | Parameter | Value | Unit |   |-----------|-------|------|   | Ka | 1.2 | 1/h |   | CL | 3.0 | L/h |   | V | 35.0 | L |</li> </ul>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#pd-component","title":"PD Component","text":"<ul> <li>Model: Indirect response turnover (inhibition of production)</li> <li>Equation: dR/dt = Kin * (1 - Emax * C / (EC50 + C)) - Kout * R</li> <li>Parameters:   | Parameter | Value | Unit |   |-----------|-------|------|   | Kin | 10.0 | 1/h |   | Kout | 0.5 | 1/h |   | R0 | 20.0 | % activity |   | Emax | 0.8 | - |   | EC50 | 2.0 | mg/L |</li> </ul>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#validation-approach","title":"Validation Approach","text":"<p>This is simulation-only validation using fixed literature-derived parameters: 1. Parse warfarin dataset with both PK and PD observations 2. Simulate coupled PKPD using OpenPKPD 3. Compute RMSE separately for PK (concentration) and PD (response) endpoints 4. Compare against expected output (deterministic replay)</p>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#outputs","title":"Outputs","text":"<p>Per subject (32 subjects total): - <code>subj_&lt;id&gt;.json</code> - Coupled PKPD simulation artifact</p> <p>Summary: - <code>metrics.json</code> - Per-subject RMSE for PK and PD endpoints</p>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#running","title":"Running","text":"<pre><code># Run simulation (from repository root)\njulia --project=core/OpenPKPDCore \\\n  docs/examples/real_world_validation/datasets/warfarin_nlmixr2data/run.jl\n\n# Copy to expected (first time or when regenerating)\nrm -f docs/examples/real_world_validation/studies/warfarin_pkpd/expected/*.json\ncp docs/examples/real_world_validation/studies/warfarin_pkpd/output/*.json \\\n   docs/examples/real_world_validation/studies/warfarin_pkpd/expected/\n\n# Validate\njulia --project=core/OpenPKPDCore \\\n  docs/examples/real_world_validation/datasets/warfarin_nlmixr2data/validate.jl\n</code></pre>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#validation-criteria","title":"Validation Criteria","text":"<ul> <li>Deterministic replay of all artifacts</li> <li>Metrics matched with strict tolerance (1e-12)</li> <li>Both PK and PD predictions validated</li> </ul>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ol> <li>Coupled PKPD Simulation: PK drives PD through concentration-effect relationship</li> <li>Indirect Response Model: Turnover dynamics with inhibition of production</li> <li>Multi-endpoint Handling: Separate PK (cp) and PD (pca) observations</li> <li>Real-World Data: Actual clinical trial data structure with covariates</li> </ol>"},{"location":"examples/real_world_validation/studies/warfarin_pkpd/#see-also","title":"See Also","text":"<ul> <li>Theophylline SD Study</li> <li>Theophylline MD Study</li> </ul>"},{"location":"examples/reproducibility/","title":"Reproducibility Examples","text":"<p>Examples demonstrating artifact creation, replay, and version validation.</p>"},{"location":"examples/reproducibility/#examples","title":"Examples","text":"Example Description Artifact Creation Create reproducible simulation artifacts Artifact Replay Replay and validate artifacts Version Validation Validate across OpenPKPD versions"},{"location":"examples/reproducibility/#overview","title":"Overview","text":"<p>OpenPKPD ensures reproducibility through: - Deterministic simulation with seeds - Artifact serialization with full state - Version-aware replay and validation</p>"},{"location":"examples/reproducibility/#see-also","title":"See Also","text":"<ul> <li>Sensitivity Examples</li> <li>Population Examples</li> </ul>"},{"location":"examples/sensitivity/","title":"Sensitivity Analysis Examples","text":"<p>Examples demonstrating parameter sensitivity analysis for pharmacometric models.</p>"},{"location":"examples/sensitivity/#examples","title":"Examples","text":"Example Description Directory Single Subject Parameter perturbation 01_single_subject Population Population-level sensitivity 02_population Tornado Plot Visual sensitivity display 03_tornado_plot"},{"location":"examples/sensitivity/#what-is-sensitivity-analysis","title":"What is Sensitivity Analysis?","text":"<p>Sensitivity analysis examines how changes in model parameters affect outputs:</p> <ul> <li>Local sensitivity: Small perturbations around nominal values</li> <li>Global sensitivity: Large parameter ranges, interactions</li> <li>Parameter ranking: Which parameters most affect outputs</li> </ul>"},{"location":"examples/sensitivity/#key-metrics","title":"Key Metrics","text":"Metric Description Use AUC Area under curve Exposure Cmax Maximum concentration Safety Cmin Trough concentration Efficacy t_half Half-life Dosing interval"},{"location":"examples/sensitivity/#usage","title":"Usage","text":"<pre><code>from openpkpd import compute_sensitivity\n\nresult = compute_sensitivity(\n    model_spec,\n    parameters=[\"CL\", \"V\", \"Ka\"],\n    perturbation=0.10,  # \u00b110%\n    metrics=[\"auc\", \"cmax\", \"tmax\"]\n)\n\nprint(result.sensitivity_matrix)\n</code></pre>"},{"location":"examples/sensitivity/#see-also","title":"See Also","text":"<ul> <li>Models - Model specifications</li> <li>Population - Population modeling</li> </ul>"},{"location":"examples/sensitivity/01_single_subject/","title":"Single Subject Sensitivity","text":"<p>Local sensitivity analysis for individual parameter perturbations.</p>"},{"location":"examples/sensitivity/01_single_subject/#method","title":"Method","text":"<ol> <li>Simulate at nominal parameter values</li> <li>Perturb each parameter by \u00b1X%</li> <li>Compare output metrics</li> <li>Calculate sensitivity coefficients</li> </ol>"},{"location":"examples/sensitivity/01_single_subject/#files","title":"Files","text":"File Description python.py Python implementation julia.jl Julia implementation"},{"location":"examples/sensitivity/02_population/","title":"Population Sensitivity Analysis","text":"<p>Sensitivity analysis at the population level, accounting for IIV.</p>"},{"location":"examples/sensitivity/02_population/#method","title":"Method","text":"<ol> <li>Simulate population at nominal parameters</li> <li>Perturb population parameters (typical values, omegas)</li> <li>Compare population-level metrics (median, CV)</li> <li>Rank parameter importance</li> </ol>"},{"location":"examples/sensitivity/02_population/#files","title":"Files","text":"File Description python.py Python implementation"},{"location":"examples/sensitivity/03_tornado_plot/","title":"Tornado Plot","text":"<p>Visual representation of parameter sensitivity.</p>"},{"location":"examples/sensitivity/03_tornado_plot/#features","title":"Features","text":"<ul> <li>Horizontal bar chart</li> <li>Parameters ranked by impact</li> <li>Positive/negative effects shown</li> <li>Multiple metrics supported</li> </ul>"},{"location":"examples/sensitivity/03_tornado_plot/#files","title":"Files","text":"File Description plot.py Python plotting example"},{"location":"examples/trial/","title":"Clinical Trial Simulation Examples","text":"<p>Examples demonstrating clinical trial design and simulation capabilities.</p>"},{"location":"examples/trial/#examples","title":"Examples","text":"Example Description Directory Parallel Design Two-arm parallel group study 01_parallel_design Crossover Design 2x2 crossover study 02_crossover_design 3+3 Dose Escalation Phase I dose escalation 03_dose_escalation_3plus3 Bioequivalence BE study with TOST analysis 04_bioequivalence_study Power Analysis Sample size and power 05_power_analysis"},{"location":"examples/trial/#study-design-types","title":"Study Design Types","text":"Design Use Case Key Features Parallel Phase II/III efficacy Independent arms, randomization Crossover BE, Phase I Within-subject comparison, washout Dose Escalation Phase I FIH Safety-driven, cohort-based Adaptive Phase II/III Interim analyses, alpha spending"},{"location":"examples/trial/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/trial/#study-components","title":"Study Components","text":"<ol> <li>Design: Structure (parallel, crossover, adaptive)</li> <li>Arms: Treatment groups with dosing regimens</li> <li>Population: Virtual subjects with demographics</li> <li>Endpoints: PK exposure, efficacy, safety</li> </ol>"},{"location":"examples/trial/#simulation-features","title":"Simulation Features","text":"<ul> <li>Enrollment and randomization</li> <li>Dropout modeling</li> <li>Compliance patterns</li> <li>Multiple replicates</li> </ul>"},{"location":"examples/trial/#usage","title":"Usage","text":"<pre><code>from openpkpd import trial\n\n# Simple parallel study\nspec = trial.TrialSpec(\n    name=\"Phase 2 Study\",\n    design=trial.parallel_design(2),\n    arms=[\n        trial.TreatmentArm(\"Placebo\", trial.dosing_qd(0.0, 28), 50, placebo=True),\n        trial.TreatmentArm(\"Active\", trial.dosing_qd(100.0, 28), 50),\n    ],\n    duration_days=28,\n    seed=42\n)\n\nresult = trial.simulate_trial(spec)\nprint(f\"Completion rate: {result.overall_completion_rate:.1%}\")\n</code></pre>"},{"location":"examples/trial/#see-also","title":"See Also","text":"<ul> <li>Population Examples - Virtual population generation</li> <li>NCA Examples - Non-compartmental analysis</li> <li>VPC Examples - Model validation</li> </ul>"},{"location":"examples/trial/01_parallel_design/","title":"Parallel Group Design","text":"<p>Two-arm parallel group Phase II efficacy study simulation.</p>"},{"location":"examples/trial/01_parallel_design/#design","title":"Design","text":"<ul> <li>Type: Parallel, 1:1 randomization</li> <li>Arms: Placebo vs Active (100 mg QD)</li> <li>Duration: 28 days</li> <li>N per arm: 50 subjects</li> <li>Endpoints: PK exposure</li> </ul>"},{"location":"examples/trial/01_parallel_design/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>Parallel design creation</li> <li>Treatment arm specification</li> <li>QD dosing regimen</li> <li>Dropout modeling</li> <li>Compliance patterns</li> <li>Trial simulation</li> </ul>"},{"location":"examples/trial/01_parallel_design/#files","title":"Files","text":"File Description python.py Python implementation julia.jl Julia implementation cli.json CLI specification"},{"location":"examples/trial/01_parallel_design/#expected-output","title":"Expected Output","text":"<pre><code>Phase 2 Parallel Study\n======================\nDesign: 2-arm parallel (1:1)\nDuration: 28 days\n\nArm Results:\n  Placebo: 48/50 completed (96.0%)\n  Active:  47/50 completed (94.0%)\n\nOverall completion: 95.0%\nOverall compliance: 89.5%\n</code></pre>"},{"location":"examples/trial/02_crossover_design/","title":"2x2 Crossover Design","text":"<p>Two-period, two-sequence crossover study for within-subject comparison.</p>"},{"location":"examples/trial/02_crossover_design/#design","title":"Design","text":"<ul> <li>Type: 2x2 crossover (AB, BA)</li> <li>Treatments: Reference vs Test formulation</li> <li>Washout: 7 days between periods</li> <li>N per sequence: 12 subjects</li> <li>Endpoints: PK exposure (Cmax, AUC)</li> </ul>"},{"location":"examples/trial/02_crossover_design/#sequences","title":"Sequences","text":"Sequence Period 1 Washout Period 2 AB Reference 7 days Test BA Test 7 days Reference"},{"location":"examples/trial/02_crossover_design/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>2x2 crossover design creation</li> <li>Washout period specification</li> <li>Period-specific dosing</li> <li>Within-subject analysis</li> </ul>"},{"location":"examples/trial/02_crossover_design/#files","title":"Files","text":"File Description python.py Python implementation julia.jl Julia implementation cli.json CLI specification"},{"location":"examples/trial/02_crossover_design/#expected-output","title":"Expected Output","text":"<pre><code>2x2 Crossover Study\n===================\nDesign: 2 periods, 2 sequences\nWashout: 7 days\n\nSequence AB: 12 subjects\nSequence BA: 12 subjects\n\nCompletion rate: 95.8%\n</code></pre>"},{"location":"examples/trial/03_dose_escalation_3plus3/","title":"3+3 Dose Escalation Design","text":"<p>Traditional rule-based dose escalation for Phase I first-in-human studies.</p>"},{"location":"examples/trial/03_dose_escalation_3plus3/#design","title":"Design","text":"<ul> <li>Type: 3+3 dose escalation</li> <li>Dose levels: 10, 25, 50, 100, 200 mg</li> <li>Cohort size: 3 subjects</li> <li>Max DLT rate: 33%</li> <li>Max subjects: 30</li> </ul>"},{"location":"examples/trial/03_dose_escalation_3plus3/#escalation-rules","title":"Escalation Rules","text":"DLTs in Cohort Action 0/3 Escalate to next dose 1/3 Expand cohort (+3) 0-1/6 Escalate to next dose 2+/3 or 2+/6 Stop, previous dose is MTD"},{"location":"examples/trial/03_dose_escalation_3plus3/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>Dose escalation design</li> <li>Rule-based decisions</li> <li>DLT probability modeling</li> <li>MTD determination</li> </ul>"},{"location":"examples/trial/03_dose_escalation_3plus3/#files","title":"Files","text":"File Description python.py Python implementation julia.jl Julia implementation cli.json CLI specification"},{"location":"examples/trial/03_dose_escalation_3plus3/#expected-output","title":"Expected Output","text":"<pre><code>3+3 Dose Escalation Study\n=========================\nDose levels: [10, 25, 50, 100, 200] mg\nStarting dose: 10 mg\nMax subjects: 30\n\nCohort 1 (10 mg): 0/3 DLTs -&gt; Escalate\nCohort 2 (25 mg): 0/3 DLTs -&gt; Escalate\nCohort 3 (50 mg): 1/3 DLTs -&gt; Expand\nCohort 4 (50 mg): 0/3 DLTs (1/6 total) -&gt; Escalate\nCohort 5 (100 mg): 2/3 DLTs -&gt; Stop\n\nRecommended MTD: 50 mg\nTotal subjects: 15\n</code></pre>"},{"location":"examples/trial/04_bioequivalence_study/","title":"Bioequivalence Study","text":"<p>Complete bioequivalence study with 2x2 crossover design and TOST analysis.</p>"},{"location":"examples/trial/04_bioequivalence_study/#design","title":"Design","text":"<ul> <li>Type: 2x2 crossover bioequivalence</li> <li>Treatments: Reference vs Test formulation</li> <li>N: 24 subjects (12 per sequence)</li> <li>Washout: 7 days</li> <li>BE limits: 80.00% - 125.00%</li> <li>Parameters: Cmax, AUC0-inf</li> </ul>"},{"location":"examples/trial/04_bioequivalence_study/#regulatory-guidance","title":"Regulatory Guidance","text":"<p>Following FDA guidance for BE studies: - 90% CI for GMR must be within [0.80, 1.25] - Log-transformed data - TOST (Two One-Sided Tests) procedure</p>"},{"location":"examples/trial/04_bioequivalence_study/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>BE study design</li> <li>NCA parameter calculation</li> <li>90% CI for geometric mean ratio</li> <li>BE assessment per FDA guidance</li> </ul>"},{"location":"examples/trial/04_bioequivalence_study/#files","title":"Files","text":"File Description python.py Python implementation julia.jl Julia implementation cli.json CLI specification"},{"location":"examples/trial/04_bioequivalence_study/#expected-output","title":"Expected Output","text":"<pre><code>Bioequivalence Study\n====================\nDesign: 2x2 crossover\nN: 24 subjects\nBE limits: [0.80, 1.25]\n\nResults:\n--------\nParameter   GMR      90% CI           BE?\nCmax        0.9845   [0.8912, 1.0875] Yes\nAUC0-inf    1.0123   [0.9456, 1.0834] Yes\n\nConclusion: Bioequivalence demonstrated\n</code></pre>"},{"location":"examples/trial/05_power_analysis/","title":"Power Analysis and Sample Size","text":"<p>Statistical power analysis and sample size estimation for clinical trials.</p>"},{"location":"examples/trial/05_power_analysis/#features","title":"Features","text":"<ul> <li>Power calculation for given sample size</li> <li>Sample size estimation for target power</li> <li>Effect size interpretation (Cohen's d)</li> <li>Multiple comparison considerations</li> </ul>"},{"location":"examples/trial/05_power_analysis/#cohens-d-reference","title":"Cohen's d Reference","text":"Effect Size Cohen's d Interpretation Small 0.2 Subtle difference Medium 0.5 Moderate difference Large 0.8 Obvious difference"},{"location":"examples/trial/05_power_analysis/#sample-size-guide-80-power-alpha005","title":"Sample Size Guide (80% power, alpha=0.05)","text":"Effect Size N per arm Small (0.2) ~394 Medium (0.5) ~64 Large (0.8) ~26"},{"location":"examples/trial/05_power_analysis/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>Analytical power calculation</li> <li>Sample size estimation</li> <li>Dropout adjustment</li> <li>Power curves</li> </ul>"},{"location":"examples/trial/05_power_analysis/#files","title":"Files","text":"File Description python.py Python implementation julia.jl Julia implementation"},{"location":"examples/trial/05_power_analysis/#expected-output","title":"Expected Output","text":"<pre><code>Power Analysis\n==============\n\nGiven: n=50 per arm, effect=0.5, alpha=0.05\nCalculated power: 69.7%\n\nSample Size Estimation\n======================\nTarget: 80% power, effect=0.5, alpha=0.05\nRequired N per arm: 64\nTotal N: 128\nAchieved power: 80.1%\n\nWith 15% dropout adjustment:\nRequired N per arm: 76\nTotal N: 152\n</code></pre>"},{"location":"examples/use_cases/bioequivalence_study/","title":"Bioequivalence Study Use Case","text":"<p>Complete workflow for a 2x2 crossover bioequivalence (BE) study comparing a test formulation against a reference formulation.</p>"},{"location":"examples/use_cases/bioequivalence_study/#study-design","title":"Study Design","text":"Parameter Value Design 2-period, 2-sequence crossover Subjects per sequence 12 (24 total) Washout 7 days Sampling 0, 0.5, 1, 1.5, 2, 3, 4, 6, 8, 12, 24 h BE criteria 90% CI for AUC and Cmax within 80-125%"},{"location":"examples/use_cases/bioequivalence_study/#formulations","title":"Formulations","text":"<ul> <li>Reference (R): Approved product, Ka = 1.5 /h</li> <li>Test (T): Generic formulation, Ka = 1.4 /h (slightly slower absorption)</li> </ul>"},{"location":"examples/use_cases/bioequivalence_study/#workflow-steps","title":"Workflow Steps","text":"Step Script Description 1 <code>run.jl</code> Complete BE simulation and analysis"},{"location":"examples/use_cases/bioequivalence_study/#quick-run","title":"Quick Run","text":"<pre><code># Run complete BE workflow\njulia --project=core/OpenPKPDCore docs/examples/use_cases/bioequivalence_study/run.jl\n\n# Validate outputs\njulia --project=core/OpenPKPDCore docs/examples/use_cases/bioequivalence_study/validate.jl\n</code></pre>"},{"location":"examples/use_cases/bioequivalence_study/#expected-results","title":"Expected Results","text":""},{"location":"examples/use_cases/bioequivalence_study/#geometric-mean-ratios-tr","title":"Geometric Mean Ratios (T/R)","text":"Metric Point Estimate 90% CI Cmax 0.95 0.88-1.02 AUC_0_t 1.00 0.95-1.05"},{"location":"examples/use_cases/bioequivalence_study/#be-conclusion","title":"BE Conclusion","text":"<ul> <li>Both Cmax and AUC 90% CIs within 80-125%</li> <li>Bioequivalence demonstrated</li> </ul>"},{"location":"examples/use_cases/bioequivalence_study/#model-parameters","title":"Model Parameters","text":"Parameter Reference Test IIV (CV%) Ka 1.5 /h 1.4 /h 30 CL 10 L/h 10 L/h 25 V 100 L 100 L 20"},{"location":"examples/use_cases/bioequivalence_study/#see-also","title":"See Also","text":"<ul> <li>Trial Examples</li> <li>NCA Examples</li> </ul>"},{"location":"examples/use_cases/fih_dose_exploration/","title":"FIH dose exploration","text":"<p>This use case models first-in-human dose exploration using a population PK model with covariates.</p> <p>Purpose: - Provide a realistic, reproducible workflow that maps to day-to-day PK decision making. - Validate deterministic execution and artifact replay under a practical scenario.</p> <p>Model: - One-compartment IV bolus PK - Parameters: CL, V - Covariates:   - WT on CL via power model exponent 0.75 (ref 70 kg)   - WT on V via power model exponent 1.0 (ref 70 kg)</p> <p>Population: - Cohort weights: fixed list, deterministic - IIV: log-normal on CL and V - Seeded RNG</p> <p>Scenarios: - Dose levels: 10 mg, 30 mg, 100 mg, 300 mg (single dose)</p> <p>Outputs: - Concentration time series per individual - Summary: mean, median, p05, p95 - Exposure metrics from mean curve: Cmax, AUC0-24</p> <p>Validation: - Artifacts generated by run.jl must replay exactly. - Stored expected artifacts are compared via golden-style validation.</p>"},{"location":"examples/use_cases/nonmem_migration/","title":"NONMEM Migration Use Case","text":"<p>Complete workflow for migrating NONMEM models to OpenPKPD, demonstrating how to convert an existing NONMEM population PK model and validate that simulation results match.</p>"},{"location":"examples/use_cases/nonmem_migration/#source-model","title":"Source Model","text":"<p>This example migrates a one-compartment oral PK model from NONMEM ADVAN2:</p> <pre><code>$PROBLEM THEOPHYLLINE PK - ORAL ONE COMPARTMENT\n$DATA theo_sd.csv IGNORE=@\n$INPUT ID TIME DV AMT EVID CMT WT\n$SUBROUTINE ADVAN2 TRANS2\n\n$PK\nTVCL = THETA(1) * (WT/70)**0.75\nTVV  = THETA(2) * (WT/70)\nTVKA = THETA(3)\nCL = TVCL * EXP(ETA(1))\nV  = TVV  * EXP(ETA(2))\nKA = TVKA * EXP(ETA(3))\nS2 = V\n\n$ERROR\nIPRED = F\nY = F * (1 + ERR(1))\n\n$THETA\n(0, 2.8)    ; CL\n(0, 35)     ; V\n(0, 1.5)    ; KA\n\n$OMEGA\n0.09        ; IIV CL\n0.04        ; IIV V\n0.16        ; IIV KA\n\n$SIGMA\n0.04        ; Proportional error\n</code></pre>"},{"location":"examples/use_cases/nonmem_migration/#workflow-steps","title":"Workflow Steps","text":"Step Description 1 Parse NONMEM control file structure 2 Map ADVAN2 to OneCompOralFirstOrder 3 Extract THETA, OMEGA values 4 Convert covariate model 5 Simulate population and compare 6 Validate numerical equivalence"},{"location":"examples/use_cases/nonmem_migration/#quick-run","title":"Quick Run","text":"<pre><code># Run migration workflow\njulia --project=core/OpenPKPDCore docs/examples/use_cases/nonmem_migration/run.jl\n\n# Validate outputs\njulia --project=core/OpenPKPDCore docs/examples/use_cases/nonmem_migration/validate.jl\n</code></pre>"},{"location":"examples/use_cases/nonmem_migration/#migration-mapping","title":"Migration Mapping","text":""},{"location":"examples/use_cases/nonmem_migration/#model-type","title":"Model Type","text":"NONMEM OpenPKPD ADVAN1 OneCompIVBolus ADVAN2 OneCompOralFirstOrder ADVAN3 TwoCompIVBolus ADVAN4 TwoCompOral"},{"location":"examples/use_cases/nonmem_migration/#parameters","title":"Parameters","text":"NONMEM OpenPKPD THETA(1) typical_cl THETA(2) typical_v THETA(3) typical_ka OMEGA(1,1) omega_cl OMEGA(2,2) omega_v OMEGA(3,3) omega_ka"},{"location":"examples/use_cases/nonmem_migration/#covariates","title":"Covariates","text":"NONMEM OpenPKPD (WT/70)**0.75 PowerCovariate(exponent=0.75, reference=70.0) (WT/70) PowerCovariate(exponent=1.0, reference=70.0)"},{"location":"examples/use_cases/nonmem_migration/#validation-criteria","title":"Validation Criteria","text":"<p>The migration is considered successful if: - Simulated concentrations match within 0.1% relative error - Population summary statistics (mean, percentiles) align - Covariate effects produce identical parameter adjustments</p>"},{"location":"examples/use_cases/nonmem_migration/#files","title":"Files","text":"File Description <code>run001.ctl</code> Original NONMEM control file <code>run.jl</code> Migration and validation script <code>output/</code> Comparison results"},{"location":"examples/use_cases/nonmem_migration/#see-also","title":"See Also","text":"<ul> <li>Model Import Examples</li> <li>Estimation Examples</li> <li>Population Examples</li> </ul>"},{"location":"examples/use_cases/pkpd_biomarker_turnover/","title":"PKPD Biomarker Turnover","text":"<p>This use case models exposure-driven biomarker suppression using a coupled PKPD indirect response turnover model.</p>"},{"location":"examples/use_cases/pkpd_biomarker_turnover/#purpose","title":"Purpose","text":"<ul> <li>Validate coupled PKPD, regimen comparison, and IOV behavior under realistic workflows</li> <li>Provide a reproducible, replayable contract for response metrics used in decision making</li> </ul>"},{"location":"examples/use_cases/pkpd_biomarker_turnover/#models","title":"Models","text":"<p>PK Model: One-compartment IV bolus (CL=10 L/h, V=50 L typical)</p> <p>PD Model: Indirect response turnover - Baseline R0 = Kin / Kout = 100 - Drug effect: inhibitory Emax (Imax=0.9, IC50=5)</p>"},{"location":"examples/use_cases/pkpd_biomarker_turnover/#scenarios","title":"Scenarios","text":"Regimen Doses QD 100 mg at 0, 24, 48 h BID 50 mg at 0, 12, 24, 36, 48, 60 h <p>Each scenario runs with and without IOV on CL across occasions.</p>"},{"location":"examples/use_cases/pkpd_biomarker_turnover/#outputs","title":"Outputs","text":"<ul> <li>Population artifacts with mean and quantile response summaries</li> <li>Decision metrics: Emin, time below 80% baseline, suppression AUC</li> </ul>"},{"location":"examples/use_cases/pkpd_biomarker_turnover/#running","title":"Running","text":"<pre><code>julia docs/examples/use_cases/pkpd_biomarker_turnover/run.jl\njulia docs/examples/use_cases/pkpd_biomarker_turnover/validate.jl\n</code></pre>"},{"location":"examples/use_cases/population_pkpd_analysis/","title":"Population PKPD Analysis Use Case","text":"<p>Complete population pharmacokinetic-pharmacodynamic (PKPD) analysis workflow demonstrating drug exposure-response modeling with indirect response dynamics.</p>"},{"location":"examples/use_cases/population_pkpd_analysis/#model-structure","title":"Model Structure","text":""},{"location":"examples/use_cases/population_pkpd_analysis/#pk-component","title":"PK Component","text":"<ul> <li>Model: Two-compartment oral</li> <li>Parameters: Ka, CL, V1, Q, V2</li> <li>Covariates: Weight on CL and V1</li> </ul>"},{"location":"examples/use_cases/population_pkpd_analysis/#pd-component","title":"PD Component","text":"<ul> <li>Model: Indirect response (inhibition of production)</li> <li>Parameters: Kin, Kout, Imax, IC50</li> <li>Baseline: E0 = Kin/Kout</li> </ul>"},{"location":"examples/use_cases/population_pkpd_analysis/#workflow-steps","title":"Workflow Steps","text":"Step Script Description 1 <code>run.jl</code> Complete PKPD simulation and analysis"},{"location":"examples/use_cases/population_pkpd_analysis/#quick-run","title":"Quick Run","text":"<pre><code># Run complete PKPD workflow\njulia --project=core/OpenPKPDCore docs/examples/use_cases/population_pkpd_analysis/run.jl\n\n# Validate outputs\njulia --project=core/OpenPKPDCore docs/examples/use_cases/population_pkpd_analysis/validate.jl\n</code></pre>"},{"location":"examples/use_cases/population_pkpd_analysis/#population","title":"Population","text":"Parameter Description N 50 subjects Weight 50-100 kg (uniform) Dose 50 mg oral Sampling PK: 0-24h, PD: 0-72h"},{"location":"examples/use_cases/population_pkpd_analysis/#expected-results","title":"Expected Results","text":""},{"location":"examples/use_cases/population_pkpd_analysis/#pk-parameters-population","title":"PK Parameters (Population)","text":"Parameter Typical IIV (CV%) Ka 1.0 /h 30 CL 5.0 L/h 25 V1 20 L 20 Q 2.0 L/h - V2 40 L -"},{"location":"examples/use_cases/population_pkpd_analysis/#pd-parameters-population","title":"PD Parameters (Population)","text":"Parameter Typical IIV (CV%) Kin 1.0 /h 20 Kout 0.1 /h 20 Imax 0.9 15 IC50 2.0 mg/L 30"},{"location":"examples/use_cases/population_pkpd_analysis/#key-findings","title":"Key Findings","text":"<ul> <li>Cmax (PK): ~5 mg/L</li> <li>E_max inhibition: ~45% from baseline</li> <li>Time to max PD effect: ~8-12 hours post-dose</li> <li>PD recovery: ~80% by 72 hours</li> </ul>"},{"location":"examples/use_cases/population_pkpd_analysis/#see-also","title":"See Also","text":"<ul> <li>Population Documentation</li> <li>VPC Documentation</li> </ul>"},{"location":"examples/use_cases/real_world_theophylline/","title":"Real-World Theophylline Analysis","text":"<p>Complete pharmacokinetic analysis workflow using the classic theophylline dataset from the nlmixr2 package.</p>"},{"location":"examples/use_cases/real_world_theophylline/#dataset","title":"Dataset","text":"<ul> <li>Source: Boeckmann AJ, Sheiner LB, Beal SL (1994). NONMEM Users Guide: Part V</li> <li>Subjects: 12 healthy adults</li> <li>Route: Oral administration</li> <li>Observations: ~11 concentration measurements per subject over 24h</li> <li>Covariates: Body weight (WT)</li> </ul>"},{"location":"examples/use_cases/real_world_theophylline/#workflow-steps","title":"Workflow Steps","text":"<p>This use case demonstrates a complete PK analysis workflow:</p> Step Script Description 1 <code>01_data_exploration.jl</code> Load and explore the dataset 2 <code>02_nca_analysis.jl</code> Non-compartmental analysis 3 <code>03_model_fitting.jl</code> One-compartment oral model fitting 4 <code>04_diagnostics.jl</code> Goodness-of-fit and residual diagnostics 5 <code>05_vpc.jl</code> Visual predictive check 6 <code>06_report.jl</code> Generate summary report"},{"location":"examples/use_cases/real_world_theophylline/#quick-run","title":"Quick Run","text":"<pre><code># Run complete workflow\njulia --project=core/OpenPKPDCore docs/examples/use_cases/real_world_theophylline/run.jl\n\n# Validate outputs\njulia --project=core/OpenPKPDCore docs/examples/use_cases/real_world_theophylline/validate.jl\n</code></pre>"},{"location":"examples/use_cases/real_world_theophylline/#expected-results","title":"Expected Results","text":""},{"location":"examples/use_cases/real_world_theophylline/#nca-metrics-population-mean","title":"NCA Metrics (Population Mean)","text":"Metric Value Units Cmax 8.2 mg/L Tmax 1.5 h AUC_0_24 114 mg*h/L t_half 8.5 h"},{"location":"examples/use_cases/real_world_theophylline/#model-parameters-population-estimates","title":"Model Parameters (Population Estimates)","text":"Parameter Estimate CV% Ka 1.5 h\u207b\u00b9 25 CL 0.04 L/h/kg 20 V 0.5 L/kg 15"},{"location":"examples/use_cases/real_world_theophylline/#see-also","title":"See Also","text":"<ul> <li>NCA Documentation</li> <li>Estimation Documentation</li> <li>VPC Documentation</li> </ul>"},{"location":"examples/visualization/","title":"Visualization Examples","text":"<p>Examples demonstrating plotting and visualization for pharmacometric analyses.</p>"},{"location":"examples/visualization/#plot-types","title":"Plot Types","text":"Plot Use Case Directory Concentration-Time Single subject PK 01_concentration_time Spaghetti Plot Population PK 02_population_spaghetti VPC Plot Model validation 03_vpc_plots Diagnostics Estimation GOF 04_estimation_diagnostics"},{"location":"examples/visualization/#quick-start","title":"Quick Start","text":"<pre><code>from openpkpd.viz import plot_concentration_time, plot_vpc, plot_gof\nimport matplotlib.pyplot as plt\n\n# Concentration-time plot\nfig, ax = plot_concentration_time(result, title=\"PK Profile\")\nplt.savefig(\"pk_profile.png\")\n\n# VPC plot\nfig, ax = plot_vpc(vpc_result, title=\"Visual Predictive Check\")\nplt.savefig(\"vpc.png\")\n\n# Goodness-of-fit\nfig = plot_gof(estimation_result)\nplt.savefig(\"gof.png\")\n</code></pre>"},{"location":"examples/visualization/#customization","title":"Customization","text":"<p>All plotting functions return matplotlib figures that can be customized:</p> <pre><code>fig, ax = plot_concentration_time(result)\nax.set_xlabel(\"Time (hours)\")\nax.set_ylabel(\"Concentration (ng/mL)\")\nax.set_xlim(0, 24)\nax.grid(True, alpha=0.3)\nfig.savefig(\"custom_plot.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"examples/visualization/#see-also","title":"See Also","text":"<ul> <li>NCA Examples - NCA metrics</li> <li>VPC Examples - VPC computation</li> <li>Estimation Examples - Parameter estimation</li> </ul>"},{"location":"examples/visualization/01_concentration_time/","title":"Concentration-Time Plot","text":"<p>Basic PK concentration-time profile visualization.</p>"},{"location":"examples/visualization/01_concentration_time/#features","title":"Features","text":"<ul> <li>Linear and semi-log scales</li> <li>Multiple compartments</li> <li>Dose annotation</li> <li>Customizable styling</li> </ul>"},{"location":"examples/visualization/01_concentration_time/#files","title":"Files","text":"File Description plot.py Python plotting example"},{"location":"examples/visualization/02_population_spaghetti/","title":"Population Spaghetti Plot","text":"<p>Visualization of population PK profiles with individual trajectories.</p>"},{"location":"examples/visualization/02_population_spaghetti/#features","title":"Features","text":"<ul> <li>Individual subject lines</li> <li>Population median/mean overlay</li> <li>Confidence bands</li> <li>Observed data overlay</li> </ul>"},{"location":"examples/visualization/02_population_spaghetti/#files","title":"Files","text":"File Description plot.py Python plotting example"},{"location":"examples/visualization/03_vpc_plots/","title":"VPC Plots","text":"<p>Visual Predictive Check visualization for model validation.</p>"},{"location":"examples/visualization/03_vpc_plots/#features","title":"Features","text":"<ul> <li>Observed data overlay</li> <li>Simulated prediction intervals</li> <li>Quantile bands (5th, 50th, 95th)</li> <li>BLQ handling</li> </ul>"},{"location":"examples/visualization/03_vpc_plots/#files","title":"Files","text":"File Description plot.py Python plotting example"},{"location":"examples/visualization/04_estimation_diagnostics/","title":"Estimation Diagnostic Plots","text":"<p>Goodness-of-fit and diagnostic plots for parameter estimation.</p>"},{"location":"examples/visualization/04_estimation_diagnostics/#plot-types","title":"Plot Types","text":"<ul> <li>DV vs PRED</li> <li>DV vs IPRED</li> <li>CWRES vs Time</li> <li>CWRES vs PRED</li> <li>ETA distributions</li> <li>QQ plots</li> </ul>"},{"location":"examples/visualization/04_estimation_diagnostics/#files","title":"Files","text":"File Description plot.py Python plotting example"},{"location":"examples/vpc/","title":"Visual Predictive Check (VPC)","text":"<p>Examples demonstrating VPC generation for model validation.</p>"},{"location":"examples/vpc/#what-is-vpc","title":"What is VPC?","text":"<p>VPC compares simulated data from the model to observed data: 1. Simulate n replicates (e.g., 500) using final model estimates 2. Compute quantiles (5th, 50th, 95th) of simulated data at each time 3. Overlay observed data 4. Check if observed quantiles fall within simulated confidence intervals</p>"},{"location":"examples/vpc/#vpc-types","title":"VPC Types","text":"Type Description Use Case Standard VPC Basic VPC Initial validation pcVPC Prediction-corrected Variable dosing Stratified By covariate Covariate effects VPC with BLQ Below LOQ handling Assay limits"},{"location":"examples/vpc/#examples","title":"Examples","text":"Example Description Directory Standard VPC Basic implementation 01_standard_vpc pcVPC Prediction-corrected 02_prediction_corrected_vpc"},{"location":"examples/vpc/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Generate VPC\nvpc_result = compute_vpc(\n    observed_data,\n    pop_spec,\n    n_simulations = 500,\n    quantiles = [0.05, 0.5, 0.95],\n    seed = 12345\n)\n\n# Access results\nsim_quantiles = vpc_result.simulated_quantiles  # Simulated CI\nobs_quantiles = vpc_result.observed_quantiles   # Observed data\n</code></pre>"},{"location":"examples/vpc/#interpretation","title":"Interpretation","text":"<p>Good VPC: - Observed median close to simulated median - 90% of observed data within 90% simulated PI - No systematic deviations</p> <p>Poor VPC signals: - Median bias \u2192 Structural model misspecification - Over-prediction \u2192 IIV too large - Under-prediction \u2192 IIV too small</p>"},{"location":"examples/vpc/01_standard_vpc/","title":"Standard VPC","text":"<p>Basic Visual Predictive Check implementation.</p>"},{"location":"examples/vpc/01_standard_vpc/#method","title":"Method","text":"<ol> <li>Simulate n replicates (e.g., 500) using final model estimates</li> <li>Compute quantiles (5th, 50th, 95th) of simulated data</li> <li>Overlay observed data</li> <li>Check if observed quantiles fall within simulated CI</li> </ol>"},{"location":"examples/vpc/01_standard_vpc/#files","title":"Files","text":"File Description julia.jl Julia implementation python.py Python implementation"},{"location":"examples/vpc/02_prediction_corrected_vpc/","title":"Prediction-Corrected VPC","text":"<p>VPC with prediction correction for variable dosing scenarios.</p>"},{"location":"examples/vpc/02_prediction_corrected_vpc/#when-to-use","title":"When to Use","text":"<p>pcVPC is useful when: - Different doses across subjects - Variable dosing schedules - Covariate-dependent predictions</p>"},{"location":"examples/vpc/02_prediction_corrected_vpc/#method","title":"Method","text":"<p>Observations and predictions are normalized by the population prediction before computing quantiles.</p>"},{"location":"examples/vpc/02_prediction_corrected_vpc/#see-also","title":"See Also","text":"<ul> <li>Standard VPC</li> </ul>"},{"location":"intro/","title":"Introduction to OpenPKPD","text":"Transparent, Validated PK/PD Modeling Infrastructure <p>OpenPKPD is an open-source platform for pharmacokinetic and pharmacodynamic modeling, built for reproducibility, scientific rigor, and regulatory compliance.</p>"},{"location":"intro/#what-is-openpkpd","title":"What is OpenPKPD?","text":"<p>OpenPKPD is a comprehensive pharmacometrics platform that provides:</p> <ul> <li>Validated PK/PD Models - Industry-standard compartmental models with full mathematical transparency</li> <li>Population Simulation - Inter-individual and inter-occasion variability modeling</li> <li>Parameter Estimation - FOCE-I, SAEM, and Laplacian methods for NLME estimation</li> <li>Non-Compartmental Analysis - FDA/EMA-compliant exposure metrics</li> <li>Clinical Trial Simulation - Virtual trial design and power analysis</li> <li>Professional Visualization - Publication-ready plots with dual backend support</li> </ul>"},{"location":"intro/#why-openpkpd","title":"Why OpenPKPD?","text":""},{"location":"intro/#transparency","title":"Transparency","text":"<p>Every model equation, algorithm, and numerical method is documented and open for inspection. No black boxes.</p>"},{"location":"intro/#reproducibility","title":"Reproducibility","text":"<p>JSON-serialized artifacts capture complete simulation state, enabling bit-exact reproduction across versions and platforms.</p>"},{"location":"intro/#dual-language-support","title":"Dual-Language Support","text":"<p>Write your analysis in Julia for maximum performance, or Python for seamless integration with data science workflows.</p>"},{"location":"intro/#regulatory-ready","title":"Regulatory-Ready","text":"<p>NCA calculations follow FDA/EMA guidelines. VPC and diagnostic plots meet regulatory submission standards.</p>"},{"location":"intro/#quick-links","title":"Quick Links","text":"<ul> <li> <p> Julia Documentation</p> <p>Complete reference for the Julia core library</p> <p> Julia Docs</p> </li> <li> <p> Python Documentation</p> <p>Python bindings with visualization support</p> <p> Python Docs</p> </li> <li> <p> Getting Started</p> <p>Install OpenPKPD and run your first simulation</p> <p> Get Started</p> </li> </ul>"},{"location":"intro/#core-capabilities","title":"Core Capabilities","text":""},{"location":"intro/#pharmacokinetic-models","title":"Pharmacokinetic Models","text":"Model Compartments Route Key Application One-Compartment 1 IV/Oral Simple kinetics Two-Compartment 2 IV/Oral Distribution phase Three-Compartment 3 IV Deep tissue binding Transit Absorption N+1 Oral Delayed absorption Michaelis-Menten 1 IV Saturable elimination TMDD 2-3 IV Target-mediated disposition"},{"location":"intro/#pharmacodynamic-models","title":"Pharmacodynamic Models","text":"Model Type Mechanism Direct Emax Direct Immediate response Sigmoid Emax Direct Hill equation Effect Compartment Indirect Biophase equilibration Indirect Response (I-IV) Indirect Turnover modulation Disease Progression Complex Biomarker dynamics"},{"location":"intro/#analysis-workflows","title":"Analysis Workflows","text":"<pre><code>graph LR\n    A[Define Model] --&gt; B[Simulate Population]\n    B --&gt; C[Estimate Parameters]\n    C --&gt; D[Validate with VPC]\n    D --&gt; E[Clinical Trial Simulation]\n    E --&gt; F[Power Analysis]\n</code></pre>"},{"location":"intro/#platform-architecture","title":"Platform Architecture","text":"<p>OpenPKPD is organized as a monorepo with three main packages:</p> <pre><code>openpkpd/\n\u251c\u2500\u2500 core/           # Julia core library (OpenPKPDCore.jl)\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 python/     # Python bindings (openpkpd)\n\u2502   \u2514\u2500\u2500 cli/        # Command-line interface\n\u251c\u2500\u2500 validation/     # Golden artifacts for reproducibility\n\u2514\u2500\u2500 docs/           # This documentation\n</code></pre> <p>Learn more about the architecture \u2192</p>"},{"location":"intro/#version-information","title":"Version Information","text":"Component Version OpenPKPD 0.1.0 Event Semantics 1.0.0 Solver Semantics 1.0.0 Artifact Schema 1.0.0"},{"location":"intro/#next-steps","title":"Next Steps","text":"<ul> <li> <p>New to OpenPKPD?</p> <p>Start with the Getting Started Guide</p> </li> <li> <p>Coming from NONMEM?</p> <p>See the NONMEM Migration Guide</p> </li> <li> <p>Need visualization?</p> <p>Check out Python Visualization</p> </li> </ul>"},{"location":"intro/architecture/","title":"Architecture Overview","text":"<p>OpenPKPD is designed as a modular, multi-language platform with a high-performance Julia core and accessible Python bindings.</p>"},{"location":"intro/architecture/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"User Interfaces\"\n        CLI[CLI&lt;br/&gt;openpkpd]\n        PY[Python&lt;br/&gt;openpkpd package]\n        JL[Julia&lt;br/&gt;OpenPKPDCore.jl]\n    end\n\n    subgraph \"Core Engine\"\n        SIM[Simulation Engine]\n        EST[Estimation Engine]\n        NCA[NCA Engine]\n        VPC[VPC Engine]\n        TRIAL[Trial Engine]\n    end\n\n    subgraph \"Foundation\"\n        ODE[ODE Solvers&lt;br/&gt;DifferentialEquations.jl]\n        STAT[Statistics&lt;br/&gt;Distributions.jl]\n        OPT[Optimization&lt;br/&gt;Optim.jl]\n    end\n\n    CLI --&gt; SIM\n    PY --&gt; SIM\n    JL --&gt; SIM\n\n    SIM --&gt; ODE\n    EST --&gt; ODE\n    EST --&gt; OPT\n    NCA --&gt; STAT\n    VPC --&gt; STAT\n    TRIAL --&gt; STAT\n</code></pre>"},{"location":"intro/architecture/#package-structure","title":"Package Structure","text":"<pre><code>openpkpd/\n\u251c\u2500\u2500 core/                          # Julia core library\n\u2502   \u2514\u2500\u2500 OpenPKPDCore/\n\u2502       \u251c\u2500\u2500 src/\n\u2502       \u2502   \u251c\u2500\u2500 OpenPKPDCore.jl    # Main module\n\u2502       \u2502   \u251c\u2500\u2500 engine/            # Simulation engines\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 simulation.jl\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 population.jl\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 covariates.jl\n\u2502       \u2502   \u251c\u2500\u2500 models/            # PK/PD model definitions\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 pk/\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 pd/\n\u2502       \u2502   \u251c\u2500\u2500 estimation/        # NLME estimation\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 foce.jl\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 saem.jl\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 laplacian.jl\n\u2502       \u2502   \u251c\u2500\u2500 nca/               # Non-compartmental analysis\n\u2502       \u2502   \u251c\u2500\u2500 vpc/               # Visual predictive checks\n\u2502       \u2502   \u251c\u2500\u2500 trial/             # Clinical trial simulation\n\u2502       \u2502   \u251c\u2500\u2500 import/            # NONMEM/Monolix parsers\n\u2502       \u2502   \u251c\u2500\u2500 serialization/     # JSON artifact I/O\n\u2502       \u2502   \u2514\u2500\u2500 specs/             # Type specifications\n\u2502       \u2514\u2500\u2500 test/                  # Comprehensive test suite\n\u2502\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 python/                    # Python bindings\n\u2502   \u2502   \u2514\u2500\u2500 openpkpd/\n\u2502   \u2502       \u251c\u2500\u2500 __init__.py        # Core simulation functions\n\u2502   \u2502       \u251c\u2500\u2500 nca/               # NCA module\n\u2502   \u2502       \u251c\u2500\u2500 trial/             # Trial simulation module\n\u2502   \u2502       \u251c\u2500\u2500 viz/               # Visualization (55+ functions)\n\u2502   \u2502       \u2514\u2500\u2500 data/              # Data import utilities\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 cli/                       # Command-line interface\n\u2502       \u2514\u2500\u2500 bin/openpkpd           # CLI executable\n\u2502\n\u251c\u2500\u2500 validation/                    # Reproducibility validation\n\u2502   \u251c\u2500\u2500 golden/                    # Golden reference artifacts\n\u2502   \u2514\u2500\u2500 scripts/                   # Validation scripts\n\u2502\n\u2514\u2500\u2500 docs/                          # Documentation (this site)\n</code></pre>"},{"location":"intro/architecture/#core-components","title":"Core Components","text":""},{"location":"intro/architecture/#simulation-engine","title":"Simulation Engine","text":"<p>The simulation engine handles ODE-based PK/PD model execution:</p> <pre><code># Core simulation flow\nfunction simulate(spec::ModelSpec, grid::SimGrid, solver::SolverSpec)\n    # 1. Build ODE problem\n    prob = build_ode_problem(spec)\n\n    # 2. Add dose callbacks\n    callbacks = build_dose_callbacks(spec.doses, grid)\n\n    # 3. Solve ODE system\n    sol = solve(prob, solver.alg;\n                reltol=solver.reltol,\n                abstol=solver.abstol,\n                callback=callbacks,\n                saveat=grid.saveat)\n\n    # 4. Extract observations\n    observations = compute_observations(sol, spec.model)\n\n    return SimResult(sol.t, sol.u, observations)\nend\n</code></pre> <p>Key Features: - Automatic dose event handling (bolus, infusion) - Flexible ODE solver selection - State and observation extraction - Full numerical precision</p>"},{"location":"intro/architecture/#population-engine","title":"Population Engine","text":"<p>Extends single-subject simulation to populations:</p> <pre><code>function simulate_population(pop_spec::PopulationSpec, grid, solver)\n    individuals = Vector{SimResult}(undef, pop_spec.n)\n    realized_params = Vector{Dict}(undef, pop_spec.n)\n\n    for i in 1:pop_spec.n\n        # Sample random effects\n        eta = sample_random_effects(pop_spec.omega, pop_spec.seed + i)\n\n        # Apply IIV to parameters\n        params = apply_iiv(pop_spec.typical_params, eta)\n\n        # Apply covariates if present\n        if has_covariates(pop_spec)\n            params = apply_covariates(params, pop_spec.covariates[i])\n        end\n\n        # Simulate individual\n        individuals[i] = simulate(build_spec(params), grid, solver)\n        realized_params[i] = params\n    end\n\n    # Compute population summaries\n    summaries = compute_summaries(individuals)\n\n    return PopulationResult(individuals, realized_params, summaries)\nend\n</code></pre>"},{"location":"intro/architecture/#estimation-engine","title":"Estimation Engine","text":"<p>NLME parameter estimation using FOCE-I, SAEM, or Laplacian:</p> <pre><code>graph LR\n    A[Data] --&gt; B[Initial Estimates]\n    B --&gt; C{Method}\n    C --&gt;|FOCE-I| D[Gradient-Based Optimization]\n    C --&gt;|SAEM| E[Stochastic EM]\n    C --&gt;|Laplacian| F[Laplace Approximation]\n    D --&gt; G[Parameter Estimates]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H[Standard Errors]\n    H --&gt; I[Diagnostics]\n</code></pre>"},{"location":"intro/architecture/#nca-engine","title":"NCA Engine","text":"<p>Non-compartmental analysis following regulatory guidelines:</p> <pre><code>function run_nca(times, conc, dose; config=NCAConfig())\n    # Exposure metrics\n    cmax, tmax = find_cmax(times, conc)\n\n    # AUC calculation\n    auc_0_t = compute_auc(times, conc, config.method)\n\n    # Terminal phase\n    lambda_z, r2, n_points = estimate_lambda_z(times, conc, config)\n    t_half = log(2) / lambda_z\n\n    # Extrapolation\n    auc_0_inf = auc_0_t + conc[end] / lambda_z\n\n    # Clearance\n    cl_f = dose / auc_0_inf\n    vz_f = cl_f / lambda_z\n\n    return NCAResult(cmax, tmax, auc_0_t, auc_0_inf, t_half, cl_f, vz_f, ...)\nend\n</code></pre>"},{"location":"intro/architecture/#data-flow","title":"Data Flow","text":""},{"location":"intro/architecture/#single-simulation","title":"Single Simulation","text":"<pre><code>sequenceDiagram\n    participant User\n    participant API\n    participant Engine\n    participant Solver\n    participant Output\n\n    User-&gt;&gt;API: simulate_pk_iv_bolus(cl, v, doses, ...)\n    API-&gt;&gt;Engine: Build ModelSpec\n    Engine-&gt;&gt;Solver: Create ODE Problem\n    Solver-&gt;&gt;Solver: Integrate with callbacks\n    Solver-&gt;&gt;Engine: Solution\n    Engine-&gt;&gt;Output: Extract observations\n    Output-&gt;&gt;API: SimResult dict\n    API-&gt;&gt;User: Return result\n</code></pre>"},{"location":"intro/architecture/#population-simulation","title":"Population Simulation","text":"<pre><code>sequenceDiagram\n    participant User\n    participant API\n    participant Population\n    participant Engine\n    participant Summary\n\n    User-&gt;&gt;API: simulate_population(params, n, omegas, ...)\n    API-&gt;&gt;Population: Build PopulationSpec\n    loop For each individual\n        Population-&gt;&gt;Population: Sample random effects\n        Population-&gt;&gt;Engine: Simulate individual\n        Engine-&gt;&gt;Population: Individual result\n    end\n    Population-&gt;&gt;Summary: Aggregate results\n    Summary-&gt;&gt;API: PopulationResult\n    API-&gt;&gt;User: Return result with summaries\n</code></pre>"},{"location":"intro/architecture/#type-system","title":"Type System","text":""},{"location":"intro/architecture/#core-types-julia","title":"Core Types (Julia)","text":"<pre><code># Model specification\nstruct ModelSpec{M&lt;:ModelKind, P&lt;:AbstractParams}\n    model::M\n    name::String\n    params::P\n    doses::Vector{DoseEvent}\nend\n\n# Simulation grid\nstruct SimGrid\n    t0::Float64\n    t1::Float64\n    saveat::Vector{Float64}\nend\n\n# Solver configuration\nstruct SolverSpec\n    alg::Symbol\n    reltol::Float64\n    abstol::Float64\n    maxiters::Int\nend\n\n# Simulation result\nstruct SimResult\n    t::Vector{Float64}\n    states::Dict{Symbol, Vector{Float64}}\n    observations::Dict{Symbol, Vector{Float64}}\n    metadata::Dict{Symbol, Any}\nend\n</code></pre>"},{"location":"intro/architecture/#python-type-mapping","title":"Python Type Mapping","text":"Julia Type Python Type <code>Float64</code> <code>float</code> <code>Vector{Float64}</code> <code>list[float]</code> <code>Dict{Symbol, Any}</code> <code>dict[str, Any]</code> <code>SimResult</code> <code>dict</code> with standard keys <code>DoseEvent</code> <code>dict</code> with <code>time</code>, <code>amount</code>, <code>duration</code>"},{"location":"intro/architecture/#serialization","title":"Serialization","text":""},{"location":"intro/architecture/#artifact-schema","title":"Artifact Schema","text":"<p>All simulation results can be serialized to JSON artifacts:</p> <pre><code>{\n  \"schema_version\": \"1.0.0\",\n  \"artifact_type\": \"simulation\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"model\": {\n    \"kind\": \"OneCompIVBolus\",\n    \"params\": {\"CL\": 5.0, \"V\": 50.0},\n    \"doses\": [{\"time\": 0.0, \"amount\": 100.0, \"duration\": 0.0}]\n  },\n  \"grid\": {\n    \"t0\": 0.0,\n    \"t1\": 24.0,\n    \"saveat\": [0.0, 1.0, 2.0, ...]\n  },\n  \"solver\": {\n    \"alg\": \"Tsit5\",\n    \"reltol\": 1e-10,\n    \"abstol\": 1e-12,\n    \"maxiters\": 10000000\n  },\n  \"result\": {\n    \"t\": [0.0, 1.0, 2.0, ...],\n    \"observations\": {\n      \"conc\": [2.0, 1.81, 1.64, ...]\n    }\n  },\n  \"semantics\": {\n    \"event_version\": \"1.0.0\",\n    \"solver_version\": \"1.0.0\"\n  }\n}\n</code></pre>"},{"location":"intro/architecture/#replay-capability","title":"Replay Capability","text":"<p>Artifacts can be replayed to reproduce exact results:</p> <pre><code>./bin/openpkpd replay --artifact simulation.json\n</code></pre>"},{"location":"intro/architecture/#extension-points","title":"Extension Points","text":""},{"location":"intro/architecture/#custom-models","title":"Custom Models","text":"<p>Add new models by implementing the model interface:</p> <pre><code># 1. Define model kind\nstruct MyCustomModel &lt;: ModelKind end\n\n# 2. Define parameters\nstruct MyCustomParams &lt;: AbstractParams\n    param1::Float64\n    param2::Float64\nend\n\n# 3. Implement ODE function\nfunction ode!(du, u, p::MyCustomParams, t)\n    du[1] = -p.param1 * u[1]\nend\n\n# 4. Implement observation function\nfunction observe(model::MyCustomModel, u, p)\n    return Dict(:conc =&gt; u[1] / p.param2)\nend\n</code></pre>"},{"location":"intro/architecture/#custom-visualization","title":"Custom Visualization","text":"<p>Add new visualization functions following the pattern:</p> <pre><code>def plot_my_custom(\n    data: DataType,\n    *,\n    backend: str = \"matplotlib\",\n    title: str | None = None,\n    figsize: tuple[float, float] = (10, 6),\n    **kwargs\n) -&gt; Figure:\n    \"\"\"Custom plot function.\"\"\"\n    backend_module = get_backend_module(backend)\n    fig, ax = backend_module.create_figure(figsize)\n    # ... plotting logic\n    return fig\n</code></pre>"},{"location":"intro/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"intro/architecture/#julia-jit-compilation","title":"Julia JIT Compilation","text":"<p>First simulation incurs compilation overhead. Subsequent simulations are fast:</p> <pre><code># First call: ~2-5 seconds (compilation)\n@time simulate(spec, grid, solver)\n\n# Subsequent calls: ~1-10 ms\n@time simulate(spec, grid, solver)\n</code></pre>"},{"location":"intro/architecture/#python-bridge-overhead","title":"Python Bridge Overhead","text":"<p>The Python-Julia bridge adds minimal overhead (~1ms per call).</p>"},{"location":"intro/architecture/#population-parallelization","title":"Population Parallelization","text":"<p>Population simulations can be parallelized:</p> <pre><code>using Threads\n\nThreads.@threads for i in 1:n\n    individuals[i] = simulate(...)\nend\n</code></pre>"},{"location":"intro/architecture/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and setup</li> <li>Julia Tutorial - Deep dive into Julia API</li> <li>Python Tutorial - Python bindings walkthrough</li> </ul>"},{"location":"intro/features/","title":"Key Features","text":"<p>OpenPKPD provides a comprehensive suite of pharmacometrics capabilities designed for research, clinical development, and regulatory submissions.</p>"},{"location":"intro/features/#pharmacokinetic-models","title":"Pharmacokinetic Models","text":""},{"location":"intro/features/#compartmental-models","title":"Compartmental Models","text":"<p>OpenPKPD supports all standard compartmental PK models with rigorous mathematical formulations:</p> One-CompartmentTwo-CompartmentThree-Compartment <pre><code># IV Bolus\nparams = OneCompIVBolusParams(CL=5.0, V=50.0)\n\n# Oral First-Order\nparams = OneCompOralFirstOrderParams(Ka=1.5, CL=5.0, V=50.0)\n</code></pre> \\[\\frac{dA}{dt} = -\\frac{CL}{V} \\cdot A\\] <pre><code>params = TwoCompIVBolusParams(CL=5.0, V1=20.0, Q=15.0, V2=50.0)\n</code></pre> \\[\\frac{dA_1}{dt} = -k_{10} A_1 - k_{12} A_1 + k_{21} A_2\\] <pre><code>params = ThreeCompIVBolusParams(CL=5.0, V1=10.0, Q2=20.0, V2=30.0, Q3=5.0, V3=100.0)\n</code></pre> <p>Tri-exponential decline with shallow and deep peripheral compartments.</p>"},{"location":"intro/features/#advanced-absorption","title":"Advanced Absorption","text":"Model Description Use Case Transit Compartments Chain of N compartments Delayed/complex absorption Lag Time Fixed delay before absorption Enteric-coated tablets Zero-Order Constant-rate absorption Controlled-release"},{"location":"intro/features/#nonlinear-kinetics","title":"Nonlinear Kinetics","text":"<ul> <li>Michaelis-Menten Elimination: Saturable metabolism</li> <li>TMDD Models: Target-mediated drug disposition for biologics</li> </ul>"},{"location":"intro/features/#pharmacodynamic-models","title":"Pharmacodynamic Models","text":""},{"location":"intro/features/#direct-response-models","title":"Direct Response Models","text":"<pre><code># Direct Emax\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    e0=0.0, emax=100.0, ec50=2.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0\n)\n\n# Sigmoid Emax (Hill Equation)\nresult = openpkpd.simulate_pkpd_sigmoid_emax(\n    cl=5.0, v=50.0,\n    e0=0.0, emax=100.0, ec50=2.0, gamma=2.5,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0\n)\n</code></pre>"},{"location":"intro/features/#indirect-response-models","title":"Indirect Response Models","text":"<p>All four indirect response types are supported:</p> Type Mechanism Drug Effect Type I Inhibition of Kin Decreases response Type II Inhibition of Kout Increases response Type III Stimulation of Kin Increases response Type IV Stimulation of Kout Decreases response"},{"location":"intro/features/#effect-compartment-biophase","title":"Effect Compartment (Biophase)","text":"<p>Models temporal delay between plasma and effect site concentrations:</p> \\[\\frac{dC_e}{dt} = k_{e0} \\cdot (C_p - C_e)\\]"},{"location":"intro/features/#population-modeling","title":"Population Modeling","text":""},{"location":"intro/features/#inter-individual-variability-iiv","title":"Inter-Individual Variability (IIV)","text":"<p>Log-normal distribution of parameters across subjects:</p> <pre><code># Define omega matrix (variance of random effects)\nomega = OmegaMatrix([\n    0.09 0.0;   # 30% CV on CL\n    0.0  0.04   # 20% CV on V\n])\n\npop_spec = PopulationSpec(\n    model_spec,\n    100,           # n subjects\n    omega,\n    12345          # seed\n)\n</code></pre>"},{"location":"intro/features/#inter-occasion-variability-iov","title":"Inter-Occasion Variability (IOV)","text":"<p>Parameter variation between dosing occasions within the same subject.</p>"},{"location":"intro/features/#covariate-models","title":"Covariate Models","text":"<p>Multiple covariate functional forms:</p> Type Formula Example Linear \\(\\theta \\cdot (1 + \\theta_{cov} \\cdot (COV - COV_{ref}))\\) Age effect Power \\(\\theta \\cdot (COV/COV_{ref})^{\\theta_{cov}}\\) Weight on CL Exponential \\(\\theta \\cdot e^{\\theta_{cov} \\cdot COV}\\) Enzyme induction Categorical \\(\\theta \\cdot \\theta_{cov}\\) if category Sex effect"},{"location":"intro/features/#residual-error-models","title":"Residual Error Models","text":"<ul> <li>Additive: \\(Y = F + \\epsilon\\)</li> <li>Proportional: \\(Y = F \\cdot (1 + \\epsilon)\\)</li> <li>Combined: \\(Y = F \\cdot (1 + \\epsilon_1) + \\epsilon_2\\)</li> <li>Exponential: \\(Y = F \\cdot e^\\epsilon\\)</li> </ul>"},{"location":"intro/features/#parameter-estimation","title":"Parameter Estimation","text":""},{"location":"intro/features/#foce-i-first-order-conditional-estimation-with-interaction","title":"FOCE-I (First-Order Conditional Estimation with Interaction)","text":"<p>The gold standard for NLME estimation:</p> <pre><code>result = estimate(\n    data,\n    model_spec,\n    FOCEConfig(\n        max_iterations=1000,\n        tolerance=1e-6\n    )\n)\n</code></pre>"},{"location":"intro/features/#saem-stochastic-approximation-em","title":"SAEM (Stochastic Approximation EM)","text":"<p>Robust estimation for complex models:</p> <pre><code>result = estimate(\n    data,\n    model_spec,\n    SAEMConfig(\n        n_iterations=500,\n        n_burn_in=100,\n        n_chains=3\n    )\n)\n</code></pre>"},{"location":"intro/features/#laplacian-estimation","title":"Laplacian Estimation","text":"<p>For sparse data or complex likelihoods.</p>"},{"location":"intro/features/#estimation-diagnostics","title":"Estimation Diagnostics","text":"<ul> <li>Convergence assessment</li> <li>Parameter uncertainty (SE, RSE, CI)</li> <li>Shrinkage calculation</li> <li>Correlation matrices</li> <li>Objective function comparison</li> </ul>"},{"location":"intro/features/#non-compartmental-analysis","title":"Non-Compartmental Analysis","text":""},{"location":"intro/features/#fdaema-compliant-metrics","title":"FDA/EMA-Compliant Metrics","text":"Metric Description Cmax Maximum concentration Tmax Time to maximum concentration AUC0-t Area under curve to last observation AUC0-inf Area extrapolated to infinity t\u00bd Terminal half-life CL/F Apparent clearance Vz/F Apparent volume MRT Mean residence time"},{"location":"intro/features/#bioequivalence-analysis","title":"Bioequivalence Analysis","text":"<pre><code>from openpkpd.nca import bioequivalence_90ci, tost_analysis\n\n# 90% CI for geometric mean ratio\nlower, upper = bioequivalence_90ci(test_auc, reference_auc)\n\n# TOST analysis\nresult = tost_analysis(\n    test_auc, reference_auc,\n    theta_lower=0.80, theta_upper=1.25\n)\n</code></pre>"},{"location":"intro/features/#visual-predictive-check-vpc","title":"Visual Predictive Check (VPC)","text":""},{"location":"intro/features/#standard-vpc","title":"Standard VPC","text":"<p>Comparison of observed vs simulated percentiles:</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_vpc_detailed(\n    simulated_data,\n    observed_data,\n    prediction_intervals=[0.05, 0.50, 0.95]\n)\n</code></pre>"},{"location":"intro/features/#prediction-corrected-vpc-pcvpc","title":"Prediction-Corrected VPC (pcVPC)","text":"<p>Corrects for design differences across bins.</p>"},{"location":"intro/features/#stratified-vpc","title":"Stratified VPC","text":"<p>Separate VPC by covariate strata (e.g., dose group, renal function).</p>"},{"location":"intro/features/#blq-handling","title":"BLQ Handling","text":"<p>Proper visualization of below-limit-of-quantification observations.</p>"},{"location":"intro/features/#clinical-trial-simulation","title":"Clinical Trial Simulation","text":""},{"location":"intro/features/#study-designs","title":"Study Designs","text":"Design Description Parallel Independent treatment groups Crossover (2\u00d72) Standard two-period crossover Williams Three-period, three-treatment 3+3 Traditional dose escalation mTPI/CRM Model-based escalation Adaptive Interim analysis with adaptation"},{"location":"intro/features/#power-analysis","title":"Power Analysis","text":"<pre><code>from openpkpd import trial\n\npower = trial.estimate_power_analytical(\n    n_per_arm=50,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\n\nsample_size = trial.estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\n</code></pre>"},{"location":"intro/features/#virtual-population-generation","title":"Virtual Population Generation","text":"<p>Generate realistic virtual subjects with specified demographics.</p>"},{"location":"intro/features/#visualization","title":"Visualization","text":""},{"location":"intro/features/#dual-backend-support","title":"Dual Backend Support","text":"MatplotlibPlotly <pre><code>from openpkpd import viz\nviz.set_backend(\"matplotlib\")\n\nfig = viz.plot_conc_time(result)\nfig.savefig(\"plot.png\", dpi=300)\n</code></pre> <pre><code>from openpkpd import viz\nviz.set_backend(\"plotly\")\n\nfig = viz.plot_conc_time(result)\nfig.write_html(\"plot.html\")\n</code></pre>"},{"location":"intro/features/#55-visualization-functions","title":"55+ Visualization Functions","text":"Category Functions PK Plots <code>plot_conc_time</code>, <code>plot_spaghetti</code>, <code>plot_mean_ribbon</code> NCA Plots <code>plot_lambda_z_fit</code>, <code>plot_auc_visualization</code> PKPD Plots <code>plot_effect_conc</code>, <code>plot_hysteresis</code> VPC Plots <code>plot_vpc_detailed</code>, <code>plot_pcvpc</code>, <code>plot_stratified_vpc</code> Estimation <code>plot_convergence</code>, <code>plot_shrinkage</code>, <code>plot_eta_distributions</code> Bootstrap <code>plot_bootstrap_distributions</code>, <code>plot_bootstrap_ci</code> Sensitivity <code>plot_tornado</code>, <code>plot_spider</code>, <code>plot_waterfall</code> Trial <code>plot_power_curve</code>, <code>plot_kaplan_meier</code>"},{"location":"intro/features/#model-import","title":"Model Import","text":""},{"location":"intro/features/#nonmem","title":"NONMEM","text":"<p>Parse NONMEM control stream files:</p> <pre><code>./bin/openpkpd import --input run001.ctl --format nonmem --out model.json\n</code></pre> <p>Supported ADVAN subroutines: ADVAN1, ADVAN2, ADVAN3, ADVAN4, ADVAN11, ADVAN12</p>"},{"location":"intro/features/#monolix","title":"Monolix","text":"<p>Parse Monolix project files (.mlxtran).</p>"},{"location":"intro/features/#cdisc-data","title":"CDISC Data","text":"<p>Import PC, EX, and DM domains in CSV or XPT format.</p>"},{"location":"intro/features/#reproducibility","title":"Reproducibility","text":""},{"location":"intro/features/#artifact-system","title":"Artifact System","text":"<p>Every simulation produces a JSON artifact containing:</p> <ul> <li>Complete model specification</li> <li>Solver settings</li> <li>Input data hash</li> <li>Full results with numerical precision</li> <li>Semantic version fingerprint</li> </ul>"},{"location":"intro/features/#golden-artifact-validation","title":"Golden Artifact Validation","text":"<pre><code>./bin/openpkpd validate-golden\n</code></pre> <p>Ensures bit-exact reproducibility across code changes.</p>"},{"location":"intro/features/#replay-capability","title":"Replay Capability","text":"<pre><code>./bin/openpkpd replay --artifact simulation.json\n</code></pre> <p>Reproduce any previous simulation exactly.</p>"},{"location":"intro/features/#performance","title":"Performance","text":""},{"location":"intro/features/#julia-core","title":"Julia Core","text":"<ul> <li>Just-in-time compilation for near-native speed</li> <li>Efficient ODE solvers (DifferentialEquations.jl)</li> <li>Parallelized population simulations</li> </ul>"},{"location":"intro/features/#python-integration","title":"Python Integration","text":"<ul> <li>Seamless Julia-Python bridge via juliacall</li> <li>NumPy/Pandas integration</li> <li>Lazy initialization for fast startup</li> </ul>"},{"location":"intro/features/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide - Installation and first simulation</li> <li>Architecture Overview - System design details</li> <li>Julia Tutorial - Complete Julia walkthrough</li> <li>Python Tutorial - Complete Python walkthrough</li> </ul>"},{"location":"intro/getting-started/","title":"Getting Started","text":"<p>This guide will help you install OpenPKPD and run your first simulation in under 10 minutes.</p>"},{"location":"intro/getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"intro/getting-started/#system-requirements","title":"System Requirements","text":"Requirement Minimum Recommended Julia 1.10+ 1.11+ Python 3.10+ 3.12+ Memory 4 GB 8 GB+ OS macOS, Linux, Windows macOS, Linux"},{"location":"intro/getting-started/#installing-julia","title":"Installing Julia","text":"macOSLinuxWindows <pre><code># Using Homebrew\nbrew install julia\n\n# Or download from julialang.org\ncurl -fsSL https://install.julialang.org | sh\n</code></pre> <pre><code># Using juliaup (recommended)\ncurl -fsSL https://install.julialang.org | sh\n\n# Or using apt (Ubuntu/Debian)\nsudo apt install julia\n</code></pre> <pre><code># Using winget\nwinget install julia\n\n# Or download installer from julialang.org\n</code></pre> <p>Verify installation:</p> <pre><code>julia --version\n# Julia Version 1.11.0\n</code></pre>"},{"location":"intro/getting-started/#installing-python","title":"Installing Python","text":"macOSLinuxWindows <pre><code># Using Homebrew\nbrew install python@3.12\n\n# Or using pyenv\npyenv install 3.12.0\n</code></pre> <pre><code># Ubuntu/Debian\nsudo apt install python3.12 python3.12-venv\n\n# Or using pyenv\npyenv install 3.12.0\n</code></pre> <pre><code># Using winget\nwinget install Python.Python.3.12\n</code></pre>"},{"location":"intro/getting-started/#installation","title":"Installation","text":""},{"location":"intro/getting-started/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/openpkpd/openpkpd.git\ncd openpkpd\n</code></pre>"},{"location":"intro/getting-started/#install-julia-core","title":"Install Julia Core","text":"<pre><code># Activate and instantiate the Julia project\njulia --project=core/OpenPKPDCore -e 'using Pkg; Pkg.instantiate()'\n</code></pre> <p>This installs all Julia dependencies including: - DifferentialEquations.jl (ODE solvers) - Distributions.jl (Statistical distributions) - JSON3.jl (Serialization)</p>"},{"location":"intro/getting-started/#install-python-bindings-optional","title":"Install Python Bindings (Optional)","text":"<pre><code>cd packages/python\n\n# Create virtual environment\npython3 -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n\n# Install package with all dependencies\npip install -e \".[all]\"\n</code></pre> <p>This installs: - <code>openpkpd</code> - Core Python bindings - <code>matplotlib</code>, <code>plotly</code> - Visualization backends - <code>numpy</code>, <code>pandas</code> - Data manipulation - <code>juliacall</code> - Julia-Python bridge</p>"},{"location":"intro/getting-started/#verify-installation","title":"Verify Installation","text":"JuliaPythonCLI <pre><code>julia --project=core/OpenPKPDCore\n\njulia&gt; using OpenPKPDCore\njulia&gt; println(version())\n# 0.1.0\n</code></pre> <pre><code>import openpkpd\nopenpkpd.init_julia()\nprint(openpkpd.version())\n# 0.1.0\n</code></pre> <pre><code>./packages/cli/bin/openpkpd version\n# OpenPKPD version 0.1.0\n</code></pre>"},{"location":"intro/getting-started/#your-first-simulation","title":"Your First Simulation","text":""},{"location":"intro/getting-started/#julia-one-compartment-iv-bolus","title":"Julia: One-Compartment IV Bolus","text":"<pre><code>using OpenPKPDCore\n\n# Define model parameters\n# CL = 5 L/h, V = 50 L\nparams = OneCompIVBolusParams(5.0, 50.0)\n\n# Define dose: 100 mg at time 0\ndoses = [DoseEvent(0.0, 100.0)]\n\n# Create model specification\nspec = ModelSpec(OneCompIVBolus(), \"my_first_sim\", params, doses)\n\n# Define simulation time grid (0 to 24 hours, hourly output)\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\n\n# Define solver settings\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Access results\nprintln(\"Time points: \", result.t)\nprintln(\"Concentrations: \", result.observations[:conc])\n</code></pre> <p>Expected Output: <pre><code>Time points: [0.0, 1.0, 2.0, ..., 24.0]\nConcentrations: [2.0, 1.81, 1.64, ..., 0.18]\n</code></pre></p>"},{"location":"intro/getting-started/#python-one-compartment-iv-bolus","title":"Python: One-Compartment IV Bolus","text":"<pre><code>import openpkpd\n\n# Initialize Julia (required once per session)\nopenpkpd.init_julia()\n\n# Run IV bolus simulation\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0,              # Clearance (L/h)\n    v=50.0,              # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],  # 100 mg at t=0\n    t0=0.0,              # Start time\n    t1=24.0,             # End time\n    saveat=[float(t) for t in range(25)]  # Hourly output\n)\n\n# Access results\nprint(\"Time points:\", result[\"t\"])\nprint(\"Concentrations:\", result[\"observations\"][\"conc\"])\n</code></pre>"},{"location":"intro/getting-started/#cli-simulate-from-spec-file","title":"CLI: Simulate from Spec File","text":"<p>Create a spec file <code>simulation.json</code>:</p> <pre><code>{\n  \"model\": {\n    \"kind\": \"OneCompIVBolus\",\n    \"params\": {\"CL\": 5.0, \"V\": 50.0},\n    \"doses\": [{\"time\": 0.0, \"amount\": 100.0}]\n  },\n  \"grid\": {\n    \"t0\": 0.0,\n    \"t1\": 24.0,\n    \"saveat\": [0, 1, 2, 3, 4, 6, 8, 12, 24]\n  },\n  \"solver\": {\n    \"alg\": \"Tsit5\",\n    \"reltol\": 1e-10,\n    \"abstol\": 1e-12\n  }\n}\n</code></pre> <p>Run simulation:</p> <pre><code>./packages/cli/bin/openpkpd simulate --spec simulation.json --out result.json\n</code></pre>"},{"location":"intro/getting-started/#your-first-population-simulation","title":"Your First Population Simulation","text":""},{"location":"intro/getting-started/#python-population-with-iiv","title":"Python: Population with IIV","text":"<pre><code>import openpkpd\n\nopenpkpd.init_julia()\n\n# Simulate 100 subjects with inter-individual variability\nresult = openpkpd.simulate_population_iv_bolus(\n    cl=5.0,              # Typical CL\n    v=50.0,              # Typical V\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[float(t) for t in range(25)],\n    n=100,               # Number of subjects\n    seed=12345,          # For reproducibility\n    omegas={             # IIV (CV)\n        \"CL\": 0.3,       # 30% CV on CL\n        \"V\": 0.2         # 20% CV on V\n    }\n)\n\n# Access individual results\nfor i in range(3):\n    cmax = max(result[\"individuals\"][i][\"observations\"][\"conc\"])\n    print(f\"Subject {i+1} Cmax: {cmax:.2f} mg/L\")\n\n# Access population summary\nsummary = result[\"summaries\"][\"conc\"]\nprint(f\"\\nPopulation median Cmax: {max(summary['median']):.2f} mg/L\")\nprint(f\"90% prediction interval: {max(summary['quantiles']['0.05']):.2f} - {max(summary['quantiles']['0.95']):.2f}\")\n</code></pre>"},{"location":"intro/getting-started/#your-first-visualization","title":"Your First Visualization","text":""},{"location":"intro/getting-started/#python-concentration-time-plot","title":"Python: Concentration-Time Plot","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\n\n# Run simulation\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)]\n)\n\n# Set visualization backend\nviz.set_backend(\"matplotlib\")\n\n# Create concentration-time plot\nfig = viz.plot_conc_time(result, title=\"One-Compartment IV Bolus\")\nfig.savefig(\"concentration_time.png\", dpi=300)\n</code></pre>"},{"location":"intro/getting-started/#python-population-spaghetti-plot","title":"Python: Population Spaghetti Plot","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\n\n# Run population simulation\npop_result = openpkpd.simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)],\n    n=50, seed=42,\n    omegas={\"CL\": 0.3, \"V\": 0.2}\n)\n\n# Create spaghetti plot\nviz.set_backend(\"matplotlib\")\nfig = viz.plot_spaghetti(pop_result, alpha=0.3)\nfig.savefig(\"population_spaghetti.png\", dpi=300)\n\n# Create mean with confidence ribbon\nfig = viz.plot_mean_ribbon(pop_result, ci_levels=[0.05, 0.95])\nfig.savefig(\"population_ribbon.png\", dpi=300)\n</code></pre>"},{"location":"intro/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have OpenPKPD running, explore these topics:</p>"},{"location":"intro/getting-started/#learn-the-basics","title":"Learn the Basics","text":"<ul> <li> <p> Julia Tutorial</p> <p>Complete walkthrough of Julia API</p> <p> Julia Tutorial</p> </li> <li> <p> Python Tutorial</p> <p>Complete walkthrough of Python bindings</p> <p> Python Tutorial</p> </li> </ul>"},{"location":"intro/getting-started/#explore-models","title":"Explore Models","text":"<ul> <li> <p> PK Models</p> <p>One, two, three-compartment, transit, Michaelis-Menten</p> <p> PK Models</p> </li> <li> <p> PD Models</p> <p>Emax, sigmoid, effect compartment, indirect response</p> <p> PD Models</p> </li> </ul>"},{"location":"intro/getting-started/#advanced-features","title":"Advanced Features","text":"<ul> <li> <p> Population Modeling</p> <p>IIV, IOV, and covariate effects</p> <p> Population</p> </li> <li> <p> Parameter Estimation</p> <p>FOCE-I, SAEM, Laplacian</p> <p> Estimation</p> </li> <li> <p> Clinical Trials</p> <p>Trial simulation and power analysis</p> <p> Trials</p> </li> <li> <p> Visualization</p> <p>55+ plotting functions</p> <p> Visualization</p> </li> </ul>"},{"location":"intro/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"intro/getting-started/#julia-not-found","title":"Julia Not Found","text":"<pre><code>Error: Julia executable not found\n</code></pre> <p>Solution: Ensure Julia is in your PATH:</p> <pre><code># Check Julia location\nwhich julia\n\n# Add to PATH if needed (add to ~/.bashrc or ~/.zshrc)\nexport PATH=\"$PATH:/path/to/julia/bin\"\n</code></pre>"},{"location":"intro/getting-started/#python-package-import-error","title":"Python Package Import Error","text":"<pre><code>ModuleNotFoundError: No module named 'openpkpd'\n</code></pre> <p>Solution: Ensure virtual environment is activated and package is installed:</p> <pre><code>source packages/python/.venv/bin/activate\npip install -e \".[all]\"\n</code></pre>"},{"location":"intro/getting-started/#julia-initialization-slow","title":"Julia Initialization Slow","text":"<p>First Julia call takes 2-5 seconds due to JIT compilation. This is normal. Subsequent calls are fast (~1-10ms).</p>"},{"location":"intro/getting-started/#memory-issues-with-large-populations","title":"Memory Issues with Large Populations","text":"<p>For populations &gt;1000 subjects, consider:</p> <ul> <li>Using sparser <code>saveat</code> time points</li> <li>Running in batches</li> <li>Increasing system memory</li> </ul>"},{"location":"intro/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: You're reading it!</li> <li>Examples: See <code>docs/examples/</code> for runnable code</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"julia/","title":"Julia Documentation","text":"<p>Welcome to the Julia documentation for OpenPKPD. The Julia core (<code>OpenPKPDCore.jl</code>) provides the foundation for all PK/PD modeling capabilities.</p>"},{"location":"julia/#why-julia","title":"Why Julia?","text":"<p>OpenPKPD uses Julia as its core language for several reasons:</p> <ul> <li>Performance: Near-native speed through JIT compilation</li> <li>Mathematical Expressiveness: Natural syntax for differential equations</li> <li>Ecosystem: World-class ODE solvers via DifferentialEquations.jl</li> <li>Multiple Dispatch: Flexible, extensible type system</li> </ul>"},{"location":"julia/#quick-start","title":"Quick Start","text":"<pre><code>using OpenPKPDCore\n\n# One-compartment IV bolus simulation\nparams = OneCompIVBolusParams(5.0, 50.0)  # CL=5 L/h, V=50 L\ndoses = [DoseEvent(0.0, 100.0)]            # 100 mg at t=0\nspec = ModelSpec(OneCompIVBolus(), \"example\", params, doses)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nresult = simulate(spec, grid, solver)\nprintln(result.observations[:conc])\n</code></pre>"},{"location":"julia/#documentation-sections","title":"Documentation Sections","text":"<ul> <li> <p> Tutorial</p> <p>Step-by-step introduction to OpenPKPD Julia API</p> <p> Start Tutorial</p> </li> <li> <p> Models</p> <p>Complete reference for PK and PD models</p> <p> Models Reference</p> </li> <li> <p> Population Modeling</p> <p>IIV, IOV, covariates, and residual error</p> <p> Population</p> </li> <li> <p> NCA</p> <p>Non-compartmental analysis</p> <p> NCA Reference</p> </li> <li> <p> Parameter Estimation</p> <p>FOCE-I, SAEM, and Laplacian methods</p> <p> Estimation</p> </li> <li> <p> Visual Predictive Check</p> <p>VPC, pcVPC, and stratification</p> <p> VPC Reference</p> </li> <li> <p> Model Import</p> <p>NONMEM and Monolix file parsing</p> <p> Import Reference</p> </li> <li> <p> Clinical Trials</p> <p>Trial simulation and power analysis</p> <p> Trial Reference</p> </li> </ul>"},{"location":"julia/#core-types","title":"Core Types","text":""},{"location":"julia/#modelspec","title":"ModelSpec","text":"<p>The central type for defining a simulation:</p> <pre><code>struct ModelSpec{M&lt;:ModelKind, P&lt;:AbstractParams}\n    model::M           # Model type (e.g., OneCompIVBolus)\n    name::String       # Simulation identifier\n    params::P          # Model parameters\n    doses::Vector{DoseEvent}\nend\n</code></pre>"},{"location":"julia/#simgrid","title":"SimGrid","text":"<p>Defines the time domain:</p> <pre><code>struct SimGrid\n    t0::Float64        # Start time\n    t1::Float64        # End time\n    saveat::Vector{Float64}  # Output time points\nend\n</code></pre>"},{"location":"julia/#solverspec","title":"SolverSpec","text":"<p>Configures the ODE solver:</p> <pre><code>struct SolverSpec\n    alg::Symbol        # Algorithm (:Tsit5, :Rosenbrock23, etc.)\n    reltol::Float64    # Relative tolerance\n    abstol::Float64    # Absolute tolerance\n    maxiters::Int      # Maximum iterations\nend\n</code></pre>"},{"location":"julia/#simresult","title":"SimResult","text":"<p>Simulation output:</p> <pre><code>struct SimResult\n    t::Vector{Float64}\n    states::Dict{Symbol, Vector{Float64}}\n    observations::Dict{Symbol, Vector{Float64}}\n    metadata::Dict{Symbol, Any}\nend\n</code></pre>"},{"location":"julia/#available-models","title":"Available Models","text":""},{"location":"julia/#pharmacokinetic-models","title":"Pharmacokinetic Models","text":"Model Type Parameters Description <code>OneCompIVBolus</code> CL, V IV bolus, first-order elimination <code>OneCompOralFirstOrder</code> Ka, CL, V Oral with first-order absorption <code>TwoCompIVBolus</code> CL, V1, Q, V2 Two-compartment IV <code>TwoCompOral</code> Ka, CL, V1, Q, V2 Two-compartment oral <code>ThreeCompIVBolus</code> CL, V1, Q2, V2, Q3, V3 Three-compartment IV <code>TransitAbsorption</code> N, Ktr, Ka, CL, V Transit compartment absorption <code>MichaelisMentenElimination</code> Vmax, Km, V Saturable elimination"},{"location":"julia/#pharmacodynamic-models","title":"Pharmacodynamic Models","text":"Model Type Parameters Description <code>DirectEmax</code> E0, Emax, EC50 Direct effect model <code>SigmoidEmax</code> E0, Emax, EC50, gamma Hill equation <code>BiophaseEquilibration</code> ke0, E0, Emax, EC50 Effect compartment <code>IndirectResponseTurnover</code> Kin, Kout, R0, Imax, IC50 Indirect response"},{"location":"julia/#key-functions","title":"Key Functions","text":""},{"location":"julia/#simulation","title":"Simulation","text":"<pre><code># Single subject simulation\nresult = simulate(spec::ModelSpec, grid::SimGrid, solver::SolverSpec)\n\n# Population simulation\nresult = simulate_population(pop_spec::PopulationSpec, grid, solver)\n</code></pre>"},{"location":"julia/#parameter-estimation","title":"Parameter Estimation","text":"<pre><code># FOCE-I estimation\nresult = estimate(data, spec, FOCEConfig())\n\n# SAEM estimation\nresult = estimate(data, spec, SAEMConfig())\n</code></pre>"},{"location":"julia/#nca","title":"NCA","text":"<pre><code># Non-compartmental analysis\nresult = run_nca(times, conc, dose; config=NCAConfig())\n</code></pre>"},{"location":"julia/#vpc","title":"VPC","text":"<pre><code># Visual predictive check\nvpc_result = compute_vpc(observed, simulated; config=VPCConfig())\n</code></pre>"},{"location":"julia/#next-steps","title":"Next Steps","text":"<ul> <li>Start the Tutorial \u2192</li> <li>Explore PK Models \u2192</li> <li>Learn Population Modeling \u2192</li> </ul>"},{"location":"julia/tutorial/","title":"Tutorial: Getting Started with Julia","text":"<p>This tutorial provides a comprehensive introduction to using OpenPKPD with Julia. By the end, you'll be able to run simulations, analyze populations, and perform parameter estimation.</p>"},{"location":"julia/tutorial/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have:</p> <ul> <li>Julia 1.10 or later installed</li> <li>OpenPKPD repository cloned</li> <li>Julia dependencies installed</li> </ul> <pre><code>julia --project=core/OpenPKPDCore -e 'using Pkg; Pkg.instantiate()'\n</code></pre>"},{"location":"julia/tutorial/#part-1-your-first-simulation","title":"Part 1: Your First Simulation","text":""},{"location":"julia/tutorial/#loading-the-package","title":"Loading the Package","text":"<pre><code># Start Julia with the project\n# julia --project=core/OpenPKPDCore\n\nusing OpenPKPDCore\n</code></pre>"},{"location":"julia/tutorial/#one-compartment-iv-bolus","title":"One-Compartment IV Bolus","text":"<p>The simplest PK model: a single compartment with first-order elimination.</p> <pre><code># Define parameters\n# CL = 5 L/h (clearance)\n# V = 50 L (volume of distribution)\nparams = OneCompIVBolusParams(5.0, 50.0)\n\n# Define a single 100 mg dose at time 0\ndoses = [DoseEvent(0.0, 100.0)]\n\n# Create model specification\nspec = ModelSpec(\n    OneCompIVBolus(),      # Model type\n    \"tutorial_sim\",        # Simulation name\n    params,                # Parameters\n    doses                  # Dose events\n)\n\n# Define time grid: 0 to 24 hours, output every hour\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\n\n# Configure ODE solver\n# Tsit5 is the default 5th order Runge-Kutta\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Access results\nprintln(\"Time points: \", length(result.t))\nprintln(\"First 5 concentrations: \", result.observations[:conc][1:5])\n</code></pre> <p>Expected output: <pre><code>Time points: 25\nFirst 5 concentrations: [2.0, 1.8097..., 1.6375..., 1.4816..., 1.3406...]\n</code></pre></p>"},{"location":"julia/tutorial/#understanding-the-result","title":"Understanding the Result","text":"<pre><code># The SimResult contains:\n# - t: Time points\n# - states: Internal ODE state variables\n# - observations: Derived quantities (concentrations, effects)\n# - metadata: Additional information\n\n# Time points\nresult.t  # [0.0, 1.0, 2.0, ..., 24.0]\n\n# Concentrations (primary observation)\nresult.observations[:conc]  # [2.0, 1.81, 1.64, ...]\n\n# State variables (amount in central compartment)\nresult.states[:A_central]  # [100.0, 90.5, 81.9, ...]\n</code></pre>"},{"location":"julia/tutorial/#pk-metrics","title":"PK Metrics","text":"<pre><code># Calculate half-life\nt_half = log(2) * params.V / params.CL\nprintln(\"Half-life: \", t_half, \" hours\")\n\n# Find Cmax (for IV bolus, it's at t=0)\ncmax = maximum(result.observations[:conc])\nprintln(\"Cmax: \", cmax, \" mg/L\")\n\n# Calculate AUC using trapezoidal rule\nfunction auc_trap(t, c)\n    auc = 0.0\n    for i in 2:length(t)\n        auc += (t[i] - t[i-1]) * (c[i] + c[i-1]) / 2\n    end\n    return auc\nend\n\nauc = auc_trap(result.t, result.observations[:conc])\nprintln(\"AUC0-24: \", auc, \" mg\u00b7h/L\")\n</code></pre>"},{"location":"julia/tutorial/#part-2-multiple-doses","title":"Part 2: Multiple Doses","text":""},{"location":"julia/tutorial/#repeated-dosing","title":"Repeated Dosing","text":"<pre><code># Multiple doses: 100 mg every 12 hours for 3 days\ndoses = [\n    DoseEvent(0.0, 100.0),\n    DoseEvent(12.0, 100.0),\n    DoseEvent(24.0, 100.0),\n    DoseEvent(36.0, 100.0),\n    DoseEvent(48.0, 100.0),\n    DoseEvent(60.0, 100.0),\n]\n\nspec = ModelSpec(OneCompIVBolus(), \"multiple_dose\", params, doses)\n\n# Extend simulation to 72 hours\ngrid = SimGrid(0.0, 72.0, collect(0.0:0.5:72.0))\n\nresult = simulate(spec, grid, solver)\n\n# Find steady-state trough\n# Trough is just before the next dose\ntrough_times = [11.5, 23.5, 35.5, 47.5, 59.5, 71.5]\nfor t in trough_times\n    idx = findfirst(x -&gt; x \u2248 t, result.t)\n    if idx !== nothing\n        println(\"Trough at t=$(t): $(result.observations[:conc][idx]) mg/L\")\n    end\nend\n</code></pre>"},{"location":"julia/tutorial/#iv-infusion","title":"IV Infusion","text":"<pre><code># 100 mg infused over 1 hour\ndoses = [DoseEvent(0.0, 100.0, 1.0)]  # duration = 1.0 hour\n\nspec = ModelSpec(OneCompIVBolus(), \"infusion\", params, doses)\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\n\nresult = simulate(spec, grid, solver)\n\n# Cmax occurs at end of infusion\nidx_end_infusion = findfirst(x -&gt; x \u2248 1.0, result.t)\nprintln(\"Cmax at end of infusion: \", result.observations[:conc][idx_end_infusion])\n</code></pre>"},{"location":"julia/tutorial/#part-3-two-compartment-model","title":"Part 3: Two-Compartment Model","text":""},{"location":"julia/tutorial/#bi-exponential-kinetics","title":"Bi-Exponential Kinetics","text":"<pre><code># Two-compartment model\n# CL = 10 L/h, V1 = 20 L (central)\n# Q = 15 L/h (inter-compartmental clearance)\n# V2 = 50 L (peripheral)\nparams = TwoCompIVBolusParams(10.0, 20.0, 15.0, 50.0)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(TwoCompIVBolus(), \"twocomp\", params, doses)\n\n# Dense output to see distribution phase\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.1:48.0))\n\nresult = simulate(spec, grid, solver)\n\n# You'll see bi-exponential decline:\n# - Fast initial decline (distribution phase, \u03b1)\n# - Slower terminal decline (elimination phase, \u03b2)\nprintln(\"C at t=0.5h: \", result.observations[:conc][6])   # During distribution\nprintln(\"C at t=24h: \", result.observations[:conc][241])  # Terminal phase\n</code></pre>"},{"location":"julia/tutorial/#accessing-both-compartments","title":"Accessing Both Compartments","text":"<pre><code># Central compartment amount\nA_central = result.states[:A_central]\n\n# Peripheral compartment amount\nA_peripheral = result.states[:A_peripheral]\n\n# Verify mass balance\ntotal_amount_t0 = A_central[1] + A_peripheral[1]\nprintln(\"Total amount at t=0: \", total_amount_t0, \" mg\")\n</code></pre>"},{"location":"julia/tutorial/#part-4-oral-absorption","title":"Part 4: Oral Absorption","text":""},{"location":"julia/tutorial/#first-order-absorption","title":"First-Order Absorption","text":"<pre><code># One-compartment oral\n# Ka = 1.5 /h, CL = 5 L/h, V = 50 L\nparams = OneCompOralFirstOrderParams(1.5, 5.0, 50.0)\n\ndoses = [DoseEvent(0.0, 200.0)]  # Oral dose of 200 mg\nspec = ModelSpec(OneCompOralFirstOrder(), \"oral\", params, doses)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\n\nresult = simulate(spec, grid, solver)\n\n# Find Tmax and Cmax\ncmax, idx_cmax = findmax(result.observations[:conc])\ntmax = result.t[idx_cmax]\n\nprintln(\"Tmax: \", tmax, \" hours\")\nprintln(\"Cmax: \", cmax, \" mg/L\")\n</code></pre>"},{"location":"julia/tutorial/#transit-compartment-absorption","title":"Transit Compartment Absorption","text":"<p>For drugs with complex absorption (delayed peak, GI transit):</p> <pre><code># Transit absorption model\n# 5 transit compartments, Ktr = 0.5/h, Ka = 2.0/h\n# CL = 10 L/h, V = 70 L\nparams = TransitAbsorptionParams(5, 0.5, 2.0, 10.0, 70.0)\n\ndoses = [DoseEvent(0.0, 300.0)]\nspec = ModelSpec(TransitAbsorption(), \"transit\", params, doses)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.1:24.0))\n\nresult = simulate(spec, grid, solver)\n\n# Delayed Tmax due to transit compartments\ncmax, idx_cmax = findmax(result.observations[:conc])\nprintln(\"Tmax: \", result.t[idx_cmax], \" hours\")  # Will be later than simple oral\n</code></pre>"},{"location":"julia/tutorial/#part-5-pk-pd-modeling","title":"Part 5: PK-PD Modeling","text":""},{"location":"julia/tutorial/#direct-emax-model","title":"Direct Emax Model","text":"<pre><code># Direct Emax: effect is immediate function of concentration\n# PK: CL = 5, V = 50\n# PD: E0 = 0 (baseline), Emax = 100, EC50 = 2 mg/L\n\npk_params = OneCompIVBolusParams(5.0, 50.0)\npd_params = DirectEmaxParams(0.0, 100.0, 2.0)\n\n# Combined PKPD parameters\nparams = PKPDDirectEmaxParams(pk_params, pd_params)\n\ndoses = [DoseEvent(0.0, 100.0)]\nspec = ModelSpec(DirectEmax(), \"pkpd\", params, doses)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\n\nresult = simulate(spec, grid, solver)\n\n# Both concentration and effect are available\nprintln(\"Concentration: \", result.observations[:conc][1:5])\nprintln(\"Effect: \", result.observations[:effect][1:5])\n</code></pre>"},{"location":"julia/tutorial/#indirect-response-model","title":"Indirect Response Model","text":"<pre><code># Indirect response (inhibition of Kout)\n# Kin = 10, Kout = 0.5, baseline R0 = 20\n# Imax = 0.8, IC50 = 1.0 mg/L\n\npk_params = OneCompIVBolusParams(5.0, 50.0)\npd_params = IndirectResponseTurnoverParams(10.0, 0.5, 20.0, 0.8, 1.0)\n\nparams = PKPDIndirectResponseParams(pk_params, pd_params)\n\ndoses = [DoseEvent(0.0, 100.0)]\nspec = ModelSpec(IndirectResponseTurnover(), \"indirect\", params, doses)\n\ngrid = SimGrid(0.0, 72.0, collect(0.0:1.0:72.0))\n\nresult = simulate(spec, grid, solver)\n\n# Response changes slowly (indirect mechanism)\nprintln(\"Baseline response: \", result.observations[:response][1])\nprintln(\"Response at 24h: \", result.observations[:response][25])\nprintln(\"Response at 72h: \", result.observations[:response][73])\n</code></pre>"},{"location":"julia/tutorial/#part-6-population-simulation","title":"Part 6: Population Simulation","text":""},{"location":"julia/tutorial/#inter-individual-variability-iiv","title":"Inter-Individual Variability (IIV)","text":"<pre><code># Define typical parameters\ntypical_params = OneCompIVBolusParams(5.0, 50.0)\n\n# Define omega matrix (variance of log-normal random effects)\n# 30% CV on CL, 20% CV on V\n# CV = sqrt(exp(omega^2) - 1) \u2248 omega for small omega\nomega = OmegaMatrix([\n    0.09 0.0;   # omega_CL^2 = 0.09 -&gt; ~30% CV\n    0.0  0.04   # omega_V^2 = 0.04 -&gt; ~20% CV\n])\n\n# Create population specification\ndoses = [DoseEvent(0.0, 100.0)]\nbase_spec = ModelSpec(OneCompIVBolus(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    100,           # 100 individuals\n    omega,\n    12345          # seed for reproducibility\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\n\n# Simulate population\npop_result = simulate_population(pop_spec, grid, solver)\n\n# Access individual results\nfor i in 1:5\n    cmax = maximum(pop_result.individuals[i].observations[:conc])\n    println(\"Individual $i Cmax: $(round(cmax, digits=2)) mg/L\")\nend\n\n# Population summary statistics\nsummary = pop_result.summaries[:conc]\nprintln(\"\\nPopulation median: \", summary.median)\nprintln(\"5th percentile: \", summary.quantiles[0.05])\nprintln(\"95th percentile: \", summary.quantiles[0.95])\n</code></pre>"},{"location":"julia/tutorial/#with-covariates","title":"With Covariates","text":"<pre><code># Weight-based dosing with allometric scaling\n# CL = 5 * (WT/70)^0.75\n# V = 50 * (WT/70)^1.0\n\n# Define covariate model\ncovariate_model = CovariateModel([\n    CovariateEffect(:CL, :WT, 70.0, :power, 0.75),\n    CovariateEffect(:V, :WT, 70.0, :power, 1.0)\n])\n\n# Generate subjects with varying weights\nusing Random\nRandom.seed!(42)\nn_subjects = 50\nweights = 50.0 .+ 40.0 .* rand(n_subjects)  # 50-90 kg\n\ncovariates = [Dict(:WT =&gt; w) for w in weights]\n\n# Population with covariates\npop_spec = PopulationSpec(\n    base_spec,\n    n_subjects,\n    omega,\n    12345,\n    covariate_model,\n    covariates\n)\n\npop_result = simulate_population(pop_spec, grid, solver)\n\n# Show effect of weight on CL\nfor i in 1:5\n    wt = covariates[i][:WT]\n    cl = pop_result.realized_params[i][:CL]\n    println(\"Subject $i: WT=$(round(wt, digits=1)) kg, CL=$(round(cl, digits=2)) L/h\")\nend\n</code></pre>"},{"location":"julia/tutorial/#part-7-non-compartmental-analysis","title":"Part 7: Non-Compartmental Analysis","text":""},{"location":"julia/tutorial/#basic-nca","title":"Basic NCA","text":"<pre><code># Run NCA on simulation result\ntimes = result.t\nconc = result.observations[:conc]\ndose = 100.0\n\nnca_result = run_nca(times, conc, dose)\n\nprintln(\"Cmax: \", nca_result.cmax)\nprintln(\"Tmax: \", nca_result.tmax)\nprintln(\"AUC0-t: \", nca_result.auc_0_t)\nprintln(\"AUC0-inf: \", nca_result.auc_0_inf)\nprintln(\"Half-life: \", nca_result.t_half)\nprintln(\"CL/F: \", nca_result.cl_f)\nprintln(\"Vz/F: \", nca_result.vz_f)\n</code></pre>"},{"location":"julia/tutorial/#nca-configuration","title":"NCA Configuration","text":"<pre><code>config = NCAConfig(\n    method = :log_linear,           # AUC calculation method\n    lambda_z_min_points = 3,        # Minimum points for lambda_z\n    lambda_z_r2_threshold = 0.9,    # R\u00b2 threshold\n    extrapolation_max_pct = 20.0,   # Warning threshold\n    blq_handling = :zero            # BLQ handling\n)\n\nnca_result = run_nca(times, conc, dose; config=config)\n</code></pre>"},{"location":"julia/tutorial/#part-8-artifacts-and-reproducibility","title":"Part 8: Artifacts and Reproducibility","text":""},{"location":"julia/tutorial/#writing-artifacts","title":"Writing Artifacts","text":"<pre><code># Save simulation as artifact\nartifact = write_artifact(\"simulation.json\", spec, grid, solver, result)\n\nprintln(\"Artifact saved with version: \", artifact.schema_version)\n</code></pre>"},{"location":"julia/tutorial/#replaying-artifacts","title":"Replaying Artifacts","text":"<pre><code># Load and replay artifact\nreplayed = replay_artifact(\"simulation.json\")\n\n# Verify results match\n@assert replayed.observations[:conc] == result.observations[:conc]\nprintln(\"Replay successful - results match!\")\n</code></pre>"},{"location":"julia/tutorial/#summary","title":"Summary","text":"<p>In this tutorial, you learned:</p> <ol> <li>Basic Simulation: <code>ModelSpec</code>, <code>SimGrid</code>, <code>SolverSpec</code>, <code>simulate()</code></li> <li>Multiple Doses: Using <code>DoseEvent</code> arrays, IV infusions</li> <li>Multi-Compartment Models: Two-compartment, three-compartment</li> <li>Oral Absorption: First-order and transit compartment</li> <li>PK-PD: Direct Emax and indirect response models</li> <li>Population Simulation: IIV with omega matrix, covariates</li> <li>NCA: Exposure metrics and configuration</li> <li>Reproducibility: Artifacts and replay</li> </ol>"},{"location":"julia/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>PK Models Reference - Detailed model documentation</li> <li>PD Models Reference - Pharmacodynamic models</li> <li>Population Modeling - Advanced IIV/IOV/covariates</li> <li>Parameter Estimation - FOCE-I, SAEM, Laplacian</li> </ul>"},{"location":"julia/estimation/","title":"Parameter Estimation","text":"<p>OpenPKPD provides nonlinear mixed-effects (NLME) estimation methods for fitting population PK/PD models to observed data.</p>"},{"location":"julia/estimation/#overview","title":"Overview","text":"<p>Parameter estimation determines the typical parameter values (\u03b8), random effect variances (\u03a9), and residual error (\u03a3) that best describe observed data.</p> <pre><code>graph LR\n    A[Observed Data] --&gt; B[Estimation Algorithm]\n    C[Model Structure] --&gt; B\n    D[Initial Estimates] --&gt; B\n    B --&gt; E[\u03b8: Fixed Effects]\n    B --&gt; F[\u03a9: Random Effects]\n    B --&gt; G[\u03a3: Residual Error]\n    B --&gt; H[\u03b7: Individual Effects]\n</code></pre>"},{"location":"julia/estimation/#estimation-methods","title":"Estimation Methods","text":"<ul> <li> <p> FOCE-I</p> <p>First-Order Conditional Estimation with Interaction</p> <p> FOCE-I</p> </li> <li> <p> SAEM</p> <p>Stochastic Approximation EM Algorithm</p> <p> SAEM</p> </li> <li> <p> Laplacian</p> <p>Laplace Approximation for Sparse Data</p> <p> Laplacian</p> </li> <li> <p> Diagnostics</p> <p>Model fit assessment and validation</p> <p> Diagnostics</p> </li> <li> <p> Model Comparison</p> <p>AIC, BIC, likelihood ratio tests</p> <p> Comparison</p> </li> </ul>"},{"location":"julia/estimation/#quick-start","title":"Quick Start","text":""},{"location":"julia/estimation/#foce-i-estimation","title":"FOCE-I Estimation","text":"<pre><code>using OpenPKPDCore\n\n# Prepare observed data\ndata = EstimationData(\n    ids = [1, 1, 1, 2, 2, 2, 3, 3, 3],\n    times = [0.5, 2.0, 8.0, 0.5, 2.0, 8.0, 0.5, 2.0, 8.0],\n    dv = [1.8, 1.2, 0.4, 2.1, 1.4, 0.5, 1.5, 1.0, 0.3],\n    doses = [\n        DoseEvent(0.0, 100.0),\n        DoseEvent(0.0, 100.0),\n        DoseEvent(0.0, 100.0)\n    ],\n    dose_ids = [1, 1, 1, 2, 2, 2, 3, 3, 3]\n)\n\n# Model specification\nmodel = OneCompIVBolus()\n\n# Initial parameter estimates\ninit = InitialEstimates(\n    theta = [5.0, 50.0],          # CL, V\n    omega = [0.09, 0.04],         # \u03c9\u00b2_CL, \u03c9\u00b2_V\n    sigma = [0.01]                 # \u03c3\u00b2 (proportional)\n)\n\n# Configure FOCE\nconfig = FOCEConfig(\n    max_iterations = 1000,\n    tolerance = 1e-6,\n    compute_se = true\n)\n\n# Run estimation\nresult = estimate(data, model, init, config)\n\n# Access results\nprintln(\"\u03b8 (CL, V): \", result.theta)\nprintln(\"SE: \", result.theta_se)\nprintln(\"\u03c9\u00b2: \", result.omega)\nprintln(\"\u03c3\u00b2: \", result.sigma)\nprintln(\"OFV: \", result.ofv)\n</code></pre>"},{"location":"julia/estimation/#saem-estimation","title":"SAEM Estimation","text":"<pre><code>config = SAEMConfig(\n    n_iterations = 500,\n    n_burn_in = 100,\n    n_chains = 3,\n    step_size = 0.7\n)\n\nresult = estimate(data, model, init, config)\n</code></pre>"},{"location":"julia/estimation/#method-comparison","title":"Method Comparison","text":"Feature FOCE-I SAEM Laplacian Speed Fast Moderate Fast Robustness Good Excellent Good Sparse Data Fair Good Excellent Complex Models Fair Excellent Good Standard Errors Analytical Bootstrap Analytical Local Minima Risk Low Risk Risk"},{"location":"julia/estimation/#when-to-use-each-method","title":"When to Use Each Method","text":"<p>FOCE-I: Default choice for most problems - Well-behaved data - Standard PK models - Need analytical SE</p> <p>SAEM: Complex or problematic datasets - Highly nonlinear models - Multimodal likelihood - Many random effects</p> <p>Laplacian: Sparse sampling - Few observations per subject - Time-to-event data - Categorical outcomes</p>"},{"location":"julia/estimation/#estimation-result-structure","title":"Estimation Result Structure","text":"<pre><code>struct EstimationResult\n    # Parameter estimates\n    theta::Vector{Float64}          # Fixed effects\n    theta_se::Vector{Float64}       # Standard errors\n    theta_rse::Vector{Float64}      # Relative SE (%)\n    theta_ci::Matrix{Float64}       # 95% CI\n\n    # Random effects\n    omega::Matrix{Float64}          # Variance-covariance\n    omega_se::Matrix{Float64}\n\n    # Residual error\n    sigma::Vector{Float64}\n    sigma_se::Vector{Float64}\n\n    # Individual estimates\n    etas::Matrix{Float64}           # EBEs (n \u00d7 p)\n    ipred::Vector{Float64}          # Individual predictions\n\n    # Diagnostics\n    ofv::Float64                    # Objective function value\n    aic::Float64                    # Akaike Information Criterion\n    bic::Float64                    # Bayesian IC\n\n    # Convergence\n    converged::Bool\n    n_iterations::Int\n    gradient::Vector{Float64}\n\n    # Metadata\n    method::Symbol\n    runtime::Float64\nend\n</code></pre>"},{"location":"julia/estimation/#model-diagnostics","title":"Model Diagnostics","text":""},{"location":"julia/estimation/#goodness-of-fit","title":"Goodness of Fit","text":"<pre><code># Predictions\npred = result.pred       # Population predictions\nipred = result.ipred     # Individual predictions\n\n# Residuals\ncwres = result.cwres     # Conditional weighted residuals\niwres = result.iwres     # Individual weighted residuals\nnpde = result.npde       # Normalized prediction distribution errors\n</code></pre>"},{"location":"julia/estimation/#shrinkage","title":"Shrinkage","text":"<p>Eta shrinkage indicates information content:</p> \\[\\text{Shrinkage}_\\eta = 1 - \\frac{SD(\\hat{\\eta})}{SD(\\eta)}\\] <pre><code>shrinkage = compute_shrinkage(result)\nprintln(\"CL shrinkage: \", shrinkage[1] * 100, \"%\")\nprintln(\"V shrinkage: \", shrinkage[2] * 100, \"%\")\n</code></pre> <p>High shrinkage (&gt;30%) suggests limited information for individual parameters.</p>"},{"location":"julia/estimation/#objective-function","title":"Objective Function","text":"<p>The FOCE-I objective function:</p> \\[OFV = \\sum_i \\left[ \\ln|C_i| + (y_i - f_i)^T C_i^{-1} (y_i - f_i) \\right]\\] <p>Where: - \\(C_i\\) = Individual covariance matrix - \\(y_i\\) = Observations - \\(f_i\\) = Model predictions</p>"},{"location":"julia/estimation/#next-steps","title":"Next Steps","text":"<ul> <li>FOCE-I Details - Deep dive into FOCE algorithm</li> <li>SAEM Details - Stochastic approximation</li> <li>Diagnostics - Model validation</li> <li>Model Comparison - AIC, BIC, LRT</li> </ul>"},{"location":"julia/estimation/bootstrap/","title":"Bootstrap Analysis","text":"<p>Industry-standard bootstrap methods for parameter uncertainty estimation, supporting regulatory submissions (FDA/EMA).</p>"},{"location":"julia/estimation/bootstrap/#overview","title":"Overview","text":"<p>Bootstrap analysis provides non-parametric estimates of parameter uncertainty by resampling the data and re-estimating parameters multiple times.</p>"},{"location":"julia/estimation/bootstrap/#key-features","title":"Key Features","text":"<ul> <li>Case bootstrap: Standard FDA/EMA-recommended approach</li> <li>Parametric bootstrap: Simulate from fitted model</li> <li>Residual bootstrap: Preserve covariate structure</li> <li>Stratified resampling: By study, dose, formulation</li> <li>Multiple CI methods: Percentile, BCa, Basic</li> <li>Parallel execution: Multi-threaded for large studies</li> <li>Regulatory output: Formatted tables for submissions</li> </ul>"},{"location":"julia/estimation/bootstrap/#bootstrap-types","title":"Bootstrap Types","text":""},{"location":"julia/estimation/bootstrap/#case-bootstrap-non-parametric","title":"Case Bootstrap (Non-Parametric)","text":"<p>Resample subjects with replacement - the gold standard for regulatory submissions:</p> <pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# After initial estimation\nresult = foce_estimate(observed, model_spec, config, grid, solver, rng)\n\n# Configure bootstrap\nbootstrap_spec = BootstrapSpec(\n    n_bootstrap = 1000,           # FDA recommends \u2265500\n    bootstrap_type = CaseBootstrap(),\n    seed = 12345,\n    parallel = true,\n    ci_level = 0.95,\n    ci_method = PercentileCI()\n)\n\n# Run bootstrap\nbootstrap_result = run_bootstrap(\n    observed,\n    model_spec,\n    config,\n    grid,\n    solver,\n    result,  # Original estimates as starting point\n    bootstrap_spec\n)\n\n# Access results\nprintln(\"Bootstrap SE: \", bootstrap_result.theta_se)\nprintln(\"Bootstrap 95% CI:\")\nfor i in 1:length(result.theta)\n    println(\"  \u03b8$i: [$(bootstrap_result.theta_ci_lower[i]), $(bootstrap_result.theta_ci_upper[i])]\")\nend\n</code></pre>"},{"location":"julia/estimation/bootstrap/#parametric-bootstrap","title":"Parametric Bootstrap","text":"<p>Simulate new data from the fitted model:</p> <pre><code>bootstrap_spec = BootstrapSpec(\n    n_bootstrap = 500,\n    bootstrap_type = ParametricBootstrap(\n        n_simulations_per_subject = 1\n    ),\n    seed = 12345\n)\n</code></pre> <p>Parametric bootstrap is useful when: - Small sample size - Want to assess model adequacy - Case bootstrap has high failure rate</p>"},{"location":"julia/estimation/bootstrap/#residual-bootstrap","title":"Residual Bootstrap","text":"<p>Resample residuals and add to predictions:</p> <pre><code>bootstrap_spec = BootstrapSpec(\n    n_bootstrap = 500,\n    bootstrap_type = ResidualBootstrap(\n        standardize = true  # Standardize residuals before resampling\n    ),\n    seed = 12345\n)\n</code></pre> <p>Residual bootstrap preserves: - Original covariate structure - Observation times - Dosing patterns</p>"},{"location":"julia/estimation/bootstrap/#stratified-resampling","title":"Stratified Resampling","text":"<p>Maintain proportions within strata when resampling:</p> <pre><code># Stratify by study and formulation\nbootstrap_spec = BootstrapSpec(\n    n_bootstrap = 1000,\n    bootstrap_type = CaseBootstrap(),\n    stratify_by = [:study, :formulation],  # Stratification variables\n    seed = 12345\n)\n</code></pre> <p>Stratification is important for: - Pooled analyses across studies - Bioequivalence studies - Different dose groups</p>"},{"location":"julia/estimation/bootstrap/#confidence-interval-methods","title":"Confidence Interval Methods","text":""},{"location":"julia/estimation/bootstrap/#percentile-ci-default","title":"Percentile CI (Default)","text":"<p>Simple percentile method:</p> \\[CI = [\\theta^*_{\\alpha/2}, \\theta^*_{1-\\alpha/2}]\\] <pre><code>bootstrap_spec = BootstrapSpec(\n    ci_method = PercentileCI(),\n    ci_level = 0.95\n)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#bca-bias-corrected-and-accelerated","title":"BCa (Bias-Corrected and Accelerated)","text":"<p>More accurate for skewed distributions:</p> <pre><code>bootstrap_spec = BootstrapSpec(\n    ci_method = BCCI(acceleration = 0.0),  # Computed from jackknife\n    ci_level = 0.95\n)\n</code></pre> <p>BCa adjusts for: - Bias in bootstrap distribution - Skewness (acceleration)</p>"},{"location":"julia/estimation/bootstrap/#basic-bootstrap-ci","title":"Basic Bootstrap CI","text":"<p>Also known as reverse percentile:</p> \\[CI = [2\\hat{\\theta} - \\theta^*_{1-\\alpha/2}, 2\\hat{\\theta} - \\theta^*_{\\alpha/2}]\\] <pre><code>bootstrap_spec = BootstrapSpec(\n    ci_method = BasicCI(),\n    ci_level = 0.95\n)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#bootstrapspec-configuration","title":"BootstrapSpec Configuration","text":""},{"location":"julia/estimation/bootstrap/#all-parameters","title":"All Parameters","text":"<pre><code>BootstrapSpec(;\n    # Number of replicates\n    n_bootstrap = 1000,              # FDA recommends \u2265500\n\n    # Bootstrap type\n    bootstrap_type = CaseBootstrap(), # CaseBootstrap, ParametricBootstrap, ResidualBootstrap\n\n    # Stratification\n    stratify_by = Symbol[],          # Variables to stratify by\n\n    # Reproducibility\n    seed = 12345,\n\n    # Execution\n    parallel = true,                 # Use multiple threads\n\n    # Confidence intervals\n    ci_level = 0.95,                 # 95% CI\n    ci_method = PercentileCI(),      # PercentileCI, BCCI, BasicCI\n\n    # What to compute\n    compute_omega_ci = true,         # CI for random effects\n    compute_sigma_ci = true,         # CI for residual error\n\n    # Quality control\n    min_success_rate = 0.8           # Minimum successful runs (80%)\n)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#bootstrap-results","title":"Bootstrap Results","text":""},{"location":"julia/estimation/bootstrap/#bootstrapresult-structure","title":"BootstrapResult Structure","text":"<pre><code>struct BootstrapResult\n    # Fixed effects\n    theta_estimates::Matrix{Float64}   # All bootstrap estimates (n_boot \u00d7 n_theta)\n    theta_mean::Vector{Float64}        # Mean of bootstrap estimates\n    theta_se::Vector{Float64}          # Bootstrap standard error\n    theta_rse::Vector{Float64}         # Relative SE (%)\n    theta_ci_lower::Vector{Float64}    # Lower CI bound\n    theta_ci_upper::Vector{Float64}    # Upper CI bound\n\n    # Bias correction\n    original_estimate::Vector{Float64} # Original point estimate\n    bias::Vector{Float64}              # Bootstrap bias\n    bias_corrected::Vector{Float64}    # Bias-corrected estimate\n\n    # Random effects\n    omega_summary::OmegaBootstrapSummary\n    sigma_summary::SigmaBootstrapSummary\n\n    # Shrinkage distribution\n    eta_shrinkage::Matrix{Float64}     # Shrinkage per replicate\n\n    # Diagnostics\n    diagnostics::BootstrapDiagnostics\n\n    # CI info\n    ci_level::Float64\n    ci_method::String\nend\n</code></pre>"},{"location":"julia/estimation/bootstrap/#accessing-results","title":"Accessing Results","text":"<pre><code>result = run_bootstrap(...)\n\n# Fixed effects\nprintln(\"Theta estimates: \", result.theta_mean)\nprintln(\"Standard errors: \", result.theta_se)\nprintln(\"RSE%: \", result.theta_rse)\n\n# CIs\nfor i in 1:length(result.theta_mean)\n    println(\"\u03b8$i: $(result.theta_mean[i]) [$(result.theta_ci_lower[i]), $(result.theta_ci_upper[i])]\")\nend\n\n# Bias\nprintln(\"Bias: \", result.bias)\nprintln(\"Bias-corrected: \", result.bias_corrected)\n\n# Random effects\nprintln(\"Omega SE: \", result.omega_summary.se)\nprintln(\"Sigma SE: \", result.sigma_summary.se)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#bootstrap-diagnostics","title":"Bootstrap Diagnostics","text":""},{"location":"julia/estimation/bootstrap/#bootstrapdiagnostics-structure","title":"BootstrapDiagnostics Structure","text":"<pre><code>struct BootstrapDiagnostics\n    n_successful::Int               # Successful runs\n    n_failed::Int                   # Failed runs\n    convergence_rate::Float64       # Success rate (FDA requires \u226580%)\n    median_iterations::Float64      # Median iterations to converge\n    outlier_indices::Vector{Int}    # Potential outlier estimates\n    failure_reasons::Dict{Symbol, Int}  # Why runs failed\n    rse_stability::Vector{Float64}  # RSE of SE estimate\nend\n</code></pre>"},{"location":"julia/estimation/bootstrap/#checking-bootstrap-quality","title":"Checking Bootstrap Quality","text":"<pre><code>diag = result.diagnostics\n\nprintln(\"Successful runs: $(diag.n_successful)/$(diag.n_successful + diag.n_failed)\")\nprintln(\"Success rate: $(diag.convergence_rate * 100)%\")\n\n# FDA requires \u226580% success rate\nif diag.convergence_rate &lt; 0.8\n    println(\"WARNING: Success rate below FDA threshold\")\nend\n\n# Check for outliers\nif !isempty(diag.outlier_indices)\n    println(\"Outlier estimates at indices: \", diag.outlier_indices)\nend\n\n# Failure reasons\nfor (reason, count) in diag.failure_reasons\n    println(\"  $reason: $count failures\")\nend\n</code></pre>"},{"location":"julia/estimation/bootstrap/#parallel-execution","title":"Parallel Execution","text":""},{"location":"julia/estimation/bootstrap/#using-thread-pool","title":"Using Thread Pool","text":"<pre><code>using Base.Threads\nprintln(\"Available threads: \", nthreads())\n\nbootstrap_spec = BootstrapSpec(\n    n_bootstrap = 1000,\n    parallel = true,  # Uses all available threads\n    seed = 12345\n)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#advanced-parallel-config","title":"Advanced Parallel Config","text":"<pre><code>parallel_config = ParallelConfig(\n    ThreadedBackend(8),      # Use 8 threads\n    seed = 12345,\n    load_balance = true,     # Dynamic load balancing\n    progress = true          # Show progress\n)\n\nbootstrap_spec = BootstrapSpec(\n    n_bootstrap = 1000,\n    parallel = parallel_config\n)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#regulatory-output","title":"Regulatory Output","text":""},{"location":"julia/estimation/bootstrap/#generate-formatted-table","title":"Generate Formatted Table","text":"<pre><code># Generate regulatory-compliant summary table\nsummary_table = generate_bootstrap_summary(result)\n\nprintln(summary_table)\n# Output:\n# Parameter  Estimate    SE      RSE%    95% CI\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n# CL         10.5       0.82    7.8%    [8.9, 12.1]\n# V          52.3       3.41    6.5%    [45.6, 59.2]\n# ...\n</code></pre>"},{"location":"julia/estimation/bootstrap/#export-for-regulatory-submission","title":"Export for Regulatory Submission","text":"<pre><code># Format as regulatory table\nreg_table = format_regulatory_table(result;\n    parameter_names = [\"CL (L/h)\", \"V (L)\", \"ka (1/h)\"],\n    ci_level = 0.95,\n    decimal_places = 3\n)\n\n# Save to file\nwrite(\"bootstrap_table.txt\", reg_table)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#influential-subject-analysis","title":"Influential Subject Analysis","text":""},{"location":"julia/estimation/bootstrap/#jackknife-influence","title":"Jackknife Influence","text":"<pre><code># Identify influential subjects\ninfluence_analysis = jackknife_influence(\n    result,\n    observed,\n    model_spec,\n    config,\n    grid,\n    solver\n)\n\n# Subjects that strongly affect estimates\ninfluential = influence_analysis.influential_subjects\nprintln(\"Most influential subjects: \", influential)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#bootstrap-coverage-check","title":"Bootstrap Coverage Check","text":"<pre><code># Validate CI coverage via simulation\ncoverage = compute_bootstrap_coverage(\n    true_theta = [10.0, 50.0],  # True values (if known)\n    bootstrap_results = [result1, result2, ...]  # Multiple runs\n)\n\nprintln(\"Empirical coverage: $(coverage * 100)%\")\n# Should be close to 95% for 95% CI\n</code></pre>"},{"location":"julia/estimation/bootstrap/#example-full-bootstrap-analysis","title":"Example: Full Bootstrap Analysis","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Load and prepare data\nobserved = load_observed_data(\"pk_study.csv\")\n\n# Model specification\nmodel = TwoCompOral()\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# Initial estimation\nfoce_config = EstimationConfig(\n    method = FOCEIMethod(),\n    theta_init = [10.0, 30.0, 5.0, 100.0, 1.5],\n    omega_init = diagm([0.09, 0.04, 0.16, 0.04, 0.25]),\n    sigma_init = ResidualErrorSpec(CombinedError(), CombinedErrorParams(0.1, 0.1), :conc),\n    compute_se = true\n)\n\ngrid = SimGrid(0.0, 72.0, 0:0.5:72)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^7)\n\n# Run initial estimation\nbase_result = foce_estimate(observed, model_spec, foce_config, grid, solver, StableRNG(42))\n\nprintln(\"=== Initial FOCE-I Estimates ===\")\nprintln(\"Theta: \", base_result.theta)\nprintln(\"Asymptotic SE: \", base_result.theta_se)\n\n# Configure bootstrap\nbootstrap_spec = BootstrapSpec(\n    n_bootstrap = 1000,\n    bootstrap_type = CaseBootstrap(),\n    stratify_by = [:study],  # Stratify by study\n    ci_level = 0.95,\n    ci_method = PercentileCI(),\n    parallel = true,\n    min_success_rate = 0.8,\n    seed = 12345\n)\n\n# Run bootstrap (this takes time!)\nprintln(\"\\n=== Running Bootstrap (1000 replicates) ===\")\nboot_result = run_bootstrap(\n    observed, model_spec, foce_config, grid, solver,\n    base_result, bootstrap_spec\n)\n\n# Report results\nprintln(\"\\n=== Bootstrap Results ===\")\nprintln(\"Success rate: $(boot_result.diagnostics.convergence_rate * 100)%\")\n\nparam_names = [\"CL\", \"V1\", \"Q\", \"V2\", \"ka\"]\nprintln(\"\\nParameter Estimates with Bootstrap SE and 95% CI:\")\nprintln(\"-\" ^ 60)\nprintln(\"Parameter   Estimate    SE       RSE%     95% CI\")\nprintln(\"-\" ^ 60)\n\nfor (i, name) in enumerate(param_names)\n    est = round(base_result.theta[i], sigdigits=4)\n    se = round(boot_result.theta_se[i], sigdigits=3)\n    rse = round(boot_result.theta_rse[i], digits=1)\n    ci_lo = round(boot_result.theta_ci_lower[i], sigdigits=4)\n    ci_hi = round(boot_result.theta_ci_upper[i], sigdigits=4)\n    println(\"$name         $est      $se      $rse%    [$ci_lo, $ci_hi]\")\nend\n\n# Compare asymptotic vs bootstrap SE\nprintln(\"\\n=== Asymptotic vs Bootstrap SE ===\")\nfor (i, name) in enumerate(param_names)\n    asymp = round(base_result.theta_se[i], sigdigits=3)\n    boot = round(boot_result.theta_se[i], sigdigits=3)\n    ratio = round(boot / asymp, digits=2)\n    println(\"$name: Asymptotic=$asymp, Bootstrap=$boot, Ratio=$ratio\")\nend\n\n# Check for outliers\nif !isempty(boot_result.diagnostics.outlier_indices)\n    println(\"\\nWARNING: Potential outlier estimates detected\")\nend\n\n# Generate regulatory table\nreg_table = format_regulatory_table(boot_result,\n    parameter_names = [\"CL (L/h)\", \"V1 (L)\", \"Q (L/h)\", \"V2 (L)\", \"ka (1/h)\"]\n)\nprintln(\"\\n=== Regulatory Table ===\")\nprintln(reg_table)\n</code></pre>"},{"location":"julia/estimation/bootstrap/#best-practices","title":"Best Practices","text":""},{"location":"julia/estimation/bootstrap/#sample-size","title":"Sample Size","text":"<ul> <li>FDA recommends n \u2265 500 bootstrap replicates</li> <li>1000 replicates is standard for regulatory submissions</li> <li>For complex models, 2000+ may improve stability</li> </ul>"},{"location":"julia/estimation/bootstrap/#success-rate","title":"Success Rate","text":"<ul> <li>Target \u2265 80% successful runs</li> <li>If &lt; 80%, consider:</li> <li>Simplifying the model</li> <li>Improving initial estimates</li> <li>Using SAEM instead of FOCE</li> </ul>"},{"location":"julia/estimation/bootstrap/#stratification","title":"Stratification","text":"<ul> <li>Always stratify for pooled analyses</li> <li>Match stratification to study design</li> <li>Check strata have sufficient subjects</li> </ul>"},{"location":"julia/estimation/bootstrap/#ci-method-selection","title":"CI Method Selection","text":"Method When to Use Percentile Default, symmetric distributions BCa Skewed parameters (e.g., variance components) Basic Alternative to percentile"},{"location":"julia/estimation/bootstrap/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Primary estimation</li> <li>SAEM Algorithm - Alternative estimation</li> <li>Diagnostics - Model validation</li> <li>Model Comparison - Comparing models</li> </ul>"},{"location":"julia/estimation/comparison/","title":"Model Comparison","text":"<p>Tools for comparing nested and non-nested models to select the best-fitting model for your data.</p>"},{"location":"julia/estimation/comparison/#overview","title":"Overview","text":"<p>Model comparison helps answer: - Is the more complex model significantly better? - Which model best balances fit and parsimony? - Should I include this random effect or covariate?</p>"},{"location":"julia/estimation/comparison/#objective-function-value-ofv","title":"Objective Function Value (OFV)","text":"<p>The OFV is -2 \u00d7 log-likelihood:</p> \\[OFV = -2 \\cdot \\ln L(\\theta, \\Omega, \\sigma | y)\\] <p>Lower OFV = better fit (but beware overfitting).</p> <pre><code>result = foce_estimate(...)\nprintln(\"OFV: \", result.ofv)\n</code></pre>"},{"location":"julia/estimation/comparison/#likelihood-ratio-test-lrt","title":"Likelihood Ratio Test (LRT)","text":"<p>For nested models only (reduced model is special case of full model).</p>"},{"location":"julia/estimation/comparison/#mathematical-basis","title":"Mathematical Basis","text":"<p>Test statistic:</p> \\[\\chi^2 = OFV_{reduced} - OFV_{full}\\] <p>Under H\u2080 (reduced model is adequate), this follows \u03c7\u00b2 with df = difference in parameters.</p>"},{"location":"julia/estimation/comparison/#usage","title":"Usage","text":"<pre><code># Estimate both models\nresult_full = foce_estimate(observed, model_full, config_full, grid, solver, rng)\nresult_reduced = foce_estimate(observed, model_reduced, config_reduced, grid, solver, rng)\n\n# Likelihood ratio test\nchi_sq, p_value = likelihood_ratio_test(\n    result_full.ofv,\n    result_reduced.ofv,\n    df = 1  # Number of parameters removed\n)\n\nprintln(\"Chi-squared: $chi_sq\")\nprintln(\"p-value: $p_value\")\n\nif p_value &lt; 0.05\n    println(\"Full model significantly better (p &lt; 0.05)\")\n    println(\"Recommendation: Use full model\")\nelse\n    println(\"No significant improvement with full model\")\n    println(\"Recommendation: Use simpler (reduced) model\")\nend\n</code></pre>"},{"location":"julia/estimation/comparison/#significance-thresholds","title":"Significance Thresholds","text":"\u0394OFV df p-value Decision 3.84 1 0.05 Significant 6.63 1 0.01 Highly significant 10.83 1 0.001 Very highly significant 5.99 2 0.05 Significant 7.81 3 0.05 Significant"},{"location":"julia/estimation/comparison/#common-lrt-applications","title":"Common LRT Applications","text":"<pre><code># Test IIV on CL\n# Full: OMEGA on CL and V\n# Reduced: OMEGA on V only (CL IIV fixed to 0)\nchi_sq, p = likelihood_ratio_test(ofv_full, ofv_reduced, df=1)\n\n# Test covariate effect\n# Full: CL = \u03b8\u2081 \u00d7 (WT/70)^\u03b8\u2082\n# Reduced: CL = \u03b8\u2081 (no weight effect)\nchi_sq, p = likelihood_ratio_test(ofv_full, ofv_reduced, df=1)\n\n# Test correlation between etas\n# Full: Block OMEGA (CL, V correlated)\n# Reduced: Diagonal OMEGA (independent)\nchi_sq, p = likelihood_ratio_test(ofv_full, ofv_reduced, df=1)\n</code></pre>"},{"location":"julia/estimation/comparison/#information-criteria","title":"Information Criteria","text":"<p>For both nested and non-nested model comparison.</p>"},{"location":"julia/estimation/comparison/#akaike-information-criterion-aic","title":"Akaike Information Criterion (AIC)","text":"\\[AIC = OFV + 2p\\] <p>Where p = number of estimated parameters.</p> <pre><code>aic = compute_aic(result.ofv, n_params)\nprintln(\"AIC: \", result.aic)\n</code></pre>"},{"location":"julia/estimation/comparison/#bayesian-information-criterion-bic","title":"Bayesian Information Criterion (BIC)","text":"\\[BIC = OFV + p \\cdot \\ln(n)\\] <p>Where n = number of observations.</p> <pre><code>bic = compute_bic(result.ofv, n_params, n_observations)\nprintln(\"BIC: \", result.bic)\n</code></pre>"},{"location":"julia/estimation/comparison/#aic-vs-bic","title":"AIC vs BIC","text":"Criterion Penalty Best For AIC 2 per parameter Prediction BIC ln(n) per parameter Model selection <p>BIC penalizes complexity more heavily, especially for large datasets.</p>"},{"location":"julia/estimation/comparison/#interpretation","title":"Interpretation","text":"\u0394AIC Evidence 0-2 Weak 2-4 Positive 4-7 Strong &gt;10 Very strong <pre><code># Compare models\ndelta_aic = result1.aic - result2.aic\n\nif delta_aic &gt; 10\n    println(\"Strong evidence for Model 2\")\nelseif delta_aic &gt; 4\n    println(\"Good evidence for Model 2\")\nelseif delta_aic &gt; 2\n    println(\"Weak evidence for Model 2\")\nelse\n    println(\"Models are similar - prefer simpler\")\nend\n</code></pre>"},{"location":"julia/estimation/comparison/#model-comparison-table","title":"Model Comparison Table","text":"<pre><code># Compare multiple models\nmodels = [\n    (\"1-comp\", result_1comp),\n    (\"2-comp\", result_2comp),\n    (\"2-comp + CL~WT\", result_2comp_wt)\n]\n\nprintln(\"Model                n_params    OFV        AIC        BIC\")\nprintln(\"-\" ^ 65)\n\nfor (name, result) in models\n    np = count_parameters(result)\n    println(\"$(rpad(name, 20)) $np           $(round(result.ofv, digits=2))     $(round(result.aic, digits=2))     $(round(result.bic, digits=2))\")\nend\n</code></pre>"},{"location":"julia/estimation/comparison/#covariate-model-selection","title":"Covariate Model Selection","text":""},{"location":"julia/estimation/comparison/#forward-selection","title":"Forward Selection","text":"<p>Add covariates one at a time:</p> <pre><code># Start with base model\nbase_ofv = base_result.ofv\ncandidate_covariates = [:WT, :AGE, :SEX, :CRCL]\n\nprintln(\"=== Forward Selection ===\")\nprintln(\"Base OFV: $base_ofv\")\n\nfor cov in candidate_covariates\n    # Fit model with this covariate\n    result_with_cov = estimate_with_covariate(cov)\n    delta_ofv = base_ofv - result_with_cov.ofv\n\n    if delta_ofv &gt; 3.84  # p &lt; 0.05\n        println(\"$cov: \u0394OFV = $delta_ofv, p &lt; 0.05 \u2713\")\n    else\n        println(\"$cov: \u0394OFV = $delta_ofv, NS\")\n    end\nend\n</code></pre>"},{"location":"julia/estimation/comparison/#backward-elimination","title":"Backward Elimination","text":"<p>Remove covariates from full model:</p> <pre><code># Start with full model (all covariates)\nfull_ofv = full_result.ofv\n\nprintln(\"=== Backward Elimination ===\")\nprintln(\"Full OFV: $full_ofv\")\n\nfor cov in included_covariates\n    # Fit model without this covariate\n    result_without_cov = estimate_without_covariate(cov)\n    delta_ofv = result_without_cov.ofv - full_ofv\n\n    if delta_ofv &gt; 6.63  # p &lt; 0.01 (stricter for removal)\n        println(\"$cov: \u0394OFV = $delta_ofv, KEEP (p &lt; 0.01)\")\n    else\n        println(\"$cov: \u0394OFV = $delta_ofv, DROP\")\n    end\nend\n</code></pre>"},{"location":"julia/estimation/comparison/#stepwise-covariate-modeling-scm","title":"Stepwise Covariate Modeling (SCM)","text":"<pre><code># Automated forward-backward procedure\nscm_result = stepwise_covariate_modeling(\n    observed,\n    base_model,\n    candidate_covariates = [:WT, :AGE, :SEX, :CRCL],\n    forward_p = 0.05,      # p-value for inclusion\n    backward_p = 0.01,     # p-value for exclusion\n    max_iterations = 20\n)\n\nprintln(\"Final covariates: \", scm_result.included_covariates)\nprintln(\"Final OFV: \", scm_result.final_ofv)\n</code></pre>"},{"location":"julia/estimation/comparison/#random-effects-selection","title":"Random Effects Selection","text":""},{"location":"julia/estimation/comparison/#test-iiv-on-parameter","title":"Test IIV on Parameter","text":"<pre><code># Should we include IIV on ka?\n\n# Model 1: IIV on CL, V only\nconfig_no_ka_iiv = EstimationConfig(\n    omega_init = diagm([0.09, 0.04]),  # 2 random effects\n    # ...\n)\n\n# Model 2: IIV on CL, V, ka\nconfig_with_ka_iiv = EstimationConfig(\n    omega_init = diagm([0.09, 0.04, 0.25]),  # 3 random effects\n    # ...\n)\n\nresult1 = foce_estimate(..., config_no_ka_iiv, ...)\nresult2 = foce_estimate(..., config_with_ka_iiv, ...)\n\n# Test\nchi_sq, p = likelihood_ratio_test(result2.ofv, result1.ofv, df=1)\nprintln(\"IIV on ka: p = $p\")\n</code></pre>"},{"location":"julia/estimation/comparison/#test-correlation-between-random-effects","title":"Test Correlation Between Random Effects","text":"<pre><code># Should CL and V be correlated?\n\n# Model 1: Diagonal omega\nconfig_diag = EstimationConfig(\n    omega_init = diagm([0.09, 0.04]),\n    omega_structure = :diagonal\n)\n\n# Model 2: Block omega (CL-V correlated)\nconfig_block = EstimationConfig(\n    omega_init = [0.09 0.02; 0.02 0.04],\n    omega_structure = :block\n)\n\nresult_diag = foce_estimate(..., config_diag, ...)\nresult_block = foce_estimate(..., config_block, ...)\n\n# Test (1 df for correlation parameter)\nchi_sq, p = likelihood_ratio_test(result_block.ofv, result_diag.ofv, df=1)\nprintln(\"CL-V correlation: p = $p\")\n\nif p &lt; 0.05\n    corr = result_block.omega[1,2] / sqrt(result_block.omega[1,1] * result_block.omega[2,2])\n    println(\"Estimated correlation: $corr\")\nend\n</code></pre>"},{"location":"julia/estimation/comparison/#residual-error-model-selection","title":"Residual Error Model Selection","text":"<pre><code># Compare additive vs proportional vs combined error\n\n# Additive\nconfig_add = EstimationConfig(\n    sigma_init = ResidualErrorSpec(AdditiveError(), AdditiveErrorParams(0.5), :conc)\n)\n\n# Proportional\nconfig_prop = EstimationConfig(\n    sigma_init = ResidualErrorSpec(ProportionalError(), ProportionalErrorParams(0.1), :conc)\n)\n\n# Combined (2 parameters)\nconfig_comb = EstimationConfig(\n    sigma_init = ResidualErrorSpec(CombinedError(), CombinedErrorParams(0.5, 0.1), :conc)\n)\n\n# Fit all\nresult_add = foce_estimate(..., config_add, ...)\nresult_prop = foce_estimate(..., config_prop, ...)\nresult_comb = foce_estimate(..., config_comb, ...)\n\n# Compare using AIC (non-nested models)\nprintln(\"Error Model    OFV        AIC\")\nprintln(\"-\" ^ 40)\nprintln(\"Additive       $(result_add.ofv)    $(result_add.aic)\")\nprintln(\"Proportional   $(result_prop.ofv)    $(result_prop.aic)\")\nprintln(\"Combined       $(result_comb.ofv)    $(result_comb.aic)\")\n\n# Combined vs Additive (nested)\nchi_sq, p = likelihood_ratio_test(result_comb.ofv, result_add.ofv, df=1)\nprintln(\"\\nCombined vs Additive: p = $p\")\n</code></pre>"},{"location":"julia/estimation/comparison/#model-comparison-functions","title":"Model Comparison Functions","text":""},{"location":"julia/estimation/comparison/#core-functions","title":"Core Functions","text":"<pre><code># Likelihood ratio test\nchi_sq, p_value = likelihood_ratio_test(ofv_full, ofv_reduced, df)\n\n# Information criteria\naic = compute_aic(ofv, n_params)\nbic = compute_bic(ofv, n_params, n_obs)\n\n# Log-likelihood\nll = loglikelihood_from_ofv(ofv)  # Returns -OFV/2\n</code></pre>"},{"location":"julia/estimation/comparison/#parameter-counting","title":"Parameter Counting","text":"<pre><code># Count parameters for information criteria\nn_params = count_parameters(result)\n# Includes: theta + omega parameters + sigma parameters\n\n# Detailed breakdown\nn_theta = length(result.theta)\nn_omega = count_omega_params(result.omega, omega_structure)\nn_sigma = count_sigma_params(result.sigma)\n</code></pre>"},{"location":"julia/estimation/comparison/#example-complete-model-selection","title":"Example: Complete Model Selection","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Data\nobserved = load_observed_data(\"pk_data.csv\")\ngrid = SimGrid(0.0, 72.0, 0:0.5:72)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^7)\nrng = StableRNG(42)\n\n# ============================================\n# Step 1: Structural Model Selection\n# ============================================\nprintln(\"=== Structural Model Selection ===\")\n\n# 1-compartment\nmodel_1c = OneCompIVBolus()\nresult_1c = foce_estimate(observed, ModelSpec(model_1c, \"pk\", nothing, nothing),\n    EstimationConfig(theta_init=[10.0, 50.0], omega_init=diagm([0.09, 0.04]), ...),\n    grid, solver, rng)\n\n# 2-compartment\nmodel_2c = TwoCompIVBolus()\nresult_2c = foce_estimate(observed, ModelSpec(model_2c, \"pk\", nothing, nothing),\n    EstimationConfig(theta_init=[10.0, 30.0, 5.0, 100.0], omega_init=diagm([0.09, 0.04, 0.16, 0.04]), ...),\n    grid, solver, rng)\n\n# Non-nested: use AIC\nprintln(\"1-comp AIC: $(result_1c.aic)\")\nprintln(\"2-comp AIC: $(result_2c.aic)\")\nprintln(\"\u0394AIC = $(result_1c.aic - result_2c.aic)\")\n\n# Select 2-comp if AIC lower by &gt;4\nbest_struct = result_2c.aic &lt; result_1c.aic - 4 ? \"2-comp\" : \"1-comp\"\nprintln(\"Selected: $best_struct\")\n\n# ============================================\n# Step 2: Random Effects Model\n# ============================================\nprintln(\"\\n=== Random Effects Selection ===\")\n\n# Start with IIV on all structural parameters\nbase_model = best_struct == \"2-comp\" ? model_2c : model_1c\n\n# Test diagonal vs block omega for CL-V\nresult_diag = estimate_with_diagonal_omega(...)\nresult_block = estimate_with_block_omega(...)\n\nchi_sq, p = likelihood_ratio_test(result_block.ofv, result_diag.ofv, df=1)\nprintln(\"CL-V correlation test: p = $p\")\n\n# ============================================\n# Step 3: Covariate Selection\n# ============================================\nprintln(\"\\n=== Covariate Selection ===\")\n\n# Forward selection\ncandidates = [:WT, :AGE, :SEX, :CRCL]\nselected = Symbol[]\ncurrent_ofv = result_block.ofv\n\nfor cov in candidates\n    result_cov = estimate_with_covariate(base_model, cov)\n    delta = current_ofv - result_cov.ofv\n\n    if delta &gt; 3.84\n        println(\"$cov: \u0394OFV = $delta, INCLUDE\")\n        push!(selected, cov)\n        current_ofv = result_cov.ofv\n    else\n        println(\"$cov: \u0394OFV = $delta, EXCLUDE\")\n    end\nend\n\n# ============================================\n# Step 4: Residual Error Model\n# ============================================\nprintln(\"\\n=== Residual Error Selection ===\")\n\nresult_prop = estimate_with_proportional_error(...)\nresult_comb = estimate_with_combined_error(...)\n\nchi_sq, p = likelihood_ratio_test(result_comb.ofv, result_prop.ofv, df=1)\nprintln(\"Combined vs Prop: p = $p\")\n\n# ============================================\n# Final Model Summary\n# ============================================\nprintln(\"\\n=== Final Model ===\")\nprintln(\"Structural: $best_struct\")\nprintln(\"Random effects: $(result_block.converged ? \"Block CL-V\" : \"Diagonal\")\")\nprintln(\"Covariates: $selected\")\nprintln(\"Residual error: $(p &lt; 0.05 ? \"Combined\" : \"Proportional\")\")\nprintln(\"\\nFinal OFV: $(final_result.ofv)\")\nprintln(\"Final AIC: $(final_result.aic)\")\nprintln(\"Final BIC: $(final_result.bic)\")\n</code></pre>"},{"location":"julia/estimation/comparison/#best-practices","title":"Best Practices","text":"<ol> <li>Start simple: Begin with simplest model and add complexity</li> <li>Nested vs non-nested: Use LRT for nested, AIC/BIC for non-nested</li> <li>Multiple comparisons: Adjust significance threshold if many tests</li> <li>Clinical plausibility: Statistical significance \u2260 clinical importance</li> <li>Validate: Check diagnostics after selection</li> </ol>"},{"location":"julia/estimation/comparison/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Estimation method</li> <li>Diagnostics - Model validation</li> <li>Bootstrap - Uncertainty quantification</li> </ul>"},{"location":"julia/estimation/diagnostics/","title":"Model Diagnostics","text":"<p>Comprehensive diagnostic tools for assessing model fit, validating assumptions, and identifying potential issues in population PK/PD analyses.</p>"},{"location":"julia/estimation/diagnostics/#overview","title":"Overview","text":"<p>Model diagnostics help answer: - Does the model adequately describe the data? - Are the random effects properly specified? - Are there systematic biases or trends? - Which subjects/observations are influential?</p>"},{"location":"julia/estimation/diagnostics/#residual-types","title":"Residual Types","text":""},{"location":"julia/estimation/diagnostics/#cwres-conditional-weighted-residuals","title":"CWRES - Conditional Weighted Residuals","text":"<p>The gold standard for NLME diagnostics:</p> \\[CWRES = \\frac{y - E[y|\\hat{\\eta}]}{\\sqrt{Var(y|\\hat{\\eta})}}\\] <p>CWRES accounts for: - Individual predictions (using \\(\\hat{\\eta}\\)) - Proper variance structure - Gradient corrections (for FOCE-I)</p> <pre><code>result = foce_estimate(...)\n\n# Access CWRES per subject\nfor ind in result.individual_estimates\n    println(\"Subject $(ind.subject_id): CWRES = $(ind.cwres)\")\nend\n\n# All CWRES combined\nall_cwres = vcat([ind.cwres for ind in result.individual_estimates]...)\n</code></pre>"},{"location":"julia/estimation/diagnostics/#iwres-individual-weighted-residuals","title":"IWRES - Individual Weighted Residuals","text":"<p>Simpler than CWRES, uses individual predictions:</p> \\[IWRES = \\frac{y - f(\\hat{\\eta})}{\\sigma(f(\\hat{\\eta}))}\\] <pre><code># Access IWRES\nfor ind in result.individual_estimates\n    println(\"Subject $(ind.subject_id): IWRES = $(ind.iwres)\")\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#wres-population-weighted-residuals","title":"WRES - Population Weighted Residuals","text":"<p>Uses population predictions (\\(\\eta = 0\\)):</p> \\[WRES = \\frac{y - f(0)}{\\sigma(f(0))}\\] <pre><code>wres = compute_wres(observed, predictions_eta_zero, sigma)\n</code></pre>"},{"location":"julia/estimation/diagnostics/#npde-normalized-prediction-distribution-errors","title":"NPDE - Normalized Prediction Distribution Errors","text":"<p>Simulation-based diagnostic (most rigorous):</p> \\[NPDE = \\Phi^{-1}(pde_i)\\] <p>Where \\(pde_i\\) is the fraction of simulated values below the observation.</p> <pre><code># Compute NPDE from simulations\nnpde = compute_npde(observed_values, simulated_matrix, rng)\n\n# NPDE should follow N(0,1) if model is correct\nmean(npde)  # Should be ~0\nstd(npde)   # Should be ~1\n</code></pre>"},{"location":"julia/estimation/diagnostics/#diagnostic-criteria","title":"Diagnostic Criteria","text":""},{"location":"julia/estimation/diagnostics/#residual-expectations","title":"Residual Expectations","text":"Residual Mean SD Distribution CWRES 0 1 N(0,1) IWRES 0 1 N(0,1) NPDE 0 1 N(0,1)"},{"location":"julia/estimation/diagnostics/#warning-signs","title":"Warning Signs","text":"Issue Symptom Possible Cause Bias Mean \u2260 0 Structural model misspecification Over/under-dispersion SD \u2260 1 Residual error misspecification Trends vs time Pattern in plot Time-varying effect Trends vs pred Pattern in plot Nonlinearity Heavy tails Non-normal QQ Outliers or wrong error model"},{"location":"julia/estimation/diagnostics/#shrinkage","title":"Shrinkage","text":""},{"location":"julia/estimation/diagnostics/#eta-shrinkage","title":"Eta Shrinkage","text":"<p>Measures how much individual estimates regress toward population:</p> \\[\\text{Shrinkage}_\\eta = 1 - \\frac{SD(\\hat{\\eta}_i)}{\\omega}\\] <pre><code># From estimation result\nprintln(\"Eta shrinkage: \", result.eta_shrinkage)\n\n# Manual computation\nshrinkage = shrinkage_eta(result.individual_estimates, result.omega)\n</code></pre>"},{"location":"julia/estimation/diagnostics/#interpretation","title":"Interpretation","text":"Shrinkage Interpretation &lt; 20% Good - individual estimates well-supported 20-30% Moderate - use caution 30-50% High - individual estimates uncertain &gt; 50% Very high - rely on population estimates <p>High shrinkage indicates: - Sparse data per subject - Low IIV (hard to distinguish subjects) - Model overparameterized</p>"},{"location":"julia/estimation/diagnostics/#epsilon-shrinkage","title":"Epsilon Shrinkage","text":"<p>Measures information in residual error:</p> \\[\\text{Shrinkage}_\\epsilon = 1 - SD(IWRES)\\] <pre><code># Compute epsilon shrinkage\nall_iwres = vcat([ind.iwres for ind in result.individual_estimates]...)\neps_shrinkage = shrinkage_epsilon(all_iwres)\nprintln(\"Epsilon shrinkage: $(eps_shrinkage * 100)%\")\n</code></pre> <p>High epsilon shrinkage suggests: - Sparse data - Overparameterized residual error model - Individual predictions nearly match observations</p>"},{"location":"julia/estimation/diagnostics/#goodness-of-fit-diagnostics","title":"Goodness-of-Fit Diagnostics","text":""},{"location":"julia/estimation/diagnostics/#standard-gof-plots","title":"Standard GOF Plots","text":"<pre><code>using Plots\n\nresult = foce_estimate(...)\n\n# Collect data\nobs = Float64[]\npred = Float64[]\nipred = Float64[]\ncwres = Float64[]\ntime = Float64[]\n\nfor ind in result.individual_estimates\n    append!(obs, ind.observed)\n    append!(pred, ind.pred)\n    append!(ipred, ind.ipred)\n    append!(cwres, ind.cwres)\n    append!(time, ind.times)\nend\n\n# 1. DV vs PRED\np1 = scatter(pred, obs, xlabel=\"Population Prediction\", ylabel=\"Observed\",\n             title=\"DV vs PRED\", legend=false)\nplot!(p1, [minimum(pred), maximum(pred)], [minimum(pred), maximum(pred)],\n      linewidth=2, linestyle=:dash)\n\n# 2. DV vs IPRED\np2 = scatter(ipred, obs, xlabel=\"Individual Prediction\", ylabel=\"Observed\",\n             title=\"DV vs IPRED\", legend=false)\nplot!(p2, [minimum(ipred), maximum(ipred)], [minimum(ipred), maximum(ipred)],\n      linewidth=2, linestyle=:dash)\n\n# 3. CWRES vs Time\np3 = scatter(time, cwres, xlabel=\"Time\", ylabel=\"CWRES\",\n             title=\"CWRES vs Time\", legend=false)\nhline!(p3, [-2, 0, 2], linestyle=:dash)\n\n# 4. CWRES vs PRED\np4 = scatter(pred, cwres, xlabel=\"Population Prediction\", ylabel=\"CWRES\",\n             title=\"CWRES vs PRED\", legend=false)\nhline!(p4, [-2, 0, 2], linestyle=:dash)\n\n# Combined 4-panel plot\nplot(p1, p2, p3, p4, layout=(2,2), size=(800, 800))\n</code></pre>"},{"location":"julia/estimation/diagnostics/#qq-plot-for-residuals","title":"QQ Plot for Residuals","text":"<pre><code>using StatsPlots\n\n# QQ plot\nqqnorm(cwres, title=\"QQ Plot of CWRES\")\n</code></pre>"},{"location":"julia/estimation/diagnostics/#residual-summary-statistics","title":"Residual Summary Statistics","text":"<pre><code># Get residual summary\nsummary = residual_summary(all_cwres)\n\nprintln(\"CWRES Summary:\")\nprintln(\"  Mean: $(summary[:mean])\")\nprintln(\"  SD: $(summary[:sd])\")\nprintln(\"  Median: $(summary[:median])\")\nprintln(\"  Min: $(summary[:min])\")\nprintln(\"  Max: $(summary[:max])\")\nprintln(\"  Skewness: $(summary[:skewness])\")\nprintln(\"  Kurtosis: $(summary[:kurtosis])\")\n</code></pre>"},{"location":"julia/estimation/diagnostics/#individual-fit-diagnostics","title":"Individual Fit Diagnostics","text":""},{"location":"julia/estimation/diagnostics/#individual-plots","title":"Individual Plots","text":"<pre><code># Plot individual fits\nfor (i, ind) in enumerate(result.individual_estimates[1:9])\n    p = plot(title=\"Subject $(ind.subject_id)\")\n    scatter!(p, ind.times, ind.observed, label=\"Observed\", markersize=6)\n    plot!(p, ind.times, ind.ipred, label=\"IPRED\", linewidth=2)\n    plot!(p, ind.times, ind.pred, label=\"PRED\", linestyle=:dash)\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#individual-parameters","title":"Individual Parameters","text":"<pre><code># Examine individual estimates\nfor ind in result.individual_estimates\n    println(\"Subject $(ind.subject_id):\")\n    println(\"  eta = $(ind.eta)\")\n    println(\"  Individual CL = $(result.theta[1] * exp(ind.eta[1]))\")\n    println(\"  Individual V  = $(result.theta[2] * exp(ind.eta[2]))\")\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#covariance-diagnostics","title":"Covariance Diagnostics","text":""},{"location":"julia/estimation/diagnostics/#condition-number","title":"Condition Number","text":"<p>Large condition numbers indicate near-singularity:</p> <pre><code>println(\"Condition number: \", result.condition_number)\n\n# Interpretation\n# &lt; 100: Good\n# 100-1000: Monitor\n# &gt; 1000: Problematic - consider fixing parameters\n</code></pre>"},{"location":"julia/estimation/diagnostics/#eigenvalue-analysis","title":"Eigenvalue Analysis","text":"<pre><code>eigenvalues = result.eigenvalues\nprintln(\"Eigenvalue ratio: \", maximum(eigenvalues) / minimum(eigenvalues))\n\n# Check for near-zero eigenvalues\nif minimum(eigenvalues) &lt; 1e-6\n    println(\"Warning: Near-singular covariance matrix\")\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#correlation-matrix","title":"Correlation Matrix","text":"<pre><code># Parameter correlation matrix\ncorr_matrix = cov_to_corr(result.covariance_matrix)\n\n# High correlations (&gt;0.9) suggest identifiability issues\nfor i in 1:size(corr_matrix, 1)\n    for j in i+1:size(corr_matrix, 2)\n        if abs(corr_matrix[i,j]) &gt; 0.9\n            println(\"High correlation: param $i - param $j: $(corr_matrix[i,j])\")\n        end\n    end\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#model-comparison","title":"Model Comparison","text":""},{"location":"julia/estimation/diagnostics/#objective-function-value","title":"Objective Function Value","text":"<pre><code># Compare nested models\nofv_full = result_full.ofv\nofv_reduced = result_reduced.ofv\n\ndelta_ofv = ofv_reduced - ofv_full\nprintln(\"\u0394OFV = \", delta_ofv)\n</code></pre>"},{"location":"julia/estimation/diagnostics/#likelihood-ratio-test","title":"Likelihood Ratio Test","text":"<pre><code># For nested models: test if full model is significantly better\nchi_sq, p_value = likelihood_ratio_test(\n    ofv_full,\n    ofv_reduced,\n    df = 1  # Difference in parameters\n)\n\nprintln(\"Chi-squared: $chi_sq, p-value: $p_value\")\n\nif p_value &lt; 0.05\n    println(\"Full model significantly better (p &lt; 0.05)\")\nelse\n    println(\"No significant difference - prefer simpler model\")\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#information-criteria","title":"Information Criteria","text":"<pre><code>println(\"Model 1: AIC = $(result1.aic), BIC = $(result1.bic)\")\nprintln(\"Model 2: AIC = $(result2.aic), BIC = $(result2.bic)\")\n\n# Lower is better\n# AIC: Good for prediction\n# BIC: Good for model selection (stronger penalty)\n</code></pre>"},{"location":"julia/estimation/diagnostics/#aicbic-formulas","title":"AIC/BIC Formulas","text":"\\[AIC = OFV + 2p$$ $$BIC = OFV + p \\cdot \\ln(n)\\] <p>Where: - \\(p\\) = number of parameters - \\(n\\) = number of observations</p>"},{"location":"julia/estimation/diagnostics/#influential-subject-analysis","title":"Influential Subject Analysis","text":""},{"location":"julia/estimation/diagnostics/#jackknife-influence","title":"Jackknife Influence","text":"<pre><code># Compute influence of each subject\ninfluence = jackknife_influence(result, observed, model_spec, config, grid, solver)\n\n# Find most influential subjects\nsorted_idx = sortperm(influence, rev=true)\nprintln(\"Most influential subjects:\")\nfor i in sorted_idx[1:5]\n    println(\"  Subject $(observed.subjects[i].id): influence = $(influence[i])\")\nend\n</code></pre>"},{"location":"julia/estimation/diagnostics/#cooks-distance","title":"Cook's Distance","text":"<pre><code># Cook's distance for each subject\ncooks_d = compute_cooks_distance(result, observed)\n\n# Subjects with Cook's D &gt; 4/n are potentially influential\nthreshold = 4 / n_subjects(observed)\ninfluential = findall(cooks_d .&gt; threshold)\nprintln(\"Potentially influential subjects: \", influential)\n</code></pre>"},{"location":"julia/estimation/diagnostics/#vpc-based-diagnostics","title":"VPC-Based Diagnostics","text":""},{"location":"julia/estimation/diagnostics/#vpc-check-statistic","title":"VPC Check Statistic","text":"<pre><code># Percentage of observations within prediction interval\nvpc_stat = vpc_check(observed_values, pi_lower, pi_upper)\nprintln(\"$(vpc_stat)% of observations within 90% PI\")\n\n# Should be close to 90% for 90% PI\n</code></pre>"},{"location":"julia/estimation/diagnostics/#diagnostic-functions-reference","title":"Diagnostic Functions Reference","text":""},{"location":"julia/estimation/diagnostics/#residual-functions","title":"Residual Functions","text":"Function Description <code>compute_cwres(obs, ipred, sigma, gradients)</code> Conditional weighted residuals <code>compute_iwres(obs, ipred, sigma)</code> Individual weighted residuals <code>compute_wres(obs, pred, sigma)</code> Population weighted residuals <code>compute_npde(obs, simulated, rng)</code> Normalized prediction distribution errors"},{"location":"julia/estimation/diagnostics/#shrinkage-functions","title":"Shrinkage Functions","text":"Function Description <code>shrinkage_eta(etas, omega)</code> Eta shrinkage per parameter <code>shrinkage_epsilon(iwres)</code> Epsilon shrinkage"},{"location":"julia/estimation/diagnostics/#model-comparison-functions","title":"Model Comparison Functions","text":"Function Description <code>likelihood_ratio_test(ofv1, ofv2, df)</code> LRT between nested models <code>compute_aic(ofv, n_params)</code> Akaike Information Criterion <code>compute_bic(ofv, n_params, n_obs)</code> Bayesian Information Criterion"},{"location":"julia/estimation/diagnostics/#diagnostic-checklist","title":"Diagnostic Checklist","text":""},{"location":"julia/estimation/diagnostics/#pre-estimation","title":"Pre-Estimation","text":"<ul> <li>[ ] Initial estimates reasonable?</li> <li>[ ] Data formatted correctly?</li> <li>[ ] BLQ handling specified?</li> </ul>"},{"location":"julia/estimation/diagnostics/#post-estimation","title":"Post-Estimation","text":"<ul> <li>[ ] Convergence achieved?</li> <li>[ ] Condition number acceptable (&lt;1000)?</li> <li>[ ] RSE &lt; 50% for all parameters?</li> <li>[ ] Shrinkage &lt; 30%?</li> <li>[ ] CWRES mean \u2248 0, SD \u2248 1?</li> <li>[ ] No trends in residual plots?</li> <li>[ ] QQ plot approximately linear?</li> <li>[ ] Individual fits adequate?</li> </ul>"},{"location":"julia/estimation/diagnostics/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Primary estimation method</li> <li>SAEM Algorithm - Alternative estimation</li> <li>Bootstrap - Uncertainty quantification</li> <li>Model Comparison - Comparing models</li> </ul>"},{"location":"julia/estimation/foce/","title":"FOCE-I Method","text":"<p>First-Order Conditional Estimation with Interaction (FOCE-I) is the industry-standard estimation method for nonlinear mixed-effects modeling, matching NONMEM's implementation.</p>"},{"location":"julia/estimation/foce/#overview","title":"Overview","text":"<p>FOCE-I linearizes the model around individual eta estimates rather than zero, providing more accurate parameter estimates for most PK/PD models.</p>"},{"location":"julia/estimation/foce/#key-features","title":"Key Features","text":"<ul> <li>Full Laplacian correction: log|H_eta| computed from actual Hessian</li> <li>Proper CWRES: Sensitivity gradients dF/d_eta included</li> <li>Analytic solutions: AD-compatible for common PK models</li> <li>Sandwich estimator: Robust standard errors</li> <li>Covariate effects on IIV: Support for eta-covariate relationships</li> <li>IOV support: Inter-Occasion Variability estimation</li> </ul>"},{"location":"julia/estimation/foce/#usage","title":"Usage","text":""},{"location":"julia/estimation/foce/#basic-foce-i-estimation","title":"Basic FOCE-I Estimation","text":"<pre><code>using OpenPKPDCore\n\n# Create observed data\nobserved = ObservedData(\n    subjects = [\n        Subject(\n            id = \"1\",\n            times = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0],\n            observations = Dict(:conc =&gt; [8.2, 9.1, 7.8, 5.2, 2.8, 1.5, 0.4]),\n            doses = [DoseEvent(0.0, 500.0)],\n            covariates = Dict(:WT =&gt; 70.0, :AGE =&gt; 45.0)\n        ),\n        # ... more subjects\n    ]\n)\n\n# Model specification\nmodel = OneCompIVBolus()\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# Configure FOCE-I estimation\nconfig = EstimationConfig(\n    method = FOCEIMethod(),\n    theta_init = [10.0, 50.0],           # Initial [CL, V]\n    omega_init = diagm([0.09, 0.04]),    # Initial omega (30% CV CL, 20% CV V)\n    sigma_init = ResidualErrorSpec(\n        ProportionalError(),\n        ProportionalErrorParams(0.1),     # 10% proportional error\n        :conc\n    ),\n    max_iter = 1000,\n    tol = 1e-6,\n    compute_se = true,\n    compute_ci = true,\n    ci_level = 0.95,\n    verbose = true\n)\n\n# Create grid and solver\ngrid = SimGrid(0.0, 24.0, 0:0.1:24)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^6)\n\n# Run estimation\nresult = foce_estimate(observed, model_spec, config, grid, solver, StableRNG(12345))\n\n# Access results\nprintln(\"Fixed effects (theta):\")\nprintln(\"  CL = $(result.theta[1]) \u00b1 $(result.theta_se[1])\")\nprintln(\"  V  = $(result.theta[2]) \u00b1 $(result.theta_se[2])\")\nprintln(\"\\nRandom effects (omega):\")\nprintln(\"  omega_CL = $(result.omega[1,1]) (CV = $(sqrt(result.omega[1,1])*100)%)\")\nprintln(\"  omega_V  = $(result.omega[2,2]) (CV = $(sqrt(result.omega[2,2])*100)%)\")\nprintln(\"\\nResidual error:\")\nprintln(\"  sigma = $(result.sigma)\")\nprintln(\"\\nModel fit:\")\nprintln(\"  OFV = $(result.ofv)\")\nprintln(\"  AIC = $(result.aic)\")\nprintln(\"  BIC = $(result.bic)\")\n</code></pre>"},{"location":"julia/estimation/foce/#configuration-options","title":"Configuration Options","text":""},{"location":"julia/estimation/foce/#estimationconfig-parameters","title":"EstimationConfig Parameters","text":"Parameter Type Default Description <code>method</code> FOCEIMethod Required FOCE-I method specification <code>theta_init</code> Vector{Float64} Required Initial fixed effect estimates <code>omega_init</code> Matrix{Float64} Required Initial omega matrix <code>sigma_init</code> ResidualErrorSpec Required Initial residual error specification <code>max_iter</code> Int 1000 Maximum iterations <code>tol</code> Float64 1e-6 Convergence tolerance <code>compute_se</code> Bool true Compute standard errors <code>compute_ci</code> Bool true Compute confidence intervals <code>ci_level</code> Float64 0.95 Confidence level <code>omega_structure</code> Symbol :diagonal Omega structure (:diagonal, :block, :full) <code>verbose</code> Bool false Print progress <code>seed</code> UInt64 12345 Random seed for reproducibility"},{"location":"julia/estimation/foce/#foceimethod-options","title":"FOCEIMethod Options","text":"<pre><code>FOCEIMethod(;\n    centered = false,        # Use FOCE (not FOCE-I) when true\n    compute_cwres = true,    # Compute conditional weighted residuals\n    laplacian = true,        # Include Laplacian correction\n    eta_tol = 1e-8,          # Inner optimization tolerance\n    max_eta_iter = 100       # Max iterations for eta optimization\n)\n</code></pre>"},{"location":"julia/estimation/foce/#omega-structures","title":"Omega Structures","text":""},{"location":"julia/estimation/foce/#diagonal-omega","title":"Diagonal Omega","text":"<p>Independent random effects (most common):</p> <pre><code>config = EstimationConfig(\n    # ...\n    omega_init = diagm([0.09, 0.04]),  # Diagonal\n    omega_structure = :diagonal\n)\n</code></pre>"},{"location":"julia/estimation/foce/#block-omega","title":"Block Omega","text":"<p>Correlated random effects within blocks:</p> <pre><code># CL and V correlated, ka independent\nomega_init = [\n    0.09  0.02  0.0;   # CL\n    0.02  0.04  0.0;   # V\n    0.0   0.0   0.16   # ka\n]\n\nconfig = EstimationConfig(\n    omega_init = omega_init,\n    omega_structure = :block\n)\n</code></pre>"},{"location":"julia/estimation/foce/#full-omega","title":"Full Omega","text":"<p>All random effects correlated:</p> <pre><code>omega_init = [\n    0.09  0.02  0.01;\n    0.02  0.04  0.005;\n    0.01  0.005 0.16\n]\n\nconfig = EstimationConfig(\n    omega_init = omega_init,\n    omega_structure = :full\n)\n</code></pre>"},{"location":"julia/estimation/foce/#residual-error-models","title":"Residual Error Models","text":""},{"location":"julia/estimation/foce/#additive-error","title":"Additive Error","text":"\\[\\epsilon \\sim N(0, \\sigma^2)\\] <pre><code>sigma_init = ResidualErrorSpec(\n    AdditiveError(),\n    AdditiveErrorParams(0.5),  # sigma = 0.5\n    :conc\n)\n</code></pre>"},{"location":"julia/estimation/foce/#proportional-error","title":"Proportional Error","text":"\\[\\epsilon \\sim N(0, (\\sigma \\cdot F)^2)\\] <pre><code>sigma_init = ResidualErrorSpec(\n    ProportionalError(),\n    ProportionalErrorParams(0.1),  # 10% CV\n    :conc\n)\n</code></pre>"},{"location":"julia/estimation/foce/#combined-error","title":"Combined Error","text":"\\[\\epsilon \\sim N(0, (\\sigma_{add}^2 + (\\sigma_{prop} \\cdot F)^2))\\] <pre><code>sigma_init = ResidualErrorSpec(\n    CombinedError(),\n    CombinedErrorParams(0.5, 0.1),  # additive=0.5, proportional=10%\n    :conc\n)\n</code></pre>"},{"location":"julia/estimation/foce/#exponential-error","title":"Exponential Error","text":"\\[\\log(Y) = \\log(F) + \\epsilon, \\quad \\epsilon \\sim N(0, \\sigma^2)\\] <pre><code>sigma_init = ResidualErrorSpec(\n    ExponentialError(),\n    ExponentialErrorParams(0.15),  # 15% CV on log-scale\n    :conc\n)\n</code></pre>"},{"location":"julia/estimation/foce/#blq-handling","title":"BLQ Handling","text":"<p>FOCE-I supports Below Limit of Quantification (BLQ) data with multiple methods:</p>"},{"location":"julia/estimation/foce/#m1-method-discard","title":"M1 Method (Discard)","text":"<p>Simply discards BLQ observations:</p> <pre><code>blq_config = BLQConfig(\n    method = :M1,\n    lloq = 0.1\n)\n\nconfig = EstimationConfig(\n    # ... other options\n    blq_config = blq_config\n)\n</code></pre>"},{"location":"julia/estimation/foce/#m2-method-imputation","title":"M2 Method (Imputation)","text":"<p>Imputes BLQ values at LLOQ/2 or 0:</p> <pre><code>blq_config = BLQConfig(\n    method = :M2,\n    lloq = 0.1,\n    impute_value = :half  # or :zero\n)\n</code></pre>"},{"location":"julia/estimation/foce/#m3-method-censored-likelihood","title":"M3 Method (Censored Likelihood)","text":"<p>Gold standard - uses censored likelihood:</p> <pre><code>blq_config = BLQConfig(\n    method = :M3,\n    lloq = 0.1\n)\n</code></pre> <p>M3 properly accounts for the information that observations are below LLOQ using:</p> \\[L_{BLQ} = \\Phi\\left(\\frac{LLOQ - F}{\\sigma}\\right)\\]"},{"location":"julia/estimation/foce/#covariate-effects-on-iiv","title":"Covariate Effects on IIV","text":"<p>Model covariate effects on inter-individual variability:</p> <pre><code># Define covariate effects\ncovariate_effects = [\n    CovariateOnIIV(\n        eta_name = :eta_CL,\n        covariate_name = :WT,\n        effect_type = :exponential,\n        reference_value = 70.0\n    ),\n    CovariateOnIIV(\n        eta_name = :eta_V,\n        covariate_name = :AGE,\n        effect_type = :linear,\n        reference_value = 40.0\n    )\n]\n\nconfig = EstimationConfig(\n    # ... other options\n    covariate_effects = covariate_effects\n)\n</code></pre> <p>This implements: - Exponential: \\(\\omega_{adjusted} = \\omega_{base} \\cdot \\exp(\\theta_{cov} \\cdot (COV - COV_{ref}))\\) - Linear: \\(\\omega_{adjusted} = \\omega_{base} \\cdot (1 + \\theta_{cov} \\cdot (COV - COV_{ref}))\\)</p>"},{"location":"julia/estimation/foce/#inter-occasion-variability-iov","title":"Inter-Occasion Variability (IOV)","text":"<p>Support multiple occasions with occasion-specific random effects:</p> <pre><code># Define IOV specification\niov_specs = [\n    EstimationIOVSpec(\n        eta_name = :eta_CL,\n        occasion_names = [:OCC1, :OCC2, :OCC3],\n        omega_iov = 0.04  # 20% IOV on CL\n    )\n]\n\nconfig = EstimationConfig(\n    # ... other options\n    iov_specs = iov_specs\n)\n</code></pre> <p>Total eta: \\(\\eta_{total} = \\eta_{IIV} + \\eta_{IOV}[occasion]\\)</p>"},{"location":"julia/estimation/foce/#diagnostics","title":"Diagnostics","text":""},{"location":"julia/estimation/foce/#foceidiagnostics-structure","title":"FOCEIDiagnostics Structure","text":"<pre><code>struct FOCEIDiagnostics\n    eta_hessians::Vector{Matrix{Float64}}      # Per-subject Hessians\n    laplacian_corrections::Vector{Float64}      # Laplacian terms\n    likelihood_contributions::Vector{Float64}   # Per-subject -2LL\n    prior_contributions::Vector{Float64}        # Prior penalty\n    interaction_enabled::Bool                   # FOCE-I vs FOCE\n    cwres_fallback_subjects::Vector{String}     # CWRES issues\nend\n</code></pre>"},{"location":"julia/estimation/foce/#accessing-diagnostics","title":"Accessing Diagnostics","text":"<pre><code>result = foce_estimate(observed, model_spec, config, grid, solver, rng)\n\n# Individual estimates\nfor (i, ind) in enumerate(result.individual_estimates)\n    println(\"Subject $(ind.subject_id):\")\n    println(\"  eta = $(ind.eta)\")\n    println(\"  ipred = $(ind.ipred[1:3])...\")\n    println(\"  cwres = $(ind.cwres[1:3])...\")\nend\n\n# Shrinkage\nprintln(\"Eta shrinkage: $(result.eta_shrinkage)\")\nprintln(\"Epsilon shrinkage: $(result.epsilon_shrinkage)\")\n</code></pre>"},{"location":"julia/estimation/foce/#standard-errors","title":"Standard Errors","text":""},{"location":"julia/estimation/foce/#asymptotic-standard-errors","title":"Asymptotic Standard Errors","text":"<p>Computed from inverse Fisher Information Matrix:</p> <pre><code>config = EstimationConfig(\n    # ...\n    compute_se = true,\n    se_method = :hessian  # Default\n)\n</code></pre>"},{"location":"julia/estimation/foce/#sandwich-robust-standard-errors","title":"Sandwich (Robust) Standard Errors","text":"<p>More robust to model misspecification:</p> <pre><code>config = EstimationConfig(\n    # ...\n    compute_se = true,\n    se_method = :sandwich\n)\n</code></pre> <p>The sandwich estimator uses: \\(SE = R^{-1} S R^{-1}\\) where R is the Hessian and S is the score covariance.</p>"},{"location":"julia/estimation/foce/#convergence-monitoring","title":"Convergence Monitoring","text":""},{"location":"julia/estimation/foce/#objective-function-value-ofv","title":"Objective Function Value (OFV)","text":"\\[OFV = -2 \\cdot \\log(L) = \\sum_i \\left[ \\ln|C_i| + (y_i - f_i)^T C_i^{-1} (y_i - f_i) + \\ln|H_{\\eta,i}| \\right]\\]"},{"location":"julia/estimation/foce/#convergence-criteria","title":"Convergence Criteria","text":"<p>The algorithm converges when: 1. Relative parameter change &lt; tolerance 2. Gradient norm &lt; gradient tolerance 3. OFV change &lt; function tolerance</p> <pre><code>result.converged      # Did it converge?\nresult.n_iterations   # How many iterations?\nresult.final_gradient # Final gradient vector\n</code></pre>"},{"location":"julia/estimation/foce/#mathematical-details","title":"Mathematical Details","text":""},{"location":"julia/estimation/foce/#foce-i-objective-function","title":"FOCE-I Objective Function","text":"<p>For subject \\(i\\):</p> \\[OFV_i = \\ln|C_i(\\hat{\\eta}_i)| + (y_i - f_i(\\hat{\\eta}_i))^T C_i^{-1}(\\hat{\\eta}_i) (y_i - f_i(\\hat{\\eta}_i)) + \\hat{\\eta}_i^T \\Omega^{-1} \\hat{\\eta}_i + \\ln|H_{\\eta,i}|\\] <p>Where: - \\(f_i(\\eta)\\) = Model predictions for subject i - \\(C_i(\\eta)\\) = Residual variance matrix - \\(\\hat{\\eta}_i\\) = Individual eta estimates (modes) - \\(H_{\\eta,i}\\) = Hessian of -2LL with respect to eta</p>"},{"location":"julia/estimation/foce/#foce-vs-foce-i","title":"FOCE vs FOCE-I","text":"Method Interaction Term \\(\\partial f / \\partial \\eta\\) FOCE No Evaluated at \\(\\eta = 0\\) FOCE-I Yes Evaluated at \\(\\eta = \\hat{\\eta}\\) <p>FOCE-I includes the \"interaction\" between random effects and residual error.</p>"},{"location":"julia/estimation/foce/#example-full-population-pk-analysis","title":"Example: Full Population PK Analysis","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Load data\ndata = load_estimation_data(\"pk_data.csv\")\n\nobserved = ObservedData(\n    subjects = [\n        Subject(\n            id = row.id,\n            times = row.times,\n            observations = Dict(:conc =&gt; row.dv),\n            doses = row.doses,\n            covariates = Dict(:WT =&gt; row.wt, :SEX =&gt; row.sex)\n        )\n        for row in data\n    ]\n)\n\n# Two-compartment model\nmodel = TwoCompIVBolus()\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# Initial estimates from NCA\nconfig = EstimationConfig(\n    method = FOCEIMethod(centered=false, compute_cwres=true),\n    theta_init = [10.0, 30.0, 3.0, 100.0],  # CL, V1, Q, V2\n    omega_init = diagm([0.09, 0.04, 0.16, 0.04]),\n    sigma_init = ResidualErrorSpec(\n        CombinedError(),\n        CombinedErrorParams(0.1, 0.05),\n        :conc\n    ),\n    omega_structure = :diagonal,\n    blq_config = BLQConfig(method=:M3, lloq=0.01),\n    max_iter = 2000,\n    tol = 1e-8,\n    compute_se = true,\n    verbose = true\n)\n\ngrid = SimGrid(0.0, 72.0, 0:0.1:72)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\n# Run estimation\nresult = foce_estimate(observed, model_spec, config, grid, solver, StableRNG(42))\n\n# Print results\nprintln(\"=== FOCE-I Estimation Results ===\")\nprintln(\"\\nFixed Effects:\")\nparams = [\"CL\", \"V1\", \"Q\", \"V2\"]\nfor (i, p) in enumerate(params)\n    println(\"  $p = $(round(result.theta[i], sigdigits=4)) (RSE = $(round(result.theta_rse[i], digits=1))%)\")\nend\n\nprintln(\"\\nRandom Effects (CV%):\")\nfor (i, p) in enumerate(params)\n    cv = sqrt(result.omega[i,i]) * 100\n    println(\"  $p IIV = $(round(cv, digits=1))%\")\nend\n\nprintln(\"\\nEta Shrinkage:\")\nfor (i, p) in enumerate(params)\n    println(\"  $p = $(round(result.eta_shrinkage[i]*100, digits=1))%\")\nend\n\nprintln(\"\\nModel Fit:\")\nprintln(\"  OFV = $(round(result.ofv, digits=2))\")\nprintln(\"  AIC = $(round(result.aic, digits=2))\")\nprintln(\"  BIC = $(round(result.bic, digits=2))\")\nprintln(\"  Converged: $(result.converged)\")\n</code></pre>"},{"location":"julia/estimation/foce/#see-also","title":"See Also","text":"<ul> <li>SAEM Algorithm - Alternative for complex models</li> <li>Laplacian Method - For sparse data</li> <li>Diagnostics - Model validation</li> <li>Bootstrap - Non-parametric uncertainty</li> </ul>"},{"location":"julia/estimation/laplacian/","title":"Laplacian Method","text":"<p>The Laplacian approximation method provides fast, efficient parameter estimation particularly suited for sparse data situations.</p>"},{"location":"julia/estimation/laplacian/#overview","title":"Overview","text":"<p>The Laplacian method approximates the marginal likelihood by: 1. Finding the mode (MAP estimate) of eta for each subject 2. Using the Laplace approximation for the integral over random effects</p>"},{"location":"julia/estimation/laplacian/#key-features","title":"Key Features","text":"<ul> <li>Fast computation: Simpler than FOCE-I, no interaction terms</li> <li>Sparse data friendly: Works well with few observations per subject</li> <li>Analytical gradients: Efficient optimization</li> <li>BLQ support: All M1/M2/M3 methods supported</li> <li>Standard errors: From Hessian approximation</li> </ul>"},{"location":"julia/estimation/laplacian/#when-to-use-laplacian","title":"When to Use Laplacian","text":"<p>The Laplacian method is preferred when:</p> Situation Why Laplacian Helps Sparse sampling Few observations per subject (1-3) Large populations Fast computation scales well Initial estimates Quick screening before FOCE/SAEM Simple models One-compartment, few parameters Exploratory analysis Rapid model comparison"},{"location":"julia/estimation/laplacian/#usage","title":"Usage","text":""},{"location":"julia/estimation/laplacian/#basic-laplacian-estimation","title":"Basic Laplacian Estimation","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Observed data (sparse sampling)\nobserved = ObservedData(\n    subjects = [\n        Subject(\n            id = \"1\",\n            times = [1.0, 4.0],  # Only 2 observations\n            observations = Dict(:conc =&gt; [8.5, 3.2]),\n            doses = [DoseEvent(0.0, 500.0)]\n        ),\n        Subject(\n            id = \"2\",\n            times = [2.0, 8.0],\n            observations = Dict(:conc =&gt; [6.8, 1.4]),\n            doses = [DoseEvent(0.0, 500.0)]\n        ),\n        # ... more sparse subjects\n    ]\n)\n\n# Model specification\nmodel = OneCompIVBolus()\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# Configure Laplacian estimation\nconfig = EstimationConfig(\n    method = LaplacianMethod(\n        max_inner_iter = 50,    # Max iterations for eta optimization\n        inner_tol = 1e-6        # Inner optimization tolerance\n    ),\n    theta_init = [10.0, 50.0],        # CL, V\n    omega_init = diagm([0.09, 0.04]),\n    sigma_init = ResidualErrorSpec(\n        ProportionalError(),\n        ProportionalErrorParams(0.15),\n        :conc\n    ),\n    max_iter = 500,\n    tol = 1e-6,\n    compute_se = true,\n    verbose = true\n)\n\ngrid = SimGrid(0.0, 24.0, 0:0.1:24)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^6)\n\nresult = laplacian_estimate(observed, model_spec, config, grid, solver, StableRNG(12345))\n\nprintln(\"Theta: \", result.theta)\nprintln(\"Theta SE: \", result.theta_se)\nprintln(\"OFV: \", result.ofv)\n</code></pre>"},{"location":"julia/estimation/laplacian/#laplacianmethod-configuration","title":"LaplacianMethod Configuration","text":""},{"location":"julia/estimation/laplacian/#all-parameters","title":"All Parameters","text":"<pre><code>LaplacianMethod(;\n    max_inner_iter = 50,     # Max iterations for finding eta mode\n    inner_tol = 1e-6,        # Convergence tolerance for inner loop\n    use_prior = true,        # Include prior on eta in optimization\n    hessian_method = :exact  # or :finite_diff\n)\n</code></pre>"},{"location":"julia/estimation/laplacian/#mathematical-details","title":"Mathematical Details","text":""},{"location":"julia/estimation/laplacian/#laplace-approximation","title":"Laplace Approximation","text":"<p>The marginal likelihood integrates out random effects:</p> \\[L(\\theta, \\Omega, \\sigma | y) = \\int p(y | \\eta, \\theta, \\sigma) p(\\eta | \\Omega) d\\eta\\] <p>The Laplace approximation expands around the mode \\(\\hat{\\eta}\\):</p> \\[\\log L \\approx \\log p(y | \\hat{\\eta}, \\theta, \\sigma) + \\log p(\\hat{\\eta} | \\Omega) - \\frac{1}{2}\\log|H|\\] <p>Where \\(H\\) is the Hessian of \\(-\\log p(\\eta | y)\\) at \\(\\hat{\\eta}\\).</p>"},{"location":"julia/estimation/laplacian/#objective-function","title":"Objective Function","text":"\\[OFV = \\sum_i \\left[ (y_i - f_i(\\hat{\\eta}_i))^T C_i^{-1} (y_i - f_i(\\hat{\\eta}_i)) + \\ln|C_i| + \\hat{\\eta}_i^T \\Omega^{-1} \\hat{\\eta}_i + \\ln|\\Omega| + \\ln|H_i| \\right]\\]"},{"location":"julia/estimation/laplacian/#finding-eta-mode","title":"Finding Eta Mode","text":"<p>For each subject, minimize:</p> \\[J_i(\\eta) = (y_i - f_i(\\eta))^T C_i^{-1} (y_i - f_i(\\eta)) + \\eta^T \\Omega^{-1} \\eta\\] <p>This is solved using Newton-Raphson or L-BFGS.</p>"},{"location":"julia/estimation/laplacian/#comparison-with-foce-i","title":"Comparison with FOCE-I","text":"Aspect Laplacian FOCE-I Interaction term No Yes F linearization Around \\(\\hat{\\eta}\\) Around \\(\\hat{\\eta}\\) C linearization No Yes (at \\(\\hat{\\eta}\\)) Computational cost Lower Higher Accuracy Good for sparse Better for dense Implementation Simpler More complex <p>The main difference is that Laplacian doesn't include the \"interaction\" term in the residual covariance linearization.</p>"},{"location":"julia/estimation/laplacian/#sparse-data-example","title":"Sparse Data Example","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Very sparse: 1-2 observations per subject\n# This is common in Phase I oncology trials\n\nsubjects = [\n    Subject(id=\"$(i)\", times=[rand([1.0, 2.0, 4.0])],\n            observations=Dict(:conc =&gt; [rand()*10]),\n            doses=[DoseEvent(0.0, 100.0)])\n    for i in 1:50\n]\n\nobserved = ObservedData(subjects=subjects)\n\nmodel = OneCompIVBolus()\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# Laplacian handles sparse data well\nconfig = EstimationConfig(\n    method = LaplacianMethod(),\n    theta_init = [5.0, 30.0],\n    omega_init = diagm([0.25, 0.16]),  # Wide initial IIV\n    sigma_init = ResidualErrorSpec(\n        CombinedError(),\n        CombinedErrorParams(0.5, 0.2),\n        :conc\n    ),\n    max_iter = 500,\n    compute_se = true,\n    verbose = true\n)\n\ngrid = SimGrid(0.0, 24.0, 0:0.5:24)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^6)\n\nresult = laplacian_estimate(observed, model_spec, config, grid, solver, StableRNG(123))\n\nprintln(\"=== Sparse Data Analysis ===\")\nprintln(\"CL = $(round(result.theta[1], sigdigits=3)) \u00b1 $(round(result.theta_se[1], sigdigits=2))\")\nprintln(\"V  = $(round(result.theta[2], sigdigits=3)) \u00b1 $(round(result.theta_se[2], sigdigits=2))\")\nprintln(\"OFV = $(round(result.ofv, digits=2))\")\n</code></pre>"},{"location":"julia/estimation/laplacian/#blq-handling","title":"BLQ Handling","text":"<p>All BLQ methods are supported:</p> <pre><code># M3 (censored likelihood) - recommended\nblq_config = BLQConfig(\n    method = :M3,\n    lloq = 0.1,\n    report_blq_summary = true\n)\n\nconfig = EstimationConfig(\n    method = LaplacianMethod(),\n    # ... other options\n    blq_config = blq_config\n)\n\nresult = laplacian_estimate(observed, model_spec, config, grid, solver, rng)\n\n# Check BLQ summary\nprintln(\"BLQ observations: $(result.blq_summary.blq_observations)\")\nprintln(\"BLQ percentage: $(result.blq_summary.blq_percentage)%\")\n</code></pre>"},{"location":"julia/estimation/laplacian/#standard-errors","title":"Standard Errors","text":""},{"location":"julia/estimation/laplacian/#hessian-based-ses","title":"Hessian-Based SEs","text":"<pre><code>config = EstimationConfig(\n    method = LaplacianMethod(hessian_method=:exact),\n    compute_se = true,\n    # ...\n)\n\nresult = laplacian_estimate(...)\n\n# Access SEs\nprintln(\"Theta SE: \", result.theta_se)\nprintln(\"Theta RSE%: \", result.theta_rse)\n\n# Confidence intervals\nprintln(\"95% CI for CL: [$(result.theta_ci_lower[1]), $(result.theta_ci_upper[1])]\")\n</code></pre>"},{"location":"julia/estimation/laplacian/#se-computation-details","title":"SE Computation Details","text":"<p>Standard errors are computed from the inverse Hessian of the marginal log-likelihood:</p> \\[SE(\\hat{\\theta}) = \\sqrt{diag(H^{-1})}\\] <p>Where H is computed using central finite differences or automatic differentiation.</p>"},{"location":"julia/estimation/laplacian/#parallel-execution","title":"Parallel Execution","text":"<pre><code>parallel_config = ParallelConfig(\n    ThreadedBackend(4),\n    seed = 12345,\n    load_balance = true\n)\n\nresult = laplacian_estimate(\n    observed, model_spec, config, grid, solver, rng;\n    parallel_config = parallel_config\n)\n</code></pre>"},{"location":"julia/estimation/laplacian/#model-fit-statistics","title":"Model Fit Statistics","text":"<pre><code>result = laplacian_estimate(...)\n\n# Objective function value\nprintln(\"OFV = \", result.ofv)\n\n# Information criteria\nprintln(\"AIC = \", result.aic)\nprintln(\"BIC = \", result.bic)\n\n# For model comparison\n# Lower AIC/BIC indicates better fit (penalized for complexity)\n</code></pre>"},{"location":"julia/estimation/laplacian/#algorithm-summary","title":"Algorithm Summary","text":"<ol> <li>Initialize: Set initial theta, omega, sigma</li> <li>E-step: For each subject, find eta mode by minimizing:    $\\(J(\\eta) = \\|y - f(\\eta)\\|_C^2 + \\eta^T\\Omega^{-1}\\eta\\)$</li> <li>M-step: Update theta, omega, sigma using the eta modes</li> <li>Convergence check: If parameter change &lt; tolerance, stop</li> <li>Iterate steps 2-4 until convergence</li> </ol>"},{"location":"julia/estimation/laplacian/#equations-summary","title":"Equations Summary","text":"Quantity Formula Eta mode \\(\\hat{\\eta} = \\arg\\min_\\eta [(y-f)^TC^{-1}(y-f) + \\eta^T\\Omega^{-1}\\eta]\\) Laplacian correction \\(-\\frac{1}{2}\\log\\|H_\\eta\\|\\) OFV contribution \\(\\|y-f\\|_C^2 + \\ln\\|C\\| + \\|\\eta\\|_\\Omega^2 + \\ln\\|\\Omega\\| + \\ln\\|H\\|\\) Hessian \\(H = \\nabla_\\eta^2 J(\\eta)\\)"},{"location":"julia/estimation/laplacian/#limitations","title":"Limitations","text":"<ul> <li>Dense data: FOCE-I may be more accurate</li> <li>High IIV: May underestimate variability</li> <li>Complex models: SAEM may be more robust</li> <li>Interaction effects: Not captured (no C linearization)</li> </ul>"},{"location":"julia/estimation/laplacian/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - More accurate for dense data</li> <li>SAEM Algorithm - More robust for complex models</li> <li>Diagnostics - Model validation</li> </ul>"},{"location":"julia/estimation/saem/","title":"SAEM Algorithm","text":"<p>Stochastic Approximation Expectation Maximization (SAEM) is a robust estimation method that uses MCMC sampling to handle complex models and problematic datasets.</p>"},{"location":"julia/estimation/saem/#overview","title":"Overview","text":"<p>SAEM alternates between: 1. E-step: MCMC sampling of random effects from their posterior distribution 2. M-step: Stochastic approximation update of population parameters</p>"},{"location":"julia/estimation/saem/#key-features","title":"Key Features","text":"<ul> <li>Robust convergence: Less prone to local minima than FOCE</li> <li>Handles complex models: High IIV, multimodal likelihoods</li> <li>Multiple MCMC chains: Improved mixing and convergence diagnostics</li> <li>Adaptive proposals: Automatic tuning of Metropolis-Hastings proposals</li> <li>Parallel execution: Multi-threaded E-step for large datasets</li> <li>Convergence diagnostics: Gelman-Rubin, effective sample size</li> </ul>"},{"location":"julia/estimation/saem/#when-to-use-saem","title":"When to Use SAEM","text":"<p>SAEM is preferred over FOCE-I when:</p> Situation Why SAEM Helps Large IIV (&gt;50% CV) Better handles extreme random effects Complex nonlinear models More robust to model nonlinearity Multimodal likelihood Multiple chains explore the space FOCE convergence issues SAEM often converges where FOCE fails Many random effects Stochastic sampling scales better"},{"location":"julia/estimation/saem/#usage","title":"Usage","text":""},{"location":"julia/estimation/saem/#basic-saem-estimation","title":"Basic SAEM Estimation","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Create observed data\nobserved = ObservedData(\n    subjects = [\n        Subject(\n            id = \"1\",\n            times = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0],\n            observations = Dict(:conc =&gt; [8.2, 9.1, 7.8, 5.2, 2.8, 1.5, 0.4]),\n            doses = [DoseEvent(0.0, 500.0)],\n            covariates = Dict(:WT =&gt; 70.0)\n        ),\n        # ... more subjects\n    ]\n)\n\n# Model specification\nmodel = TwoCompOral()\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# Configure SAEM estimation\nconfig = EstimationConfig(\n    method = SAEMMethod(\n        n_burn = 200,          # Burn-in iterations\n        n_iter = 300,          # Main iterations\n        n_chains = 3,          # MCMC chains per subject\n        n_mcmc_steps = 50,     # MCMC steps per E-step\n        adapt_proposal = true, # Adaptive Metropolis-Hastings\n        target_acceptance = 0.3\n    ),\n    theta_init = [15.0, 30.0, 5.0, 100.0, 1.5],  # CL, V1, Q, V2, ka\n    omega_init = diagm([0.09, 0.04, 0.16, 0.04, 0.25]),\n    sigma_init = ResidualErrorSpec(\n        ProportionalError(),\n        ProportionalErrorParams(0.15),\n        :conc\n    ),\n    max_iter = 500,\n    tol = 1e-6,\n    compute_se = true,\n    verbose = true,\n    seed = 12345\n)\n\n# Create grid and solver\ngrid = SimGrid(0.0, 48.0, 0:0.1:48)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^6)\n\n# Run estimation\nresult = saem_estimate(observed, model_spec, config, grid, solver, StableRNG(12345))\n\nprintln(\"Theta: \", result.theta)\nprintln(\"Omega diagonal: \", diag(result.omega))\nprintln(\"OFV: \", result.ofv)\nprintln(\"Converged: \", result.converged)\n</code></pre>"},{"location":"julia/estimation/saem/#saemmethod-configuration","title":"SAEMMethod Configuration","text":""},{"location":"julia/estimation/saem/#all-parameters","title":"All Parameters","text":"<pre><code>SAEMMethod(;\n    # Iteration control\n    n_burn = 200,              # Burn-in iterations (adaptation phase)\n    n_iter = 300,              # Main iterations (averaging phase)\n\n    # MCMC settings\n    n_chains = 3,              # Number of parallel chains per subject\n    n_mcmc_steps = 50,         # MCMC steps per E-step\n\n    # Proposal adaptation\n    adapt_proposal = true,     # Enable adaptive MH\n    target_acceptance = 0.3,   # Target acceptance rate (0.2-0.4)\n    adaptation_interval = 20,  # Adapt every N iterations\n\n    # Step size schedule\n    step_size_schedule = :standard,  # or :fast, :slow\n\n    # Convergence monitoring\n    track_diagnostics = true,  # Track MCMC diagnostics\n    use_all_chains = true,     # Average across all chains\n    parallel_chains = false    # Parallel chain execution (within subject)\n)\n</code></pre>"},{"location":"julia/estimation/saem/#step-size-schedules","title":"Step Size Schedules","text":"<p>The step size controls the stochastic approximation:</p> <pre><code># Standard schedule: \u03b3_k = 1 for k \u2264 n_burn, then \u03b3_k = 1/(k - n_burn + 1)\nSAEMMethod(step_size_schedule = :standard)\n\n# Fast convergence: \u03b3_k = 1/(k^0.6)\nSAEMMethod(step_size_schedule = :fast)\n\n# Slow (more stable): \u03b3_k = 1/(k^0.7)\nSAEMMethod(step_size_schedule = :slow)\n</code></pre>"},{"location":"julia/estimation/saem/#mcmc-details","title":"MCMC Details","text":""},{"location":"julia/estimation/saem/#metropolis-hastings-sampling","title":"Metropolis-Hastings Sampling","text":"<p>For each subject, SAEM samples eta from the posterior:</p> \\[p(\\eta_i | y_i, \\theta, \\Omega, \\sigma) \\propto p(y_i | \\eta_i, \\theta, \\sigma) \\cdot p(\\eta_i | \\Omega)\\] <p>The algorithm uses random walk MH with proposal:</p> \\[\\eta^* \\sim N(\\eta_{current}, \\sigma_{proposal}^2)\\]"},{"location":"julia/estimation/saem/#adaptive-proposals","title":"Adaptive Proposals","text":"<p>During burn-in, proposals are adapted to achieve target acceptance rate:</p> <pre><code># If acceptance rate &gt; target + 0.05: increase proposal SD by 10%\n# If acceptance rate &lt; target - 0.05: decrease proposal SD by 10%\n</code></pre>"},{"location":"julia/estimation/saem/#sufficient-statistics","title":"Sufficient Statistics","text":"<p>SAEM updates parameters using sufficient statistics computed from MCMC samples:</p>"},{"location":"julia/estimation/saem/#fixed-effects-update-theta","title":"Fixed Effects Update (theta)","text":"<p>Uses gradient-based update with stochastic approximation:</p> \\[\\theta_{k+1} = \\theta_k + \\gamma_k \\cdot \\nabla_\\theta Q(\\theta | \\eta_{sampled})\\]"},{"location":"julia/estimation/saem/#random-effects-update-omega","title":"Random Effects Update (omega)","text":"<p>Updates omega using empirical covariance:</p> \\[S_\\Omega^{(k+1)} = (1 - \\gamma_k) S_\\Omega^{(k)} + \\gamma_k \\cdot \\frac{1}{N} \\sum_{i=1}^N E[\\eta_i \\eta_i^T | y_i]\\] <p>The expectation is approximated by averaging over MCMC samples.</p>"},{"location":"julia/estimation/saem/#residual-error-update-sigma","title":"Residual Error Update (sigma)","text":"<p>Similar stochastic approximation for sigma parameters.</p>"},{"location":"julia/estimation/saem/#convergence-diagnostics","title":"Convergence Diagnostics","text":""},{"location":"julia/estimation/saem/#saemdiagnostics-structure","title":"SAEMDiagnostics Structure","text":"<pre><code>struct SAEMDiagnostics\n    acceptance_rates::Vector{Vector{Float64}}  # Per-subject, per-iteration\n    mean_acceptance_rate::Float64              # Overall mean\n    proposal_sds::Vector{Vector{Float64}}      # Final proposals per subject\n    theta_trace::Vector{Vector{Float64}}       # Theta history\n    omega_trace::Vector{Vector{Float64}}       # Omega history\n    ofv_trace::Vector{Float64}                 # OFV history\n    gelman_rubin::Vector{Float64}              # R-hat statistics\n    effective_sample_size::Vector{Float64}     # ESS per eta\n    converged::Bool                            # Convergence status\nend\n</code></pre>"},{"location":"julia/estimation/saem/#accessing-diagnostics","title":"Accessing Diagnostics","text":"<pre><code>result = saem_estimate(...)\n\n# MCMC diagnostics\ndiag = result.saem_diagnostics\nprintln(\"Mean acceptance rate: $(diag.mean_acceptance_rate)\")\nprintln(\"Gelman-Rubin R-hat: $(diag.gelman_rubin)\")\nprintln(\"Effective sample size: $(diag.effective_sample_size)\")\n\n# Trace plots\nusing Plots\nplot(diag.theta_trace, label=[\"CL\" \"V\"], title=\"Parameter Trace\")\nplot(diag.ofv_trace, title=\"OFV Convergence\")\n</code></pre>"},{"location":"julia/estimation/saem/#gelman-rubin-diagnostic","title":"Gelman-Rubin Diagnostic","text":"<p>R-hat should be &lt; 1.1 for convergence:</p> <pre><code># Check all R-hat values\nall(diag.gelman_rubin .&lt; 1.1)  # true = good convergence\n</code></pre>"},{"location":"julia/estimation/saem/#effective-sample-size","title":"Effective Sample Size","text":"<p>ESS should be &gt; 100 for reliable estimates:</p> <pre><code>minimum(diag.effective_sample_size) &gt; 100  # Check minimum ESS\n</code></pre>"},{"location":"julia/estimation/saem/#blq-handling-in-saem","title":"BLQ Handling in SAEM","text":"<p>SAEM supports all BLQ methods with proper likelihood integration:</p> <pre><code>blq_config = BLQConfig(\n    method = :M3,  # Censored likelihood (recommended)\n    lloq = 0.05\n)\n\nconfig = EstimationConfig(\n    method = SAEMMethod(),\n    # ... other options\n    blq_config = blq_config\n)\n</code></pre> <p>For M3, the BLQ contribution to the posterior is:</p> \\[p(y_{BLQ} | \\eta, \\theta, \\sigma) = \\Phi\\left(\\frac{LLOQ - f(\\eta, \\theta)}{\\sigma}\\right)\\]"},{"location":"julia/estimation/saem/#parallel-execution","title":"Parallel Execution","text":""},{"location":"julia/estimation/saem/#parallel-e-step","title":"Parallel E-Step","text":"<p>Run subjects in parallel using multiple threads:</p> <pre><code>using Base.Threads\n\n# Set threads before Julia starts: JULIA_NUM_THREADS=8\nprintln(\"Using $(nthreads()) threads\")\n\n# Enable parallel execution\nparallel_config = ParallelConfig(\n    ThreadedBackend(nthreads()),\n    seed = 12345,\n    load_balance = true,\n    progress = true\n)\n\nresult = saem_estimate(\n    observed, model_spec, config, grid, solver, rng;\n    parallel_config = parallel_config\n)\n</code></pre>"},{"location":"julia/estimation/saem/#parallel-chains","title":"Parallel Chains","text":"<p>Run multiple chains per subject in parallel:</p> <pre><code>config = EstimationConfig(\n    method = SAEMMethod(\n        n_chains = 4,\n        parallel_chains = true  # Chains run in parallel\n    ),\n    # ... other options\n)\n</code></pre>"},{"location":"julia/estimation/saem/#example-complex-model-with-high-iiv","title":"Example: Complex Model with High IIV","text":"<pre><code>using OpenPKPDCore\nusing StableRNGs\n\n# Simulate data with high variability\n# (In practice, load real data)\n\n# Transit compartment absorption model\nmodel = TransitAbsorption(n_transit=3)\nmodel_spec = ModelSpec(model, \"pk\", nothing, nothing)\n\n# High IIV scenario\nconfig = EstimationConfig(\n    method = SAEMMethod(\n        n_burn = 300,          # More burn-in for complex models\n        n_iter = 500,          # More iterations\n        n_chains = 4,          # More chains for better mixing\n        n_mcmc_steps = 100,    # More MCMC steps\n        target_acceptance = 0.25,\n        track_diagnostics = true\n    ),\n    theta_init = [5.0, 50.0, 0.5, 3],   # CL, V, ktr, n_transit\n    omega_init = diagm([0.36, 0.16, 0.49]),  # 60%, 40%, 70% CV\n    sigma_init = ResidualErrorSpec(\n        CombinedError(),\n        CombinedErrorParams(0.1, 0.15),\n        :conc\n    ),\n    omega_structure = :diagonal,\n    compute_se = true,\n    verbose = true,\n    seed = 42\n)\n\ngrid = SimGrid(0.0, 72.0, 0:0.5:72)\nsolver = SolverSpec(:Tsit5, 1e-8, 1e-10, 10^7)\n\nresult = saem_estimate(observed, model_spec, config, grid, solver, StableRNG(42))\n\n# Check convergence\nprintln(\"=== SAEM Results ===\")\nprintln(\"Converged: $(result.converged)\")\nprintln(\"Final OFV: $(result.ofv)\")\n\nprintln(\"\\nMCMC Diagnostics:\")\ndiag = result.saem_diagnostics\nprintln(\"  Mean acceptance: $(round(diag.mean_acceptance_rate, digits=2))\")\nprintln(\"  Max R-hat: $(round(maximum(diag.gelman_rubin), digits=3))\")\nprintln(\"  Min ESS: $(round(minimum(diag.effective_sample_size), digits=0))\")\n\nprintln(\"\\nParameter Estimates:\")\nprintln(\"  CL = $(round(result.theta[1], sigdigits=4)) ($(round(sqrt(result.omega[1,1])*100, digits=1))% IIV)\")\nprintln(\"  V  = $(round(result.theta[2], sigdigits=4)) ($(round(sqrt(result.omega[2,2])*100, digits=1))% IIV)\")\nprintln(\"  ktr = $(round(result.theta[3], sigdigits=4)) ($(round(sqrt(result.omega[3,3])*100, digits=1))% IIV)\")\n</code></pre>"},{"location":"julia/estimation/saem/#standard-errors-from-saem","title":"Standard Errors from SAEM","text":"<p>SAEM doesn't directly produce analytical SEs. Use bootstrap for uncertainty:</p> <pre><code># Run bootstrap after SAEM\nbootstrap_spec = BootstrapSpec(\n    n_bootstrap = 500,\n    parallel = true,\n    seed = 12345\n)\n\nbootstrap_result = run_bootstrap(\n    observed, model_spec, config, grid, solver,\n    result,  # Initial from SAEM\n    bootstrap_spec\n)\n\nprintln(\"Bootstrap SE: \", bootstrap_result.theta_se)\nprintln(\"Bootstrap 95% CI:\")\nfor i in 1:length(result.theta)\n    println(\"  \u03b8$i: [$(bootstrap_result.theta_ci_lower[i]), $(bootstrap_result.theta_ci_upper[i])]\")\nend\n</code></pre> <p>Alternatively, use Louis' missing information principle:</p> <pre><code># SE using Louis' method (based on MCMC samples)\nse_result = compute_standard_errors_marginal(\n    result.theta, result.omega, result.sigma,\n    subjects, model_spec, config;\n    method = LouisSE(n_importance_samples=200),\n    grid = grid,\n    solver = solver\n)\n</code></pre>"},{"location":"julia/estimation/saem/#algorithm-summary","title":"Algorithm Summary","text":""},{"location":"julia/estimation/saem/#saem-algorithm-steps","title":"SAEM Algorithm Steps","text":"<ol> <li>Initialize: Set theta, omega, sigma; initialize eta chains</li> <li>For k = 1 to K:</li> <li>E-step: For each subject, run MCMC to sample eta from posterior</li> <li>M-step: Update theta, omega, sigma using stochastic approximation</li> <li>If k \u2264 n_burn: step_size = 1 (exploration)</li> <li>If k &gt; n_burn: step_size = 1/(k - n_burn + 1) (averaging)</li> <li>Post-processing: Compute final OFV, individual estimates, diagnostics</li> </ol>"},{"location":"julia/estimation/saem/#mathematical-formulation","title":"Mathematical Formulation","text":"<p>E-step computes: $\\(Q_k(\\theta | \\theta_k) = E_{\\eta | y, \\theta_k}[\\log L(\\theta; y, \\eta)]\\)$</p> <p>M-step updates: $\\(\\theta_{k+1} = \\theta_k + \\gamma_k (\\hat{\\theta}_k - \\theta_k)\\)$</p> <p>Where \\(\\hat{\\theta}_k\\) maximizes the approximate Q function.</p>"},{"location":"julia/estimation/saem/#comparison-with-foce-i","title":"Comparison with FOCE-I","text":"Aspect FOCE-I SAEM Eta estimation Mode (optimization) Posterior samples (MCMC) Local minima Susceptible More robust Computation Faster Slower Standard errors Analytical Bootstrap/Louis High IIV Can struggle Handles well Sparse data Fair Good"},{"location":"julia/estimation/saem/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Faster alternative for standard models</li> <li>Laplacian Method - For sparse data</li> <li>Bootstrap - Uncertainty quantification for SAEM</li> <li>Diagnostics - Model validation</li> </ul>"},{"location":"julia/import/","title":"Model Import","text":"<p>OpenPKPD can import models from other pharmacometrics platforms, enabling migration and interoperability.</p>"},{"location":"julia/import/#supported-formats","title":"Supported Formats","text":"<ul> <li> <p> NONMEM</p> <p>Parse NONMEM control stream files (.ctl, .mod)</p> <p> NONMEM Import</p> </li> <li> <p> Monolix</p> <p>Parse Monolix project files (.mlxtran)</p> <p> Monolix Import</p> </li> <li> <p> CDISC Data</p> <p>Import CDISC/SDTM formatted data</p> <p> CDISC Import</p> </li> </ul>"},{"location":"julia/import/#nonmem-import","title":"NONMEM Import","text":""},{"location":"julia/import/#supported-features","title":"Supported Features","text":"Feature Support Notes ADVAN1 (1-comp IV) \u2705 Full Direct mapping ADVAN2 (1-comp oral) \u2705 Full Ka, CL, V ADVAN3 (2-comp IV) \u2705 Full CL, V1, Q, V2 ADVAN4 (2-comp oral) \u2705 Full Ka, CL, V1, Q, V2 ADVAN11 (3-comp IV) \u2705 Full Full three-comp ADVAN12 (3-comp oral) \u2705 Full With absorption TRANS parameters \u2705 Full TRANS1-4 $THETA \u2705 Full Fixed effects $OMEGA \u2705 Full Random effects $SIGMA \u2705 Full Residual error $ERROR \u26a0\ufe0f Partial Common patterns $PK \u26a0\ufe0f Partial Standard code"},{"location":"julia/import/#quick-start","title":"Quick Start","text":"<pre><code>using OpenPKPDCore\n\n# Import NONMEM control stream\nmodel = import_nonmem(\"run001.ctl\")\n\n# Access parsed components\nprintln(\"Model type: \", model.advan)\nprintln(\"THETA: \", model.theta)\nprintln(\"OMEGA: \", model.omega)\n\n# Convert to OpenPKPD ModelSpec\nspec = to_model_spec(model)\n</code></pre>"},{"location":"julia/import/#cli-usage","title":"CLI Usage","text":"<pre><code>./bin/openpkpd import --input run001.ctl --format nonmem --out model.json\n</code></pre>"},{"location":"julia/import/#monolix-import","title":"Monolix Import","text":""},{"location":"julia/import/#supported-features_1","title":"Supported Features","text":"Feature Support Structural models \u2705 Full Parameter definitions \u2705 Full Random effects \u2705 Full Covariate models \u26a0\ufe0f Partial Error models \u2705 Full"},{"location":"julia/import/#quick-start_1","title":"Quick Start","text":"<pre><code># Import Monolix project\nmodel = import_monolix(\"project.mlxtran\")\n\n# Convert to OpenPKPD\nspec = to_model_spec(model)\n</code></pre>"},{"location":"julia/import/#cdisc-data-import","title":"CDISC Data Import","text":""},{"location":"julia/import/#supported-domains","title":"Supported Domains","text":"Domain Description Support PC Pharmacokinetic Concentrations \u2705 Full EX Exposure (Dosing) \u2705 Full DM Demographics \u2705 Full VS Vital Signs \u26a0\ufe0f Partial LB Laboratory \u26a0\ufe0f Partial"},{"location":"julia/import/#quick-start_2","title":"Quick Start","text":"<pre><code># Import CDISC data\ndata = import_cdisc(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\",\n    format = :csv           # or :xpt for SAS transport\n)\n\n# Access standardized data\nprintln(\"Subjects: \", length(unique(data.usubjid)))\nprintln(\"Observations: \", length(data.dv))\n</code></pre>"},{"location":"julia/import/#data-structure","title":"Data Structure","text":"<pre><code>struct CDISCData\n    # Subject identifiers\n    usubjid::Vector{String}\n    subjid::Vector{Int}\n\n    # Time and observations\n    times::Vector{Float64}\n    dv::Vector{Float64}\n\n    # Dosing\n    doses::Vector{DoseEvent}\n    dose_times::Vector{Float64}\n    dose_amounts::Vector{Float64}\n\n    # Demographics\n    age::Vector{Float64}\n    sex::Vector{Symbol}\n    weight::Vector{Float64}\n\n    # Metadata\n    study::String\n    analyte::String\nend\n</code></pre>"},{"location":"julia/import/#migration-workflow","title":"Migration Workflow","text":""},{"location":"julia/import/#nonmem-to-openpkpd","title":"NONMEM to OpenPKPD","text":"<pre><code>graph LR\n    A[NONMEM .ctl] --&gt; B[import_nonmem]\n    B --&gt; C[ParsedModel]\n    C --&gt; D[to_model_spec]\n    D --&gt; E[OpenPKPD ModelSpec]\n    E --&gt; F[Simulate/Estimate]\n</code></pre>"},{"location":"julia/import/#step-by-step","title":"Step-by-Step","text":"<ol> <li> <p>Parse control stream <pre><code>parsed = import_nonmem(\"run001.ctl\")\n</code></pre></p> </li> <li> <p>Review parsed model <pre><code>println(\"ADVAN: \", parsed.advan)\nprintln(\"Parameters: \", parsed.theta)\nprintln(\"Random effects: \", parsed.omega)\n</code></pre></p> </li> <li> <p>Convert to OpenPKPD <pre><code>spec = to_model_spec(parsed)\n</code></pre></p> </li> <li> <p>Validate with simulation <pre><code>result = simulate(spec, grid, solver)\n</code></pre></p> </li> <li> <p>Compare to NONMEM output <pre><code># Load NONMEM predictions\nnm_pred = load_nonmem_output(\"run001.tab\")\n\n# Compare\n@assert isapprox(result.observations[:conc], nm_pred.IPRED, rtol=0.01)\n</code></pre></p> </li> </ol>"},{"location":"julia/import/#limitations","title":"Limitations","text":""},{"location":"julia/import/#nonmem","title":"NONMEM","text":"<ul> <li>Custom \\(PK/\\)ERROR blocks may not parse correctly</li> <li>User-defined ADVAN/TRANS not supported</li> <li>Complex conditional logic requires manual conversion</li> </ul>"},{"location":"julia/import/#monolix","title":"Monolix","text":"<ul> <li>Custom structural models need adaptation</li> <li>Some advanced features may not translate</li> </ul>"},{"location":"julia/import/#workarounds","title":"Workarounds","text":"<p>For unsupported features:</p> <ol> <li>Simplify the NONMEM code before import</li> <li>Manually define the OpenPKPD model</li> <li>Use the CLI <code>--validate</code> flag to check import accuracy</li> </ol>"},{"location":"julia/import/#next-steps","title":"Next Steps","text":"<ul> <li>NONMEM Details - Complete NONMEM import guide</li> <li>Monolix Details - Monolix project import</li> <li>CDISC Details - CDISC data format support</li> </ul>"},{"location":"julia/import/cdisc/","title":"CDISC Data Import","text":"<p>Comprehensive guide for importing CDISC/SDTM and ADaM formatted data into OpenPKPD.</p>"},{"location":"julia/import/cdisc/#overview","title":"Overview","text":"<p>OpenPKPD supports importing data from CDISC (Clinical Data Interchange Standards Consortium) formats, including SDTM (Study Data Tabulation Model) and ADaM (Analysis Data Model) datasets.</p> <pre><code>using OpenPKPDCore\n\n# Import CDISC data\ndata = import_cdisc(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\"\n)\n</code></pre>"},{"location":"julia/import/cdisc/#supported-domains","title":"Supported Domains","text":""},{"location":"julia/import/cdisc/#sdtm-domains","title":"SDTM Domains","text":"Domain Full Name Description Support PC Pharmacokinetic Concentrations Drug concentration measurements \u2705 Full PP Pharmacokinetic Parameters Derived PK parameters \u2705 Full EX Exposure Dosing information \u2705 Full DM Demographics Subject characteristics \u2705 Full VS Vital Signs Weight, height, etc. \u26a0\ufe0f Partial LB Laboratory Lab test results \u26a0\ufe0f Partial"},{"location":"julia/import/cdisc/#adam-datasets","title":"ADaM Datasets","text":"Dataset Description Support ADPC Analysis PK Concentrations \u2705 Full ADPP Analysis PK Parameters \u2705 Full ADSL Subject-Level Analysis \u2705 Full ADEX Analysis Exposure \u26a0\ufe0f Partial"},{"location":"julia/import/cdisc/#pc-domain-pharmacokinetic-concentrations","title":"PC Domain (Pharmacokinetic Concentrations)","text":""},{"location":"julia/import/cdisc/#required-variables","title":"Required Variables","text":"Variable Label Type Description STUDYID Study Identifier Char Unique study ID USUBJID Unique Subject ID Char Unique subject identifier PCTESTCD Test Code Char Short test name (e.g., \"DRUG\") PCTEST Test Name Char Full test name PCORRES Original Result Char Result as collected PCSTRESN Numeric Result Num Standardized numeric result PCSTRESU Unit Char Units (ng/mL, \u00b5g/L, etc.) PCELTM Elapsed Time Char Time from reference (ISO 8601)"},{"location":"julia/import/cdisc/#optional-variables","title":"Optional Variables","text":"Variable Label Description PCLLOQ Lower LOQ Lower limit of quantification PCSTAT Status Completion status (null or \"NOT DONE\") PCREASND Reason Not Done Reason if PCSTAT=\"NOT DONE\" PCBLFL Baseline Flag \"Y\" for baseline records PCSPEC Specimen Specimen type (PLASMA, SERUM, etc.) PCMETHOD Method Analytical method VISITNUM Visit Number Planned visit number VISIT Visit Name Visit description PCDTC Collection Datetime ISO 8601 datetime PCDY Study Day Study day of collection"},{"location":"julia/import/cdisc/#example-pc-data","title":"Example PC Data","text":"<pre><code>STUDYID,USUBJID,PCTESTCD,PCTEST,PCSTRESN,PCSTRESU,PCELTM,PCDTC,PCSPEC,PCLLOQ\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,0.0,ng/mL,PT0H,2024-01-15T08:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,125.3,ng/mL,PT1H,2024-01-15T09:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,89.7,ng/mL,PT2H,2024-01-15T10:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,52.1,ng/mL,PT4H,2024-01-15T12:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,28.4,ng/mL,PT8H,2024-01-15T16:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,12.1,ng/mL,PT12H,2024-01-15T20:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A Concentration,3.2,ng/mL,PT24H,2024-01-16T08:00,PLASMA,0.5\n</code></pre>"},{"location":"julia/import/cdisc/#ex-domain-exposure","title":"EX Domain (Exposure)","text":""},{"location":"julia/import/cdisc/#required-variables_1","title":"Required Variables","text":"Variable Label Type Description STUDYID Study Identifier Char Unique study ID USUBJID Unique Subject ID Char Unique subject identifier EXDOSE Dose Num Administered dose amount EXDOSU Dose Units Char Units (mg, \u00b5g, etc.) EXROUTE Route Char Route of administration EXSTDTC Start Datetime Char Dose start (ISO 8601)"},{"location":"julia/import/cdisc/#optional-variables_1","title":"Optional Variables","text":"Variable Label Description EXENDTC End Datetime Dose end (for infusions) EXDOSFRM Dose Form TABLET, CAPSULE, SOLUTION, etc. EXDOSFRQ Dosing Frequency QD, BID, Q12H, etc. EXDUR Duration Infusion duration (ISO 8601) EXTRT Treatment Treatment name EXSEQ Sequence Sequence number VISITNUM Visit Number Planned visit number EXDY Study Day Study day of dose"},{"location":"julia/import/cdisc/#example-ex-data","title":"Example EX Data","text":"<pre><code>STUDYID,USUBJID,EXTRT,EXDOSE,EXDOSU,EXROUTE,EXDOSFRM,EXSTDTC,EXDY\nSTUDY01,SUBJ001,Drug A,100,mg,ORAL,TABLET,2024-01-15T08:00,1\nSTUDY01,SUBJ001,Drug A,100,mg,ORAL,TABLET,2024-01-16T08:00,2\nSTUDY01,SUBJ002,Drug A,200,mg,ORAL,TABLET,2024-01-15T08:00,1\nSTUDY01,SUBJ002,Drug A,200,mg,ORAL,TABLET,2024-01-16T08:00,2\n</code></pre>"},{"location":"julia/import/cdisc/#dm-domain-demographics","title":"DM Domain (Demographics)","text":""},{"location":"julia/import/cdisc/#required-variables_2","title":"Required Variables","text":"Variable Label Type Description STUDYID Study Identifier Char Unique study ID USUBJID Unique Subject ID Char Unique subject identifier SUBJID Subject ID Char Subject identifier within study RFSTDTC Reference Start Char Reference start date (ISO 8601) RFENDTC Reference End Char Reference end date"},{"location":"julia/import/cdisc/#optional-variables_2","title":"Optional Variables","text":"Variable Label Description AGE Age Age at screening AGEU Age Units YEARS, MONTHS, etc. SEX Sex M, F, U RACE Race Racial designation ETHNIC Ethnicity Ethnic group ARMCD Arm Code Treatment arm code ARM Arm Description Treatment arm description COUNTRY Country Country of participation SITEID Site Identifier Study site ID DMDTC Collection Date Demographics collection date"},{"location":"julia/import/cdisc/#example-dm-data","title":"Example DM Data","text":"<pre><code>STUDYID,USUBJID,SUBJID,AGE,AGEU,SEX,RACE,ETHNIC,ARM,ARMCD,RFSTDTC\nSTUDY01,SUBJ001,001,45,YEARS,M,WHITE,NOT HISPANIC OR LATINO,Treatment A,TRT_A,2024-01-15\nSTUDY01,SUBJ002,002,38,YEARS,F,ASIAN,NOT HISPANIC OR LATINO,Treatment A,TRT_A,2024-01-15\nSTUDY01,SUBJ003,003,52,YEARS,M,BLACK OR AFRICAN AMERICAN,NOT HISPANIC OR LATINO,Treatment B,TRT_B,2024-01-15\n</code></pre>"},{"location":"julia/import/cdisc/#pp-domain-pk-parameters","title":"PP Domain (PK Parameters)","text":""},{"location":"julia/import/cdisc/#required-variables_3","title":"Required Variables","text":"Variable Label Type Description STUDYID Study Identifier Char Unique study ID USUBJID Unique Subject ID Char Unique subject identifier PPTESTCD Parameter Code Char Short parameter name PPTEST Parameter Name Char Full parameter name PPSTRESN Numeric Result Num Standardized result PPSTRESU Units Char Result units"},{"location":"julia/import/cdisc/#common-pk-parameter-codes","title":"Common PK Parameter Codes","text":"PPTESTCD Description Units CMAX Maximum Concentration ng/mL TMAX Time to Maximum h AUCLST AUC to Last ng\u00b7h/mL AUCIFO AUC Extrapolated ng\u00b7h/mL LAMZ Lambda z 1/h LAMZHL Terminal Half-life h CLFO Clearance L/h VZFO Volume of Distribution L"},{"location":"julia/import/cdisc/#example-pp-data","title":"Example PP Data","text":"<pre><code>STUDYID,USUBJID,PPTESTCD,PPTEST,PPSTRESN,PPSTRESU,PPCAT\nSTUDY01,SUBJ001,CMAX,Maximum Concentration,125.3,ng/mL,PK PARAMETERS\nSTUDY01,SUBJ001,TMAX,Time to Maximum,1.0,h,PK PARAMETERS\nSTUDY01,SUBJ001,AUCLST,AUC to Last Observation,845.2,ng.h/mL,PK PARAMETERS\nSTUDY01,SUBJ001,AUCIFO,AUC Extrapolated to Infinity,892.4,ng.h/mL,PK PARAMETERS\nSTUDY01,SUBJ001,LAMZHL,Terminal Half-life,8.5,h,PK PARAMETERS\n</code></pre>"},{"location":"julia/import/cdisc/#import-functions","title":"Import Functions","text":""},{"location":"julia/import/cdisc/#basic-import","title":"Basic Import","text":"<pre><code>using OpenPKPDCore\n\n# Import from CSV files\ndata = import_cdisc(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\"\n)\n\n# Access imported data\nprintln(\"Subjects: $(length(data.subjects))\")\nprintln(\"Total observations: $(n_observations(data))\")\n</code></pre>"},{"location":"julia/import/cdisc/#individual-domain-import","title":"Individual Domain Import","text":"<pre><code># Import PC domain only\npc_data = read_cdisc_pc(\"pc.csv\")\n\n# Import EX domain only\nex_data = read_cdisc_ex(\"ex.csv\")\n\n# Import DM domain only\ndm_data = read_cdisc_dm(\"dm.csv\")\n\n# Combine manually\ndata = cdisc_to_observed_data(pc_data, ex_data, dm_data)\n</code></pre>"},{"location":"julia/import/cdisc/#import-from-sas-transport-xpt","title":"Import from SAS Transport (XPT)","text":"<pre><code># Import XPT files\ndata = import_cdisc(\n    pc_path = \"pc.xpt\",\n    ex_path = \"ex.xpt\",\n    dm_path = \"dm.xpt\",\n    format = :xpt\n)\n</code></pre>"},{"location":"julia/import/cdisc/#data-structures","title":"Data Structures","text":""},{"location":"julia/import/cdisc/#observeddata","title":"ObservedData","text":"<pre><code>struct ObservedData\n    subjects::Vector{SubjectData}  # All subjects\n    study_id::String               # Study identifier\n    analyte::String                # Drug/analyte name\n    units::String                  # Concentration units\n    time_units::String             # Time units\nend\n</code></pre>"},{"location":"julia/import/cdisc/#subjectdata","title":"SubjectData","text":"<pre><code>struct SubjectData\n    subject_id::String             # Unique subject ID\n    times::Vector{Float64}         # Time points (h from first dose)\n    observations::Vector{Float64}  # Concentrations\n    doses::Vector{DoseEvent}       # Dose events\n    covariates::Dict{Symbol,Any}   # Age, weight, sex, etc.\n    lloq::Float64                  # Lower limit of quantification\n    blq_flags::Vector{Bool}        # Below LOQ indicators\nend\n</code></pre>"},{"location":"julia/import/cdisc/#accessing-subject-data","title":"Accessing Subject Data","text":"<pre><code>data = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\")\n\n# Iterate through subjects\nfor subj in data.subjects\n    println(\"Subject: $(subj.subject_id)\")\n    println(\"  Time points: $(length(subj.times))\")\n    println(\"  Doses: $(length(subj.doses))\")\n    println(\"  Age: $(subj.covariates[:age])\")\n    println(\"  Weight: $(subj.covariates[:weight])\")\nend\n\n# Get specific subject\nsubj = get_subject(data, \"SUBJ001\")\n</code></pre>"},{"location":"julia/import/cdisc/#time-handling","title":"Time Handling","text":""},{"location":"julia/import/cdisc/#elapsed-time-parsing","title":"Elapsed Time Parsing","text":"<pre><code># PCELTM format (ISO 8601 duration)\n# PT0H = 0 hours (pre-dose)\n# PT1H = 1 hour post-dose\n# PT2H30M = 2.5 hours post-dose\n# P1DT2H = 1 day + 2 hours = 26 hours\n\n# OpenPKPD converts to numeric hours from first dose\n</code></pre>"},{"location":"julia/import/cdisc/#reference-time","title":"Reference Time","text":"<pre><code># Time is calculated relative to:\n# 1. First dose in EX domain (EXSTDTC)\n# 2. Or reference start date in DM (RFSTDTC)\n\n# Custom reference time\ndata = import_cdisc(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\",\n    reference_time = :first_dose  # or :rfstdtc\n)\n</code></pre>"},{"location":"julia/import/cdisc/#blq-handling","title":"BLQ Handling","text":""},{"location":"julia/import/cdisc/#detection","title":"Detection","text":"<pre><code># BLQ detected from:\n# 1. PCSTRESN == 0 or missing\n# 2. PCSTAT == \"NOT DONE\"\n# 3. PCORRES contains \"&lt;\", \"BLQ\", \"BLOQ\"\n# 4. PCSTRESN &lt; PCLLOQ\n\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\")\n\n# Access BLQ flags\nfor subj in data.subjects\n    n_blq = sum(subj.blq_flags)\n    println(\"Subject $(subj.subject_id): $(n_blq) BLQ samples\")\nend\n</code></pre>"},{"location":"julia/import/cdisc/#blq-handling-options","title":"BLQ Handling Options","text":"<pre><code># Default: BLQ values set to 0\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\",\n    blq_handling = :zero\n)\n\n# Set BLQ to LLOQ/2\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\",\n    blq_handling = :lloq_half\n)\n\n# Keep as missing (NaN)\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\",\n    blq_handling = :missing\n)\n</code></pre>"},{"location":"julia/import/cdisc/#validation","title":"Validation","text":""},{"location":"julia/import/cdisc/#automatic-validation","title":"Automatic Validation","text":"<pre><code># Validation checks performed automatically:\n# 1. Required columns present\n# 2. Data types correct\n# 3. Subject IDs consistent across domains\n# 4. Dose information available for PK subjects\n# 5. No negative concentrations\n# 6. Time sequence valid\n\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\")\n\n# Check validation results\nif !isempty(data.validation_warnings)\n    println(\"Validation warnings:\")\n    for w in data.validation_warnings\n        println(\"  \u26a0\ufe0f $w\")\n    end\nend\n</code></pre>"},{"location":"julia/import/cdisc/#manual-validation","title":"Manual Validation","text":"<pre><code># Validate before import\nvalidation = validate_cdisc_dataset(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\"\n)\n\nif validation.valid\n    println(\"\u2713 Dataset passes validation\")\n    data = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\")\nelse\n    println(\"\u274c Validation failed:\")\n    for error in validation.errors\n        println(\"  - $error\")\n    end\nend\n</code></pre>"},{"location":"julia/import/cdisc/#dose-reconstruction","title":"Dose Reconstruction","text":""},{"location":"julia/import/cdisc/#from-ex-domain","title":"From EX Domain","text":"<pre><code># Doses automatically extracted from EX domain\n# Route mapping:\n# ORAL \u2192 :oral\n# INTRAVENOUS \u2192 :iv_bolus\n# INTRAVENOUS INFUSION \u2192 :iv_infusion\n# SUBCUTANEOUS \u2192 :subcutaneous\n# INTRAMUSCULAR \u2192 :intramuscular\n\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\")\n\nfor subj in data.subjects\n    for dose in subj.doses\n        println(\"Dose: $(dose.amount) $(dose.units) at $(dose.time)h via $(dose.route)\")\n    end\nend\n</code></pre>"},{"location":"julia/import/cdisc/#multiple-dose-handling","title":"Multiple Dose Handling","text":"<pre><code># Multiple doses per subject are supported\n# Dose times relative to first dose\n\n# For steady-state data:\ndata = import_cdisc(\n    pc_path = \"pc_ss.csv\",\n    ex_path = \"ex_ss.csv\",\n    dm_path = \"dm.csv\",\n    dosing_type = :steady_state,\n    tau = 24.0  # Dosing interval\n)\n</code></pre>"},{"location":"julia/import/cdisc/#covariate-extraction","title":"Covariate Extraction","text":""},{"location":"julia/import/cdisc/#from-dm-domain","title":"From DM Domain","text":"<pre><code># Standard covariates extracted:\n# - age (AGE)\n# - sex (SEX \u2192 :M, :F)\n# - weight (if in DM or VS)\n# - race (RACE)\n# - ethnicity (ETHNIC)\n\ndata = import_cdisc(pc_path=\"pc.csv\", ex_path=\"ex.csv\", dm_path=\"dm.csv\")\n\n# Access covariates\nfor subj in data.subjects\n    println(\"Subject $(subj.subject_id):\")\n    println(\"  Age: $(subj.covariates[:age])\")\n    println(\"  Sex: $(subj.covariates[:sex])\")\n    println(\"  Weight: $(get(subj.covariates, :weight, \"N/A\"))\")\nend\n</code></pre>"},{"location":"julia/import/cdisc/#additional-covariates-from-vslb","title":"Additional Covariates from VS/LB","text":"<pre><code># Include vital signs\ndata = import_cdisc(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\",\n    vs_path = \"vs.csv\",  # Include vital signs\n    covariates = [:weight, :height, :bmi]\n)\n</code></pre>"},{"location":"julia/import/cdisc/#complete-example","title":"Complete Example","text":""},{"location":"julia/import/cdisc/#sample-dataset-files","title":"Sample Dataset Files","text":"<p>pc.csv: <pre><code>STUDYID,USUBJID,PCTESTCD,PCTEST,PCSTRESN,PCSTRESU,PCELTM,PCDTC,PCSPEC,PCLLOQ\nSTUDY01,SUBJ001,DRUGA,Drug A,0.0,ng/mL,PT0H,2024-01-15T08:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A,125.3,ng/mL,PT1H,2024-01-15T09:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A,89.7,ng/mL,PT2H,2024-01-15T10:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A,52.1,ng/mL,PT4H,2024-01-15T12:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A,28.4,ng/mL,PT8H,2024-01-15T16:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A,12.1,ng/mL,PT12H,2024-01-15T20:00,PLASMA,0.5\nSTUDY01,SUBJ001,DRUGA,Drug A,3.2,ng/mL,PT24H,2024-01-16T08:00,PLASMA,0.5\nSTUDY01,SUBJ002,DRUGA,Drug A,0.0,ng/mL,PT0H,2024-01-15T08:00,PLASMA,0.5\nSTUDY01,SUBJ002,DRUGA,Drug A,198.5,ng/mL,PT1H,2024-01-15T09:00,PLASMA,0.5\nSTUDY01,SUBJ002,DRUGA,Drug A,142.3,ng/mL,PT2H,2024-01-15T10:00,PLASMA,0.5\n</code></pre></p> <p>ex.csv: <pre><code>STUDYID,USUBJID,EXTRT,EXDOSE,EXDOSU,EXROUTE,EXDOSFRM,EXSTDTC,EXDY\nSTUDY01,SUBJ001,Drug A,100,mg,ORAL,TABLET,2024-01-15T08:00,1\nSTUDY01,SUBJ002,Drug A,200,mg,ORAL,TABLET,2024-01-15T08:00,1\n</code></pre></p> <p>dm.csv: <pre><code>STUDYID,USUBJID,SUBJID,AGE,AGEU,SEX,RACE,ETHNIC,ARM,ARMCD,RFSTDTC\nSTUDY01,SUBJ001,001,45,YEARS,M,WHITE,NOT HISPANIC OR LATINO,100mg,TRT100,2024-01-15\nSTUDY01,SUBJ002,002,38,YEARS,F,ASIAN,NOT HISPANIC OR LATINO,200mg,TRT200,2024-01-15\n</code></pre></p>"},{"location":"julia/import/cdisc/#julia-import-code","title":"Julia Import Code","text":"<pre><code>using OpenPKPDCore\n\n# Import CDISC data\ndata = import_cdisc(\n    pc_path = \"pc.csv\",\n    ex_path = \"ex.csv\",\n    dm_path = \"dm.csv\"\n)\n\n# Display import results\nprintln(\"=\" ^ 50)\nprintln(\"CDISC Data Import Results\")\nprintln(\"=\" ^ 50)\n\nprintln(\"\\n--- Study Information ---\")\nprintln(\"Study ID: $(data.study_id)\")\nprintln(\"Analyte: $(data.analyte)\")\nprintln(\"Units: $(data.units)\")\n\nprintln(\"\\n--- Dataset Summary ---\")\nprintln(\"Total subjects: $(length(data.subjects))\")\nprintln(\"Total observations: $(n_observations(data))\")\n\nprintln(\"\\n--- Subject Details ---\")\nfor subj in data.subjects\n    println(\"\\nSubject $(subj.subject_id):\")\n    println(\"  Observations: $(length(subj.times))\")\n    println(\"  Time range: $(minimum(subj.times)) to $(maximum(subj.times)) h\")\n    println(\"  Doses: $(length(subj.doses))\")\n\n    if !isempty(subj.doses)\n        dose = subj.doses[1]\n        println(\"  First dose: $(dose.amount) mg at $(dose.time)h\")\n    end\n\n    println(\"  Covariates:\")\n    println(\"    Age: $(subj.covariates[:age]) years\")\n    println(\"    Sex: $(subj.covariates[:sex])\")\n\n    n_blq = sum(subj.blq_flags)\n    if n_blq &gt; 0\n        println(\"  BLQ samples: $n_blq\")\n    end\nend\n\n# Convert to DataFrame for analysis\nprintln(\"\\n--- Export to DataFrame ---\")\ndf = to_dataframe(data)\nprintln(\"DataFrame created with $(nrow(df)) rows\")\n\n# Use with NCA\nprintln(\"\\n--- NCA Analysis ---\")\nfor subj in data.subjects\n    result = run_nca(subj.times, subj.observations, subj.doses[1].amount)\n    println(\"Subject $(subj.subject_id):\")\n    println(\"  Cmax: $(round(result.cmax, digits=2)) $(data.units)\")\n    println(\"  Tmax: $(result.tmax) h\")\n    println(\"  AUC0-inf: $(round(result.auc_0_inf, digits=2)) $(data.units)\u00b7h\")\nend\n</code></pre>"},{"location":"julia/import/cdisc/#expected-output","title":"Expected Output","text":"<pre><code>==================================================\nCDISC Data Import Results\n==================================================\n\n--- Study Information ---\nStudy ID: STUDY01\nAnalyte: Drug A\nUnits: ng/mL\n\n--- Dataset Summary ---\nTotal subjects: 2\nTotal observations: 10\n\n--- Subject Details ---\n\nSubject SUBJ001:\n  Observations: 7\n  Time range: 0.0 to 24.0 h\n  Doses: 1\n  First dose: 100.0 mg at 0.0h\n  Covariates:\n    Age: 45 years\n    Sex: M\n\nSubject SUBJ002:\n  Observations: 3\n  Time range: 0.0 to 2.0 h\n  Doses: 1\n  First dose: 200.0 mg at 0.0h\n  Covariates:\n    Age: 38 years\n    Sex: F\n\n--- Export to DataFrame ---\nDataFrame created with 10 rows\n\n--- NCA Analysis ---\nSubject SUBJ001:\n  Cmax: 125.3 ng/mL\n  Tmax: 1.0 h\n  AUC0-inf: 523.45 ng/mL\u00b7h\nSubject SUBJ002:\n  Cmax: 198.5 ng/mL\n  Tmax: 1.0 h\n  AUC0-inf: N/A (insufficient data)\n</code></pre>"},{"location":"julia/import/cdisc/#adam-import","title":"ADaM Import","text":""},{"location":"julia/import/cdisc/#adpc-dataset","title":"ADPC Dataset","text":"<pre><code># Import ADaM PK concentrations\nadpc = import_adam_adpc(\"adpc.csv\")\n\n# ADaM-specific variables:\n# AVAL - Analysis value\n# ATPT - Analysis timepoint\n# ATPTN - Analysis timepoint (numeric)\n# TRTP - Planned treatment\n# TRTA - Actual treatment\n</code></pre>"},{"location":"julia/import/cdisc/#adsl-dataset","title":"ADSL Dataset","text":"<pre><code># Import subject-level dataset\nadsl = import_adam_adsl(\"adsl.csv\")\n\n# Subject-level variables merged automatically\n# with concentration data\n</code></pre>"},{"location":"julia/import/cdisc/#combined-adam-import","title":"Combined ADaM Import","text":"<pre><code>data = import_adam(\n    adpc_path = \"adpc.csv\",\n    adsl_path = \"adsl.csv\"\n)\n</code></pre>"},{"location":"julia/import/cdisc/#helper-functions","title":"Helper Functions","text":""},{"location":"julia/import/cdisc/#data-access","title":"Data Access","text":"<pre><code># Get all subject IDs\nids = subject_ids(data)\n\n# Get number of subjects\nn = n_subjects(data)\n\n# Get total observations\nn_obs = n_observations(data)\n\n# Get pooled times and observations\nall_t = all_times(data)\nall_c = all_observations(data)\n</code></pre>"},{"location":"julia/import/cdisc/#data-filtering","title":"Data Filtering","text":"<pre><code># Filter by treatment arm\narm_a = filter_by_arm(data, \"TRT_A\")\n\n# Filter by sex\nmales = filter_by_covariate(data, :sex, :M)\n\n# Filter by dose\nhigh_dose = filter_by_dose(data, dose -&gt; dose &gt;= 200)\n</code></pre>"},{"location":"julia/import/cdisc/#export","title":"Export","text":"<pre><code># Export to DataFrame\ndf = to_dataframe(data)\n\n# Export to NONMEM format\nexport_nonmem_data(data, \"nm_data.csv\")\n\n# Export to Monolix format\nexport_monolix_data(data, \"mlx_data.csv\")\n</code></pre>"},{"location":"julia/import/cdisc/#see-also","title":"See Also","text":"<ul> <li>NONMEM Import - Import NONMEM control files</li> <li>Monolix Import - Import Monolix projects</li> <li>Population NCA - Population NCA analysis</li> </ul>"},{"location":"julia/import/monolix/","title":"Monolix Import","text":"<p>Comprehensive guide for importing Monolix project files (.mlxtran) into OpenPKPD.</p>"},{"location":"julia/import/monolix/#overview","title":"Overview","text":"<p>OpenPKPD can parse Monolix project files and convert them to native OpenPKPD model specifications, enabling migration from Monolix workflows.</p> <pre><code>using OpenPKPDCore\n\nresult = import_monolix(\"project.mlxtran\")\nprintln(\"Model: $(result.model_type)\")\nprintln(\"Parameters: $(result.parameters)\")\n</code></pre>"},{"location":"julia/import/monolix/#quick-start","title":"Quick Start","text":""},{"location":"julia/import/monolix/#basic-import","title":"Basic Import","text":"<pre><code>using OpenPKPDCore\n\n# Import Monolix project file\nresult = import_monolix(\"project.mlxtran\")\n\n# Access the converted model\nmodel_spec = result.spec\n\n# Simulate with the imported model\ntimes = 0.0:0.5:24.0\ndose = DoseEvent(time=0.0, amount=100.0)\nsim = simulate_single(model_spec, collect(times), [dose])\n</code></pre>"},{"location":"julia/import/monolix/#with-dose-events","title":"With Dose Events","text":"<pre><code># Specify doses if needed\ndoses = [\n    DoseEvent(time=0.0, amount=100.0, route=:oral)\n]\n\nresult = import_monolix(\"project.mlxtran\"; doses=doses)\n</code></pre>"},{"location":"julia/import/monolix/#supported-model-types","title":"Supported Model Types","text":""},{"location":"julia/import/monolix/#pharmacokinetic-models","title":"Pharmacokinetic Models","text":"Monolix Model OpenPKPD Model <code>pk_bolus1cpt_Vk_PLASMA</code> <code>:OneCompIVBolus</code> <code>pk_bolus1cpt_VCl_PLASMA</code> <code>:OneCompIVBolus</code> <code>pk_oral1cpt_kaVk_PLASMA</code> <code>:OneCompOralFirstOrder</code> <code>pk_oral1cpt_kaVCl_PLASMA</code> <code>:OneCompOralFirstOrder</code> <code>pk_bolus2cpt_V1k12k21k_PLASMA</code> <code>:TwoCompIVBolus</code> <code>pk_bolus2cpt_V1ClQ2V2_PLASMA</code> <code>:TwoCompIVBolus</code> <code>pk_oral2cpt_kaV1k12k21k_PLASMA</code> <code>:TwoCompOral</code> <code>pk_oral2cpt_kaV1ClQ2V2_PLASMA</code> <code>:TwoCompOral</code> <code>pk_bolus3cpt_V1ClQ2V2Q3V3_PLASMA</code> <code>:ThreeCompIVBolus</code> <code>pk_bolus1cpt_VVmKm_PLASMA</code> <code>:MichaelisMentenElimination</code>"},{"location":"julia/import/monolix/#model-name-pattern-recognition","title":"Model Name Pattern Recognition","text":"<pre><code># Monolix model names follow patterns:\n# pk_{route}{n}cpt_{parameters}_{observation}\n\n# Route: bolus, oral, infusion\n# n: 1, 2, 3 (compartments)\n# Parameters: V, Cl, k, ka, Q, Vm, Km\n# Observation: PLASMA, EFFECT, etc.\n</code></pre>"},{"location":"julia/import/monolix/#monolix-project-structure","title":"Monolix Project Structure","text":""},{"location":"julia/import/monolix/#project-file-format-mlxtran","title":"Project File Format (.mlxtran)","text":"<pre><code>&lt;DATAFILE&gt;\n  &lt;FILENAME path=\"../data/pk_data.csv\"/&gt;\n  &lt;HEADER&gt;\n    ID, TIME, DV, AMT, EVID, MDV, WT\n  &lt;/HEADER&gt;\n&lt;/DATAFILE&gt;\n\n&lt;STRUCTURAL_MODEL&gt;\n  &lt;FILE path=\"lib:pk_oral1cpt_kaVCl_PLASMA\"/&gt;\n&lt;/STRUCTURAL_MODEL&gt;\n\n&lt;PARAMETER&gt;\n  &lt;POPULATION name=\"ka_pop\" value=\"1.5\"/&gt;\n  &lt;POPULATION name=\"V_pop\" value=\"50.0\"/&gt;\n  &lt;POPULATION name=\"Cl_pop\" value=\"5.0\"/&gt;\n&lt;/PARAMETER&gt;\n\n&lt;INDIVIDUAL&gt;\n  &lt;PARAMETER name=\"ka\" variability=\"none\"/&gt;\n  &lt;PARAMETER name=\"V\" variability=\"lognormal\" value=\"0.25\"/&gt;\n  &lt;PARAMETER name=\"Cl\" variability=\"lognormal\" value=\"0.30\"/&gt;\n&lt;/INDIVIDUAL&gt;\n\n&lt;OBSERVATION&gt;\n  &lt;ERROR type=\"proportional\" value=\"0.1\"/&gt;\n&lt;/OBSERVATION&gt;\n</code></pre>"},{"location":"julia/import/monolix/#parsed-structures","title":"Parsed Structures","text":""},{"location":"julia/import/monolix/#monolixproject","title":"MonolixProject","text":"<pre><code>struct MonolixProject\n    data::MonolixDataset              # Data file specification\n    structural_model::MonolixStructuralModel  # Model definition\n    parameters::Vector{MonolixParameter}      # Population parameters\n    individual::Vector{MonolixIndividual}     # IIV specifications\n    observation::MonolixObservation   # Error model\n    estimation::Dict{String,Any}      # Estimation settings\n    raw_text::String                  # Original file content\nend\n</code></pre>"},{"location":"julia/import/monolix/#monolixparameter","title":"MonolixParameter","text":"<pre><code>struct MonolixParameter\n    name::String           # Parameter name (ka_pop, V_pop, Cl_pop)\n    value::Float64         # Population value\n    fixed::Bool            # Fixed or estimated\n    lower_bound::Float64   # Lower constraint\n    upper_bound::Float64   # Upper constraint\nend\n</code></pre>"},{"location":"julia/import/monolix/#monolixindividual","title":"MonolixIndividual","text":"<pre><code>struct MonolixIndividual\n    parameter::String      # Base parameter name\n    variability::Symbol    # :none, :lognormal, :normal, :logitnormal\n    omega::Float64         # Standard deviation\n    correlation::Dict{String,Float64}  # Correlations with other params\nend\n</code></pre>"},{"location":"julia/import/monolix/#parameter-extraction","title":"Parameter Extraction","text":""},{"location":"julia/import/monolix/#population-parameters","title":"Population Parameters","text":"<pre><code>result = import_monolix(\"project.mlxtran\")\n\n# Access population parameters\nfor (param, value) in result.parameters\n    println(\"$param = $value\")\nend\n\n# Example output:\n# Ka = 1.5\n# V = 50.0\n# CL = 5.0\n</code></pre>"},{"location":"julia/import/monolix/#random-effects","title":"Random Effects","text":"<pre><code>if !isnothing(result.iiv)\n    println(\"IIV Structure:\")\n    for (i, param) in enumerate(result.iiv.parameters)\n        omega = result.iiv.omega[i, i]\n        cv = sqrt(exp(omega^2) - 1) * 100  # For lognormal\n        println(\"  $param: \u03c9=$(omega), CV\u2248$(round(cv, digits=1))%\")\n    end\nend\n</code></pre>"},{"location":"julia/import/monolix/#parameter-transformations","title":"Parameter Transformations","text":"Monolix Variability OpenPKPD Transformation Formula <code>lognormal</code> <code>:exponential</code> \\(\\theta_i = \\theta_{pop} \\cdot e^{\\eta_i}\\) <code>normal</code> <code>:additive</code> \\(\\theta_i = \\theta_{pop} + \\eta_i\\) <code>logitnormal</code> <code>:logit</code> Logit-normal transform <code>none</code> No IIV Fixed to population value"},{"location":"julia/import/monolix/#error-model-import","title":"Error Model Import","text":""},{"location":"julia/import/monolix/#supported-error-models","title":"Supported Error Models","text":"<pre><code># Proportional error\n# Y = F * (1 + b*\u03b5)\nstruct ProportionalError\n    b::Float64  # Proportional coefficient\nend\n\n# Additive error\n# Y = F + a*\u03b5\nstruct AdditiveError\n    a::Float64  # Additive coefficient\nend\n\n# Combined error\n# Y = F * (1 + b*\u03b5\u2081) + a*\u03b5\u2082\nstruct CombinedError\n    a::Float64  # Additive\n    b::Float64  # Proportional\nend\n</code></pre>"},{"location":"julia/import/monolix/#accessing-error-model","title":"Accessing Error Model","text":"<pre><code>result = import_monolix(\"project.mlxtran\")\n\nif !isnothing(result.error)\n    println(\"Error type: $(result.error.type)\")\n    println(\"Error SD: $(result.error.sigma)\")\nend\n</code></pre>"},{"location":"julia/import/monolix/#covariate-models","title":"Covariate Models","text":""},{"location":"julia/import/monolix/#supported-covariate-patterns","title":"Supported Covariate Patterns","text":"<pre><code>&lt;COVARIATE&gt;\n  &lt;CONTINUOUS name=\"WT\" transformation=\"none\"/&gt;\n  &lt;CONTINUOUS name=\"AGE\" transformation=\"log\"/&gt;\n  &lt;CATEGORICAL name=\"SEX\" categories=\"M,F\"/&gt;\n&lt;/COVARIATE&gt;\n\n&lt;INDIVIDUAL&gt;\n  &lt;PARAMETER name=\"Cl\"&gt;\n    &lt;COVARIATE name=\"WT\" coefficient=\"0.75\" type=\"power\" reference=\"70\"/&gt;\n  &lt;/PARAMETER&gt;\n&lt;/INDIVIDUAL&gt;\n</code></pre>"},{"location":"julia/import/monolix/#extracting-covariate-effects","title":"Extracting Covariate Effects","text":"<pre><code>result = import_monolix(\"project.mlxtran\")\n\nfor effect in result.covariate_effects\n    println(\"$(effect.covariate) on $(effect.parameter):\")\n    println(\"  Type: $(effect.effect_type)\")\n    println(\"  Coefficient: $(effect.coefficient)\")\n    println(\"  Reference: $(effect.reference_value)\")\nend\n</code></pre>"},{"location":"julia/import/monolix/#unsupported-features","title":"Unsupported Features","text":""},{"location":"julia/import/monolix/#models-not-supported","title":"Models Not Supported","text":"Model Type Reason Workaround PD models Complex dynamics Manual definition Turnover models Indirect response Use OpenPKPD IRM Transit compartment Absorption Use OpenPKPD transit Mixture models Subpopulations Not supported Markov models State transitions Not supported Time-to-event Survival Not supported Count data Poisson/NegBin Not supported Categorical Ordered/unordered Not supported"},{"location":"julia/import/monolix/#features-imported-with-warnings","title":"Features Imported with Warnings","text":"Feature Handling Warning Lag time (Tlag) Ignored \"Lag time not imported, assuming Tlag=0\" Bioavailability (F) Assumes F=1 \"Bioavailability not imported, assuming F=1\" Complex covariates Partial \"Complex covariate effect simplified\""},{"location":"julia/import/monolix/#validation","title":"Validation","text":""},{"location":"julia/import/monolix/#checking-import-quality","title":"Checking Import Quality","text":"<pre><code>result = import_monolix(\"project.mlxtran\")\n\n# Check for warnings\nif !isempty(result.warnings)\n    println(\"\u26a0\ufe0f Import warnings:\")\n    for w in result.warnings\n        println(\"  - $w\")\n    end\nend\n\n# Validate model type was recognized\nif result.model_type == :Unknown\n    println(\"\u274c Model type not recognized\")\nelse\n    println(\"\u2713 Model type: $(result.model_type)\")\nend\n\n# Check parameter completeness\nexpected_params = [:Ka, :CL, :V]  # For 1-comp oral\nfor param in expected_params\n    if haskey(result.parameters, param)\n        println(\"\u2713 $param = $(result.parameters[param])\")\n    else\n        println(\"\u274c Missing parameter: $param\")\n    end\nend\n</code></pre>"},{"location":"julia/import/monolix/#complete-example","title":"Complete Example","text":""},{"location":"julia/import/monolix/#monolix-project-file-projectmlxtran","title":"Monolix Project File (project.mlxtran)","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;monolix&gt;\n  &lt;project name=\"pk_analysis\" version=\"2023R1\"&gt;\n\n    &lt;DATAFILE&gt;\n      &lt;FILENAME path=\"../data/pk_data.csv\"/&gt;\n      &lt;HEADER&gt;ID, TIME, DV, AMT, EVID, WT&lt;/HEADER&gt;\n      &lt;COLUMNMAPPING&gt;\n        &lt;COLUMN name=\"ID\" type=\"ID\"/&gt;\n        &lt;COLUMN name=\"TIME\" type=\"TIME\"/&gt;\n        &lt;COLUMN name=\"DV\" type=\"OBSERVATION\"/&gt;\n        &lt;COLUMN name=\"AMT\" type=\"AMOUNT\"/&gt;\n        &lt;COLUMN name=\"EVID\" type=\"EVID\"/&gt;\n        &lt;COLUMN name=\"WT\" type=\"COVARIATE\"/&gt;\n      &lt;/COLUMNMAPPING&gt;\n    &lt;/DATAFILE&gt;\n\n    &lt;STRUCTURAL_MODEL&gt;\n      &lt;FILE path=\"lib:pk_oral2cpt_kaV1ClQ2V2_PLASMA\"/&gt;\n    &lt;/STRUCTURAL_MODEL&gt;\n\n    &lt;PARAMETER&gt;\n      &lt;POPULATION name=\"ka_pop\" value=\"1.5\" method=\"MLE\"/&gt;\n      &lt;POPULATION name=\"V1_pop\" value=\"50.0\" method=\"MLE\"/&gt;\n      &lt;POPULATION name=\"Cl_pop\" value=\"5.0\" method=\"MLE\"/&gt;\n      &lt;POPULATION name=\"Q_pop\" value=\"3.0\" method=\"MLE\"/&gt;\n      &lt;POPULATION name=\"V2_pop\" value=\"80.0\" method=\"MLE\"/&gt;\n    &lt;/PARAMETER&gt;\n\n    &lt;INDIVIDUAL&gt;\n      &lt;PARAMETER name=\"ka\" variability=\"lognormal\"&gt;\n        &lt;OMEGA value=\"0.3\"/&gt;\n      &lt;/PARAMETER&gt;\n      &lt;PARAMETER name=\"V1\" variability=\"lognormal\"&gt;\n        &lt;OMEGA value=\"0.25\"/&gt;\n      &lt;/PARAMETER&gt;\n      &lt;PARAMETER name=\"Cl\" variability=\"lognormal\"&gt;\n        &lt;OMEGA value=\"0.30\"/&gt;\n        &lt;COVARIATE name=\"WT\" coefficient=\"0.75\" type=\"power\" reference=\"70\"/&gt;\n      &lt;/PARAMETER&gt;\n      &lt;PARAMETER name=\"Q\" variability=\"none\"/&gt;\n      &lt;PARAMETER name=\"V2\" variability=\"none\"/&gt;\n    &lt;/INDIVIDUAL&gt;\n\n    &lt;OBSERVATION&gt;\n      &lt;PREDICTION name=\"Cc\"/&gt;\n      &lt;ERROR type=\"proportional\"&gt;\n        &lt;PARAMETER name=\"b\" value=\"0.1\"/&gt;\n      &lt;/ERROR&gt;\n    &lt;/OBSERVATION&gt;\n\n    &lt;ESTIMATION&gt;\n      &lt;METHOD name=\"SAEM\"/&gt;\n      &lt;NBCHAINS value=\"5\"/&gt;\n      &lt;NBITERATIONS value=\"500\"/&gt;\n    &lt;/ESTIMATION&gt;\n\n  &lt;/project&gt;\n&lt;/monolix&gt;\n</code></pre>"},{"location":"julia/import/monolix/#julia-import-code","title":"Julia Import Code","text":"<pre><code>using OpenPKPDCore\n\n# Import Monolix project\nresult = import_monolix(\"project.mlxtran\")\n\n# Display results\nprintln(\"=\" ^ 50)\nprintln(\"Monolix Import Results\")\nprintln(\"=\" ^ 50)\n\nprintln(\"\\n--- Model Information ---\")\nprintln(\"Source: Monolix\")\nprintln(\"Model type: $(result.model_type)\")\n\nprintln(\"\\n--- Population Parameters ---\")\nfor (param, value) in result.parameters\n    println(\"  $param = $value\")\nend\n\nprintln(\"\\n--- Inter-Individual Variability ---\")\nif !isnothing(result.iiv)\n    println(\"  Parameters with IIV: $(result.iiv.parameters)\")\n    println(\"  Transformations: $(result.iiv.transformations)\")\n    println(\"\\n  Omega matrix (SD scale):\")\n    for (i, p) in enumerate(result.iiv.parameters)\n        omega = result.iiv.omega[i, i]\n        println(\"    \u03c9_$p = $omega\")\n    end\nend\n\nprintln(\"\\n--- Residual Error ---\")\nif !isnothing(result.error)\n    println(\"  Type: $(result.error.type)\")\n    println(\"  Coefficient: $(result.error.sigma)\")\nend\n\nprintln(\"\\n--- Covariate Effects ---\")\nif !isempty(result.covariate_effects)\n    for eff in result.covariate_effects\n        println(\"  $(eff.covariate) on $(eff.parameter):\")\n        println(\"    Effect: $(eff.effect_type)\")\n        println(\"    Coefficient: $(eff.coefficient)\")\n    end\nelse\n    println(\"  None imported\")\nend\n\nprintln(\"\\n--- Warnings ---\")\nif isempty(result.warnings)\n    println(\"  None\")\nelse\n    for w in result.warnings\n        println(\"  \u26a0\ufe0f $w\")\n    end\nend\n\n# Validate with simulation\nprintln(\"\\n--- Validation Simulation ---\")\ntimes = collect(0.0:0.5:72.0)\ndoses = [DoseEvent(time=0.0, amount=500.0, route=:oral)]\n\nsim = simulate_single(result.spec, times, doses)\nprintln(\"Simulation completed successfully\")\nprintln(\"Cmax: $(round(maximum(sim.observations[:conc]), digits=2))\")\nprintln(\"Tmax: $(times[argmax(sim.observations[:conc])])\")\n</code></pre>"},{"location":"julia/import/monolix/#expected-output","title":"Expected Output","text":"<pre><code>==================================================\nMonolix Import Results\n==================================================\n\n--- Model Information ---\nSource: Monolix\nModel type: TwoCompOral\n\n--- Population Parameters ---\n  Ka = 1.5\n  V1 = 50.0\n  CL = 5.0\n  Q = 3.0\n  V2 = 80.0\n\n--- Inter-Individual Variability ---\n  Parameters with IIV: [:Ka, :V1, :CL]\n  Transformations: [:exponential, :exponential, :exponential]\n\n  Omega matrix (SD scale):\n    \u03c9_Ka = 0.3\n    \u03c9_V1 = 0.25\n    \u03c9_CL = 0.3\n\n--- Residual Error ---\n  Type: proportional\n  Coefficient: 0.1\n\n--- Covariate Effects ---\n  WT on CL:\n    Effect: power\n    Coefficient: 0.75\n\n--- Warnings ---\n  None\n\n--- Validation Simulation ---\nSimulation completed successfully\nCmax: 4.87\nTmax: 1.5\n</code></pre>"},{"location":"julia/import/monolix/#model-library-reference","title":"Model Library Reference","text":""},{"location":"julia/import/monolix/#one-compartment-models","title":"One-Compartment Models","text":"Library Model Parameters Route <code>pk_bolus1cpt_Vk_PLASMA</code> V, k IV bolus <code>pk_bolus1cpt_VCl_PLASMA</code> V, Cl IV bolus <code>pk_oral1cpt_kaVk_PLASMA</code> ka, V, k Oral <code>pk_oral1cpt_kaVCl_PLASMA</code> ka, V, Cl Oral <code>pk_infusion1cpt_VCl_PLASMA</code> V, Cl IV infusion"},{"location":"julia/import/monolix/#two-compartment-models","title":"Two-Compartment Models","text":"Library Model Parameters Route <code>pk_bolus2cpt_V1k12k21k_PLASMA</code> V1, k, k12, k21 IV bolus <code>pk_bolus2cpt_V1ClQ2V2_PLASMA</code> V1, Cl, Q, V2 IV bolus <code>pk_oral2cpt_kaV1k12k21k_PLASMA</code> ka, V1, k, k12, k21 Oral <code>pk_oral2cpt_kaV1ClQ2V2_PLASMA</code> ka, V1, Cl, Q, V2 Oral"},{"location":"julia/import/monolix/#three-compartment-models","title":"Three-Compartment Models","text":"Library Model Parameters Route <code>pk_bolus3cpt_V1ClQ2V2Q3V3_PLASMA</code> V1, Cl, Q2, V2, Q3, V3 IV bolus"},{"location":"julia/import/monolix/#special-models","title":"Special Models","text":"Library Model Parameters Description <code>pk_bolus1cpt_VVmKm_PLASMA</code> V, Vm, Km Michaelis-Menten"},{"location":"julia/import/monolix/#see-also","title":"See Also","text":"<ul> <li>NONMEM Import - Import NONMEM control files</li> <li>CDISC Import - Import CDISC data</li> <li>Model Specification - OpenPKPD model types</li> </ul>"},{"location":"julia/import/nonmem/","title":"NONMEM Import","text":"<p>Comprehensive guide for importing NONMEM control stream files (.ctl, .mod) into OpenPKPD.</p>"},{"location":"julia/import/nonmem/#overview","title":"Overview","text":"<p>OpenPKPD can parse NONMEM control files and convert them to native OpenPKPD model specifications, enabling seamless migration from NONMEM workflows.</p> <pre><code>using OpenPKPDCore\n\nresult = import_nonmem(\"run001.ctl\")\nprintln(\"Model: $(result.model_type)\")\nprintln(\"Parameters: $(result.parameters)\")\n</code></pre>"},{"location":"julia/import/nonmem/#quick-start","title":"Quick Start","text":""},{"location":"julia/import/nonmem/#basic-import","title":"Basic Import","text":"<pre><code>using OpenPKPDCore\n\n# Import NONMEM control file\nresult = import_nonmem(\"run001.ctl\")\n\n# Access the converted model\nmodel_spec = result.spec\n\n# Simulate with the imported model\ntimes = 0.0:0.5:24.0\ndose = DoseEvent(time=0.0, amount=100.0)\nsim = simulate_single(model_spec, collect(times), [dose])\n</code></pre>"},{"location":"julia/import/nonmem/#with-dose-events","title":"With Dose Events","text":"<pre><code># Specify doses if not in control file\ndoses = [\n    DoseEvent(time=0.0, amount=100.0),\n    DoseEvent(time=12.0, amount=100.0)\n]\n\nresult = import_nonmem(\"run001.ctl\"; doses=doses)\n</code></pre>"},{"location":"julia/import/nonmem/#import-result-structure","title":"Import Result Structure","text":"<pre><code>struct ImportResult\n    model_type::Symbol              # OpenPKPD model kind\n    parameters::Dict{Symbol,Float64} # Parameter values\n    spec::ModelSpec                 # Complete model specification\n    iiv::Union{Nothing,IIVSpec}     # Inter-individual variability\n    error::Union{Nothing,ResidualErrorSpec}  # Residual error model\n    source::String                  # \"NONMEM\"\n    warnings::Vector{String}        # Import warnings\nend\n</code></pre>"},{"location":"julia/import/nonmem/#accessing-results","title":"Accessing Results","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\n# Model type (e.g., :OneCompOralFirstOrder)\nprintln(\"Model: $(result.model_type)\")\n\n# Fixed effect parameters\nfor (param, value) in result.parameters\n    println(\"  $param = $value\")\nend\n\n# IIV specification\nif !isnothing(result.iiv)\n    println(\"IIV on: $(result.iiv.parameters)\")\n    println(\"Omega: $(result.iiv.omega)\")\nend\n\n# Residual error\nif !isnothing(result.error)\n    println(\"Error type: $(result.error.type)\")\n    println(\"Error param: $(result.error.sigma)\")\nend\n\n# Check for warnings\nfor warning in result.warnings\n    println(\"\u26a0\ufe0f $warning\")\nend\n</code></pre>"},{"location":"julia/import/nonmem/#supported-advantrans-combinations","title":"Supported ADVAN/TRANS Combinations","text":""},{"location":"julia/import/nonmem/#advan1-one-compartment-iv-bolus","title":"ADVAN1 - One-Compartment IV Bolus","text":"<pre><code>$SUBROUTINES ADVAN1 TRANS2\n</code></pre> TRANS Parameters OpenPKPD Model TRANS1 K, V <code>:OneCompIVBolus</code> TRANS2 CL, V <code>:OneCompIVBolus</code>"},{"location":"julia/import/nonmem/#advan2-one-compartment-oral","title":"ADVAN2 - One-Compartment Oral","text":"<pre><code>$SUBROUTINES ADVAN2 TRANS2\n</code></pre> TRANS Parameters OpenPKPD Model TRANS1 KA, K, V <code>:OneCompOralFirstOrder</code> TRANS2 KA, CL, V <code>:OneCompOralFirstOrder</code>"},{"location":"julia/import/nonmem/#advan3-two-compartment-iv-bolus","title":"ADVAN3 - Two-Compartment IV Bolus","text":"<pre><code>$SUBROUTINES ADVAN3 TRANS4\n</code></pre> TRANS Parameters OpenPKPD Model TRANS1 K, K12, K21, V <code>:TwoCompIVBolus</code> TRANS3 CL, V, Q, VSS <code>:TwoCompIVBolus</code> TRANS4 CL, V1, Q, V2 <code>:TwoCompIVBolus</code>"},{"location":"julia/import/nonmem/#advan4-two-compartment-oral","title":"ADVAN4 - Two-Compartment Oral","text":"<pre><code>$SUBROUTINES ADVAN4 TRANS4\n</code></pre> TRANS Parameters OpenPKPD Model TRANS1 KA, K, K23, K32, V <code>:TwoCompOral</code> TRANS3 KA, CL, V, Q, VSS <code>:TwoCompOral</code> TRANS4 KA, CL, V1, Q, V2 <code>:TwoCompOral</code>"},{"location":"julia/import/nonmem/#advan10-michaelis-menten-elimination","title":"ADVAN10 - Michaelis-Menten Elimination","text":"<pre><code>$SUBROUTINES ADVAN10\n</code></pre> Parameters OpenPKPD Model VM, KM, V <code>:MichaelisMentenElimination</code>"},{"location":"julia/import/nonmem/#advan11-three-compartment-iv-bolus","title":"ADVAN11 - Three-Compartment IV Bolus","text":"<pre><code>$SUBROUTINES ADVAN11 TRANS4\n</code></pre> TRANS Parameters OpenPKPD Model TRANS1 K, K12, K21, K13, K31, V <code>:ThreeCompIVBolus</code> TRANS4 CL, V1, Q2, V2, Q3, V3 <code>:ThreeCompIVBolus</code>"},{"location":"julia/import/nonmem/#theta-parsing","title":"$THETA Parsing","text":""},{"location":"julia/import/nonmem/#supported-formats","title":"Supported Formats","text":"<pre><code>; Simple initial estimate\n$THETA 5.0\n\n; With bounds\n$THETA (0, 5.0, 100)\n\n; Lower bound only\n$THETA (0, 5.0)\n\n; Fixed parameter\n$THETA 5.0 FIX\n\n; Multiple on one line\n$THETA 5.0 50.0 0.1\n\n; With comments\n$THETA 5.0 ; CL (L/h)\n</code></pre>"},{"location":"julia/import/nonmem/#accessing-theta-values","title":"Accessing THETA Values","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\n# Parsed control file contains THETA specs\nparsed = result.parsed_control_file\nfor (i, theta) in enumerate(parsed.thetas)\n    println(\"THETA($i):\")\n    println(\"  Initial: $(theta.init)\")\n    println(\"  Lower: $(theta.lower)\")\n    println(\"  Upper: $(theta.upper)\")\n    println(\"  Fixed: $(theta.fixed)\")\nend\n</code></pre>"},{"location":"julia/import/nonmem/#omega-parsing","title":"$OMEGA Parsing","text":""},{"location":"julia/import/nonmem/#diagonal-structure","title":"DIAGONAL Structure","text":"<pre><code>$OMEGA\n0.09       ; IIV on CL (30% CV)\n0.0625     ; IIV on V (25% CV)\n</code></pre>"},{"location":"julia/import/nonmem/#block-structure","title":"BLOCK Structure","text":"<pre><code>$OMEGA BLOCK(2)\n0.09                    ; Variance CL\n0.03 0.0625             ; Covariance, Variance V\n</code></pre>"},{"location":"julia/import/nonmem/#mixed-structures","title":"Mixed Structures","text":"<pre><code>$OMEGA BLOCK(2)\n0.09\n0.03 0.0625\n\n$OMEGA\n0.04      ; Separate IIV on Ka\n</code></pre>"},{"location":"julia/import/nonmem/#conversion-to-iiv","title":"Conversion to IIV","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\nif !isnothing(result.iiv)\n    # Variances converted to standard deviations\n    println(\"IIV parameters: $(result.iiv.parameters)\")\n    println(\"Omega matrix (SD): $(result.iiv.omega)\")\n    println(\"Transformations: $(result.iiv.transformations)\")\nend\n</code></pre>"},{"location":"julia/import/nonmem/#sigma-parsing","title":"$SIGMA Parsing","text":""},{"location":"julia/import/nonmem/#proportional-error","title":"Proportional Error","text":"<pre><code>$SIGMA\n0.01      ; Proportional error (10% CV)\n</code></pre>"},{"location":"julia/import/nonmem/#additive-error","title":"Additive Error","text":"<pre><code>$SIGMA\n0.1       ; Additive error (SD = 0.316)\n</code></pre>"},{"location":"julia/import/nonmem/#combined-error","title":"Combined Error","text":"<pre><code>$SIGMA BLOCK(2)\n0.01      ; Proportional\n0.0 0.1   ; Additive\n</code></pre>"},{"location":"julia/import/nonmem/#pk-block-parsing","title":"$PK Block Parsing","text":""},{"location":"julia/import/nonmem/#supported-patterns","title":"Supported Patterns","text":""},{"location":"julia/import/nonmem/#typical-value-definitions","title":"Typical Value Definitions","text":"<pre><code>$PK\nTVCL = THETA(1)\nTVV = THETA(2)\nTVKA = THETA(3)\n</code></pre>"},{"location":"julia/import/nonmem/#parameter-assignments-with-eta","title":"Parameter Assignments with ETA","text":"<pre><code>; Exponential IIV (default)\nCL = TVCL * EXP(ETA(1))\nV = TVV * EXP(ETA(2))\n\n; Additive IIV\nCL = TVCL + ETA(1)\n\n; Proportional IIV\nCL = TVCL * (1 + ETA(1))\n</code></pre>"},{"location":"julia/import/nonmem/#covariate-effects","title":"Covariate Effects","text":"<pre><code>; Power model (weight effect)\nTVCL = THETA(1) * (WT/70)**THETA(4)\n\n; Linear model (age effect)\nTVCL = THETA(1) * (1 + THETA(5)*(AGE-40))\n\n; Exponential model\nTVCL = THETA(1) * EXP(THETA(6)*(CRCL-100))\n</code></pre>"},{"location":"julia/import/nonmem/#scaling-factors","title":"Scaling Factors","text":"<pre><code>; Volume scaling for central compartment\nS1 = V\nS2 = V1\n</code></pre>"},{"location":"julia/import/nonmem/#parsed-pk-block-structure","title":"Parsed PK Block Structure","text":"<pre><code>struct PKBlock\n    tv_definitions::Dict{Symbol,Int}    # TV to THETA mapping\n    assignments::Vector{PKAssignment}   # Parameter assignments\n    scaling::Vector{ScalingFactor}      # Scaling factors\n    unsupported_lines::Vector{String}   # Lines not parsed\nend\n\nstruct PKAssignment\n    parameter::Symbol         # CL, V, Ka, etc.\n    tv_symbol::Symbol         # TVCL, TVV, etc.\n    eta_index::Union{Nothing,Int}  # ETA index or nothing\n    transformation::Symbol    # :exponential, :additive, :proportional\nend\n</code></pre>"},{"location":"julia/import/nonmem/#accessing-parsed-pk","title":"Accessing Parsed $PK","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\npk = result.parsed_control_file.pk_block\n\n# TV definitions\nfor (tv, theta_idx) in pk.tv_definitions\n    println(\"$tv = THETA($theta_idx)\")\nend\n\n# Parameter assignments\nfor assign in pk.assignments\n    println(\"$(assign.parameter): TV=$(assign.tv_symbol), ETA=$(assign.eta_index)\")\nend\n\n# Check for unsupported lines\nif !isempty(pk.unsupported_lines)\n    println(\"\u26a0\ufe0f Unsupported $PK lines:\")\n    for line in pk.unsupported_lines\n        println(\"  $line\")\n    end\nend\n</code></pre>"},{"location":"julia/import/nonmem/#error-block-parsing","title":"$ERROR Block Parsing","text":""},{"location":"julia/import/nonmem/#proportional-error_1","title":"Proportional Error","text":"<pre><code>$ERROR\nIPRED = F\nW = IPRED * THETA(4)\nY = IPRED + W * ERR(1)\n</code></pre>"},{"location":"julia/import/nonmem/#additive-error_1","title":"Additive Error","text":"<pre><code>$ERROR\nIPRED = F\nW = THETA(4)\nY = IPRED + W * ERR(1)\n</code></pre>"},{"location":"julia/import/nonmem/#combined-error_1","title":"Combined Error","text":"<pre><code>$ERROR\nIPRED = F\nW = SQRT(THETA(4)**2 + (THETA(5)*IPRED)**2)\nY = IPRED + W * ERR(1)\n</code></pre>"},{"location":"julia/import/nonmem/#exponential-error","title":"Exponential Error","text":"<pre><code>$ERROR\nIPRED = F\nY = IPRED * EXP(ERR(1))\n</code></pre>"},{"location":"julia/import/nonmem/#detection-logic","title":"Detection Logic","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\nif !isnothing(result.error)\n    println(\"Error type: $(result.error.type)\")  # :proportional, :additive, :combined, :exponential\n    println(\"Sigma value: $(result.error.sigma)\")\nend\n</code></pre>"},{"location":"julia/import/nonmem/#covariate-effects-extraction","title":"Covariate Effects Extraction","text":""},{"location":"julia/import/nonmem/#supported-covariate-patterns","title":"Supported Covariate Patterns","text":"<pre><code>struct PKCovariateEffect\n    parameter::Symbol           # Affected parameter (CL, V, etc.)\n    covariate::Symbol           # Covariate name (WT, AGE, CRCL)\n    effect_type::Symbol         # :power, :linear, :exponential\n    theta_index::Int            # THETA index for effect\n    reference_value::Float64    # Centering value (70 for WT, etc.)\nend\n</code></pre>"},{"location":"julia/import/nonmem/#example-weight-on-cl","title":"Example: Weight on CL","text":"<pre><code>; Power model\nTVCL = THETA(1) * (WT/70)**THETA(4)\n</code></pre> <p>Extracted as: <pre><code>PKCovariateEffect(\n    parameter = :CL,\n    covariate = :WT,\n    effect_type = :power,\n    theta_index = 4,\n    reference_value = 70.0\n)\n</code></pre></p>"},{"location":"julia/import/nonmem/#accessing-covariate-effects","title":"Accessing Covariate Effects","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\nfor effect in result.covariate_effects\n    println(\"$(effect.covariate) on $(effect.parameter):\")\n    println(\"  Type: $(effect.effect_type)\")\n    println(\"  THETA: $(effect.theta_index)\")\n    println(\"  Reference: $(effect.reference_value)\")\nend\n</code></pre>"},{"location":"julia/import/nonmem/#validation-and-quality-checks","title":"Validation and Quality Checks","text":""},{"location":"julia/import/nonmem/#automatic-validation","title":"Automatic Validation","text":"<p>The import process performs these checks:</p> <ol> <li>ADVAN/TRANS compatibility - Unsupported combinations flagged</li> <li>THETA index bounds - References beyond defined THETAs</li> <li>ETA index bounds - References beyond OMEGA dimension</li> <li>Scaling factor validity - S1, S2 must reference valid compartments</li> <li>Unused parameters - THETAs defined but not used</li> </ol>"},{"location":"julia/import/nonmem/#conversion-result","title":"Conversion Result","text":"<pre><code>struct NONMEMConversionResult\n    model_spec::Union{Nothing,ModelSpec}\n    iiv_spec::Union{Nothing,IIVSpec}\n    error_spec::Union{Nothing,ResidualErrorSpec}\n    warnings::Vector{String}\n    errors::Vector{String}\n    parameter_mapping::Dict{Int,Symbol}\n    covariate_effects::Vector{PKCovariateEffect}\nend\n</code></pre>"},{"location":"julia/import/nonmem/#handling-warnings","title":"Handling Warnings","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\nif !isempty(result.warnings)\n    println(\"Import completed with warnings:\")\n    for w in result.warnings\n        println(\"  \u26a0\ufe0f $w\")\n    end\nend\n\n# Check for critical errors\nif isnothing(result.spec)\n    println(\"Import failed - check errors\")\nend\n</code></pre>"},{"location":"julia/import/nonmem/#unsupported-features","title":"Unsupported Features","text":""},{"location":"julia/import/nonmem/#not-currently-supported","title":"Not Currently Supported","text":"Feature Description Workaround Custom $DES User-defined ODEs Manual model definition Complex IF Conditional logic Simplify before import ALAG Absorption lag Manual specification F1, F2 Bioavailability Assume F=1 or manual R1, D1 Infusion params Specify in dose events MTIME Model event time Not supported $MIX Mixture models Manual definition $MODEL Custom compartments Use predefined models"},{"location":"julia/import/nonmem/#detection-of-unsupported-constructs","title":"Detection of Unsupported Constructs","text":"<pre><code>result = import_nonmem(\"run001.ctl\")\n\n# Warnings include unsupported feature notices\nfor warning in result.warnings\n    if contains(warning, \"unsupported\")\n        println(\"Feature not imported: $warning\")\n    end\nend\n</code></pre>"},{"location":"julia/import/nonmem/#complete-example","title":"Complete Example","text":""},{"location":"julia/import/nonmem/#nonmem-control-file-run001ctl","title":"NONMEM Control File (run001.ctl)","text":"<pre><code>$PROBLEM Two-compartment oral PK model\n$DATA ../data/pk_data.csv IGNORE=@\n$INPUT ID TIME DV AMT EVID MDV WT AGE\n\n$SUBROUTINES ADVAN4 TRANS4\n\n$PK\n; Typical values with weight covariate on CL\nTVCL = THETA(1) * (WT/70)**0.75\nTVV1 = THETA(2)\nTVQ = THETA(3)\nTVV2 = THETA(4)\nTVKA = THETA(5)\n\n; Individual parameters\nCL = TVCL * EXP(ETA(1))\nV1 = TVV1 * EXP(ETA(2))\nQ = TVQ\nV2 = TVV2\nKA = TVKA * EXP(ETA(3))\n\nS2 = V1\n\n$ERROR\nIPRED = F\nW = IPRED * THETA(6)\nY = IPRED + W * ERR(1)\n\n$THETA\n(0, 10.0)     ; CL (L/h)\n(0, 50.0)     ; V1 (L)\n(0, 5.0)      ; Q (L/h)\n(0, 100.0)    ; V2 (L)\n(0, 1.5)      ; Ka (1/h)\n(0, 0.1)      ; Proportional error\n\n$OMEGA BLOCK(2)\n0.09          ; IIV CL\n0.03 0.0625   ; IIV V1\n\n$OMEGA\n0.04          ; IIV Ka\n\n$SIGMA\n1 FIX         ; SIGMA fixed to 1 (error in THETA(6))\n\n$ESTIMATION METHOD=1 INTER MAXEVAL=9999\n$COV PRINT=E\n</code></pre>"},{"location":"julia/import/nonmem/#julia-import-code","title":"Julia Import Code","text":"<pre><code>using OpenPKPDCore\n\n# Import the control file\nresult = import_nonmem(\"run001.ctl\")\n\n# Display import results\nprintln(\"=\" ^ 50)\nprintln(\"NONMEM Import Results\")\nprintln(\"=\" ^ 50)\n\nprintln(\"\\n--- Model Type ---\")\nprintln(\"OpenPKPD model: $(result.model_type)\")\n\nprintln(\"\\n--- Fixed Effects (THETA) ---\")\nfor (param, value) in result.parameters\n    println(\"  $param = $value\")\nend\n\nprintln(\"\\n--- Random Effects (OMEGA) ---\")\nif !isnothing(result.iiv)\n    println(\"  Parameters: $(result.iiv.parameters)\")\n    println(\"  Transformations: $(result.iiv.transformations)\")\n    println(\"  Omega matrix:\")\n    display(result.iiv.omega)\nend\n\nprintln(\"\\n--- Residual Error (SIGMA) ---\")\nif !isnothing(result.error)\n    println(\"  Type: $(result.error.type)\")\n    println(\"  Value: $(result.error.sigma)\")\nend\n\nprintln(\"\\n--- Covariate Effects ---\")\nfor effect in result.covariate_effects\n    println(\"  $(effect.covariate) on $(effect.parameter): $(effect.effect_type)\")\nend\n\nprintln(\"\\n--- Warnings ---\")\nif isempty(result.warnings)\n    println(\"  None\")\nelse\n    for w in result.warnings\n        println(\"  \u26a0\ufe0f $w\")\n    end\nend\n\n# Simulate with imported model\nprintln(\"\\n--- Validation Simulation ---\")\ntimes = collect(0.0:0.5:48.0)\ndoses = [DoseEvent(time=0.0, amount=500.0)]\n\nsim = simulate_single(result.spec, times, doses)\nprintln(\"Cmax: $(maximum(sim.observations[:conc]))\")\nprintln(\"Tmax: $(times[argmax(sim.observations[:conc])])\")\n</code></pre>"},{"location":"julia/import/nonmem/#expected-output","title":"Expected Output","text":"<pre><code>==================================================\nNONMEM Import Results\n==================================================\n\n--- Model Type ---\nOpenPKPD model: TwoCompOral\n\n--- Fixed Effects (THETA) ---\n  CL = 10.0\n  V1 = 50.0\n  Q = 5.0\n  V2 = 100.0\n  Ka = 1.5\n\n--- Random Effects (OMEGA) ---\n  Parameters: [:CL, :V1, :Ka]\n  Transformations: [:exponential, :exponential, :exponential]\n  Omega matrix:\n3\u00d73 Matrix{Float64}:\n 0.3   0.173  0.0\n 0.173 0.25   0.0\n 0.0   0.0    0.2\n\n--- Residual Error (SIGMA) ---\n  Type: proportional\n  Value: 0.1\n\n--- Covariate Effects ---\n  WT on CL: power\n\n--- Warnings ---\n  None\n\n--- Validation Simulation ---\nCmax: 4.23\nTmax: 1.5\n</code></pre>"},{"location":"julia/import/nonmem/#cli-usage","title":"CLI Usage","text":""},{"location":"julia/import/nonmem/#basic-import_1","title":"Basic Import","text":"<pre><code>./bin/openpkpd import --input run001.ctl --format nonmem\n</code></pre>"},{"location":"julia/import/nonmem/#export-to-json","title":"Export to JSON","text":"<pre><code>./bin/openpkpd import --input run001.ctl --format nonmem --out model.json\n</code></pre>"},{"location":"julia/import/nonmem/#validate-import","title":"Validate Import","text":"<pre><code>./bin/openpkpd import --input run001.ctl --format nonmem --validate\n</code></pre>"},{"location":"julia/import/nonmem/#see-also","title":"See Also","text":"<ul> <li>Monolix Import - Import Monolix projects</li> <li>CDISC Import - Import CDISC data</li> <li>Model Specification - OpenPKPD model types</li> </ul>"},{"location":"julia/models/","title":"Models Reference","text":"<p>OpenPKPD provides a comprehensive library of validated pharmacokinetic (PK) and pharmacodynamic (PD) models for drug concentration and effect simulation.</p>"},{"location":"julia/models/#model-categories","title":"Model Categories","text":"<ul> <li> <p> Pharmacokinetic Models</p> <p>Compartmental models describing drug distribution and elimination</p> <p> PK Models</p> </li> <li> <p> Pharmacodynamic Models</p> <p>Effect models linking concentration to response</p> <p> PD Models</p> </li> </ul>"},{"location":"julia/models/#pharmacokinetic-models","title":"Pharmacokinetic Models","text":""},{"location":"julia/models/#compartmental-pk-models","title":"Compartmental PK Models","text":"Model Page Parameters Route Use Case One-Comp IV Bolus \u2192 CL, V IV Simple IV kinetics One-Comp Oral \u2192 Ka, CL, V Oral Simple oral drugs Two-Comp IV \u2192 CL, V1, Q, V2 IV Distribution kinetics Two-Comp Oral \u2192 Ka, CL, V1, Q, V2 Oral Oral with distribution Three-Comp IV \u2192 CL, V1, Q2, V2, Q3, V3 IV Deep tissue Transit Absorption \u2192 N, Ktr, Ka, CL, V Oral Delayed absorption TMDD \u2192 Multiple IV Target-mediated disposition"},{"location":"julia/models/#model-selection-guide","title":"Model Selection Guide","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Route?}\n    B --&gt;|IV| C{Distribution?}\n    B --&gt;|Oral| D{Absorption?}\n\n    C --&gt;|Mono-exponential| E[One-Comp IV]\n    C --&gt;|Bi-exponential| F[Two-Comp IV]\n    C --&gt;|Tri-exponential| G[Three-Comp IV]\n    C --&gt;|Nonlinear| H[Michaelis-Menten]\n\n    D --&gt;|First-order| I{Distribution?}\n    D --&gt;|Delayed| J[Transit Absorption]\n\n    I --&gt;|Simple| K[One-Comp Oral]\n    I --&gt;|Complex| L[Two-Comp Oral]\n</code></pre>"},{"location":"julia/models/#pharmacodynamic-models","title":"Pharmacodynamic Models","text":""},{"location":"julia/models/#effect-models","title":"Effect Models","text":"Model Page Parameters Type Mechanism Direct Emax \u2192 E0, Emax, EC50 Direct Hyperbolic response Sigmoid Emax \u2192 E0, Emax, EC50, \u03b3 Direct Hill equation Effect Compartment \u2192 ke0, E0, Emax, EC50 Indirect Biophase equilibration Disease Progression \u2192 Multiple Complex Disease dynamics"},{"location":"julia/models/#pd-model-selection-guide","title":"PD Model Selection Guide","text":"<pre><code>graph TD\n    A[Start] --&gt; B{Temporal relationship?}\n    B --&gt;|Immediate| C[Direct Models]\n    B --&gt;|Delayed| D{Mechanism?}\n\n    C --&gt; E{Response shape?}\n    E --&gt;|Hyperbolic| F[Direct Emax]\n    E --&gt;|Steep/Sigmoid| G[Sigmoid Emax]\n\n    D --&gt;|PK-PD lag| H[Effect Compartment]\n    D --&gt;|Turnover| I{Drug effect?}\n\n    I --&gt;|Inhibition| J{Target?}\n    I --&gt;|Stimulation| K{Target?}\n\n    J --&gt;|Production| L[IDR Type I]\n    J --&gt;|Elimination| M[IDR Type II]\n\n    K --&gt;|Production| N[IDR Type III]\n    K --&gt;|Elimination| O[IDR Type IV]\n</code></pre>"},{"location":"julia/models/#common-features","title":"Common Features","text":""},{"location":"julia/models/#dose-events","title":"Dose Events","text":"<p>All models support flexible dosing:</p> <pre><code># Single bolus\ndoses = [DoseEvent(0.0, 100.0)]\n\n# Multiple doses\ndoses = [\n    DoseEvent(0.0, 100.0),\n    DoseEvent(12.0, 100.0),\n    DoseEvent(24.0, 100.0)\n]\n\n# IV Infusion (1-hour)\ndoses = [DoseEvent(0.0, 100.0, 1.0)]\n</code></pre>"},{"location":"julia/models/#observation-types","title":"Observation Types","text":"Observation Symbol Description Concentration <code>:conc</code> Drug concentration in central compartment Effect <code>:effect</code> Pharmacodynamic effect Response <code>:response</code> Indirect response biomarker Ce <code>:ce</code> Effect site concentration"},{"location":"julia/models/#solver-options","title":"Solver Options","text":"<pre><code># Standard solver for non-stiff problems\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# For stiff problems (e.g., rapid binding)\nsolver = SolverSpec(:Rosenbrock23, 1e-8, 1e-10, 1_000_000)\n\n# High accuracy for validation\nsolver = SolverSpec(:Vern9, 1e-14, 1e-14, 100_000_000)\n</code></pre>"},{"location":"julia/models/#model-implementation","title":"Model Implementation","text":""},{"location":"julia/models/#type-hierarchy","title":"Type Hierarchy","text":"<pre><code># Abstract types\nabstract type ModelKind end\nabstract type AbstractParams end\n\n# PK model kinds\nstruct OneCompIVBolus &lt;: ModelKind end\nstruct TwoCompIVBolus &lt;: ModelKind end\n# ...\n\n# Parameter types\nstruct OneCompIVBolusParams &lt;: AbstractParams\n    CL::Float64\n    V::Float64\nend\n</code></pre>"},{"location":"julia/models/#creating-custom-models","title":"Creating Custom Models","text":"<p>See the source code in <code>core/OpenPKPDCore/src/models/</code> for examples of extending OpenPKPD with custom models.</p>"},{"location":"julia/models/#next-steps","title":"Next Steps","text":"<ul> <li>One-Comp IV Bolus - Start with the simplest model</li> <li>Population Modeling - Add variability</li> <li>Parameter Estimation - Fit to data</li> </ul>"},{"location":"julia/models/pd/direct-emax/","title":"Direct Emax Model","text":"<p>Simple hyperbolic concentration-effect relationship where effect is directly proportional to receptor occupancy.</p>"},{"location":"julia/models/pd/direct-emax/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    C[Plasma&lt;br/&gt;Concentration] --&gt;|Direct Link| E[Effect]\n\n    subgraph \"Emax Function\"\n        direction TB\n        E0[E0: Baseline]\n        EM[Emax: Maximum]\n        EC[EC50: Potency]\n    end\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Simple receptor-mediated effects</li> <li>Anticoagulants (warfarin effect on INR)</li> <li>Beta-blockers (heart rate reduction)</li> <li>Enzyme inhibitors</li> <li>Rapid-equilibrium systems</li> </ul>"},{"location":"julia/models/pd/direct-emax/#when-to-use","title":"When to Use","text":"Use When Don't Use When Effect tracks concentration Temporal delay observed Rapid equilibration Hysteresis present Simple dose-response Tolerance develops Reversible binding Effect persists after drug"},{"location":"julia/models/pd/direct-emax/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pd/direct-emax/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Baseline effect E0 varies Effect with no drug any real Maximum effect Emax varies Maximum drug-induced change typically &gt; 0 Half-maximal concentration EC50 mg/L Concentration at 50% Emax EC50 &gt; 0"},{"location":"julia/models/pd/direct-emax/#equation","title":"Equation","text":"\\[E(C) = E_0 + \\frac{E_{max} \\cdot C}{EC_{50} + C}\\]"},{"location":"julia/models/pd/direct-emax/#fraction-of-maximum-effect","title":"Fraction of Maximum Effect","text":"<p>At any concentration:</p> \\[\\frac{E - E_0}{E_{max}} = \\frac{C}{EC_{50} + C}\\]"},{"location":"julia/models/pd/direct-emax/#key-concentrations","title":"Key Concentrations","text":"Fraction of Emax Concentration Required 20% C = EC50/4 50% C = EC50 80% C = EC50 \u00d7 4 90% C = EC50 \u00d7 9 99% C = EC50 \u00d7 99"},{"location":"julia/models/pd/direct-emax/#model-behavior","title":"Model Behavior","text":""},{"location":"julia/models/pd/direct-emax/#concentration-effect-curve","title":"Concentration-Effect Curve","text":"<pre><code>Effect\n   \u2502\nEmax\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502                  \u250c\u2500\u2500\u2518\n    \u2502               \u250c\u2500\u2500\u2518\n    \u2502            \u250c\u2500\u2500\u2518\n    \u2502         \u250c\u2500\u2500\u2518\nE0+\u00bd\u251c \u2500 \u2500 \u2500 \u252c\u2518\n    \u2502       \u2502\n E0 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 C\n          EC50\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#key-properties","title":"Key Properties","text":"<ol> <li>Hyperbolic shape: Effect increases rapidly at low C, plateaus at high C</li> <li>Saturable: Effect cannot exceed E0 + Emax</li> <li>First-order at low C: When C &lt;&lt; EC50, E \u2248 E0 + (Emax/EC50) \u00d7 C</li> <li>Zero-order at high C: When C &gt;&gt; EC50, E \u2248 E0 + Emax</li> </ol>"},{"location":"julia/models/pd/direct-emax/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pd/direct-emax/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct DirectEmax &lt;: PDModelKind end\n\n# Parameters\nstruct DirectEmaxParams\n    E0::Float64      # Baseline effect\n    Emax::Float64    # Maximum effect\n    EC50::Float64    # Half-maximal concentration (mg/L)\nend\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#basic-usage","title":"Basic Usage","text":"<pre><code>using OpenPKPDCore\n\n# Define PD parameters\n# E0 = 70 (baseline), Emax = 40 (reduction), EC50 = 1.5 mg/L\npd_params = DirectEmaxParams(70.0, -40.0, 1.5)\n\n# Create PD specification\npd_spec = PDSpec(DirectEmax(), \"heart_rate\", pd_params)\n\n# Evaluate at specific concentrations\nconcentrations = [0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 5.0]\neffects = evaluate(pd_spec, concentrations)\n\nfor (c, e) in zip(concentrations, effects)\n    println(\"C = $c mg/L: Effect = $(round(e, digits=1))\")\nend\n</code></pre> <p>Expected Output: <pre><code>C = 0.0 mg/L: Effect = 70.0\nC = 0.5 mg/L: Effect = 60.0\nC = 1.0 mg/L: Effect = 54.0\nC = 1.5 mg/L: Effect = 50.0\nC = 2.0 mg/L: Effect = 47.1\nC = 3.0 mg/L: Effect = 43.3\nC = 5.0 mg/L: Effect = 39.2\n</code></pre></p>"},{"location":"julia/models/pd/direct-emax/#coupled-pk-pd-simulation","title":"Coupled PK-PD Simulation","text":"<pre><code>using OpenPKPDCore\n\n# PK model: One-compartment oral\npk_params = OneCompOralFirstOrderParams(1.5, 5.0, 30.0)  # Ka, CL, V\npk_spec = ModelSpec(OneCompOralFirstOrder(), \"pk\", pk_params, [DoseEvent(0.0, 100.0)])\n\n# PD model: Direct Emax (inhibitory)\npd_params = DirectEmaxParams(80.0, -30.0, 2.0)  # Baseline HR, max reduction, EC50\npd_spec = PDSpec(DirectEmax(), \"heart_rate\", pd_params)\n\n# Simulation grid\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Simulate PK\npk_result = simulate(pk_spec, grid, solver)\nconc = pk_result.observations[:conc]\n\n# Calculate PD effect\neffects = evaluate(pd_spec, conc)\n\n# Find minimum heart rate (maximum effect)\nmin_hr, idx = findmin(effects)\ntime_of_min = grid.times[idx]\n\nprintln(\"Maximum effect at t = $(round(time_of_min, digits=1)) h\")\nprintln(\"Heart rate reduced to $(round(min_hr, digits=1)) bpm\")\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#parameter-interpretation","title":"Parameter Interpretation","text":""},{"location":"julia/models/pd/direct-emax/#potency-vs-efficacy","title":"Potency vs Efficacy","text":"Parameter Meaning Clinical Relevance EC50 Potency - concentration for 50% effect Lower EC50 = more potent drug Emax Efficacy - maximum possible effect Higher Emax = more efficacious"},{"location":"julia/models/pd/direct-emax/#comparing-drugs","title":"Comparing Drugs","text":"<pre><code># Drug A: High potency, moderate efficacy\nparams_A = DirectEmaxParams(0.0, 80.0, 0.5)\n\n# Drug B: Low potency, high efficacy\nparams_B = DirectEmaxParams(0.0, 100.0, 5.0)\n\n# At low concentration (1 mg/L):\n# Drug A: E = 80 \u00d7 1/(0.5+1) = 53.3\n# Drug B: E = 100 \u00d7 1/(5+1) = 16.7\n# Drug A wins at low concentrations\n\n# At high concentration (10 mg/L):\n# Drug A: E = 80 \u00d7 10/(0.5+10) \u2248 76.2\n# Drug B: E = 100 \u00d7 10/(5+10) = 66.7\n# Drug A still higher but closer\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#clinical-example-beta-blocker","title":"Clinical Example: Beta-Blocker","text":"<pre><code># Propranolol effect on heart rate\n# Baseline HR: 80 bpm\n# Max reduction: 30 bpm\n# EC50: 50 ng/mL\n\npd_params = DirectEmaxParams(80.0, -30.0, 0.050)  # EC50 in mg/L\n\n# Target: HR reduction of 15 bpm (half of max effect)\n# Required C = EC50 = 0.050 mg/L = 50 ng/mL\n\n# Verify\nspec = PDSpec(DirectEmax(), \"hr\", pd_params)\neffect_at_ec50 = evaluate(spec, [0.050])[1]\nprintln(\"HR at EC50: $(round(effect_at_ec50, digits=1)) bpm\")\n# Expected: 80 - 15 = 65 bpm\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#stimulatory-vs-inhibitory-effects","title":"Stimulatory vs Inhibitory Effects","text":""},{"location":"julia/models/pd/direct-emax/#inhibitory-effect-emax-0","title":"Inhibitory Effect (Emax &lt; 0)","text":"<pre><code># Drug reduces blood pressure\n# E0 = baseline, Emax = negative (reduction)\npd_inhibit = DirectEmaxParams(140.0, -40.0, 2.0)\n\n# Effect range: 140 \u2192 100 mmHg\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#stimulatory-effect-emax-0","title":"Stimulatory Effect (Emax &gt; 0)","text":"<pre><code># Drug increases enzyme activity\n# E0 = baseline, Emax = positive (increase)\npd_stimulate = DirectEmaxParams(100.0, 200.0, 5.0)\n\n# Effect range: 100 \u2192 300 units\n</code></pre>"},{"location":"julia/models/pd/direct-emax/#model-limitations","title":"Model Limitations","text":"Limitation Alternative No delay between C and E Use Effect Compartment model Fixed steepness Use Sigmoid Emax (add Hill coefficient) No tolerance Use Indirect Response models Symmetric curve Use more complex models"},{"location":"julia/models/pd/direct-emax/#derived-quantities","title":"Derived Quantities","text":""},{"location":"julia/models/pd/direct-emax/#sensitivity-slope-at-origin","title":"Sensitivity (Slope at Origin)","text":"\\[\\text{Sensitivity} = \\frac{dE}{dC}\\bigg|_{C=0} = \\frac{E_{max}}{EC_{50}}\\]"},{"location":"julia/models/pd/direct-emax/#therapeutic-window","title":"Therapeutic Window","text":"<p>If target effect range is E1 to E2:</p> \\[C_1 = EC_{50} \\cdot \\frac{E_1 - E_0}{E_{max} - (E_1 - E_0)}\\] \\[C_2 = EC_{50} \\cdot \\frac{E_2 - E_0}{E_{max} - (E_2 - E_0)}\\]"},{"location":"julia/models/pd/direct-emax/#equations-summary","title":"Equations Summary","text":"Quantity Formula Effect \\(E_0 + E_{max} \\cdot C / (EC_{50} + C)\\) Fraction of Emax \\(C / (EC_{50} + C)\\) C for target effect \\(EC_{50} \\cdot (E - E_0) / (E_{max} - (E - E_0))\\) Sensitivity \\(E_{max} / EC_{50}\\)"},{"location":"julia/models/pd/direct-emax/#see-also","title":"See Also","text":"<ul> <li>Sigmoid Emax Model - Variable steepness</li> <li>Effect Compartment Model - With temporal delay</li> <li>Indirect Response Models - Mechanism-based</li> <li>PKPD Coupling - Population PKPD</li> </ul>"},{"location":"julia/models/pd/disease-progression/","title":"Disease Progression Model","text":"<p>PD model for tumor growth dynamics with drug-induced cell kill, supporting multiple growth models.</p>"},{"location":"julia/models/pd/disease-progression/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# PK setup\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(0.0, 500.0)]\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\n# Disease Progression PD\npd_model = DiseaseProgressionPD(GompertzGrowth)\npd_params = DiseaseProgressionPDParams(\n    100.0,    # s0: initial tumor size\n    0.02,     # kgrow: growth rate\n    1000.0,   # smax: carrying capacity\n    0.0,      # alpha: linear rate (not used)\n    0.01      # kdrug: drug kill rate\n)\n\npd_spec = PDSpec(pd_model, \"tumor\", pd_params, :conc, :tumor_size)\n\ngrid = SimGrid(0.0, 336.0, 0:2:336)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pd/disease-progression/#parameters","title":"Parameters","text":"Parameter Type Description <code>s0</code> Float64 Initial tumor size <code>kgrow</code> Float64 Growth rate constant <code>smax</code> Float64 Maximum size (carrying capacity) <code>alpha</code> Float64 Linear growth rate <code>kdrug</code> Float64 Drug-induced cell kill rate"},{"location":"julia/models/pd/disease-progression/#growth-models","title":"Growth Models","text":"Model Constructor Equation Exponential <code>ExponentialGrowth</code> \\(dS/dt = k_{grow} \\cdot S\\) Linear <code>LinearGrowth</code> \\(dS/dt = \\alpha\\) Logistic <code>LogisticGrowth</code> \\(dS/dt = k_{grow} \\cdot S \\cdot (1 - S/S_{max})\\) Gompertz <code>GompertzGrowth</code> \\(dS/dt = k_{grow} \\cdot S \\cdot \\ln(S_{max}/S)\\) Asymptotic <code>AsymptoticGrowth</code> \\(dS/dt = k_{grow} \\cdot (S_{max} - S)\\) <p>Drug effect: \\(-k_{drug} \\cdot C \\cdot S\\)</p>"},{"location":"julia/models/pd/disease-progression/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\n# PK setup\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(i * 168.0, 200.0) for i in 0:3]  # Weekly\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\n# Gompertz tumor growth\npd_model = DiseaseProgressionPD(GompertzGrowth)\npd_params = DiseaseProgressionPDParams(100.0, 0.02, 1000.0, 0.0, 0.01)\npd_spec = PDSpec(pd_model, \"tumor\", pd_params, :conc, :tumor_size)\n\ngrid = SimGrid(0.0, 672.0, 0:4:672)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n\ntumor = result.observations[:tumor_size]\nt = result.t\n\nprintln(\"Initial: $(tumor[1])\")\nprintln(\"Day 28: $(tumor[end])\")\n</code></pre>"},{"location":"julia/models/pd/disease-progression/#comparing-growth-models","title":"Comparing Growth Models","text":"<pre><code>using OpenPKPDCore\n\nmodels = [\n    (\"Exponential\", ExponentialGrowth),\n    (\"Logistic\", LogisticGrowth),\n    (\"Gompertz\", GompertzGrowth),\n    (\"Asymptotic\", AsymptoticGrowth)\n]\n\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, DoseEvent[])\n\nprintln(\"Model | Day 14 | Day 28\")\nprintln(\"-\" ^ 35)\n\nfor (name, growth_type) in models\n    pd_model = DiseaseProgressionPD(growth_type)\n    pd_params = DiseaseProgressionPDParams(100.0, 0.02, 1000.0, 1.0, 0.0)\n    pd_spec = PDSpec(pd_model, \"tumor\", pd_params, :conc, :tumor_size)\n\n    grid = SimGrid(0.0, 672.0, 0:4:672)\n    solver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\n    result = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n    tumor = result.observations[:tumor_size]\n\n    println(\"$name | $(tumor[85]) | $(tumor[end])\")\nend\n</code></pre>"},{"location":"julia/models/pd/disease-progression/#tumor-growth-inhibition","title":"Tumor Growth Inhibition","text":"<pre><code>using OpenPKPDCore\n\n# Reference (no treatment)\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\npk_spec_ref = ModelSpec(pk_model, \"pk\", pk_params, DoseEvent[])\n\npd_model = DiseaseProgressionPD(LogisticGrowth)\npd_params = DiseaseProgressionPDParams(100.0, 0.02, 1000.0, 0.0, 0.0)\npd_spec = PDSpec(pd_model, \"tumor\", pd_params, :conc, :tumor_size)\n\ngrid = SimGrid(0.0, 336.0, 0:4:336)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult_ref = simulate_pkpd_coupled(pk_spec_ref, pd_spec, grid, solver)\nref_final = result_ref.observations[:tumor_size][end]\n\n# With treatment\ndoses = [DoseEvent(i * 168.0, 200.0) for i in 0:1]\npk_spec_tx = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\npd_params_tx = DiseaseProgressionPDParams(100.0, 0.02, 1000.0, 0.0, 0.01)\npd_spec_tx = PDSpec(pd_model, \"tumor\", pd_params_tx, :conc, :tumor_size)\n\nresult_tx = simulate_pkpd_coupled(pk_spec_tx, pd_spec_tx, grid, solver)\ntx_final = result_tx.observations[:tumor_size][end]\n\ntgi = (1 - tx_final / ref_final) * 100\nprintln(\"Control final: $ref_final\")\nprintln(\"Treatment final: $tx_final\")\nprintln(\"TGI: $tgi%\")\n</code></pre>"},{"location":"julia/models/pd/disease-progression/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Oncology dose-response modeling</li> <li>Tumor growth inhibition studies</li> <li>Combination therapy evaluation</li> <li>Survival surrogate endpoints</li> </ul>"},{"location":"julia/models/pd/disease-progression/#equations-summary","title":"Equations Summary","text":"Model dS/dt (without drug) Steady State Exponential \\(k_{grow} \\cdot S\\) \u221e Linear \\(\\alpha\\) \u221e Logistic \\(k_{grow} \\cdot S \\cdot (1 - S/S_{max})\\) \\(S_{max}\\) Gompertz \\(k_{grow} \\cdot S \\cdot \\ln(S_{max}/S)\\) \\(S_{max}\\) Asymptotic \\(k_{grow} \\cdot (S_{max} - S)\\) \\(S_{max}\\)"},{"location":"julia/models/pd/disease-progression/#see-also","title":"See Also","text":"<ul> <li>Transit Compartment PD - Delayed effects</li> <li>Indirect Response - Turnover models</li> </ul>"},{"location":"julia/models/pd/effect-compartment/","title":"Effect Compartment (Biophase) Model","text":"<p>Hypothetical effect site compartment to model temporal delays between plasma concentration and pharmacodynamic effect.</p>"},{"location":"julia/models/pd/effect-compartment/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt; PK[PK Model]\n    PK --&gt;|Cp| EC[Effect Site&lt;br/&gt;ke0]\n    EC --&gt;|Ce| PD[PD Model&lt;br/&gt;Emax]\n    PD --&gt; E((Effect))\n\n    style EC fill:#f9f,stroke:#333\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Anesthetics (propofol, remifentanil)</li> <li>Neuromuscular blocking agents</li> <li>CNS-active drugs</li> <li>Any drug showing hysteresis</li> <li>Delayed onset/offset effects</li> <li>Drugs crossing blood-brain barrier</li> </ul>"},{"location":"julia/models/pd/effect-compartment/#when-to-use","title":"When to Use","text":"Use When Don't Use When Counter-clockwise hysteresis Effect tracks concentration Delayed onset of effect Rapid equilibration (ke0 &gt;&gt; k) Effect persists after Cp drops Clockwise hysteresis (tolerance) Site-of-action differs from plasma Simple concentration-effect"},{"location":"julia/models/pd/effect-compartment/#hysteresis-explained","title":"Hysteresis Explained","text":""},{"location":"julia/models/pd/effect-compartment/#counter-clockwise-hysteresis","title":"Counter-Clockwise Hysteresis","text":"<p>When plotting Effect vs. Concentration:</p> <pre><code>Effect\n   \u2502     \u256d\u2500\u2192\u2500\u256e absorption/distribution phase\n   \u2502    \u2197    \u2198\n   \u2502   \u2502      \u2502\n   \u2502  \u2571        \u2572 elimination phase\n   \u2502 \u2571          \u2572\n   \u2502\u2571            \u2570\u2500\u2192\u2500\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 Concentration\n</code></pre> <p>Cause: Effect site concentration lags behind plasma concentration.</p>"},{"location":"julia/models/pd/effect-compartment/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pd/effect-compartment/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Effect site rate ke0 1/h Equilibration rate constant ke0 &gt; 0 Baseline effect E0 varies Effect with no drug any real Maximum effect Emax varies Maximum change from baseline typically &gt; 0 Effect site EC50 EC50 mg/L Ce at 50% Emax EC50 &gt; 0"},{"location":"julia/models/pd/effect-compartment/#effect-site-dynamics","title":"Effect Site Dynamics","text":"\\[\\frac{dC_e}{dt} = k_{e0} \\cdot (C_p - C_e)\\] <p>Where: - Ce = Effect site concentration - Cp = Plasma concentration - ke0 = Equilibration rate constant</p>"},{"location":"julia/models/pd/effect-compartment/#effect-calculation","title":"Effect Calculation","text":"<p>Using Direct Emax on effect site concentration:</p> \\[E(C_e) = E_0 + \\frac{E_{max} \\cdot C_e}{EC_{50} + C_e}\\]"},{"location":"julia/models/pd/effect-compartment/#key-derived-parameters","title":"Key Derived Parameters","text":"Parameter Formula Meaning t1/2,ke0 ln(2)/ke0 Equilibration half-life t90 ln(10)/ke0 Time to 90% equilibration"},{"location":"julia/models/pd/effect-compartment/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pd/effect-compartment/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct BiophaseEquilibration &lt;: PDModelKind end\n\n# Parameters\nstruct BiophaseEquilibrationParams\n    ke0::Float64     # Effect site equilibration rate (1/h)\n    E0::Float64      # Baseline effect\n    Emax::Float64    # Maximum effect\n    EC50::Float64    # Effect site EC50 (mg/L)\nend\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# PK Model: One-compartment IV bolus\npk_params = OneCompIVBolusParams(5.0, 20.0)  # CL, V\ndoses = [DoseEvent(0.0, 200.0)]\n\npk_spec = ModelSpec(OneCompIVBolus(), \"pk\", pk_params, doses)\n\n# Effect compartment PD parameters\n# ke0 = 0.5/h gives t1/2,ke0 = 1.4 h\npd_params = BiophaseEquilibrationParams(0.5, 0.0, 100.0, 5.0)\n\n# Simulation grid\ngrid = SimGrid(0.0, 12.0, collect(0.0:0.1:12.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Simulate PK\npk_result = simulate(pk_spec, grid, solver)\nCp = pk_result.observations[:conc]\nt = pk_result.t\n\n# Simulate effect compartment\nCe, effects = simulate_biophase(t, Cp, pd_params, solver)\n\n# Compare Cp and Ce\nprintln(\"Time to Cp max: 0.0 h (IV bolus)\")\nCe_max, idx = findmax(Ce)\nprintln(\"Time to Ce max: $(round(t[idx], digits=2)) h\")\nprintln(\"Delay due to effect compartment: $(round(t[idx], digits=2)) h\")\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#effect-of-ke0-on-response","title":"Effect of ke0 on Response","text":"<pre><code>using OpenPKPDCore\n\n# Same PK for all\npk_params = OneCompIVBolusParams(5.0, 20.0)\ndoses = [DoseEvent(0.0, 200.0)]\npk_spec = ModelSpec(OneCompIVBolus(), \"pk\", pk_params, doses)\n\ngrid = SimGrid(0.0, 12.0, collect(0.0:0.05:12.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\npk_result = simulate(pk_spec, grid, solver)\nCp = pk_result.observations[:conc]\nt = pk_result.t\n\n# Different ke0 values\nke0_values = [0.2, 0.5, 1.0, 2.0, 5.0]\n\nfor ke0 in ke0_values\n    pd_params = BiophaseEquilibrationParams(ke0, 0.0, 100.0, 5.0)\n    Ce, effects = simulate_biophase(t, Cp, pd_params, solver)\n\n    _, idx_max = findmax(effects)\n    t_max_effect = t[idx_max]\n    t_half_eq = log(2) / ke0\n\n    println(\"ke0=$ke0: t1/2,ke0=$(round(t_half_eq, digits=2)) h, \",\n            \"Tmax,effect=$(round(t_max_effect, digits=2)) h\")\nend\n</code></pre> <p>Expected Pattern: - Higher ke0 \u2192 Faster equilibration \u2192 Earlier Tmax,effect - Lower ke0 \u2192 Slower equilibration \u2192 More delayed Tmax,effect</p>"},{"location":"julia/models/pd/effect-compartment/#clinical-example-propofol-anesthesia","title":"Clinical Example: Propofol Anesthesia","text":"<pre><code>using OpenPKPDCore\n\n# Propofol three-compartment PK (simplified to 2-comp)\n# Parameters in per-minute\npk_params = TwoCompIVBolusParams(\n    1.6 * 60,   # CL (L/h from L/min)\n    4.3,        # V1 (L)\n    2.3 * 60,   # Q (L/h)\n    22.0        # V2 (L)\n)\n\n# 200 mg bolus\ndoses = [DoseEvent(0.0, 200.0)]\npk_spec = ModelSpec(TwoCompIVBolus(), \"propofol\", pk_params, doses)\n\n# Effect compartment\n# ke0 \u2248 0.26/min = 15.6/h for propofol\npd_params = BiophaseEquilibrationParams(\n    15.6,      # ke0 (1/h)\n    0.0,       # E0 (awake = 0)\n    100.0,     # Emax (deep anesthesia = 100)\n    3.0        # EC50 (mcg/mL = mg/L)\n)\n\n# Fine time grid (first 30 minutes)\ngrid = SimGrid(0.0, 0.5, collect(0.0:0.01:0.5))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\npk_result = simulate(pk_spec, grid, solver)\nCp = pk_result.observations[:conc]\nt = pk_result.t\n\nCe, depth = simulate_biophase(t, Cp, pd_params, solver)\n\n# Time to loss of consciousness (effect &gt; 50)\nloc_idx = findfirst(d -&gt; d &gt; 50, depth)\nif loc_idx !== nothing\n    println(\"Time to LOC: $(round(t[loc_idx] * 60, digits=1)) seconds\")\nend\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#comparing-direct-vs-effect-compartment","title":"Comparing Direct vs Effect Compartment","text":"<pre><code>using OpenPKPDCore\n\n# PK: One-compartment oral\npk_params = OneCompOralFirstOrderParams(2.0, 5.0, 30.0)\ndoses = [DoseEvent(0.0, 100.0)]\npk_spec = ModelSpec(OneCompOralFirstOrder(), \"pk\", pk_params, doses)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.1:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\npk_result = simulate(pk_spec, grid, solver)\nCp = pk_result.observations[:conc]\nt = pk_result.t\n\n# Direct Emax (no delay)\npd_direct = DirectEmaxParams(0.0, 100.0, 3.0)\nspec_direct = PDSpec(DirectEmax(), \"direct\", pd_direct)\neffects_direct = evaluate(spec_direct, Cp)\n\n# Effect compartment (with delay)\npd_biophase = BiophaseEquilibrationParams(0.3, 0.0, 100.0, 3.0)\nCe, effects_biophase = simulate_biophase(t, Cp, pd_biophase, solver)\n\n# Compare Tmax\n_, idx_direct = findmax(effects_direct)\n_, idx_biophase = findmax(effects_biophase)\n\nprintln(\"Direct Emax: Tmax,effect = $(round(t[idx_direct], digits=2)) h\")\nprintln(\"Effect Compartment: Tmax,effect = $(round(t[idx_biophase], digits=2)) h\")\nprintln(\"Delay: $(round(t[idx_biophase] - t[idx_direct], digits=2)) h\")\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#steady-state-considerations","title":"Steady State Considerations","text":"<p>At steady state, Ce = Cp (no hysteresis observable).</p> <pre><code># Multiple dosing - hysteresis diminishes over time\ndoses = [DoseEvent(i * 8.0, 100.0) for i in 0:6]  # Q8H for 2 days\n\npk_params = OneCompOralFirstOrderParams(1.5, 5.0, 30.0)\npk_spec = ModelSpec(OneCompOralFirstOrder(), \"pk\", pk_params, doses)\n\ngrid = SimGrid(0.0, 56.0, collect(0.0:0.25:56.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\npk_result = simulate(pk_spec, grid, solver)\nCp = pk_result.observations[:conc]\nt = pk_result.t\n\npd_params = BiophaseEquilibrationParams(0.5, 0.0, 100.0, 3.0)\nCe, effects = simulate_biophase(t, Cp, pd_params, solver)\n\n# Compare Ce/Cp ratio over time\n# Early: Ce lags Cp\n# Late: Ce \u2248 Cp at all times\nfor check_time in [4.0, 28.0, 52.0]\n    idx = findfirst(x -&gt; x &gt;= check_time, t)\n    ratio = Ce[idx] / Cp[idx]\n    println(\"At t=$check_time h: Ce/Cp = $(round(ratio, digits=3))\")\nend\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#parameter-interpretation","title":"Parameter Interpretation","text":""},{"location":"julia/models/pd/effect-compartment/#equilibration-half-life","title":"Equilibration Half-Life","text":"t1/2,ke0 Implication &lt; 10 min Negligible delay, use Direct Emax 10-60 min Moderate delay, effect compartment needed &gt; 1 hour Significant hysteresis"},{"location":"julia/models/pd/effect-compartment/#choosing-between-models","title":"Choosing Between Models","text":"<pre><code># Rule of thumb:\n# If t1/2,ke0 &lt; elimination t1/2 / 10, use Direct Emax\n# Otherwise, use Effect Compartment\n\nfunction recommend_model(ke0, kel)\n    t_half_ke0 = log(2) / ke0\n    t_half_kel = log(2) / kel\n\n    if t_half_ke0 &lt; t_half_kel / 10\n        println(\"Recommend: Direct Emax (fast equilibration)\")\n    else\n        println(\"Recommend: Effect Compartment (significant delay)\")\n    end\n\n    println(\"  t1/2,ke0 = $(round(t_half_ke0, digits=2)) h\")\n    println(\"  t1/2,kel = $(round(t_half_kel, digits=2)) h\")\nend\n\n# Example\nrecommend_model(5.0, 0.5)   # Fast ke0\nrecommend_model(0.2, 0.5)   # Slow ke0\n</code></pre>"},{"location":"julia/models/pd/effect-compartment/#equations-summary","title":"Equations Summary","text":"Quantity Formula dCe/dt \\(k_{e0} \\cdot (C_p - C_e)\\) Effect \\(E_0 + E_{max} \\cdot C_e / (EC_{50} + C_e)\\) t1/2,ke0 \\(\\ln(2) / k_{e0}\\) t90% equilibration \\(\\ln(10) / k_{e0}\\) Steady state \\(C_e = C_p\\)"},{"location":"julia/models/pd/effect-compartment/#see-also","title":"See Also","text":"<ul> <li>Direct Emax Model - Without delay</li> <li>Sigmoid Emax Model - Variable steepness</li> <li>Indirect Response Models - Mechanism-based</li> <li>Population Modeling - Population PKPD</li> </ul>"},{"location":"julia/models/pd/indirect-response/","title":"Indirect Response Models (IRM)","text":"<p>Mechanism-based PD models where drug affects the production (Kin) or elimination (Kout) of a response variable, rather than directly modulating the response.</p>"},{"location":"julia/models/pd/indirect-response/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    subgraph \"Turnover System\"\n        K1[Kin&lt;br/&gt;Production] --&gt; R[Response R]\n        R --&gt; K2[Kout&lt;br/&gt;Elimination]\n    end\n\n    C[Drug&lt;br/&gt;Concentration] -.-&gt;|Inhibits or&lt;br/&gt;Stimulates| K1\n    C -.-&gt;|Inhibits or&lt;br/&gt;Stimulates| K2\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#the-four-irm-types","title":"The Four IRM Types","text":"Model Target Direction Effect on R IRM-I Kin (production) Inhibition Decreases R IRM-II Kin (production) Stimulation Increases R IRM-III Kout (elimination) Inhibition Increases R IRM-IV Kout (elimination) Stimulation Decreases R"},{"location":"julia/models/pd/indirect-response/#clinical-applications","title":"Clinical Applications","text":"IRM Type Example Applications IRM-I Corticosteroids (cortisol), Statins (cholesterol), Warfarin (clotting factors) IRM-II EPO (RBC production), G-CSF (neutrophils), Growth factors IRM-III Diuretics (renal function), Thyroid hormones (metabolism) IRM-IV Laxatives (bowel motility), Some immunosuppressants"},{"location":"julia/models/pd/indirect-response/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pd/indirect-response/#baseline-turnover","title":"Baseline Turnover","text":"<p>At baseline (no drug):</p> \\[\\frac{dR}{dt} = K_{in} - K_{out} \\cdot R = 0\\] <p>Therefore: \\(R_0 = K_{in} / K_{out}\\)</p>"},{"location":"julia/models/pd/indirect-response/#drug-functions","title":"Drug Functions","text":"<p>Inhibition function (for IRM-I, IRM-III):</p> \\[I(C) = \\frac{I_{max} \\cdot C}{IC_{50} + C}\\] <p>Stimulation function (for IRM-II, IRM-IV):</p> \\[S(C) = \\frac{S_{max} \\cdot C}{SC_{50} + C}\\]"},{"location":"julia/models/pd/indirect-response/#irm-equations","title":"IRM Equations","text":"Model Differential Equation IRM-I \\(\\frac{dR}{dt} = K_{in} \\cdot (1 - I(C)) - K_{out} \\cdot R\\) IRM-II \\(\\frac{dR}{dt} = K_{in} \\cdot (1 + S(C)) - K_{out} \\cdot R\\) IRM-III \\(\\frac{dR}{dt} = K_{in} - K_{out} \\cdot (1 - I(C)) \\cdot R\\) IRM-IV \\(\\frac{dR}{dt} = K_{in} - K_{out} \\cdot (1 + S(C)) \\cdot R\\)"},{"location":"julia/models/pd/indirect-response/#parameters","title":"Parameters","text":""},{"location":"julia/models/pd/indirect-response/#common-parameters","title":"Common Parameters","text":"Parameter Symbol Units Description Constraints Production rate Kin units/h Zero-order production Kin &gt; 0 Elimination rate Kout 1/h First-order elimination Kout &gt; 0 Baseline response R0 units Steady-state baseline R0 = Kin/Kout"},{"location":"julia/models/pd/indirect-response/#inhibition-parameters-irm-i-irm-iii","title":"Inhibition Parameters (IRM-I, IRM-III)","text":"Parameter Symbol Units Description Constraints Maximum inhibition Imax - Fraction at saturation 0 &lt; Imax \u2264 1 Inhibition potency IC50 mg/L Concentration for 50% Imax IC50 &gt; 0"},{"location":"julia/models/pd/indirect-response/#stimulation-parameters-irm-ii-irm-iv","title":"Stimulation Parameters (IRM-II, IRM-IV)","text":"Parameter Symbol Units Description Constraints Maximum stimulation Smax - Fold-increase at saturation Smax &gt; 0 Stimulation potency SC50 mg/L Concentration for 50% Smax SC50 &gt; 0"},{"location":"julia/models/pd/indirect-response/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pd/indirect-response/#type-definitions","title":"Type Definitions","text":"<pre><code># IRM-I: Inhibition of Kin\nstruct IndirectResponseIRM1 &lt;: PDModelKind end\nstruct IndirectResponseIRM1Params\n    Kin::Float64      # Production rate\n    Kout::Float64     # Elimination rate constant\n    R0::Float64       # Baseline response\n    Imax::Float64     # Maximum inhibition [0, 1]\n    IC50::Float64     # Inhibition potency\nend\n\n# IRM-II: Stimulation of Kin\nstruct IndirectResponseIRM2 &lt;: PDModelKind end\nstruct IndirectResponseIRM2Params\n    Kin::Float64\n    Kout::Float64\n    R0::Float64\n    Smax::Float64     # Maximum stimulation (can exceed 1)\n    SC50::Float64     # Stimulation potency\nend\n\n# IRM-III: Inhibition of Kout (also known as IndirectResponseTurnover)\nstruct IndirectResponseTurnover &lt;: PDModelKind end\nstruct IndirectResponseTurnoverParams\n    Kin::Float64\n    Kout::Float64\n    R0::Float64\n    Imax::Float64\n    IC50::Float64\nend\n\n# IRM-IV: Stimulation of Kout\nstruct IndirectResponseIRM4 &lt;: PDModelKind end\nstruct IndirectResponseIRM4Params\n    Kin::Float64\n    Kout::Float64\n    R0::Float64\n    Smax::Float64\n    SC50::Float64\nend\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#irm-i-inhibition-of-production","title":"IRM-I: Inhibition of Production","text":""},{"location":"julia/models/pd/indirect-response/#mechanism","title":"Mechanism","text":"<p>Drug inhibits the production of the response variable.</p> \\[\\frac{dR}{dt} = K_{in} \\cdot \\left(1 - \\frac{I_{max} \\cdot C}{IC_{50} + C}\\right) - K_{out} \\cdot R\\]"},{"location":"julia/models/pd/indirect-response/#clinical-example-corticosteroid-effect-on-cortisol","title":"Clinical Example: Corticosteroid Effect on Cortisol","text":"<pre><code>using OpenPKPDCore\n\n# Cortisol dynamics\n# Baseline cortisol: 15 mcg/dL\n# Turnover half-life: ~1.5 hours\nKout = log(2) / 1.5  # 0.46/h\nR0 = 15.0\nKin = Kout * R0  # 6.9 mcg/dL/h\n\n# Corticosteroid effect\npd_params = IndirectResponseIRM1Params(\n    Kin,\n    Kout,\n    R0,\n    0.9,    # Imax: 90% suppression possible\n    0.01    # IC50: 0.01 mg/L (very potent)\n)\n\n# Validate\nspec = PDSpec(IndirectResponseIRM1(), \"cortisol\", pd_params)\nvalidate(spec)\n\nprintln(\"Baseline cortisol: $(R0) mcg/dL\")\nprintln(\"Turnover t1/2: $(round(log(2)/Kout, digits=2)) h\")\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#response-profile","title":"Response Profile","text":"<pre><code># PK: Single oral dose\npk_params = OneCompOralFirstOrderParams(1.5, 2.0, 50.0)\ndoses = [DoseEvent(0.0, 10.0)]  # 10 mg dose\n\npk_spec = ModelSpec(OneCompOralFirstOrder(), \"steroid\", pk_params, doses)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.25:48.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Simulate coupled PKPD\nresult = simulate_pkpd(pk_spec, spec, grid, solver)\n\n# Key features of IRM-I:\n# - Effect is delayed relative to concentration\n# - Maximum suppression occurs AFTER Cmax\n# - Slow return to baseline (governed by Kout)\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#irm-ii-stimulation-of-production","title":"IRM-II: Stimulation of Production","text":""},{"location":"julia/models/pd/indirect-response/#mechanism_1","title":"Mechanism","text":"<p>Drug increases the production rate.</p> \\[\\frac{dR}{dt} = K_{in} \\cdot \\left(1 + \\frac{S_{max} \\cdot C}{SC_{50} + C}\\right) - K_{out} \\cdot R\\]"},{"location":"julia/models/pd/indirect-response/#clinical-example-epo-on-red-blood-cells","title":"Clinical Example: EPO on Red Blood Cells","text":"<pre><code>using OpenPKPDCore\n\n# RBC dynamics\n# Baseline RBC: 5 million/mcL\n# Turnover half-life: ~30 days\nKout = log(2) / (30 * 24)  # 0.001/h\nR0 = 5.0  # million/mcL\nKin = Kout * R0\n\n# EPO stimulation\npd_params = IndirectResponseIRM2Params(\n    Kin,\n    Kout,\n    R0,\n    3.0,    # Smax: up to 4\u00d7 production\n    0.1     # SC50: 0.1 mIU/mL\n)\n\nspec = PDSpec(IndirectResponseIRM2(), \"rbc\", pd_params)\n\n# Maximum possible response at infinite C:\n# R_max = Kin \u00d7 (1 + Smax) / Kout = R0 \u00d7 (1 + Smax) = 20 million/mcL\nprintln(\"Maximum possible RBC: $(R0 * (1 + pd_params.Smax)) million/mcL\")\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#irm-iii-inhibition-of-elimination","title":"IRM-III: Inhibition of Elimination","text":""},{"location":"julia/models/pd/indirect-response/#mechanism_2","title":"Mechanism","text":"<p>Drug inhibits the elimination of the response variable.</p> \\[\\frac{dR}{dt} = K_{in} - K_{out} \\cdot \\left(1 - \\frac{I_{max} \\cdot C}{IC_{50} + C}\\right) \\cdot R\\]"},{"location":"julia/models/pd/indirect-response/#clinical-example-warfarin-effect-on-clotting-factors","title":"Clinical Example: Warfarin Effect on Clotting Factors","text":"<pre><code>using OpenPKPDCore\n\n# Clotting factor dynamics\n# Baseline: 100% of normal\n# Turnover half-life: ~36 hours\nKout = log(2) / 36.0\nR0 = 100.0  # % of normal\nKin = Kout * R0\n\n# Warfarin effect (inhibits synthesis, modeled as IRM-III)\npd_params = IndirectResponseTurnoverParams(\n    Kin,\n    Kout,\n    R0,\n    0.95,   # Imax: 95% inhibition possible\n    1.5     # IC50: 1.5 mg/L\n)\n\nspec = PDSpec(IndirectResponseTurnover(), \"clotting\", pd_params)\n\n# Minimum possible response (at complete inhibition):\n# When I(C) \u2192 Imax, Kout_eff \u2192 Kout \u00d7 (1 - Imax)\n# New steady state: R_min = Kin / (Kout \u00d7 (1 - Imax))\n# For Imax = 0.95: R_min = R0 / 0.05 = 2000 (unrealistic)\n# In practice, Imax &lt; 1 ensures R remains finite\nprintln(\"With complete inhibition, R could increase to: \",\n        round(R0 / (1 - pd_params.Imax), digits=1), \"%\")\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#irm-iv-stimulation-of-elimination","title":"IRM-IV: Stimulation of Elimination","text":""},{"location":"julia/models/pd/indirect-response/#mechanism_3","title":"Mechanism","text":"<p>Drug increases the elimination rate.</p> \\[\\frac{dR}{dt} = K_{in} - K_{out} \\cdot \\left(1 + \\frac{S_{max} \\cdot C}{SC_{50} + C}\\right) \\cdot R\\]"},{"location":"julia/models/pd/indirect-response/#clinical-example-laxative-effect","title":"Clinical Example: Laxative Effect","text":"<pre><code>using OpenPKPDCore\n\n# Bowel content dynamics\nKout = log(2) / 12.0  # ~12 hour transit\nR0 = 100.0  # arbitrary units\nKin = Kout * R0\n\n# Laxative stimulates elimination\npd_params = IndirectResponseIRM4Params(\n    Kin,\n    Kout,\n    R0,\n    5.0,    # Smax: up to 6\u00d7 elimination rate\n    0.5     # SC50\n)\n\nspec = PDSpec(IndirectResponseIRM4(), \"bowel\", pd_params)\n\n# Minimum response at high drug concentration:\n# R_min = Kin / (Kout \u00d7 (1 + Smax)) = R0 / (1 + Smax)\nprintln(\"Minimum response: $(round(R0 / (1 + pd_params.Smax), digits=1)) units\")\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#comparing-irm-types","title":"Comparing IRM Types","text":"<pre><code>using OpenPKPDCore\n\n# Same baseline and turnover for all\nKout = 0.1  # 1/h\nR0 = 100.0\nKin = Kout * R0\n\n# Same drug concentration profile\npk_params = OneCompIVBolusParams(2.0, 20.0)\ndoses = [DoseEvent(0.0, 100.0)]\npk_spec = ModelSpec(OneCompIVBolus(), \"drug\", pk_params, doses)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.25:48.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\npk_result = simulate(pk_spec, grid, solver)\n\n# IRM-I and IRM-IV: Response DECREASES\nparams_irm1 = IndirectResponseIRM1Params(Kin, Kout, R0, 0.8, 2.0)\nparams_irm4 = IndirectResponseIRM4Params(Kin, Kout, R0, 4.0, 2.0)\n\n# IRM-II and IRM-III: Response INCREASES\nparams_irm2 = IndirectResponseIRM2Params(Kin, Kout, R0, 3.0, 2.0)\nparams_irm3 = IndirectResponseTurnoverParams(Kin, Kout, R0, 0.8, 2.0)\n\nprintln(\"At high drug concentrations:\")\nprintln(\"  IRM-I (inhib Kin): R decreases toward $(R0 * (1 - 0.8))\")\nprintln(\"  IRM-II (stim Kin): R increases toward $(R0 * (1 + 3.0))\")\nprintln(\"  IRM-III (inhib Kout): R increases (limited by Imax &lt; 1)\")\nprintln(\"  IRM-IV (stim Kout): R decreases toward $(round(R0 / (1 + 4.0), digits=1))\")\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#response-dynamics","title":"Response Dynamics","text":""},{"location":"julia/models/pd/indirect-response/#time-to-maximumminimum-effect","title":"Time to Maximum/Minimum Effect","text":"<p>Unlike direct effect models, IRM effects are delayed:</p> Factor Effect on Delay Lower Kout Longer delay (slower turnover) Higher IC50/SC50 Longer time at effective concentration Longer drug exposure Greater effect accumulation"},{"location":"julia/models/pd/indirect-response/#return-to-baseline","title":"Return to Baseline","text":"<p>After drug washout:</p> \\[t_{90\\%\\ recovery} \\approx \\frac{2.3}{K_{out}}\\]"},{"location":"julia/models/pd/indirect-response/#population-simulation","title":"Population Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Typical IRM-I parameters\ntypical_params = IndirectResponseIRM1Params(10.0, 0.1, 100.0, 0.8, 2.0)\n\n# IIV on turnover and potency\nomega = OmegaMatrix([\n    0.09 0.0  0.0;    # \u03c9\u00b2_Kout (30% CV on turnover)\n    0.0  0.16 0.0;    # \u03c9\u00b2_Imax (40% CV on max effect)\n    0.0  0.0  0.25    # \u03c9\u00b2_IC50 (50% CV on potency)\n])\n\n# Note: R0 and Kin are usually fixed or derived\n# since R0 = Kin/Kout at baseline\n\nbase_spec = PDSpec(IndirectResponseIRM1(), \"pop_irm\", typical_params)\npop_spec = PopulationSpec(base_spec, 50, omega, 12345)\n</code></pre>"},{"location":"julia/models/pd/indirect-response/#model-selection-guide","title":"Model Selection Guide","text":"Observation Suggested Model Drug decreases biomarker IRM-I or IRM-IV Drug increases biomarker IRM-II or IRM-III Effect persists after drug washout Any IRM (vs direct effect) Biomarker is a production rate IRM-I (inhibit) or IRM-II (stimulate) Biomarker is eliminated/degraded IRM-III (inhibit) or IRM-IV (stimulate) Known mechanism of action Select based on biology"},{"location":"julia/models/pd/indirect-response/#equations-summary","title":"Equations Summary","text":"Model dR/dt Steady State at High C IRM-I \\(K_{in}(1-I(C)) - K_{out}R\\) \\(R_0(1-I_{max})\\) IRM-II \\(K_{in}(1+S(C)) - K_{out}R\\) \\(R_0(1+S_{max})\\) IRM-III \\(K_{in} - K_{out}(1-I(C))R\\) \\(R_0/(1-I_{max})\\) IRM-IV \\(K_{in} - K_{out}(1+S(C))R\\) \\(R_0/(1+S_{max})\\) <p>Common to all: - Baseline: \\(R_0 = K_{in}/K_{out}\\) - Recovery t1/2: \\(\\ln(2)/K_{out}\\)</p>"},{"location":"julia/models/pd/indirect-response/#see-also","title":"See Also","text":"<ul> <li>Direct Emax Model - Simpler, no delay</li> <li>Sigmoid Emax Model - Variable steepness</li> <li>Effect Compartment Model - Temporal delay</li> <li>Population Modeling - Population PKPD</li> </ul>"},{"location":"julia/models/pd/sigmoid-emax/","title":"Sigmoid Emax (Hill) Model","text":"<p>Extended Emax model with Hill coefficient (gamma) controlling the steepness of the concentration-response curve.</p>"},{"location":"julia/models/pd/sigmoid-emax/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    C[Plasma&lt;br/&gt;Concentration] --&gt;|Hill Function| E[Effect]\n\n    subgraph \"Sigmoid Emax\"\n        direction TB\n        E0[E0: Baseline]\n        EM[Emax: Maximum]\n        EC[EC50: Potency]\n        G[gamma: Steepness]\n    end\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Neuromuscular blocking agents</li> <li>Ion channel blockers</li> <li>Drugs with cooperative binding</li> <li>Threshold effects</li> <li>All-or-none responses</li> <li>Antibiotics (Hill-Langmuir model)</li> </ul>"},{"location":"julia/models/pd/sigmoid-emax/#when-to-use","title":"When to Use","text":"Use When Don't Use When Steep dose-response gamma = 1 (use Direct Emax) Threshold effects Time delays needed Cooperative binding Complex hysteresis Switch-like responses Tolerance development"},{"location":"julia/models/pd/sigmoid-emax/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pd/sigmoid-emax/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Baseline effect E0 varies Effect with no drug any real Maximum effect Emax varies Maximum drug-induced change typically &gt; 0 Half-maximal concentration EC50 mg/L Concentration at 50% Emax EC50 &gt; 0 Hill coefficient gamma (n) - Steepness/cooperativity gamma &gt; 0"},{"location":"julia/models/pd/sigmoid-emax/#hill-equation","title":"Hill Equation","text":"\\[E(C) = E_0 + \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\] <p>Equivalent formulation (more stable numerically):</p> \\[E(C) = E_0 + \\frac{E_{max}}{1 + (EC_{50}/C)^\\gamma}\\]"},{"location":"julia/models/pd/sigmoid-emax/#effect-of-gamma","title":"Effect of Gamma","text":"Gamma Value Curve Shape Biological Interpretation gamma &lt; 1 Shallow, gradual Negative cooperativity gamma = 1 Standard Emax (hyperbolic) Simple binding gamma &gt; 1 Steep, sigmoidal Positive cooperativity gamma &gt;&gt; 3 Near-threshold All-or-none response"},{"location":"julia/models/pd/sigmoid-emax/#model-behavior","title":"Model Behavior","text":""},{"location":"julia/models/pd/sigmoid-emax/#concentration-effect-curves-by-gamma","title":"Concentration-Effect Curves by Gamma","text":"<pre><code>Effect\n   \u2502\nEmax\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502         \u256d\u2500\u2500\u2500gamma=3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502       \u256d\u2500\u256f\n    \u2502      \u2571  \u256d\u2500\u2500gamma=1 (Direct)\u2500\u2500\n    \u2502     \u2571  \u2571\n    \u2502    \u2571  \u2571   \u256d\u2500\u2500gamma=0.5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502   \u2571  \u2571   \u2571\nE0+\u00bd\u251c\u2500\u2500\u2573\u2500\u2500\u2573\u2500\u2500\u2500\u2573\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n    \u2502  \u2502\n E0 \u251c\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2192 C\n     EC50\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#steepness-at-ec50","title":"Steepness at EC50","text":"<p>The slope at EC50 (inflection point):</p> \\[\\frac{dE}{dC}\\bigg|_{C=EC_{50}} = \\frac{\\gamma \\cdot E_{max}}{4 \\cdot EC_{50}}\\] <p>Higher gamma = steeper transition around EC50.</p>"},{"location":"julia/models/pd/sigmoid-emax/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pd/sigmoid-emax/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct SigmoidEmax &lt;: PDModelKind end\n\n# Parameters\nstruct SigmoidEmaxParams\n    E0::Float64      # Baseline effect\n    Emax::Float64    # Maximum effect\n    EC50::Float64    # Half-maximal concentration (mg/L)\n    gamma::Float64   # Hill coefficient\nend\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#basic-usage","title":"Basic Usage","text":"<pre><code>using OpenPKPDCore\n\n# Define Sigmoid Emax parameters\n# gamma = 3 gives steep response\npd_params = SigmoidEmaxParams(0.0, 100.0, 2.0, 3.0)\n\n# Create specification\npd_spec = PDSpec(SigmoidEmax(), \"response\", pd_params)\n\n# Evaluate across concentration range\nconcentrations = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 6.0]\neffects = evaluate(pd_spec, concentrations)\n\nfor (c, e) in zip(concentrations, effects)\n    println(\"C = $c: Effect = $(round(e, digits=1))%\")\nend\n</code></pre> <p>Expected Output (gamma=3): <pre><code>C = 0.0: Effect = 0.0%\nC = 0.5: Effect = 1.5%\nC = 1.0: Effect = 11.1%\nC = 1.5: Effect = 29.7%\nC = 2.0: Effect = 50.0%\nC = 2.5: Effect = 66.1%\nC = 3.0: Effect = 77.1%\nC = 4.0: Effect = 88.9%\nC = 6.0: Effect = 96.4%\n</code></pre></p>"},{"location":"julia/models/pd/sigmoid-emax/#comparing-different-gamma-values","title":"Comparing Different Gamma Values","text":"<pre><code>using OpenPKPDCore\n\ngamma_values = [0.5, 1.0, 2.0, 3.0, 5.0]\nEC50 = 2.0\nEmax = 100.0\n\nfor gamma in gamma_values\n    params = SigmoidEmaxParams(0.0, Emax, EC50, gamma)\n    spec = PDSpec(SigmoidEmax(), \"test\", params)\n\n    # Effect at different concentrations\n    e_low = evaluate(spec, [EC50/2])[1]   # Below EC50\n    e_mid = evaluate(spec, [EC50])[1]      # At EC50\n    e_high = evaluate(spec, [EC50*2])[1]   # Above EC50\n\n    println(\"gamma=$gamma: E(EC50/2)=$(round(e_low, digits=1)), \",\n            \"E(EC50)=$(round(e_mid, digits=1)), \",\n            \"E(2\u00d7EC50)=$(round(e_high, digits=1))\")\nend\n</code></pre> <p>Expected Output: <pre><code>gamma=0.5: E(EC50/2)=41.4, E(EC50)=50.0, E(2\u00d7EC50)=58.6\ngamma=1.0: E(EC50/2)=33.3, E(EC50)=50.0, E(2\u00d7EC50)=66.7\ngamma=2.0: E(EC50/2)=20.0, E(EC50)=50.0, E(2\u00d7EC50)=80.0\ngamma=3.0: E(EC50/2)=11.1, E(EC50)=50.0, E(2\u00d7EC50)=88.9\ngamma=5.0: E(EC50/2)=3.0, E(EC50)=50.0, E(2\u00d7EC50)=97.0\n</code></pre></p>"},{"location":"julia/models/pd/sigmoid-emax/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pd/sigmoid-emax/#concentration-at-any-fraction-of-emax","title":"Concentration at Any Fraction of Emax","text":"<p>For fraction f (0 &lt; f &lt; 1):</p> \\[C_f = EC_{50} \\cdot \\left(\\frac{f}{1-f}\\right)^{1/\\gamma}\\] <pre><code># Helper function\nfunction concentration_at_fraction(EC50::Float64, gamma::Float64, fraction::Float64)\n    return EC50 * (fraction / (1 - fraction))^(1/gamma)\nend\n\n# Example: Find EC10 and EC90 for different gamma\nEC50 = 2.0\nfor gamma in [1.0, 2.0, 3.0]\n    EC10 = concentration_at_fraction(EC50, gamma, 0.1)\n    EC90 = concentration_at_fraction(EC50, gamma, 0.9)\n    ratio = EC90 / EC10\n\n    println(\"gamma=$gamma: EC10=$(round(EC10, digits=2)), \",\n            \"EC90=$(round(EC90, digits=2)), \",\n            \"EC90/EC10=$(round(ratio, digits=1))\")\nend\n</code></pre> <p>Expected Output: <pre><code>gamma=1: EC10=0.22, EC90=18.0, EC90/EC10=81.0\ngamma=2: EC10=0.67, EC90=6.0, EC90/EC10=9.0\ngamma=3: EC10=0.93, EC90=4.33, EC90/EC10=4.7\n</code></pre></p> <p>Key insight: Higher gamma compresses the concentration range between EC10 and EC90.</p>"},{"location":"julia/models/pd/sigmoid-emax/#clinical-example-neuromuscular-blockade","title":"Clinical Example: Neuromuscular Blockade","text":"<pre><code>using OpenPKPDCore\n\n# Rocuronium neuromuscular blockade\n# Typical gamma = 3-4 (steep response)\n# EC50 \u2248 1 mcg/mL for 50% twitch depression\n\npd_params = SigmoidEmaxParams(\n    100.0,    # E0: 100% baseline twitch height\n    -100.0,   # Emax: complete block possible\n    1.0,      # EC50: 1 mcg/mL\n    3.5       # gamma: steep response\n)\n\nspec = PDSpec(SigmoidEmax(), \"twitch\", pd_params)\n\n# Clinical concentrations\nconcentrations = [0.0, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0]\ntwitch = evaluate(spec, concentrations)\n\nprintln(\"Neuromuscular Blockade:\")\nfor (c, t) in zip(concentrations, twitch)\n    block = 100 - t\n    println(\"  C=$(c) mcg/mL: $(round(t, digits=1))% twitch \",\n            \"($(round(block, digits=1))% block)\")\nend\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#pkpd-simulation-with-steep-response","title":"PKPD Simulation with Steep Response","text":"<pre><code>using OpenPKPDCore\n\n# PK: Two-compartment IV\npk_params = TwoCompIVBolusParams(3.0, 10.0, 5.0, 30.0)\ndoses = [DoseEvent(0.0, 200.0)]  # 200 mg IV bolus\n\npk_spec = ModelSpec(TwoCompIVBolus(), \"pk\", pk_params, doses)\n\n# PD: Sigmoid Emax with steep gamma\npd_params = SigmoidEmaxParams(0.0, 100.0, 5.0, 4.0)\npd_spec = PDSpec(SigmoidEmax(), \"effect\", pd_params)\n\n# Simulate\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.1:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\npk_result = simulate(pk_spec, grid, solver)\nconc = pk_result.observations[:conc]\neffects = evaluate(pd_spec, conc)\n\n# Find duration of effect &gt; 90% of Emax\nthreshold = 90.0\nabove_threshold = effects .&gt; threshold\nfirst_above = findfirst(above_threshold)\nlast_above = findlast(above_threshold)\n\nif first_above !== nothing &amp;&amp; last_above !== nothing\n    duration = grid.times[last_above] - grid.times[first_above]\n    println(\"Duration of effect &gt; 90%: $(round(duration, digits=1)) hours\")\nend\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#therapeutic-index-and-gamma","title":"Therapeutic Index and Gamma","text":"<p>Higher gamma provides a narrower therapeutic window:</p> <pre><code># Drug with narrow therapeutic index (high gamma)\n# Effective concentration range is compressed\n\nEC50_efficacy = 2.0\nEC50_toxicity = 8.0  # 4\u00d7 separation\ngamma_efficacy = 3.0\ngamma_toxicity = 3.0\n\nparams_eff = SigmoidEmaxParams(0.0, 100.0, EC50_efficacy, gamma_efficacy)\nparams_tox = SigmoidEmaxParams(0.0, 100.0, EC50_toxicity, gamma_toxicity)\n\nspec_eff = PDSpec(SigmoidEmax(), \"efficacy\", params_eff)\nspec_tox = PDSpec(SigmoidEmax(), \"toxicity\", params_tox)\n\n# Find therapeutic window\n# Target: &gt;80% efficacy with &lt;20% toxicity\nconcentrations = collect(0.0:0.1:12.0)\nefficacy = evaluate(spec_eff, concentrations)\ntoxicity = evaluate(spec_tox, concentrations)\n\nfor (c, eff, tox) in zip(concentrations, efficacy, toxicity)\n    if eff &gt; 80.0 &amp;&amp; tox &lt; 20.0\n        println(\"C=$c: Efficacy=$(round(eff, digits=1))%, Toxicity=$(round(tox, digits=1))%\")\n    end\nend\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#numerical-stability","title":"Numerical Stability","text":"<p>For large gamma values, use the stable form:</p> <pre><code># Standard form (may overflow for large gamma and C &gt;&gt; EC50):\n# E = E0 + Emax * C^gamma / (EC50^gamma + C^gamma)\n\n# Stable form (used internally):\n# E = E0 + Emax / (1 + (EC50/C)^gamma)\n\nfunction sigmoid_emax_stable(C, E0, Emax, EC50, gamma)\n    if C &lt;= 0.0\n        return E0\n    end\n    ratio = (EC50 / C)^gamma\n    return E0 + Emax / (1.0 + ratio)\nend\n</code></pre>"},{"location":"julia/models/pd/sigmoid-emax/#equations-summary","title":"Equations Summary","text":"Quantity Formula Effect \\(E_0 + \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\) Stable form \\(E_0 + \\frac{E_{max}}{1 + (EC_{50}/C)^\\gamma}\\) C at fraction f \\(EC_{50} \\cdot (f/(1-f))^{1/\\gamma}\\) Slope at EC50 \\(\\gamma \\cdot E_{max} / (4 \\cdot EC_{50})\\) EC90/EC10 ratio \\(81^{1/\\gamma}\\)"},{"location":"julia/models/pd/sigmoid-emax/#see-also","title":"See Also","text":"<ul> <li>Direct Emax Model - Gamma = 1 case</li> <li>Effect Compartment Model - With temporal delay</li> <li>Indirect Response Models - Mechanism-based</li> <li>Population Modeling - Population PKPD</li> </ul>"},{"location":"julia/models/pd/tolerance/","title":"Tolerance Models","text":"<p>PD models for tolerance development through counter-regulation or receptor regulation mechanisms.</p>"},{"location":"julia/models/pd/tolerance/#counter-regulation-tolerance","title":"Counter-Regulation Tolerance","text":""},{"location":"julia/models/pd/tolerance/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# PK setup\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(i * 8.0, 50.0) for i in 0:20]  # TID for 7 days\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\n# Tolerance PD\npd_model = ToleranceCounterRegulation()\npd_params = ToleranceCounterRegulationParams(\n    0.0,      # e0\n    100.0,    # emax\n    5.0,      # ec50\n    1.0,      # gamma\n    0.1,      # kin_mod\n    0.05,     # kout_mod\n    1.0       # alpha_feedback\n)\n\npd_spec = PDSpec(pd_model, \"tol\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 168.0, 0:0.5:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pd/tolerance/#parameters","title":"Parameters","text":"Parameter Type Description <code>e0</code> Float64 Baseline effect <code>emax</code> Float64 Maximum drug effect <code>ec50</code> Float64 EC50 for drug effect <code>gamma</code> Float64 Hill coefficient <code>kin_mod</code> Float64 Moderator production rate <code>kout_mod</code> Float64 Moderator elimination rate <code>alpha_feedback</code> Float64 Feedback strength"},{"location":"julia/models/pd/tolerance/#model-equations","title":"Model Equations","text":"<p>Drug effect: $\\(E_{drug} = \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\)$</p> <p>Moderator dynamics: $\\(\\frac{dM}{dt} = k_{in,mod} \\cdot E_{drug} - k_{out,mod} \\cdot M\\)$</p> <p>Net effect: $\\(E_{net} = E_0 + E_{drug} - \\alpha \\cdot M\\)$</p>"},{"location":"julia/models/pd/tolerance/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(i * 8.0, 50.0) for i in 0:20]\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\npd_model = ToleranceCounterRegulation()\npd_params = ToleranceCounterRegulationParams(0.0, 100.0, 5.0, 1.0, 0.1, 0.05, 1.0)\npd_spec = PDSpec(pd_model, \"tol\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 168.0, 0:0.5:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n\neffect = result.observations[:effect]\n\n# Compare first vs last dose\nfirst_peak = maximum(effect[1:16])\nlast_peak = maximum(effect[end-16:end])\n\nprintln(\"First dose peak: $first_peak\")\nprintln(\"Last dose peak: $last_peak\")\nprintln(\"Tolerance: $((1 - last_peak/first_peak) * 100)%\")\n</code></pre>"},{"location":"julia/models/pd/tolerance/#receptor-regulation-model","title":"Receptor Regulation Model","text":""},{"location":"julia/models/pd/tolerance/#usage_1","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# PK setup\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(i * 8.0, 50.0) for i in 0:20]\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\n# Receptor regulation PD\npd_model = ReceptorRegulation()\npd_params = ReceptorRegulationParams(\n    0.0,      # e0\n    100.0,    # emax\n    5.0,      # ec50\n    1.0,      # gamma\n    1.0,      # r_baseline\n    0.05,     # kreg\n    2.0,      # rmax\n    0.02,     # kchange\n    :down     # direction\n)\n\npd_spec = PDSpec(pd_model, \"receptor\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 168.0, 0:0.5:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pd/tolerance/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>r_baseline</code> Float64 Baseline receptor density <code>kreg</code> Float64 Receptor recovery rate <code>rmax</code> Float64 Maximum receptor density <code>kchange</code> Float64 Rate of receptor change <code>direction</code> Symbol <code>:down</code> or <code>:up</code>"},{"location":"julia/models/pd/tolerance/#receptor-equations","title":"Receptor Equations","text":"<p>Down-regulation: $\\(\\frac{dR}{dt} = k_{reg} \\cdot (R_0 - R) - k_{change} \\cdot E_{drug} \\cdot R\\)$</p> <p>Up-regulation: $\\(\\frac{dR}{dt} = k_{reg} \\cdot (R_0 - R) + k_{change} \\cdot E_{drug} \\cdot (R_{max} - R)\\)$</p> <p>Net effect: $\\(E_{net} = E_0 + R \\cdot E_{drug}\\)$</p>"},{"location":"julia/models/pd/tolerance/#down-regulation-example","title":"Down-Regulation Example","text":"<pre><code>using OpenPKPDCore\n\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(i * 8.0, 50.0) for i in 0:20]\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\npd_model = ReceptorRegulation()\npd_params = ReceptorRegulationParams(0.0, 100.0, 5.0, 1.0, 1.0, 0.05, 2.0, 0.02, :down)\npd_spec = PDSpec(pd_model, \"beta_receptor\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 168.0, 0:0.5:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n\neffect = result.observations[:effect]\nreceptor = result.states[:R]\n\nprintln(\"Initial receptor: $(receptor[1])\")\nprintln(\"Day 7 receptor: $(receptor[end])\")\nprintln(\"First peak effect: $(maximum(effect[1:16]))\")\nprintln(\"Day 7 peak effect: $(maximum(effect[end-16:end]))\")\n</code></pre>"},{"location":"julia/models/pd/tolerance/#clinical-applications","title":"Clinical Applications","text":""},{"location":"julia/models/pd/tolerance/#counter-regulation","title":"Counter-Regulation","text":"<ul> <li>Opioid tolerance</li> <li>Benzodiazepine tolerance</li> <li>Beta-blocker tolerance</li> </ul>"},{"location":"julia/models/pd/tolerance/#receptor-regulation","title":"Receptor Regulation","text":"<ul> <li>Beta-receptor down-regulation</li> <li>Opioid receptor adaptation</li> <li>Hormone receptor changes</li> </ul>"},{"location":"julia/models/pd/tolerance/#equations-summary","title":"Equations Summary","text":""},{"location":"julia/models/pd/tolerance/#counter-regulation_1","title":"Counter-Regulation","text":"Quantity Formula Drug effect \\(E_{max} \\cdot C^\\gamma / (EC_{50}^\\gamma + C^\\gamma)\\) Moderator \\(dM/dt = k_{in} \\cdot E_{drug} - k_{out} \\cdot M\\) Net effect \\(E_0 + E_{drug} - \\alpha \\cdot M\\)"},{"location":"julia/models/pd/tolerance/#receptor-regulation_1","title":"Receptor Regulation","text":"Direction Rate Equation Down \\(k_{reg}(R_0 - R) - k_{change} \\cdot E \\cdot R\\) Up \\(k_{reg}(R_0 - R) + k_{change} \\cdot E \\cdot (R_{max} - R)\\)"},{"location":"julia/models/pd/tolerance/#see-also","title":"See Also","text":"<ul> <li>Direct Emax - Without tolerance</li> <li>Indirect Response - Turnover models</li> <li>Effect Compartment - Temporal delay</li> </ul>"},{"location":"julia/models/pd/transit-pd/","title":"Transit Compartment PD Model","text":"<p>PD model with a chain of transit compartments to model delayed drug effects and signal transduction cascades.</p>"},{"location":"julia/models/pd/transit-pd/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Create PK model\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)  # CL, V\ndoses = [DoseEvent(0.0, 500.0)]\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\n# Create Transit Compartment PD\npd_model = TransitCompartmentPD()\npd_params = TransitCompartmentPDParams(\n    5,        # n_transit\n    0.5,      # ktr\n    100.0,    # e0\n    -50.0,    # emax\n    5.0,      # ec50\n    1.0       # gamma\n)\n\npd_spec = PDSpec(pd_model, \"pd\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 168.0, 0:1:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pd/transit-pd/#parameters","title":"Parameters","text":"Parameter Type Description <code>n_transit</code> Int Number of transit compartments (1-20) <code>ktr</code> Float64 Transit rate constant (1/h) <code>e0</code> Float64 Baseline effect <code>emax</code> Float64 Maximum effect change <code>ec50</code> Float64 EC50 for effect <code>gamma</code> Float64 Hill coefficient"},{"location":"julia/models/pd/transit-pd/#key-derived-parameter","title":"Key Derived Parameter","text":"<p>Mean Transit Time (MTT): $\\(MTT = \\frac{N + 1}{K_{tr}}\\)$</p>"},{"location":"julia/models/pd/transit-pd/#model-equations","title":"Model Equations","text":"<p>Drug-induced signal: $\\(Signal(C) = E_0 + \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\)$</p> <p>Transit compartment chain: $\\(\\frac{dA_1}{dt} = K_{tr} \\cdot (Signal(C) - A_1)\\)$</p> \\[\\frac{dA_i}{dt} = K_{tr} \\cdot (A_{i-1} - A_i) \\quad \\text{for } i = 2..N\\] <p>Final effect: $\\(Effect = A_N\\)$</p>"},{"location":"julia/models/pd/transit-pd/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\n# PK setup\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(5.0, 50.0)\ndoses = [DoseEvent(0.0, 500.0)]\npk_spec = ModelSpec(pk_model, \"pk\", pk_params, doses)\n\n# PD setup: 5 transit compartments\npd_model = TransitCompartmentPD()\npd_params = TransitCompartmentPDParams(5, 0.5, 100.0, -50.0, 5.0, 1.0)\npd_spec = PDSpec(pd_model, \"pd\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 168.0, 0:1:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n\neffect = result.observations[:effect]\nt = result.t\n\n# MTT = (5+1) / 0.5 = 12 hours\nmtt = (5 + 1) / 0.5\nprintln(\"MTT: $mtt h\")\n\nnadir, idx = findmin(effect)\nprintln(\"Nadir: $nadir at t = $(t[idx]) h\")\n</code></pre>"},{"location":"julia/models/pd/transit-pd/#clinical-example-myelosuppression","title":"Clinical Example: Myelosuppression","text":"<pre><code>using OpenPKPDCore\n\n# Neutropenia model (MTT ~5 days)\nmtt_days = 5.0\nn_transit = 5\nktr = (n_transit + 1) / (mtt_days * 24)\n\npk_model = OneCompIVBolus()\npk_params = OneCompIVBolusParams(3.0, 30.0)\ndoses = [DoseEvent(0.0, 100.0)]\npk_spec = ModelSpec(pk_model, \"chemo\", pk_params, doses)\n\npd_model = TransitCompartmentPD()\npd_params = TransitCompartmentPDParams(n_transit, ktr, 5.0, -4.5, 1.0, 1.5)\npd_spec = PDSpec(pd_model, \"neutro\", pd_params, :conc, :effect)\n\ngrid = SimGrid(0.0, 504.0, 0:2:504)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate_pkpd_coupled(pk_spec, pd_spec, grid, solver)\n\neffect = result.observations[:effect]\nt = result.t\n\nnadir, idx = findmin(effect)\nprintln(\"Baseline ANC: 5.0 x10^9/L\")\nprintln(\"Nadir ANC: $nadir x10^9/L at day $(t[idx]/24)\")\n</code></pre>"},{"location":"julia/models/pd/transit-pd/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Chemotherapy-induced neutropenia</li> <li>Thrombocytopenia</li> <li>Delayed biomarker responses</li> <li>Signal transduction cascades</li> </ul>"},{"location":"julia/models/pd/transit-pd/#equations-summary","title":"Equations Summary","text":"Quantity Formula MTT \\((N+1) / K_{tr}\\) Signal \\(E_0 + E_{max} \\cdot C^\\gamma / (EC_{50}^\\gamma + C^\\gamma)\\) Transit rate \\(K_{tr} \\cdot (A_{i-1} - A_i)\\) CV of delay \\(1 / \\sqrt{N+1}\\)"},{"location":"julia/models/pd/transit-pd/#see-also","title":"See Also","text":"<ul> <li>Indirect Response - Simpler delay</li> <li>Effect Compartment - Single delay</li> <li>Disease Progression - Tumor models</li> </ul>"},{"location":"julia/models/pk/autoinduction/","title":"Autoinduction","text":"<p>PK model for drugs that induce their own metabolism, leading to time-varying clearance that increases with chronic dosing.</p>"},{"location":"julia/models/pk/autoinduction/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Create autoinduction model\nmodel = autoinduction()\nparams = CustomODEParams(\n    CL0 = 10.0,   # Baseline clearance (L/h)\n    V = 50.0,     # Volume (L)\n    Emax = 2.0,   # Max enzyme induction (fold)\n    EC50 = 5.0,   # EC50 for induction\n    kenz = 0.1    # Enzyme turnover rate (1/h)\n)\n\n# Daily dosing for 1 week\ndoses = [DoseEvent(i * 24.0, 200.0) for i in 0:6]\nspec = ModelSpec(model, \"autoinduction\", params, doses)\ngrid = SimGrid(0.0, 168.0, 0:1:168)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pk/autoinduction/#parameters","title":"Parameters","text":"Parameter Type Description <code>CL0</code> Float64 Baseline clearance (L/h) <code>V</code> Float64 Volume of distribution (L) <code>Emax</code> Float64 Maximum enzyme induction (fold increase) <code>EC50</code> Float64 Concentration for 50% of max induction <code>kenz</code> Float64 Enzyme turnover rate constant (1/h)"},{"location":"julia/models/pk/autoinduction/#derived-parameters","title":"Derived Parameters","text":"<ul> <li>Enzyme half-life: \\(t_{1/2,enz} = \\ln(2) / k_{enz}\\)</li> <li>Maximum clearance: \\(CL_{max} = CL_0 \\cdot (1 + E_{max})\\)</li> </ul>"},{"location":"julia/models/pk/autoinduction/#model-equations","title":"Model Equations","text":"<p>Enzyme induction signal: $\\(E_{induced} = 1 + \\frac{E_{max} \\cdot C}{EC_{50} + C}\\)$</p> <p>Enzyme dynamics: $\\(\\frac{dE}{dt} = k_{enz} \\cdot (E_{induced} - E)\\)$</p> <p>Drug elimination: $\\(\\frac{dA_c}{dt} = -\\frac{CL_0 \\cdot E}{V} \\cdot A_c\\)$</p> <p>Initial: \\(E(0) = 1.0\\)</p>"},{"location":"julia/models/pk/autoinduction/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\nmodel = autoinduction()\nparams = CustomODEParams(\n    CL0 = 10.0, V = 50.0, Emax = 2.0, EC50 = 5.0, kenz = 0.1\n)\n\n# Daily dosing\ndoses = [DoseEvent(i * 24.0, 200.0) for i in 0:13]\nspec = ModelSpec(model, \"auto\", params, doses)\ngrid = SimGrid(0.0, 336.0, 0:1:336)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n\nconc = result.observations[:conc]\nenzyme = result.states[:E_enzyme]\nt = result.t\n\n# Compare day 1 vs day 14\nday1_cmax = maximum(conc[1:24])\nday14_cmax = maximum(conc[313:336])\n\nprintln(\"Day 1 Cmax: $day1_cmax mg/L\")\nprintln(\"Day 14 Cmax: $day14_cmax mg/L\")\nprintln(\"Cmax decrease: $((1 - day14_cmax/day1_cmax) * 100)%\")\nprintln(\"Enzyme level day 14: $(enzyme[313])x baseline\")\n</code></pre>"},{"location":"julia/models/pk/autoinduction/#clinical-example-carbamazepine","title":"Clinical Example: Carbamazepine","text":"<pre><code>using OpenPKPDCore\n\n# Carbamazepine-like autoinduction\nkenz = 0.693 / (4 * 24)  # 4-day enzyme half-life\n\nmodel = autoinduction()\nparams = CustomODEParams(\n    CL0 = 2.0, V = 80.0, Emax = 1.5, EC50 = 4.0, kenz = kenz\n)\n\n# BID dosing for 4 weeks\ndoses = [DoseEvent(i * 12.0, 200.0) for i in 0:55]\nspec = ModelSpec(model, \"carbamazepine\", params, doses)\ngrid = SimGrid(0.0, 672.0, 0:2:672)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n\nconc = result.observations[:conc]\nenzyme = result.states[:E_enzyme]\nt = result.t\n\n# Weekly comparison\nprintln(\"Week | Cmax (mg/L) | Enzyme\")\nprintln(\"-\" ^ 35)\nfor week in 1:4\n    start_h = (week - 1) * 168\n    end_h = week * 168\n    start_idx = findfirst(x -&gt; x &gt;= start_h, t)\n    end_idx = findfirst(x -&gt; x &gt;= end_h, t)\n\n    week_cmax = maximum(conc[start_idx:end_idx])\n    week_enzyme = enzyme[end_idx]\n\n    println(\"$week | $week_cmax | $(week_enzyme)x\")\nend\n</code></pre>"},{"location":"julia/models/pk/autoinduction/#dose-adjustment-strategy","title":"Dose Adjustment Strategy","text":"<pre><code>using OpenPKPDCore\n\nkenz = 0.693 / (5 * 24)\n\nmodel = autoinduction()\n\n# Stepped dosing: increase weekly\ndoses = vcat(\n    [DoseEvent(i * 24.0, 200.0) for i in 0:6],      # Week 1\n    [DoseEvent((7 + i) * 24.0, 300.0) for i in 0:6],  # Week 2\n    [DoseEvent((14 + i) * 24.0, 400.0) for i in 0:6]  # Week 3\n)\n\nparams = CustomODEParams(\n    CL0 = 5.0, V = 50.0, Emax = 1.5, EC50 = 4.0, kenz = kenz\n)\n\nspec = ModelSpec(model, \"titration\", params, doses)\ngrid = SimGrid(0.0, 504.0, 0:2:504)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n\nconc = result.observations[:conc]\nt = result.t\n\nprintln(\"Dose Titration:\")\nfor (week, dose) in enumerate([200, 300, 400])\n    trough_idx = findfirst(x -&gt; x &gt;= week * 168 - 2, t)\n    println(\"Week $week ($dose mg QD): Trough = $(conc[trough_idx]) mg/L\")\nend\n</code></pre>"},{"location":"julia/models/pk/autoinduction/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Carbamazepine - classic autoinducer</li> <li>Phenytoin - at high doses</li> <li>Rifampicin - potent CYP3A4 inducer</li> <li>Phenobarbital - enzyme inducer</li> </ul>"},{"location":"julia/models/pk/autoinduction/#equations-summary","title":"Equations Summary","text":"Quantity Formula Induction signal \\(E_{induced} = 1 + E_{max} \\cdot C / (EC_{50} + C)\\) Enzyme rate \\(dE/dt = k_{enz} \\cdot (E_{induced} - E)\\) Effective clearance \\(CL_{eff} = CL_0 \\cdot E\\) Max clearance \\(CL_{max} = CL_0 \\cdot (1 + E_{max})\\) Enzyme t1/2 \\(\\ln(2) / k_{enz}\\)"},{"location":"julia/models/pk/autoinduction/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV - Linear PK</li> <li>Michaelis-Menten - Saturable elimination</li> </ul>"},{"location":"julia/models/pk/enterohepatic/","title":"Enterohepatic Recirculation (EHR)","text":"<p>PK model for drugs that undergo biliary excretion and intestinal reabsorption, leading to secondary concentration peaks.</p>"},{"location":"julia/models/pk/enterohepatic/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Create EHR model\nmodel = enterohepatic_recirculation()\nparams = CustomODEParams(\n    Ka = 1.0,       # Absorption rate (1/h)\n    CL = 10.0,      # Clearance (L/h)\n    V = 50.0,       # Volume (L)\n    Kbile = 0.5,    # Biliary excretion rate (1/h)\n    Kreab = 0.3,    # Reabsorption rate (1/h)\n    F_reab = 0.7    # Fraction reabsorbed\n)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(model, \"ehr_sim\", params, doses)\ngrid = SimGrid(0.0, 48.0, 0:0.25:48)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pk/enterohepatic/#parameters","title":"Parameters","text":"Parameter Type Description <code>Ka</code> Float64 Absorption rate constant (1/h) <code>CL</code> Float64 Clearance (L/h) <code>V</code> Float64 Volume of distribution (L) <code>Kbile</code> Float64 Biliary excretion rate constant (1/h) <code>Kreab</code> Float64 Reabsorption rate constant (1/h) <code>F_reab</code> Float64 Fraction reabsorbed (0-1)"},{"location":"julia/models/pk/enterohepatic/#model-equations","title":"Model Equations","text":"<p>Three-compartment system:</p> \\[\\frac{dA_{gut}}{dt} = -K_a \\cdot A_{gut} + F_{reab} \\cdot K_{reab} \\cdot A_{bile}\\] \\[\\frac{dA_c}{dt} = K_a \\cdot A_{gut} - \\frac{CL}{V} \\cdot A_c - K_{bile} \\cdot A_c\\] \\[\\frac{dA_{bile}}{dt} = K_{bile} \\cdot A_c - K_{reab} \\cdot A_{bile}\\]"},{"location":"julia/models/pk/enterohepatic/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\nmodel = enterohepatic_recirculation()\nparams = CustomODEParams(\n    Ka = 1.5, CL = 8.0, V = 50.0,\n    Kbile = 0.4, Kreab = 0.2, F_reab = 0.8\n)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(model, \"ehr\", params, doses)\ngrid = SimGrid(0.0, 48.0, 0:0.1:48)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n\nconc = result.observations[:conc]\nt = result.t\n\n# Find secondary peaks\npeaks = Int[]\nfor i in 3:length(conc)-2\n    if conc[i] &gt; conc[i-1] &amp;&amp; conc[i] &gt; conc[i+1]\n        push!(peaks, i)\n    end\nend\n\nprintln(\"Number of peaks: $(length(peaks))\")\nfor (n, idx) in enumerate(peaks)\n    println(\"Peak $n: t = $(t[idx]) h, C = $(conc[idx]) mg/L\")\nend\n</code></pre>"},{"location":"julia/models/pk/enterohepatic/#effect-of-reabsorption-fraction","title":"Effect of Reabsorption Fraction","text":"<pre><code>using OpenPKPDCore\n\nmodel = enterohepatic_recirculation()\nf_reab_values = [0.0, 0.3, 0.6, 0.9]\n\nprintln(\"F_reab | AUC (mg*h/L)\")\nprintln(\"-\" ^ 30)\n\nfor f_reab in f_reab_values\n    params = CustomODEParams(\n        Ka = 1.5, CL = 10.0, V = 50.0,\n        Kbile = 0.5, Kreab = 0.3, F_reab = f_reab\n    )\n\n    doses = [DoseEvent(0.0, 500.0)]\n    spec = ModelSpec(model, \"ehr\", params, doses)\n    grid = SimGrid(0.0, 72.0, 0:0.1:72)\n    solver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n\n    # Trapezoidal AUC\n    auc = sum((conc[i] + conc[i+1]) * 0.05 for i in 1:length(conc)-1)\n\n    println(\"$f_reab | $auc\")\nend\n</code></pre>"},{"location":"julia/models/pk/enterohepatic/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Digoxin - undergoes EHR</li> <li>NSAIDs - some undergo biliary cycling</li> <li>Hormones - estrogens, bile acids</li> <li>Antibiotics - some macrolides</li> </ul>"},{"location":"julia/models/pk/enterohepatic/#equations-summary","title":"Equations Summary","text":"Quantity Formula GI absorption \\(K_a \\cdot A_{gut}\\) Biliary excretion \\(K_{bile} \\cdot A_c\\) Reabsorption \\(F_{reab} \\cdot K_{reab} \\cdot A_{bile}\\) Net fecal elimination \\((1-F_{reab}) \\cdot K_{reab} \\cdot A_{bile}\\)"},{"location":"julia/models/pk/enterohepatic/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - Without EHR</li> <li>Transit Absorption - Delayed absorption</li> </ul>"},{"location":"julia/models/pk/michaelis-menten/","title":"Michaelis-Menten Elimination","text":"<p>One-compartment model with saturable (capacity-limited) elimination kinetics, where clearance depends on concentration.</p>"},{"location":"julia/models/pk/michaelis-menten/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt;|Bolus| C[Central&lt;br/&gt;V]\n    C --&gt;|Vmax, Km| E((Saturable&lt;br/&gt;Elimination))\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>High-dose therapeutics</li> <li>Phenytoin, ethanol, aspirin (high dose)</li> <li>Biologics with target-mediated disposition</li> <li>Enzyme saturation scenarios</li> <li>Dose-dependent kinetics</li> </ul>"},{"location":"julia/models/pk/michaelis-menten/#when-to-use","title":"When to Use","text":"Use When Don't Use When Nonlinear kinetics Linear (first-order) elimination Dose-dependent t\u00bd Constant half-life Disproportionate AUC \u2191 Dose-proportional exposure Saturable metabolism Low concentration range"},{"location":"julia/models/pk/michaelis-menten/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/michaelis-menten/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Maximum rate Vmax mg/h Maximum elimination rate Vmax &gt; 0 Michaelis constant Km mg/L Concentration at 50% Vmax Km &gt; 0 Volume V L Volume of distribution V &gt; 0"},{"location":"julia/models/pk/michaelis-menten/#differential-equation","title":"Differential Equation","text":"<p>In terms of amount:</p> \\[\\frac{dA}{dt} = -\\frac{V_{max} \\cdot A}{K_m \\cdot V + A}\\] <p>In terms of concentration:</p> \\[\\frac{dC}{dt} = -\\frac{V_{max} \\cdot C}{K_m + C}\\]"},{"location":"julia/models/pk/michaelis-menten/#observation","title":"Observation","text":"\\[C = \\frac{A}{V}\\]"},{"location":"julia/models/pk/michaelis-menten/#kinetic-behavior","title":"Kinetic Behavior","text":""},{"location":"julia/models/pk/michaelis-menten/#concentration-dependent-kinetics","title":"Concentration-Dependent Kinetics","text":"Condition Behavior Effective CL C &lt;&lt; Km First-order (linear) CL \u2248 Vmax/Km C \u2248 Km Mixed-order Variable C &gt;&gt; Km Zero-order (saturated) Rate \u2248 Vmax"},{"location":"julia/models/pk/michaelis-menten/#apparent-clearance","title":"Apparent Clearance","text":"\\[CL_{app} = \\frac{V_{max}}{K_m + C}\\] <p>At low concentrations: \\(CL_{max} = V_{max}/K_m\\)</p>"},{"location":"julia/models/pk/michaelis-menten/#apparent-half-life","title":"Apparent Half-Life","text":"<p>Half-life is concentration-dependent:</p> \\[t_{1/2} \\approx \\frac{0.693 \\cdot V \\cdot (K_m + C)}{V_{max}}\\] <p>At low C: \\(t_{1/2,min} = 0.693 \\cdot V \\cdot K_m / V_{max}\\)</p>"},{"location":"julia/models/pk/michaelis-menten/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/michaelis-menten/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct MichaelisMentenElimination &lt;: ModelKind end\n\n# Parameters\nstruct MichaelisMentenEliminationParams &lt;: AbstractParams\n    Vmax::Float64  # Maximum elimination rate (mg/h)\n    Km::Float64    # Michaelis constant (mg/L)\n    V::Float64     # Volume of distribution (L)\nend\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\n# Vmax = 500 mg/h, Km = 10 mg/L, V = 50 L\nparams = MichaelisMentenEliminationParams(500.0, 10.0, 50.0)\n\n# Single 1000 mg dose\ndoses = [DoseEvent(0.0, 1000.0)]\n\n# Create specification\nspec = ModelSpec(\n    MichaelisMentenElimination(),\n    \"mm_example\",\n    params,\n    doses\n)\n\n# Time grid\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.25:48.0))\n\n# Solver\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Check concentration-dependent kinetics\nconc = result.observations[:conc]\nt = result.t\n\nprintln(\"C0: \", round(conc[1], digits=2), \" mg/L (C &gt;&gt; Km: saturated)\")\nprintln(\"C at 6h: \", round(conc[25], digits=2), \" mg/L\")\nprintln(\"C at 24h: \", round(conc[97], digits=3), \" mg/L (C &lt; Km: linear)\")\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#dose-dependent-half-life","title":"Dose-Dependent Half-Life","text":"<pre><code># Compare half-lives at different doses\ndoses_list = [100.0, 500.0, 1000.0, 2000.0]\n\nfor dose in doses_list\n    doses = [DoseEvent(0.0, dose)]\n    spec = ModelSpec(MichaelisMentenElimination(), \"dose_$dose\", params, doses)\n    grid = SimGrid(0.0, 96.0, collect(0.0:0.5:96.0))\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n\n    # Find t\u00bd (time to reach half of initial)\n    c0 = conc[1]\n    target = c0 / 2\n    idx = findfirst(x -&gt; x &lt;= target, conc)\n\n    if idx !== nothing\n        t_half = result.t[idx]\n        println(\"Dose $(dose) mg: t\u00bd = $(round(t_half, digits=2)) h\")\n    else\n        println(\"Dose $(dose) mg: t\u00bd &gt; 96 h\")\n    end\nend\n</code></pre> <p>Expected Results: - Higher doses \u2192 Longer t\u00bd (saturation) - Low doses \u2192 Shorter t\u00bd (linear kinetics)</p>"},{"location":"julia/models/pk/michaelis-menten/#dose-proportionality","title":"Dose Proportionality","text":"<pre><code># AUC increases more than proportionally with dose\ndoses_list = [100.0, 200.0, 500.0, 1000.0]\nauc_values = Float64[]\n\nfor dose in doses_list\n    doses = [DoseEvent(0.0, dose)]\n    spec = ModelSpec(MichaelisMentenElimination(), \"dose_$dose\", params, doses)\n    grid = SimGrid(0.0, 120.0, collect(0.0:0.1:120.0))\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n\n    # Approximate AUC (trapezoidal)\n    auc = sum(conc) * 0.1\n    push!(auc_values, auc)\n\n    println(\"Dose $(dose) mg: AUC \u2248 $(round(auc, digits=1)) mg\u00b7h/L\")\nend\n\n# Check proportionality\nprintln(\"\\nDose ratio (10x): \", doses_list[4] / doses_list[1])\nprintln(\"AUC ratio: \", round(auc_values[4] / auc_values[1], digits=2))\n# AUC ratio &gt; 10 indicates saturation\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#clinical-example-phenytoin","title":"Clinical Example: Phenytoin","text":"<pre><code># Phenytoin typical parameters\n# Vmax \u2248 7 mg/kg/day, Km \u2248 4-6 mg/L, V \u2248 0.65 L/kg\n# For 70 kg patient:\nparams_phenytoin = MichaelisMentenEliminationParams(\n    7.0 * 70 / 24,  # Vmax in mg/h (\u2248 20 mg/h)\n    5.0,            # Km (mg/L)\n    0.65 * 70       # V (\u2248 45.5 L)\n)\n\n# Loading dose followed by maintenance\nloading = 15 * 70  # 15 mg/kg loading\nmaintenance = 300.0 / 24 * 24  # 300 mg/day as continuous equivalent\n\n# Simulate loading\ndoses_loading = [DoseEvent(0.0, loading)]\nspec_loading = ModelSpec(MichaelisMentenElimination(), \"phenytoin_load\",\n                         params_phenytoin, doses_loading)\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\n\nresult = simulate(spec_loading, grid, solver)\n\n# Therapeutic range: 10-20 mg/L\nconc = result.observations[:conc]\nprintln(\"Post-loading C: \", round(conc[1], digits=1), \" mg/L\")\nprintln(\"24h C: \", round(conc[end], digits=1), \" mg/L\")\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#steady-state-considerations","title":"Steady-State Considerations","text":"<p>At steady state with constant infusion rate R:</p> \\[C_{ss} = \\frac{R \\cdot K_m}{V_{max} - R}\\] <p>This only applies when R &lt; Vmax. If R \u2265 Vmax, no steady state is achievable.</p> <pre><code># Critical infusion rate\nVmax = params.Vmax\nprintln(\"Maximum sustainable infusion rate: \", Vmax, \" mg/h\")\n\n# At 80% of Vmax\nR = 0.8 * Vmax\nCss = (R * params.Km) / (Vmax - R)\nprintln(\"At R = $(R) mg/h: Css = $(round(Css, digits=1)) mg/L\")\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = MichaelisMentenEliminationParams(500.0, 10.0, 50.0)\n\n# IIV: High variability on Vmax and Km\nomega = OmegaMatrix([\n    0.16 0.0  0.0;     # \u03c9\u00b2_Vmax (40% CV)\n    0.0  0.25 0.0;     # \u03c9\u00b2_Km (50% CV)\n    0.0  0.0  0.04     # \u03c9\u00b2_V (20% CV)\n])\n\ndoses = [DoseEvent(0.0, 1000.0)]\nbase_spec = ModelSpec(MichaelisMentenElimination(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 50, omega, 12345)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.5:48.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# High variability in exposure due to nonlinear kinetics\n# Small changes in Vmax/Km cause large changes in AUC at high doses\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#comparison-with-linear-elimination","title":"Comparison with Linear Elimination","text":"<pre><code># Michaelis-Menten at low dose (approximately linear)\nparams_mm = MichaelisMentenEliminationParams(500.0, 10.0, 50.0)\n# Equivalent linear: CL = Vmax/Km = 50 L/h\n\nparams_linear = OneCompIVBolusParams(50.0, 50.0)  # CL = 50 L/h, V = 50 L\n\n# Low dose: 100 mg (C0 = 2 mg/L &lt;&lt; Km = 10)\ndoses_low = [DoseEvent(0.0, 100.0)]\n\n# High dose: 2000 mg (C0 = 40 mg/L &gt;&gt; Km = 10)\ndoses_high = [DoseEvent(0.0, 2000.0)]\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.1:24.0))\n\n# At low dose, MM \u2248 linear\nspec_mm_low = ModelSpec(MichaelisMentenElimination(), \"mm_low\", params_mm, doses_low)\nspec_lin_low = ModelSpec(OneCompIVBolus(), \"lin_low\", params_linear, doses_low)\n\nresult_mm_low = simulate(spec_mm_low, grid, solver)\nresult_lin_low = simulate(spec_lin_low, grid, solver)\n\n# Nearly identical at low dose\nprintln(\"Low dose (100 mg):\")\nprintln(\"  MM at 4h: \", round(result_mm_low.observations[:conc][41], digits=3))\nprintln(\"  Linear at 4h: \", round(result_lin_low.observations[:conc][41], digits=3))\n</code></pre>"},{"location":"julia/models/pk/michaelis-menten/#equations-summary","title":"Equations Summary","text":"Quantity Formula Elimination rate \\(-V_{max} \\cdot C / (K_m + C)\\) CL_apparent \\(V_{max} / (K_m + C)\\) CL_max (C\u21920) \\(V_{max} / K_m\\) t\u00bd (apparent) \\(0.693 \\cdot V \\cdot (K_m + C) / V_{max}\\) Css (infusion R) \\(R \\cdot K_m / (V_{max} - R)\\)"},{"location":"julia/models/pk/michaelis-menten/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV Bolus - Linear model</li> <li>Population Modeling - Adding variability</li> <li>Parameter Estimation - Fitting nonlinear models</li> </ul>"},{"location":"julia/models/pk/onecomp-iv-bolus/","title":"One-Compartment IV Bolus","text":"<p>The simplest pharmacokinetic model representing instantaneous drug administration into a single well-mixed compartment with first-order elimination.</p>"},{"location":"julia/models/pk/onecomp-iv-bolus/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt;|Bolus| C[Central&lt;br/&gt;Compartment&lt;br/&gt;V]\n    C --&gt;|CL| E((Elimination))\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Simple IV drugs with rapid distribution</li> <li>Initial PK characterization studies</li> <li>Drugs without significant tissue distribution</li> <li>Loading dose calculations</li> <li>TDM (Therapeutic Drug Monitoring)</li> </ul>"},{"location":"julia/models/pk/onecomp-iv-bolus/#when-to-use","title":"When to Use","text":"Use When Don't Use When Mono-exponential decline Bi/tri-exponential decline Rapid equilibration Significant distribution phase Small molecules Large molecules with tissue binding Initial screening Final model development"},{"location":"julia/models/pk/onecomp-iv-bolus/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/onecomp-iv-bolus/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Clearance CL L/h Volume of plasma cleared per time CL &gt; 0 Volume V L Apparent volume of distribution V &gt; 0"},{"location":"julia/models/pk/onecomp-iv-bolus/#micro-rate-constant","title":"Micro-Rate Constant","text":"\\[k_{el} = \\frac{CL}{V}\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#state-variable","title":"State Variable","text":"State Symbol Units Description Amount in central A mg Drug amount in compartment"},{"location":"julia/models/pk/onecomp-iv-bolus/#differential-equation","title":"Differential Equation","text":"\\[\\frac{dA}{dt} = -k_{el} \\cdot A = -\\frac{CL}{V} \\cdot A\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#analytical-solution","title":"Analytical Solution","text":"<p>For a single bolus dose \\(D\\) at \\(t = 0\\):</p> \\[A(t) = D \\cdot e^{-k_{el} \\cdot t}\\] \\[C(t) = \\frac{D}{V} \\cdot e^{-k_{el} \\cdot t} = C_0 \\cdot e^{-k_{el} \\cdot t}\\] <p>Where \\(C_0 = D/V\\) is the initial concentration.</p>"},{"location":"julia/models/pk/onecomp-iv-bolus/#observation","title":"Observation","text":"\\[C = \\frac{A}{V}\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pk/onecomp-iv-bolus/#half-life","title":"Half-Life","text":"\\[t_{1/2} = \\frac{\\ln(2)}{k_{el}} = \\frac{0.693 \\cdot V}{CL}\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#auc-single-dose","title":"AUC (Single Dose)","text":"\\[AUC_{0-\\infty} = \\frac{D}{CL}\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#steady-state-multiple-dosing","title":"Steady-State (Multiple Dosing)","text":"<p>For dose \\(D\\) given every \\(\\tau\\) hours:</p> \\[C_{ss,max} = \\frac{D/V}{1 - e^{-k_{el} \\cdot \\tau}}\\] \\[C_{ss,min} = C_{ss,max} \\cdot e^{-k_{el} \\cdot \\tau}\\] \\[C_{ss,avg} = \\frac{D}{CL \\cdot \\tau}\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#accumulation-factor","title":"Accumulation Factor","text":"\\[R = \\frac{1}{1 - e^{-k_{el} \\cdot \\tau}}\\]"},{"location":"julia/models/pk/onecomp-iv-bolus/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/onecomp-iv-bolus/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct OneCompIVBolus &lt;: ModelKind end\n\n# Parameters\nstruct OneCompIVBolusParams &lt;: AbstractParams\n    CL::Float64    # Clearance (L/h)\n    V::Float64     # Volume (L)\nend\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\nparams = OneCompIVBolusParams(5.0, 50.0)  # CL=5 L/h, V=50 L\n\n# Single 100 mg dose at t=0\ndoses = [DoseEvent(0.0, 100.0)]\n\n# Create model specification\nspec = ModelSpec(\n    OneCompIVBolus(),\n    \"onecomp_iv_example\",\n    params,\n    doses\n)\n\n# Define time grid (0 to 24 hours, hourly)\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\n\n# Configure solver (high precision for validation)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Access results\nprintln(\"Time: \", result.t)\nprintln(\"Concentration: \", result.observations[:conc])\nprintln(\"Amount: \", result.states[:A_central])\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#expected-output","title":"Expected Output","text":"<pre><code>Time: [0.0, 1.0, 2.0, ..., 24.0]\nConcentration: [2.0, 1.8097, 1.6375, 1.4816, 1.3406, ...]\nAmount: [100.0, 90.48, 81.87, 74.08, 67.03, ...]\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code># 100 mg every 12 hours for 3 days\ndoses = [\n    DoseEvent(0.0, 100.0),\n    DoseEvent(12.0, 100.0),\n    DoseEvent(24.0, 100.0),\n    DoseEvent(36.0, 100.0),\n    DoseEvent(48.0, 100.0),\n    DoseEvent(60.0, 100.0),\n]\n\nspec = ModelSpec(OneCompIVBolus(), \"multiple_dose\", params, doses)\ngrid = SimGrid(0.0, 72.0, collect(0.0:0.5:72.0))\n\nresult = simulate(spec, grid, solver)\n\n# Find steady-state trough (just before 6th dose)\ntrough_idx = findfirst(x -&gt; x \u2248 59.5, result.t)\nprintln(\"Steady-state trough: \", result.observations[:conc][trough_idx])\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#iv-infusion","title":"IV Infusion","text":"<pre><code># 100 mg infused over 1 hour (duration parameter)\ndoses = [DoseEvent(0.0, 100.0, 1.0)]\n\nspec = ModelSpec(OneCompIVBolus(), \"infusion\", params, doses)\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\n\nresult = simulate(spec, grid, solver)\n\n# Cmax at end of infusion\nidx_1h = findfirst(x -&gt; x \u2248 1.0, result.t)\nprintln(\"Cmax at end of infusion: \", result.observations[:conc][idx_1h])\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#parameter-estimation","title":"Parameter Estimation","text":""},{"location":"julia/models/pk/onecomp-iv-bolus/#fitting-from-data","title":"Fitting from Data","text":"<pre><code># Observed data\ndata = EstimationData(\n    ids = [1, 1, 1, 1, 1],\n    times = [0.5, 1.0, 2.0, 4.0, 8.0],\n    dv = [1.8, 1.6, 1.3, 0.9, 0.4],\n    doses = [DoseEvent(0.0, 100.0)],\n    dose_ids = [1, 1, 1, 1, 1]\n)\n\n# Initial estimates\ninit = InitialEstimates(\n    theta = [5.0, 50.0],     # CL, V\n    omega = [0.09, 0.04],    # IIV on CL, V\n    sigma = [0.01]           # Proportional error\n)\n\n# Fit with FOCE\nresult = estimate(data, OneCompIVBolus(), init, FOCEConfig())\n\nprintln(\"Estimated CL: \", result.theta[1])\nprintln(\"Estimated V: \", result.theta[2])\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = OneCompIVBolusParams(5.0, 50.0)\n\n# IIV: 30% CV on CL, 20% CV on V\nomega = OmegaMatrix([\n    0.09 0.0;\n    0.0  0.04\n])\n\ndoses = [DoseEvent(0.0, 100.0)]\nbase_spec = ModelSpec(OneCompIVBolus(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 100, omega, 12345)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# Population summary\nsummary = result.summaries[:conc]\nprintln(\"Median Cmax: \", maximum(summary.median))\nprintln(\"90% PI: \", maximum(summary.quantiles[0.05]), \" - \",\n        maximum(summary.quantiles[0.95]))\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#validation","title":"Validation","text":""},{"location":"julia/models/pk/onecomp-iv-bolus/#analytical-verification","title":"Analytical Verification","text":"<pre><code># Compare simulation to analytical solution\nD = 100.0   # Dose\nCL = 5.0    # Clearance\nV = 50.0    # Volume\nk = CL / V  # Elimination rate\n\nt = collect(0.0:0.1:24.0)\n\n# Analytical solution\nC_analytical = (D / V) .* exp.(-k .* t)\n\n# Simulation\nparams = OneCompIVBolusParams(CL, V)\ndoses = [DoseEvent(0.0, D)]\nspec = ModelSpec(OneCompIVBolus(), \"validation\", params, doses)\ngrid = SimGrid(0.0, 24.0, t)\nresult = simulate(spec, grid, solver)\n\nC_simulated = result.observations[:conc]\n\n# Check agreement\nmax_error = maximum(abs.(C_analytical .- C_simulated))\nprintln(\"Maximum error: \", max_error)  # Should be &lt; 1e-10\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#clinical-examples","title":"Clinical Examples","text":""},{"location":"julia/models/pk/onecomp-iv-bolus/#example-1-aminoglycoside-dosing","title":"Example 1: Aminoglycoside Dosing","text":"<pre><code># Gentamicin: CL \u2248 5 L/h, V \u2248 15 L\nparams = OneCompIVBolusParams(5.0, 15.0)\n\n# Calculate dosing for target Cmax of 8 mg/L\ntarget_cmax = 8.0\ndose = target_cmax * params.V  # 120 mg\n\ndoses = [DoseEvent(0.0, dose)]\nspec = ModelSpec(OneCompIVBolus(), \"gentamicin\", params, doses)\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\n\nresult = simulate(spec, grid, solver)\nprintln(\"Achieved Cmax: \", maximum(result.observations[:conc]))\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#example-2-loading-dose-calculation","title":"Example 2: Loading Dose Calculation","text":"<pre><code># Target steady-state average: 10 mg/L\n# CL = 5 L/h, dosing interval \u03c4 = 8 h\ntarget_css_avg = 10.0\nCL = 5.0\ntau = 8.0\n\nmaintenance_dose = target_css_avg * CL * tau  # 400 mg\n\n# Loading dose for immediate effect\nV = 50.0\nloading_dose = target_css_avg * V  # 500 mg\n\nprintln(\"Loading dose: \", loading_dose, \" mg\")\nprintln(\"Maintenance dose: \", maintenance_dose, \" mg q\", tau, \"h\")\n</code></pre>"},{"location":"julia/models/pk/onecomp-iv-bolus/#equations-summary","title":"Equations Summary","text":"Quantity Formula Rate constant \\(k_{el} = CL/V\\) Concentration \\(C(t) = (D/V) \\cdot e^{-k_{el} \\cdot t}\\) Half-life \\(t_{1/2} = 0.693/k_{el}\\) AUC \\(AUC = D/CL\\) Steady-state average \\(C_{ss,avg} = D/(CL \\cdot \\tau)\\) Accumulation \\(R = 1/(1 - e^{-k_{el} \\cdot \\tau})\\)"},{"location":"julia/models/pk/onecomp-iv-bolus/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - With first-order absorption</li> <li>Two-Compartment IV - For distribution kinetics</li> <li>Michaelis-Menten - For saturable elimination</li> <li>Population Modeling - Adding variability</li> </ul>"},{"location":"julia/models/pk/onecomp-oral/","title":"One-Compartment Oral First-Order","text":"<p>One-compartment model with first-order absorption from a depot (gut) compartment, representing the most common oral PK profile.</p>"},{"location":"julia/models/pk/onecomp-oral/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt;|Oral| G[Gut&lt;br/&gt;Depot]\n    G --&gt;|Ka| C[Central&lt;br/&gt;Compartment&lt;br/&gt;V]\n    C --&gt;|CL| E((Elimination))\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Immediate-release oral formulations</li> <li>Most oral tablets and capsules</li> <li>Simple oral PK characterization</li> <li>Bioavailability studies</li> <li>Food effect studies</li> </ul>"},{"location":"julia/models/pk/onecomp-oral/#when-to-use","title":"When to Use","text":"Use When Don't Use When Simple first-order absorption Delayed or complex absorption Mono-exponential elimination Significant distribution phase Single Tmax Multiple peaks F is constant Nonlinear bioavailability"},{"location":"julia/models/pk/onecomp-oral/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/onecomp-oral/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Absorption rate Ka 1/h First-order absorption rate constant Ka &gt; 0 Clearance CL L/h Apparent clearance (CL/F) CL &gt; 0 Volume V L Apparent volume (V/F) V &gt; 0"},{"location":"julia/models/pk/onecomp-oral/#state-variables","title":"State Variables","text":"State Symbol Units Description Amount in gut A_gut mg Drug amount in absorption depot Amount in central A_central mg Drug amount in central compartment"},{"location":"julia/models/pk/onecomp-oral/#differential-equations","title":"Differential Equations","text":"\\[\\frac{dA_{gut}}{dt} = -K_a \\cdot A_{gut}\\] \\[\\frac{dA_{central}}{dt} = K_a \\cdot A_{gut} - \\frac{CL}{V} \\cdot A_{central}\\]"},{"location":"julia/models/pk/onecomp-oral/#analytical-solution","title":"Analytical Solution","text":"<p>For a single oral dose \\(D\\) at \\(t = 0\\):</p> \\[C(t) = \\frac{D \\cdot K_a}{V \\cdot (K_a - k_{el})} \\cdot \\left( e^{-k_{el} \\cdot t} - e^{-K_a \\cdot t} \\right)\\] <p>Where \\(k_{el} = CL/V\\).</p>"},{"location":"julia/models/pk/onecomp-oral/#observation","title":"Observation","text":"\\[C = \\frac{A_{central}}{V}\\]"},{"location":"julia/models/pk/onecomp-oral/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pk/onecomp-oral/#time-to-maximum-concentration-tmax","title":"Time to Maximum Concentration (Tmax)","text":"\\[t_{max} = \\frac{\\ln(K_a) - \\ln(k_{el})}{K_a - k_{el}} = \\frac{\\ln(K_a/k_{el})}{K_a - k_{el}}\\]"},{"location":"julia/models/pk/onecomp-oral/#maximum-concentration-cmax","title":"Maximum Concentration (Cmax)","text":"\\[C_{max} = \\frac{D}{V} \\cdot e^{-k_{el} \\cdot t_{max}}\\] <p>Or equivalently:</p> \\[C_{max} = \\frac{D}{V} \\cdot \\left( \\frac{k_{el}}{K_a} \\right)^{\\frac{k_{el}}{K_a - k_{el}}}\\]"},{"location":"julia/models/pk/onecomp-oral/#half-life","title":"Half-Life","text":"\\[t_{1/2} = \\frac{0.693 \\cdot V}{CL}\\]"},{"location":"julia/models/pk/onecomp-oral/#auc","title":"AUC","text":"\\[AUC_{0-\\infty} = \\frac{D}{CL}\\] <p>Note: AUC is independent of Ka for complete absorption.</p>"},{"location":"julia/models/pk/onecomp-oral/#mean-absorption-time-mat","title":"Mean Absorption Time (MAT)","text":"\\[MAT = \\frac{1}{K_a}\\]"},{"location":"julia/models/pk/onecomp-oral/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/onecomp-oral/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct OneCompOralFirstOrder &lt;: ModelKind end\n\n# Parameters\nstruct OneCompOralFirstOrderParams &lt;: AbstractParams\n    Ka::Float64    # Absorption rate constant (1/h)\n    CL::Float64    # Clearance (L/h)\n    V::Float64     # Volume (L)\nend\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\n# Ka = 1.5/h (absorption t\u00bd \u2248 0.46 h)\n# CL = 5 L/h, V = 50 L (elimination t\u00bd = 6.93 h)\nparams = OneCompOralFirstOrderParams(1.5, 5.0, 50.0)\n\n# Single 200 mg oral dose\ndoses = [DoseEvent(0.0, 200.0)]\n\n# Create specification\nspec = ModelSpec(\n    OneCompOralFirstOrder(),\n    \"oral_example\",\n    params,\n    doses\n)\n\n# Time grid with fine resolution around Tmax\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\n\n# Solver\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Find Cmax and Tmax\nconc = result.observations[:conc]\nt = result.t\ncmax, idx = findmax(conc)\ntmax = t[idx]\n\nprintln(\"Cmax: \", round(cmax, digits=2), \" mg/L\")\nprintln(\"Tmax: \", round(tmax, digits=2), \" h\")\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#expected-output","title":"Expected Output","text":"<pre><code>Cmax: 2.67 mg/L\nTmax: 1.50 h\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code># 200 mg twice daily for 7 days\ndoses = DoseEvent[]\nfor day in 0:6\n    push!(doses, DoseEvent(day * 24.0, 200.0))        # Morning\n    push!(doses, DoseEvent(day * 24.0 + 12.0, 200.0)) # Evening\nend\n\nspec = ModelSpec(OneCompOralFirstOrder(), \"bid_dosing\", params, doses)\ngrid = SimGrid(0.0, 168.0, collect(0.0:1.0:168.0))\n\nresult = simulate(spec, grid, solver)\n\n# Steady-state achieved after ~5 half-lives\n# t\u00bd = 6.93 h, so ~35 hours\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#flip-flop-kinetics","title":"Flip-Flop Kinetics","text":"<p>When Ka &lt; kel, the terminal slope reflects absorption, not elimination:</p> <pre><code># Slow absorption (Ka &lt; kel)\n# Ka = 0.05/h (absorption t\u00bd = 13.9 h)\n# kel = 0.1/h (elimination t\u00bd = 6.93 h)\nparams_flipflop = OneCompOralFirstOrderParams(0.05, 5.0, 50.0)\n\n# Normal kinetics (Ka &gt; kel)\nparams_normal = OneCompOralFirstOrderParams(1.5, 5.0, 50.0)\n\n# Compare terminal slopes\n# In flip-flop: terminal slope = Ka\n# In normal: terminal slope = kel\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#bioavailability-considerations","title":"Bioavailability Considerations","text":""},{"location":"julia/models/pk/onecomp-oral/#apparent-parameters","title":"Apparent Parameters","text":"<p>The estimated CL and V are apparent values:</p> \\[CL_{apparent} = \\frac{CL}{F}\\] \\[V_{apparent} = \\frac{V}{F}\\] <p>Where F is the absolute bioavailability (fraction absorbed).</p>"},{"location":"julia/models/pk/onecomp-oral/#bioavailability-calculation","title":"Bioavailability Calculation","text":"<p>If IV data is available:</p> \\[F = \\frac{AUC_{oral} / Dose_{oral}}{AUC_{IV} / Dose_{IV}}\\]"},{"location":"julia/models/pk/onecomp-oral/#relative-bioavailability","title":"Relative Bioavailability","text":"<p>For comparing formulations:</p> \\[F_{rel} = \\frac{AUC_{test} / Dose_{test}}{AUC_{reference} / Dose_{reference}}\\]"},{"location":"julia/models/pk/onecomp-oral/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = OneCompOralFirstOrderParams(1.5, 5.0, 50.0)\n\n# IIV: 40% CV on Ka, 30% CV on CL, 20% CV on V\nomega = OmegaMatrix([\n    0.16 0.0  0.0;   # \u03c9\u00b2_Ka\n    0.0  0.09 0.0;   # \u03c9\u00b2_CL\n    0.0  0.0  0.04   # \u03c9\u00b2_V\n])\n\ndoses = [DoseEvent(0.0, 200.0)]\nbase_spec = ModelSpec(OneCompOralFirstOrder(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 100, omega, 12345)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# Variability in Tmax due to Ka IIV\nfor i in 1:5\n    conc = result.individuals[i].observations[:conc]\n    t = result.individuals[i].t\n    _, idx = findmax(conc)\n    println(\"Subject $i: Tmax = \", t[idx], \" h\")\nend\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#special-cases","title":"Special Cases","text":""},{"location":"julia/models/pk/onecomp-oral/#zero-time-dose","title":"Zero-Time Dose","text":"<p>When dose is at t=0, initial conditions: - A_gut(0) = Dose - A_central(0) = 0</p>"},{"location":"julia/models/pk/onecomp-oral/#lag-time","title":"Lag Time","text":"<p>For delayed absorption, use transit compartments or specify lag:</p> <pre><code># Simple lag time implementation\nlag = 0.5  # 30 minute lag\n\n# Shift dose time\ndoses = [DoseEvent(lag, 200.0)]\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\n\n# Or use transit compartment model for more realistic delay\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#food-effect","title":"Food Effect","text":"<p>Food can affect both Ka and F:</p> <pre><code># Fasted state\nparams_fasted = OneCompOralFirstOrderParams(2.0, 5.0, 50.0)\n\n# Fed state (slower absorption, possibly higher F)\nparams_fed = OneCompOralFirstOrderParams(0.8, 4.0, 50.0)  # CL/F lower if F higher\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#validation-example","title":"Validation Example","text":"<pre><code># Compare to analytical solution\nD = 200.0\nKa = 1.5\nCL = 5.0\nV = 50.0\nkel = CL / V\n\nt = collect(0.0:0.1:24.0)\n\n# Analytical solution (Bateman function)\nC_analytical = (D * Ka) / (V * (Ka - kel)) .* (exp.(-kel .* t) .- exp.(-Ka .* t))\n\n# Simulation\nparams = OneCompOralFirstOrderParams(Ka, CL, V)\ndoses = [DoseEvent(0.0, D)]\nspec = ModelSpec(OneCompOralFirstOrder(), \"validation\", params, doses)\ngrid = SimGrid(0.0, 24.0, t)\nresult = simulate(spec, grid, solver)\n\nC_simulated = result.observations[:conc]\n\n# Check agreement\nmax_error = maximum(abs.(C_analytical .- C_simulated))\nprintln(\"Maximum error: \", max_error)  # Should be &lt; 1e-9\n</code></pre>"},{"location":"julia/models/pk/onecomp-oral/#equations-summary","title":"Equations Summary","text":"Quantity Formula Absorption rate \\(k_a\\) Elimination rate \\(k_{el} = CL/V\\) Tmax \\(t_{max} = \\ln(K_a/k_{el}) / (K_a - k_{el})\\) Concentration \\(C(t) = \\frac{D \\cdot K_a}{V(K_a - k_{el})} (e^{-k_{el}t} - e^{-K_at})\\) Half-life \\(t_{1/2} = 0.693/k_{el}\\) AUC \\(AUC = D/CL\\) MAT \\(MAT = 1/K_a\\)"},{"location":"julia/models/pk/onecomp-oral/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV Bolus - Without absorption</li> <li>Two-Compartment Oral - With distribution</li> <li>Transit Absorption - For complex absorption</li> <li>NCA Reference - Exposure calculations</li> </ul>"},{"location":"julia/models/pk/parallel-absorption/","title":"Parallel First-Order Absorption","text":"<p>PK model for drugs with multiple absorption sites or mechanisms, each with distinct absorption rate constants.</p>"},{"location":"julia/models/pk/parallel-absorption/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Create parallel absorption model\nmodel = parallel_first_order_absorption()\nparams = CustomODEParams(\n    Ka1 = 2.0,    # Fast absorption (1/h)\n    Ka2 = 0.5,    # Slow absorption (1/h)\n    F1 = 0.6,     # Fraction to fast pathway\n    CL = 10.0,    # Clearance (L/h)\n    V = 50.0      # Volume (L)\n)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(model, \"parallel_abs\", params, doses)\ngrid = SimGrid(0.0, 24.0, 0:0.25:24)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pk/parallel-absorption/#parameters","title":"Parameters","text":"Parameter Type Description <code>Ka1</code> Float64 First absorption rate constant (1/h) <code>Ka2</code> Float64 Second absorption rate constant (1/h) <code>F1</code> Float64 Fraction to first depot (0-1) <code>CL</code> Float64 Clearance (L/h) <code>V</code> Float64 Volume of distribution (L)"},{"location":"julia/models/pk/parallel-absorption/#model-equations","title":"Model Equations","text":"<p>Three-compartment system (two depots, one central):</p> \\[\\frac{dA_1}{dt} = -K_{a1} \\cdot A_1\\] \\[\\frac{dA_2}{dt} = -K_{a2} \\cdot A_2\\] \\[\\frac{dA_c}{dt} = K_{a1} \\cdot A_1 + K_{a2} \\cdot A_2 - \\frac{CL}{V} \\cdot A_c\\] <p>Initial conditions after dose D: - \\(A_1(0) = F_1 \\cdot D\\) - \\(A_2(0) = (1-F_1) \\cdot D\\)</p>"},{"location":"julia/models/pk/parallel-absorption/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\nmodel = parallel_first_order_absorption()\nparams = CustomODEParams(\n    Ka1 = 2.0,\n    Ka2 = 0.5,\n    F1 = 0.6,\n    CL = 10.0,\n    V = 50.0\n)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(model, \"parallel\", params, doses)\ngrid = SimGrid(0.0, 24.0, 0:0.25:24)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n\nconc = result.observations[:conc]\nt = result.t\n\n# Find Tmax and Cmax\ncmax, idx = findmax(conc)\ntmax = t[idx]\nprintln(\"Tmax: $tmax h\")\nprintln(\"Cmax: $cmax mg/L\")\n</code></pre>"},{"location":"julia/models/pk/parallel-absorption/#effect-of-fraction-split","title":"Effect of Fraction Split","text":"<pre><code>using OpenPKPDCore\n\nmodel = parallel_first_order_absorption()\nf1_values = [0.2, 0.4, 0.6, 0.8]\n\nprintln(\"F1 (fast) | Cmax (mg/L) | Tmax (h)\")\nprintln(\"-\" ^ 40)\n\nfor f1 in f1_values\n    params = CustomODEParams(\n        Ka1 = 3.0, Ka2 = 0.3, F1 = f1, CL = 10.0, V = 50.0\n    )\n\n    doses = [DoseEvent(0.0, 500.0)]\n    spec = ModelSpec(model, \"parallel\", params, doses)\n    grid = SimGrid(0.0, 24.0, 0:0.1:24)\n    solver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n    t = result.t\n\n    cmax, idx = findmax(conc)\n    tmax = t[idx]\n\n    println(\"$f1 | $cmax | $tmax\")\nend\n</code></pre>"},{"location":"julia/models/pk/parallel-absorption/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Extended-release formulations with immediate release coating</li> <li>Drugs with multiple absorption sites in GI tract</li> <li>Food effects changing absorption pathways</li> <li>Modified-release dosage forms</li> </ul>"},{"location":"julia/models/pk/parallel-absorption/#equations-summary","title":"Equations Summary","text":"Quantity Formula Depot 1 initial \\(A_1(0) = F_1 \\cdot Dose\\) Depot 2 initial \\(A_2(0) = (1-F_1) \\cdot Dose\\) Total absorption \\(K_{a1} \\cdot A_1 + K_{a2} \\cdot A_2\\) Concentration \\(C = A_c / V\\)"},{"location":"julia/models/pk/parallel-absorption/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - Single absorption</li> <li>Transit Absorption - Delayed absorption</li> </ul>"},{"location":"julia/models/pk/threecomp-iv/","title":"Three-Compartment IV Bolus","text":"<p>Three-compartment mammillary model with central, shallow peripheral, and deep peripheral compartments, exhibiting tri-exponential concentration decline.</p>"},{"location":"julia/models/pk/threecomp-iv/#model-overview","title":"Model Overview","text":"<pre><code>graph TB\n    D((Dose)) --&gt;|Bolus| C[Central&lt;br/&gt;V1]\n    C &lt;--&gt;|Q2| P1[Shallow Peripheral&lt;br/&gt;V2]\n    C &lt;--&gt;|Q3| P2[Deep Peripheral&lt;br/&gt;V3]\n    C --&gt;|CL| E((Elimination))\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Highly lipophilic drugs</li> <li>Drugs with deep tissue binding</li> <li>Long half-life compounds</li> <li>Anesthetics (propofol, fentanyl)</li> <li>Monoclonal antibodies</li> <li>Drugs with bone/fat distribution</li> </ul>"},{"location":"julia/models/pk/threecomp-iv/#when-to-use","title":"When to Use","text":"Use When Don't Use When Tri-exponential decline Bi-exponential adequate Very long terminal t\u00bd Simple tissue distribution Deep tissue binding Two compartments sufficient Three distinct phases Overfitting concerns"},{"location":"julia/models/pk/threecomp-iv/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/threecomp-iv/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Clearance CL L/h Systemic clearance CL &gt; 0 Central volume V1 L Central compartment V1 &gt; 0 Shallow Q Q2 L/h Clearance to shallow peripheral Q2 &gt; 0 Shallow volume V2 L Shallow peripheral volume V2 &gt; 0 Deep Q Q3 L/h Clearance to deep peripheral Q3 &gt; 0 Deep volume V3 L Deep peripheral volume V3 &gt; 0"},{"location":"julia/models/pk/threecomp-iv/#micro-rate-constants","title":"Micro-Rate Constants","text":"<p>$\\(k_{10} = \\frac{CL}{V_1}\\)$ (elimination)</p> <p>$\\(k_{12} = \\frac{Q_2}{V_1}\\)$, $\\(k_{21} = \\frac{Q_2}{V_2}\\)$ (shallow transfer)</p> <p>$\\(k_{13} = \\frac{Q_3}{V_1}\\)$, $\\(k_{31} = \\frac{Q_3}{V_3}\\)$ (deep transfer)</p>"},{"location":"julia/models/pk/threecomp-iv/#state-variables","title":"State Variables","text":"State Symbol Description A1 Central Amount in central compartment A2 Shallow Amount in shallow peripheral A3 Deep Amount in deep peripheral"},{"location":"julia/models/pk/threecomp-iv/#differential-equations","title":"Differential Equations","text":"\\[\\frac{dA_1}{dt} = -(k_{10} + k_{12} + k_{13}) \\cdot A_1 + k_{21} \\cdot A_2 + k_{31} \\cdot A_3\\] \\[\\frac{dA_2}{dt} = k_{12} \\cdot A_1 - k_{21} \\cdot A_2\\] \\[\\frac{dA_3}{dt} = k_{13} \\cdot A_1 - k_{31} \\cdot A_3\\]"},{"location":"julia/models/pk/threecomp-iv/#tri-exponential-solution","title":"Tri-Exponential Solution","text":"\\[C(t) = A \\cdot e^{-\\alpha t} + B \\cdot e^{-\\beta t} + C \\cdot e^{-\\gamma t}\\] <p>Where: - \u03b1 = fast (initial distribution) rate - \u03b2 = intermediate rate - \u03b3 = slow (terminal) rate - \u03b1 &gt; \u03b2 &gt; \u03b3</p>"},{"location":"julia/models/pk/threecomp-iv/#observation","title":"Observation","text":"\\[C = \\frac{A_1}{V_1}\\]"},{"location":"julia/models/pk/threecomp-iv/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pk/threecomp-iv/#volume-at-steady-state","title":"Volume at Steady State","text":"\\[V_{ss} = V_1 + V_2 + V_3\\]"},{"location":"julia/models/pk/threecomp-iv/#half-lives","title":"Half-Lives","text":"<p>$\\(t_{1/2,\\alpha} = \\frac{0.693}{\\alpha}\\)$ (rapid distribution)</p> <p>$\\(t_{1/2,\\beta} = \\frac{0.693}{\\beta}\\)$ (slow distribution)</p> <p>$\\(t_{1/2,\\gamma} = \\frac{0.693}{\\gamma}\\)$ (terminal elimination)</p>"},{"location":"julia/models/pk/threecomp-iv/#mean-residence-time","title":"Mean Residence Time","text":"\\[MRT = \\frac{V_{ss}}{CL}\\]"},{"location":"julia/models/pk/threecomp-iv/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/threecomp-iv/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct ThreeCompIVBolus &lt;: ModelKind end\n\n# Parameters\nstruct ThreeCompIVBolusParams &lt;: AbstractParams\n    CL::Float64    # Clearance (L/h)\n    V1::Float64    # Central volume (L)\n    Q2::Float64    # Shallow peripheral clearance (L/h)\n    V2::Float64    # Shallow peripheral volume (L)\n    Q3::Float64    # Deep peripheral clearance (L/h)\n    V3::Float64    # Deep peripheral volume (L)\nend\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\n# CL = 5 L/h, V1 = 10 L\n# Q2 = 20 L/h, V2 = 30 L (rapid equilibration)\n# Q3 = 5 L/h, V3 = 100 L (slow equilibration)\nparams = ThreeCompIVBolusParams(5.0, 10.0, 20.0, 30.0, 5.0, 100.0)\n\n# Single 1000 mg IV bolus\ndoses = [DoseEvent(0.0, 1000.0)]\n\n# Create specification\nspec = ModelSpec(\n    ThreeCompIVBolus(),\n    \"threecomp_example\",\n    params,\n    doses\n)\n\n# Long simulation to capture terminal phase (7 days)\ngrid = SimGrid(0.0, 168.0, collect(0.0:0.5:168.0))\n\n# Solver\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Observe three phases\nconc = result.observations[:conc]\nt = result.t\n\nprintln(\"C at t=0: \", round(conc[1], digits=2), \" mg/L (initial)\")\nprintln(\"C at t=1h: \", round(conc[3], digits=2), \" mg/L (\u03b1 phase)\")\nprintln(\"C at t=12h: \", round(conc[25], digits=2), \" mg/L (\u03b2 phase)\")\nprintln(\"C at t=168h: \", round(conc[end], digits=4), \" mg/L (\u03b3 phase)\")\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#calculate-rate-constants","title":"Calculate Rate Constants","text":"<pre><code># Micro-rate constants\nk10 = params.CL / params.V1\nk12 = params.Q2 / params.V1\nk21 = params.Q2 / params.V2\nk13 = params.Q3 / params.V1\nk31 = params.Q3 / params.V3\n\nprintln(\"k10 (elimination): \", round(k10, digits=3), \" 1/h\")\nprintln(\"k12 (to shallow): \", round(k12, digits=3), \" 1/h\")\nprintln(\"k21 (from shallow): \", round(k21, digits=3), \" 1/h\")\nprintln(\"k13 (to deep): \", round(k13, digits=3), \" 1/h\")\nprintln(\"k31 (from deep): \", round(k31, digits=3), \" 1/h\")\n\n# Vss and MRT\nVss = params.V1 + params.V2 + params.V3\nMRT = Vss / params.CL\n\nprintln(\"\\nVss: \", Vss, \" L\")\nprintln(\"MRT: \", MRT, \" h\")\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#clinical-example-propofol","title":"Clinical Example: Propofol","text":"<pre><code># Propofol typical parameters (anesthesia)\n# Rapid redistribution from brain to muscle, then slow to fat\nparams = ThreeCompIVBolusParams(\n    1.6,    # CL (L/min)\n    4.3,    # V1 (L) - central\n    2.3,    # Q2 (L/min) - rapid\n    22.0,   # V2 (L) - muscle\n    0.8,    # Q3 (L/min) - slow\n    200.0   # V3 (L) - fat\n)\n\n# Convert to hourly rates for simulation\nparams_hourly = ThreeCompIVBolusParams(\n    1.6 * 60, 4.3, 2.3 * 60, 22.0, 0.8 * 60, 200.0\n)\n\n# 200 mg bolus\ndoses = [DoseEvent(0.0, 200.0)]\n\nspec = ModelSpec(ThreeCompIVBolus(), \"propofol\", params_hourly, doses)\ngrid = SimGrid(0.0, 6.0, collect(0.0:0.02:6.0))  # 6 hours, 72 sec resolution\n\nresult = simulate(spec, grid, solver)\n\n# Context-sensitive half-time depends on infusion duration\n# For short infusions, distribution dominates recovery\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#compartment-amounts-over-time","title":"Compartment Amounts Over Time","text":"<pre><code># Track drug distribution\nresult = simulate(spec, grid, solver)\n\nA1 = result.states[:A_central]\nA2 = result.states[:A_periph1]\nA3 = result.states[:A_periph2]\nt = result.t\n\n# At different times\nfor time in [0.0, 1.0, 12.0, 48.0, 168.0]\n    idx = findfirst(x -&gt; x &gt;= time, t)\n    total = A1[idx] + A2[idx] + A3[idx]\n    println(\"t = $(time)h:\")\n    println(\"  Central: $(round(100*A1[idx]/total, digits=1))%\")\n    println(\"  Shallow: $(round(100*A2[idx]/total, digits=1))%\")\n    println(\"  Deep: $(round(100*A3[idx]/total, digits=1))%\")\nend\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = ThreeCompIVBolusParams(5.0, 10.0, 20.0, 30.0, 5.0, 100.0)\n\n# IIV on key parameters\nomega = OmegaMatrix([\n    0.09 0.0  0.0  0.0  0.0  0.0;   # CL (30% CV)\n    0.0  0.04 0.0  0.0  0.0  0.0;   # V1 (20% CV)\n    0.0  0.0  0.09 0.0  0.0  0.0;   # Q2 (30% CV)\n    0.0  0.0  0.0  0.04 0.0  0.0;   # V2 (20% CV)\n    0.0  0.0  0.0  0.0  0.16 0.0;   # Q3 (40% CV)\n    0.0  0.0  0.0  0.0  0.0  0.09   # V3 (30% CV)\n])\n\ndoses = [DoseEvent(0.0, 1000.0)]\nbase_spec = ModelSpec(ThreeCompIVBolus(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 50, omega, 12345)\n\ngrid = SimGrid(0.0, 168.0, collect(0.0:2.0:168.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# Terminal half-life variability\n# (Dominated by V3 and CL variability)\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#model-selection-2-comp-vs-3-comp","title":"Model Selection: 2-Comp vs 3-Comp","text":"<pre><code># Generate data from 3-comp model\ntrue_params = ThreeCompIVBolusParams(5.0, 10.0, 20.0, 30.0, 5.0, 100.0)\ndoses = [DoseEvent(0.0, 1000.0)]\n\nspec_3comp = ModelSpec(ThreeCompIVBolus(), \"true\", true_params, doses)\ngrid = SimGrid(0.0, 168.0, [0.0, 0.25, 0.5, 1, 2, 4, 8, 12, 24, 48, 72, 120, 168])\n\nresult = simulate(spec_3comp, grid, solver)\n\n# Log-linear plot reveals phases\nlog_conc = log.(result.observations[:conc])\nt = result.t\n\n# If three distinct slopes are visible, 3-comp is justified\n# Otherwise, 2-comp may be sufficient\n</code></pre>"},{"location":"julia/models/pk/threecomp-iv/#equations-summary","title":"Equations Summary","text":"Quantity Formula k10 \\(CL/V_1\\) k12, k21 \\(Q_2/V_1\\), \\(Q_2/V_2\\) k13, k31 \\(Q_3/V_1\\), \\(Q_3/V_3\\) C(t) \\(Ae^{-\\alpha t} + Be^{-\\beta t} + Ce^{-\\gamma t}\\) Vss \\(V_1 + V_2 + V_3\\) MRT \\(V_{ss}/CL\\) Terminal t\u00bd \\(0.693/\\gamma\\)"},{"location":"julia/models/pk/threecomp-iv/#see-also","title":"See Also","text":"<ul> <li>Two-Compartment IV - Simpler model</li> <li>One-Compartment IV - Simplest model</li> <li>Population Modeling - Adding variability</li> <li>Parameter Estimation - Fitting to data</li> </ul>"},{"location":"julia/models/pk/tmdd/","title":"Target-Mediated Drug Disposition (TMDD)","text":"<p>Advanced PK model for drugs that bind to their pharmacological target, forming drug-target complexes that affect both PK and PD behavior.</p>"},{"location":"julia/models/pk/tmdd/#usage","title":"Usage","text":"<pre><code>using OpenPKPDCore\n\n# Create TMDD model specification\nmodel = target_mediated_drug_disposition()\nparams = CustomODEParams(\n    kel = 0.1,    # Drug elimination rate (1/h)\n    kon = 0.01,   # Association rate\n    koff = 0.001, # Dissociation rate\n    ksyn = 1.0,   # Receptor synthesis\n    kdeg = 0.1,   # Receptor degradation\n    kint = 0.05,  # Complex internalization\n    V = 50.0      # Volume (L)\n)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(model, \"tmdd_sim\", params, doses)\ngrid = SimGrid(0.0, 72.0, 0:1:72)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n</code></pre>"},{"location":"julia/models/pk/tmdd/#parameters","title":"Parameters","text":"Parameter Type Description <code>kel</code> Float64 Drug elimination rate constant (1/h) <code>kon</code> Float64 Association rate constant (1/(conc*h)) <code>koff</code> Float64 Dissociation rate constant (1/h) <code>ksyn</code> Float64 Receptor synthesis rate (conc/h) <code>kdeg</code> Float64 Receptor degradation rate constant (1/h) <code>kint</code> Float64 Complex internalization rate constant (1/h) <code>V</code> Float64 Volume of distribution (L)"},{"location":"julia/models/pk/tmdd/#derived-parameters","title":"Derived Parameters","text":"<ul> <li>KD (dissociation constant): \\(K_D = k_{off} / k_{on}\\)</li> <li>Receptor baseline: \\(R_0 = k_{syn} / k_{deg}\\)</li> </ul>"},{"location":"julia/models/pk/tmdd/#model-equations","title":"Model Equations","text":"<p>Three-state ODE system:</p> \\[\\frac{dL}{dt} = -k_{el} \\cdot L - k_{on} \\cdot L \\cdot R + k_{off} \\cdot RL\\] \\[\\frac{dR}{dt} = k_{syn} - k_{deg} \\cdot R - k_{on} \\cdot L \\cdot R + k_{off} \\cdot RL\\] \\[\\frac{dRL}{dt} = k_{on} \\cdot L \\cdot R - k_{off} \\cdot RL - k_{int} \\cdot RL\\] <p>Where: - L = Free drug (ligand) concentration - R = Free receptor concentration - RL = Drug-receptor complex concentration</p>"},{"location":"julia/models/pk/tmdd/#basic-example","title":"Basic Example","text":"<pre><code>using OpenPKPDCore\n\nmodel = target_mediated_drug_disposition()\nparams = CustomODEParams(\n    kel = 0.1,\n    kon = 0.01,\n    koff = 0.001,\n    ksyn = 1.0,\n    kdeg = 0.1,\n    kint = 0.05,\n    V = 50.0\n)\n\ndoses = [DoseEvent(0.0, 500.0)]\nspec = ModelSpec(model, \"tmdd\", params, doses)\ngrid = SimGrid(0.0, 72.0, 0:0.5:72)\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\nresult = simulate(spec, grid, solver)\n\n# Access states\nconc = result.observations[:conc]\nprintln(\"Initial free drug: $(conc[1]) mg/L\")\nprintln(\"Free drug at 24h: $(conc[49]) mg/L\")\n</code></pre>"},{"location":"julia/models/pk/tmdd/#non-linear-pk-behavior","title":"Non-Linear PK Behavior","text":"<pre><code>using OpenPKPDCore\n\nmodel = target_mediated_drug_disposition()\n\ndoses_list = [50.0, 100.0, 200.0, 500.0, 1000.0]\n\nprintln(\"Dose (mg) | Cmax (mg/L) | Apparent t1/2\")\nprintln(\"-\" ^ 45)\n\nfor dose in doses_list\n    params = CustomODEParams(\n        kel = 0.1, kon = 0.01, koff = 0.001,\n        ksyn = 1.0, kdeg = 0.1, kint = 0.05, V = 50.0\n    )\n\n    doses = [DoseEvent(0.0, dose)]\n    spec = ModelSpec(model, \"tmdd\", params, doses)\n    grid = SimGrid(0.0, 96.0, 0:0.5:96)\n    solver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10^7)\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n\n    cmax = maximum(conc)\n    println(\"$dose | $cmax | ...\")\nend\n</code></pre>"},{"location":"julia/models/pk/tmdd/#clinical-applications","title":"Clinical Applications","text":"<p>TMDD is relevant for:</p> <ul> <li>Monoclonal antibodies binding to soluble targets</li> <li>Therapeutic proteins with receptor-mediated clearance</li> <li>Small molecules with high-affinity target binding</li> <li>Biologics with target-mediated disposition</li> </ul>"},{"location":"julia/models/pk/tmdd/#equations-summary","title":"Equations Summary","text":"Quantity Formula KD \\(k_{off} / k_{on}\\) Receptor baseline \\(R_0 = k_{syn} / k_{deg}\\) Free drug rate \\(-k_{el}L - k_{on}LR + k_{off}RL\\) Complex rate \\(k_{on}LR - k_{off}RL - k_{int}RL\\) Total drug \\(L + RL\\)"},{"location":"julia/models/pk/tmdd/#see-also","title":"See Also","text":"<ul> <li>Michaelis-Menten - Saturable elimination</li> <li>Two-Compartment IV - Distribution kinetics</li> </ul>"},{"location":"julia/models/pk/transit-absorption/","title":"Transit Compartment Absorption","text":"<p>Transit compartment model for delayed and complex oral absorption, using a chain of compartments to represent gastrointestinal transit.</p>"},{"location":"julia/models/pk/transit-absorption/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt; T1[Transit 1]\n    T1 --&gt;|Ktr| T2[Transit 2]\n    T2 --&gt;|Ktr| T3[...]\n    T3 --&gt;|Ktr| TN[Transit N]\n    TN --&gt;|Ka| C[Central&lt;br/&gt;V]\n    C --&gt;|CL| E((Elimination))\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Controlled-release formulations</li> <li>Enteric-coated tablets</li> <li>Drugs with gastric emptying delays</li> <li>Complex GI transit</li> <li>When simple lag time is insufficient</li> <li>Multiphasic absorption</li> </ul>"},{"location":"julia/models/pk/transit-absorption/#when-to-use","title":"When to Use","text":"Use When Don't Use When Delayed Tmax Simple first-order works Broad absorption peak Sharp, early peak Enteric coating Immediate release Complex GI transit Simple lag time adequate Gamma-like absorption First-order sufficient"},{"location":"julia/models/pk/transit-absorption/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/transit-absorption/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Transit compartments N - Number of transit compartments 1 \u2264 N \u2264 20 Transit rate Ktr 1/h Transfer between transits Ktr &gt; 0 Absorption rate Ka 1/h Final absorption rate Ka &gt; 0 Clearance CL L/h Apparent clearance CL &gt; 0 Volume V L Apparent volume V &gt; 0"},{"location":"julia/models/pk/transit-absorption/#state-variables","title":"State Variables","text":"State Description Transit_1 ... Transit_N Amount in each transit compartment A_central Amount in central compartment"},{"location":"julia/models/pk/transit-absorption/#differential-equations","title":"Differential Equations","text":"<p>$\\(\\frac{dT_1}{dt} = -K_{tr} \\cdot T_1\\)$ (first transit, receives dose)</p> <p>$\\(\\frac{dT_i}{dt} = K_{tr} \\cdot T_{i-1} - K_{tr} \\cdot T_i\\)$ (for i = 2 to N)</p> \\[\\frac{dA_{central}}{dt} = K_a \\cdot T_N - \\frac{CL}{V} \\cdot A_{central}\\]"},{"location":"julia/models/pk/transit-absorption/#absorption-profile","title":"Absorption Profile","text":"<p>The absorption input follows a gamma distribution:</p> \\[\\text{Input}(t) = \\frac{D \\cdot K_{tr}^{N+1} \\cdot t^N \\cdot e^{-K_{tr} \\cdot t}}{N!}\\]"},{"location":"julia/models/pk/transit-absorption/#observation","title":"Observation","text":"\\[C = \\frac{A_{central}}{V}\\]"},{"location":"julia/models/pk/transit-absorption/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pk/transit-absorption/#mean-transit-time-mtt","title":"Mean Transit Time (MTT)","text":"\\[MTT = \\frac{N + 1}{K_{tr}}\\]"},{"location":"julia/models/pk/transit-absorption/#time-to-maximum-input-rate","title":"Time to Maximum Input Rate","text":"\\[t_{max,input} = \\frac{N}{K_{tr}}\\]"},{"location":"julia/models/pk/transit-absorption/#absorption-variability","title":"Absorption Variability","text":"<p>The coefficient of variation of the absorption profile:</p> \\[CV_{absorption} = \\frac{1}{\\sqrt{N + 1}}\\] <p>More transit compartments \u2192 narrower, more reproducible absorption.</p>"},{"location":"julia/models/pk/transit-absorption/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/transit-absorption/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct TransitAbsorption &lt;: ModelKind end\n\n# Parameters\nstruct TransitAbsorptionParams &lt;: AbstractParams\n    N::Int         # Number of transit compartments\n    Ktr::Float64   # Transit rate constant (1/h)\n    Ka::Float64    # Absorption rate constant (1/h)\n    CL::Float64    # Clearance (L/h)\n    V::Float64     # Volume (L)\nend\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\n# 5 transit compartments, Ktr = 0.5/h\n# MTT = (5+1)/0.5 = 12 hours\nparams = TransitAbsorptionParams(5, 0.5, 2.0, 10.0, 70.0)\n\n# Single 300 mg oral dose\ndoses = [DoseEvent(0.0, 300.0)]\n\n# Create specification\nspec = ModelSpec(\n    TransitAbsorption(),\n    \"transit_example\",\n    params,\n    doses\n)\n\n# Time grid\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.25:48.0))\n\n# Solver\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Find Cmax and Tmax\nconc = result.observations[:conc]\nt = result.t\ncmax, idx = findmax(conc)\ntmax = t[idx]\n\nprintln(\"Cmax: \", round(cmax, digits=2), \" mg/L\")\nprintln(\"Tmax: \", round(tmax, digits=2), \" h\")\n\n# Compare to MTT\nMTT = (params.N + 1) / params.Ktr\nprintln(\"Mean Transit Time: \", MTT, \" h\")\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#effect-of-number-of-transit-compartments","title":"Effect of Number of Transit Compartments","text":"<pre><code># Compare different N values\nn_values = [1, 3, 5, 10]\n\nfor n in n_values\n    # Keep MTT constant at 12 hours\n    MTT = 12.0\n    ktr = (n + 1) / MTT\n\n    params = TransitAbsorptionParams(n, ktr, 2.0, 10.0, 70.0)\n    doses = [DoseEvent(0.0, 300.0)]\n    spec = ModelSpec(TransitAbsorption(), \"n_$n\", params, doses)\n    grid = SimGrid(0.0, 48.0, collect(0.0:0.1:48.0))\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n    cmax, idx = findmax(conc)\n    tmax = result.t[idx]\n\n    println(\"N=$n: Cmax=$(round(cmax, digits=2)), Tmax=$(round(tmax, digits=2))\")\nend\n</code></pre> <p>Expected Results: - Higher N \u2192 More delayed Tmax - Higher N \u2192 Lower, broader Cmax - Same AUC regardless of N (same CL)</p>"},{"location":"julia/models/pk/transit-absorption/#comparison-with-simple-oral","title":"Comparison with Simple Oral","text":"<pre><code># Transit absorption\nparams_transit = TransitAbsorptionParams(5, 0.5, 2.0, 10.0, 70.0)\n\n# Simple first-order with lag\n# Approximate effective Ka from transit\neffective_ka = 0.3  # Slower overall absorption\n\nparams_simple = OneCompOralFirstOrderParams(effective_ka, 10.0, 70.0)\n\ndoses = [DoseEvent(0.0, 300.0)]\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.1:48.0))\n\nspec_transit = ModelSpec(TransitAbsorption(), \"transit\", params_transit, doses)\nspec_simple = ModelSpec(OneCompOralFirstOrder(), \"simple\", params_simple, doses)\n\nresult_transit = simulate(spec_transit, grid, solver)\nresult_simple = simulate(spec_simple, grid, solver)\n\n# Transit model has:\n# - Delayed onset\n# - Broader peak\n# - More physiological shape\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#controlled-release-formulation","title":"Controlled-Release Formulation","text":"<pre><code># Extended-release tablet\n# Long MTT (18 hours), slow release\nparams_er = TransitAbsorptionParams(8, 0.5, 0.5, 10.0, 70.0)\n\n# Immediate-release for comparison\nparams_ir = OneCompOralFirstOrderParams(2.0, 10.0, 70.0)\n\n# Same total daily dose, ER given once, IR given TID\ndoses_er = [DoseEvent(0.0, 300.0)]\ndoses_ir = [DoseEvent(0.0, 100.0), DoseEvent(8.0, 100.0), DoseEvent(16.0, 100.0)]\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.25:48.0))\n\nspec_er = ModelSpec(TransitAbsorption(), \"ER\", params_er, doses_er)\nspec_ir = ModelSpec(OneCompOralFirstOrder(), \"IR\", params_ir, doses_ir)\n\nresult_er = simulate(spec_er, grid, solver)\nresult_ir = simulate(spec_ir, grid, solver)\n\n# ER has:\n# - Lower Cmax\n# - More sustained levels\n# - Better compliance (once daily)\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = TransitAbsorptionParams(5, 0.5, 2.0, 10.0, 70.0)\n\n# Note: N is typically fixed, not random\n# IIV on Ktr, Ka, CL, V\nomega = OmegaMatrix([\n    0.25 0.0  0.0  0.0;    # \u03c9\u00b2_Ktr (50% CV - high for transit)\n    0.0  0.16 0.0  0.0;    # \u03c9\u00b2_Ka (40% CV)\n    0.0  0.0  0.09 0.0;    # \u03c9\u00b2_CL (30% CV)\n    0.0  0.0  0.0  0.04    # \u03c9\u00b2_V (20% CV)\n])\n\ndoses = [DoseEvent(0.0, 300.0)]\nbase_spec = ModelSpec(TransitAbsorption(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 100, omega, 12345)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.5:48.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# High variability in Tmax due to Ktr IIV\ntmax_values = Float64[]\nfor ind in result.individuals\n    conc = ind.observations[:conc]\n    _, idx = findmax(conc)\n    push!(tmax_values, ind.t[idx])\nend\n\nusing Statistics\nprintln(\"Tmax median: \", median(tmax_values), \" h\")\nprintln(\"Tmax range: \", minimum(tmax_values), \" - \", maximum(tmax_values), \" h\")\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#estimation-considerations","title":"Estimation Considerations","text":""},{"location":"julia/models/pk/transit-absorption/#identifiability","title":"Identifiability","text":"<ul> <li>N and Ktr are correlated (same MTT with different combinations)</li> <li>Often fix N based on physiology or prior knowledge</li> <li>Estimate Ktr (or MTT) with N fixed</li> </ul>"},{"location":"julia/models/pk/transit-absorption/#starting-values","title":"Starting Values","text":"<pre><code># From observed Tmax, estimate MTT\nobserved_tmax = 8.0  # hours\n\n# MTT \u2248 Tmax for transit models\n# Choose N based on formulation (3-7 typical)\nN_guess = 5\nKtr_guess = (N_guess + 1) / observed_tmax\n\nprintln(\"Initial Ktr: \", Ktr_guess, \" 1/h\")\n</code></pre>"},{"location":"julia/models/pk/transit-absorption/#equations-summary","title":"Equations Summary","text":"Quantity Formula MTT \\((N+1)/K_{tr}\\) t_max,input \\(N/K_{tr}\\) CV_absorption \\(1/\\sqrt{N+1}\\) Input rate \\(\\frac{D \\cdot K_{tr}^{N+1} \\cdot t^N \\cdot e^{-K_{tr}t}}{N!}\\) dT_1/dt \\(-K_{tr} \\cdot T_1\\) dT_i/dt \\(K_{tr}(T_{i-1} - T_i)\\) dA/dt \\(K_a T_N - (CL/V) A\\)"},{"location":"julia/models/pk/transit-absorption/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - Simple absorption</li> <li>Two-Compartment Oral - With distribution</li> <li>NCA Reference - Exposure calculations</li> <li>Population Modeling - Adding variability</li> </ul>"},{"location":"julia/models/pk/twocomp-iv/","title":"Two-Compartment IV Bolus","text":"<p>Two-compartment mammillary model with central and peripheral compartments, exhibiting bi-exponential concentration decline after IV bolus administration.</p>"},{"location":"julia/models/pk/twocomp-iv/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt;|Bolus| C[Central&lt;br/&gt;V1]\n    C &lt;--&gt;|Q| P[Peripheral&lt;br/&gt;V2]\n    C --&gt;|CL| E((Elimination))\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Drugs with distribution phase</li> <li>Lipophilic compounds</li> <li>Antibodies and biologics</li> <li>Anesthetics</li> <li>Drugs with tissue binding</li> </ul>"},{"location":"julia/models/pk/twocomp-iv/#when-to-use","title":"When to Use","text":"Use When Don't Use When Bi-exponential decline Mono-exponential decline Clear distribution phase Rapid equilibration Multi-tissue distribution Single compartment kinetics \u03b1 and \u03b2 phases visible Tri-exponential needed"},{"location":"julia/models/pk/twocomp-iv/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/twocomp-iv/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Clearance CL L/h Systemic clearance CL &gt; 0 Central volume V1 L Volume of central compartment V1 &gt; 0 Inter-compartmental clearance Q L/h Distribution clearance Q &gt; 0 Peripheral volume V2 L Volume of peripheral compartment V2 &gt; 0"},{"location":"julia/models/pk/twocomp-iv/#micro-rate-constants","title":"Micro-Rate Constants","text":"<p>$\\(k_{10} = \\frac{CL}{V_1}\\)$ (elimination)</p> <p>$\\(k_{12} = \\frac{Q}{V_1}\\)$ (central \u2192 peripheral)</p> <p>$\\(k_{21} = \\frac{Q}{V_2}\\)$ (peripheral \u2192 central)</p>"},{"location":"julia/models/pk/twocomp-iv/#state-variables","title":"State Variables","text":"State Symbol Units Description Central amount A1 mg Drug in central compartment Peripheral amount A2 mg Drug in peripheral compartment"},{"location":"julia/models/pk/twocomp-iv/#differential-equations","title":"Differential Equations","text":"\\[\\frac{dA_1}{dt} = -k_{10} \\cdot A_1 - k_{12} \\cdot A_1 + k_{21} \\cdot A_2\\] \\[\\frac{dA_2}{dt} = k_{12} \\cdot A_1 - k_{21} \\cdot A_2\\]"},{"location":"julia/models/pk/twocomp-iv/#bi-exponential-solution","title":"Bi-Exponential Solution","text":"\\[C(t) = A \\cdot e^{-\\alpha t} + B \\cdot e^{-\\beta t}\\] <p>Where: - \u03b1 = fast (distribution) rate constant - \u03b2 = slow (elimination) rate constant - A, B = coefficients (macro-constants)</p>"},{"location":"julia/models/pk/twocomp-iv/#hybrid-constants","title":"Hybrid Constants","text":"\\[\\alpha + \\beta = k_{10} + k_{12} + k_{21}\\] \\[\\alpha \\cdot \\beta = k_{10} \\cdot k_{21}\\]"},{"location":"julia/models/pk/twocomp-iv/#observation","title":"Observation","text":"\\[C = \\frac{A_1}{V_1}\\]"},{"location":"julia/models/pk/twocomp-iv/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pk/twocomp-iv/#distribution-and-elimination-rates","title":"Distribution and Elimination Rates","text":"\\[\\alpha = \\frac{1}{2}\\left[(k_{10} + k_{12} + k_{21}) + \\sqrt{(k_{10} + k_{12} + k_{21})^2 - 4 \\cdot k_{10} \\cdot k_{21}}\\right]\\] \\[\\beta = \\frac{1}{2}\\left[(k_{10} + k_{12} + k_{21}) - \\sqrt{(k_{10} + k_{12} + k_{21})^2 - 4 \\cdot k_{10} \\cdot k_{21}}\\right]\\]"},{"location":"julia/models/pk/twocomp-iv/#half-lives","title":"Half-Lives","text":"<p>$\\(t_{1/2,\\alpha} = \\frac{0.693}{\\alpha}\\)$ (distribution half-life)</p> <p>$\\(t_{1/2,\\beta} = \\frac{0.693}{\\beta}\\)$ (terminal half-life)</p>"},{"location":"julia/models/pk/twocomp-iv/#coefficients","title":"Coefficients","text":"\\[A = \\frac{D}{V_1} \\cdot \\frac{\\alpha - k_{21}}{\\alpha - \\beta}\\] \\[B = \\frac{D}{V_1} \\cdot \\frac{k_{21} - \\beta}{\\alpha - \\beta}\\]"},{"location":"julia/models/pk/twocomp-iv/#volume-at-steady-state","title":"Volume at Steady State","text":"\\[V_{ss} = V_1 + V_2 = V_1 \\cdot \\left(1 + \\frac{k_{12}}{k_{21}}\\right)\\]"},{"location":"julia/models/pk/twocomp-iv/#auc","title":"AUC","text":"\\[AUC = \\frac{A}{\\alpha} + \\frac{B}{\\beta} = \\frac{D}{CL}\\]"},{"location":"julia/models/pk/twocomp-iv/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/twocomp-iv/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct TwoCompIVBolus &lt;: ModelKind end\n\n# Parameters\nstruct TwoCompIVBolusParams &lt;: AbstractParams\n    CL::Float64    # Clearance (L/h)\n    V1::Float64    # Central volume (L)\n    Q::Float64     # Inter-compartmental clearance (L/h)\n    V2::Float64    # Peripheral volume (L)\nend\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\n# CL = 10 L/h, V1 = 20 L\n# Q = 15 L/h, V2 = 50 L\nparams = TwoCompIVBolusParams(10.0, 20.0, 15.0, 50.0)\n\n# Single 500 mg IV bolus\ndoses = [DoseEvent(0.0, 500.0)]\n\n# Create specification\nspec = ModelSpec(\n    TwoCompIVBolus(),\n    \"twocomp_example\",\n    params,\n    doses\n)\n\n# Fine time grid to capture distribution phase\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.1:48.0))\n\n# Solver\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Observe bi-exponential decline\nconc = result.observations[:conc]\nprintln(\"C at t=0: \", round(conc[1], digits=2), \" mg/L\")\nprintln(\"C at t=1h: \", round(conc[11], digits=2), \" mg/L (distribution)\")\nprintln(\"C at t=24h: \", round(conc[241], digits=2), \" mg/L (terminal)\")\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#calculate-derived-parameters","title":"Calculate Derived Parameters","text":"<pre><code># Micro-rate constants\nk10 = params.CL / params.V1\nk12 = params.Q / params.V1\nk21 = params.Q / params.V2\n\n# Alpha and beta\nsum_k = k10 + k12 + k21\nprod_k = k10 * k21\ndiscriminant = sqrt(sum_k^2 - 4*prod_k)\n\nalpha = (sum_k + discriminant) / 2\nbeta = (sum_k - discriminant) / 2\n\n# Half-lives\nt_half_alpha = log(2) / alpha\nt_half_beta = log(2) / beta\n\nprintln(\"Distribution t\u00bd: \", round(t_half_alpha, digits=2), \" h\")\nprintln(\"Terminal t\u00bd: \", round(t_half_beta, digits=2), \" h\")\n\n# Vss\nVss = params.V1 + params.V2\nprintln(\"Vss: \", Vss, \" L\")\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#distribution-phase-analysis","title":"Distribution Phase Analysis","text":"<pre><code># Identify distribution vs elimination phases\nconc = result.observations[:conc]\nt = result.t\n\n# Log-transform for visual inspection\nlog_conc = log.(conc)\n\n# Find inflection point (approximate end of distribution)\n# Where second derivative changes sign\ndiff1 = diff(log_conc)\ndiff2 = diff(diff1)\n\n# Transition occurs where distribution phase ends\n# Typically when |dC/dt| stabilizes\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#clinical-example-vancomycin","title":"Clinical Example: Vancomycin","text":"<pre><code># Vancomycin typical parameters\n# CL \u2248 4.5 L/h, V1 \u2248 15 L, Q \u2248 4 L/h, V2 \u2248 40 L\nparams = TwoCompIVBolusParams(4.5, 15.0, 4.0, 40.0)\n\n# 1g over 1 hour (infusion)\ndoses = [DoseEvent(0.0, 1000.0, 1.0)]\n\nspec = ModelSpec(TwoCompIVBolus(), \"vancomycin\", params, doses)\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\n\nresult = simulate(spec, grid, solver)\n\n# Therapeutic monitoring\n# Target peak (2h post-start): 30-40 mg/L\n# Target trough: 15-20 mg/L\nidx_2h = findfirst(x -&gt; x \u2248 2.0, result.t)\nidx_24h = findfirst(x -&gt; x \u2248 24.0, result.t)\n\nprintln(\"Peak (2h): \", round(result.observations[:conc][idx_2h], digits=1), \" mg/L\")\nprintln(\"Trough (24h): \", round(result.observations[:conc][idx_24h], digits=1), \" mg/L\")\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = TwoCompIVBolusParams(10.0, 20.0, 15.0, 50.0)\n\n# IIV on all parameters\n# 30% CV on CL, 25% CV on V1, 35% CV on Q, 30% CV on V2\nomega = OmegaMatrix([\n    0.09 0.0  0.0  0.0;    # \u03c9\u00b2_CL\n    0.0  0.0625 0.0 0.0;   # \u03c9\u00b2_V1\n    0.0  0.0  0.1225 0.0;  # \u03c9\u00b2_Q\n    0.0  0.0  0.0  0.09    # \u03c9\u00b2_V2\n])\n\ndoses = [DoseEvent(0.0, 500.0)]\nbase_spec = ModelSpec(TwoCompIVBolus(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 100, omega, 12345)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:1.0:48.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# Summary statistics\nsummary = result.summaries[:conc]\nprintln(\"Median at 24h: \", summary.median[25])\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#comparison-with-one-compartment","title":"Comparison with One-Compartment","text":"<pre><code># Same total volume and clearance\nCL = 10.0\nVtotal = 70.0\n\n# One-compartment\nparams_1comp = OneCompIVBolusParams(CL, Vtotal)\n\n# Two-compartment (same Vss)\nparams_2comp = TwoCompIVBolusParams(CL, 20.0, 15.0, 50.0)\n\ndoses = [DoseEvent(0.0, 500.0)]\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.1:48.0))\n\n# Simulate both\nspec_1comp = ModelSpec(OneCompIVBolus(), \"1comp\", params_1comp, doses)\nspec_2comp = ModelSpec(TwoCompIVBolus(), \"2comp\", params_2comp, doses)\n\nresult_1comp = simulate(spec_1comp, grid, solver)\nresult_2comp = simulate(spec_2comp, grid, solver)\n\n# Two-comp has:\n# - Higher initial concentration\n# - Faster initial decline\n# - Same terminal AUC\n</code></pre>"},{"location":"julia/models/pk/twocomp-iv/#equations-summary","title":"Equations Summary","text":"Quantity Formula k10 \\(CL/V_1\\) k12 \\(Q/V_1\\) k21 \\(Q/V_2\\) \u03b1 \\(\\frac{1}{2}[(k_{10}+k_{12}+k_{21}) + \\sqrt{\\Delta}]\\) \u03b2 \\(\\frac{1}{2}[(k_{10}+k_{12}+k_{21}) - \\sqrt{\\Delta}]\\) C(t) \\(A \\cdot e^{-\\alpha t} + B \\cdot e^{-\\beta t}\\) Vss \\(V_1 + V_2\\) Terminal t\u00bd \\(0.693/\\beta\\)"},{"location":"julia/models/pk/twocomp-iv/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV Bolus - Simpler model</li> <li>Two-Compartment Oral - With absorption</li> <li>Three-Compartment IV - For deep tissue binding</li> <li>Population Modeling - Adding variability</li> </ul>"},{"location":"julia/models/pk/twocomp-oral/","title":"Two-Compartment Oral","text":"<p>Two-compartment model with first-order oral absorption, combining absorption kinetics with distribution between central and peripheral compartments.</p>"},{"location":"julia/models/pk/twocomp-oral/#model-overview","title":"Model Overview","text":"<pre><code>graph LR\n    D((Dose)) --&gt;|Oral| G[Gut&lt;br/&gt;Depot]\n    G --&gt;|Ka| C[Central&lt;br/&gt;V1]\n    C &lt;--&gt;|Q| P[Peripheral&lt;br/&gt;V2]\n    C --&gt;|CL| E((Elimination))\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#clinical-applications","title":"Clinical Applications","text":"<ul> <li>Oral drugs with tissue distribution</li> <li>Extended-release formulations</li> <li>Lipophilic oral compounds</li> <li>Drugs with enterohepatic recirculation (simplified)</li> <li>Biologics with oral absorption</li> </ul>"},{"location":"julia/models/pk/twocomp-oral/#when-to-use","title":"When to Use","text":"Use When Don't Use When Oral with bi-exponential decline Simple mono-exponential Distribution phase evident Rapid equilibration Complex tissue binding IV-only administration Multi-phase elimination Simple first-pass kinetics"},{"location":"julia/models/pk/twocomp-oral/#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"julia/models/pk/twocomp-oral/#parameters","title":"Parameters","text":"Parameter Symbol Units Description Constraints Absorption rate Ka 1/h First-order absorption Ka &gt; 0 Clearance CL L/h Apparent clearance (CL/F) CL &gt; 0 Central volume V1 L Central compartment (V1/F) V1 &gt; 0 Inter-compartmental clearance Q L/h Distribution clearance (Q/F) Q &gt; 0 Peripheral volume V2 L Peripheral compartment (V2/F) V2 &gt; 0"},{"location":"julia/models/pk/twocomp-oral/#state-variables","title":"State Variables","text":"State Symbol Units Description Gut amount A_gut mg Drug in absorption depot Central amount A1 mg Drug in central compartment Peripheral amount A2 mg Drug in peripheral compartment"},{"location":"julia/models/pk/twocomp-oral/#differential-equations","title":"Differential Equations","text":"\\[\\frac{dA_{gut}}{dt} = -K_a \\cdot A_{gut}\\] \\[\\frac{dA_1}{dt} = K_a \\cdot A_{gut} - \\frac{CL}{V_1} \\cdot A_1 - \\frac{Q}{V_1} \\cdot A_1 + \\frac{Q}{V_2} \\cdot A_2\\] \\[\\frac{dA_2}{dt} = \\frac{Q}{V_1} \\cdot A_1 - \\frac{Q}{V_2} \\cdot A_2\\]"},{"location":"julia/models/pk/twocomp-oral/#observation","title":"Observation","text":"\\[C = \\frac{A_1}{V_1}\\]"},{"location":"julia/models/pk/twocomp-oral/#derived-parameters","title":"Derived Parameters","text":""},{"location":"julia/models/pk/twocomp-oral/#micro-rate-constants","title":"Micro-Rate Constants","text":"\\[k_a = K_a\\] \\[k_{10} = \\frac{CL}{V_1}\\] \\[k_{12} = \\frac{Q}{V_1}\\] \\[k_{21} = \\frac{Q}{V_2}\\]"},{"location":"julia/models/pk/twocomp-oral/#hybrid-constants","title":"Hybrid Constants (\u03b1, \u03b2)","text":"<p>Same as two-compartment IV:</p> \\[\\alpha, \\beta = \\frac{1}{2}\\left[(k_{10} + k_{12} + k_{21}) \\pm \\sqrt{(k_{10} + k_{12} + k_{21})^2 - 4k_{10}k_{21}}\\right]\\]"},{"location":"julia/models/pk/twocomp-oral/#half-lives","title":"Half-Lives","text":"<ul> <li>Absorption: \\(t_{1/2,a} = 0.693/K_a\\)</li> <li>Distribution: \\(t_{1/2,\\alpha} = 0.693/\\alpha\\)</li> <li>Terminal: \\(t_{1/2,\\beta} = 0.693/\\beta\\)</li> </ul>"},{"location":"julia/models/pk/twocomp-oral/#tmax","title":"Tmax","text":"<p>No simple closed-form solution exists. Tmax is determined numerically when:</p> \\[\\frac{dC}{dt} = 0\\]"},{"location":"julia/models/pk/twocomp-oral/#julia-api","title":"Julia API","text":""},{"location":"julia/models/pk/twocomp-oral/#type-definitions","title":"Type Definitions","text":"<pre><code># Model kind\nstruct TwoCompOral &lt;: ModelKind end\n\n# Parameters\nstruct TwoCompOralParams &lt;: AbstractParams\n    Ka::Float64    # Absorption rate constant (1/h)\n    CL::Float64    # Clearance (L/h)\n    V1::Float64    # Central volume (L)\n    Q::Float64     # Inter-compartmental clearance (L/h)\n    V2::Float64    # Peripheral volume (L)\nend\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Define parameters\n# Ka = 1.2/h, CL = 8 L/h, V1 = 25 L, Q = 12 L/h, V2 = 60 L\nparams = TwoCompOralParams(1.2, 8.0, 25.0, 12.0, 60.0)\n\n# Single 400 mg oral dose\ndoses = [DoseEvent(0.0, 400.0)]\n\n# Create specification\nspec = ModelSpec(\n    TwoCompOral(),\n    \"twocomp_oral_example\",\n    params,\n    doses\n)\n\n# Time grid\ngrid = SimGrid(0.0, 72.0, collect(0.0:0.25:72.0))\n\n# Solver\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Run simulation\nresult = simulate(spec, grid, solver)\n\n# Find Cmax and Tmax\nconc = result.observations[:conc]\nt = result.t\ncmax, idx = findmax(conc)\ntmax = t[idx]\n\nprintln(\"Cmax: \", round(cmax, digits=2), \" mg/L\")\nprintln(\"Tmax: \", round(tmax, digits=2), \" h\")\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#multiple-dosing-to-steady-state","title":"Multiple Dosing to Steady State","text":"<pre><code># 400 mg every 12 hours\ndoses = DoseEvent[]\nfor i in 0:13  # 7 days\n    push!(doses, DoseEvent(i * 12.0, 400.0))\nend\n\nspec = ModelSpec(TwoCompOral(), \"bid_7days\", params, doses)\ngrid = SimGrid(0.0, 168.0, collect(0.0:0.5:168.0))\n\nresult = simulate(spec, grid, solver)\n\n# Steady-state metrics (last dosing interval)\nconc = result.observations[:conc]\nt = result.t\n\n# Find Cmax,ss and Cmin,ss in last interval (156-168 h)\nss_start = findfirst(x -&gt; x &gt;= 156.0, t)\nss_end = findfirst(x -&gt; x &gt;= 168.0, t)\n\ncmax_ss = maximum(conc[ss_start:ss_end])\ncmin_ss = minimum(conc[ss_start:ss_end])\n\nprintln(\"Steady-state Cmax: \", round(cmax_ss, digits=2), \" mg/L\")\nprintln(\"Steady-state Cmin: \", round(cmin_ss, digits=2), \" mg/L\")\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#absorption-rate-effects","title":"Absorption Rate Effects","text":"<pre><code># Compare different absorption rates\nka_values = [0.5, 1.0, 2.0, 4.0]\n\nfor ka in ka_values\n    params = TwoCompOralParams(ka, 8.0, 25.0, 12.0, 60.0)\n    doses = [DoseEvent(0.0, 400.0)]\n    spec = ModelSpec(TwoCompOral(), \"ka_$ka\", params, doses)\n    grid = SimGrid(0.0, 24.0, collect(0.0:0.1:24.0))\n\n    result = simulate(spec, grid, solver)\n    conc = result.observations[:conc]\n    cmax, idx = findmax(conc)\n    tmax = result.t[idx]\n\n    println(\"Ka = $ka: Cmax = $(round(cmax, digits=2)), Tmax = $(round(tmax, digits=2))\")\nend\n</code></pre> <p>Expected Results: - Higher Ka \u2192 Earlier Tmax, Higher Cmax - Lower Ka \u2192 Later Tmax, Lower Cmax - AUC remains constant (depends on CL, not Ka)</p>"},{"location":"julia/models/pk/twocomp-oral/#population-simulation","title":"Population Simulation","text":"<pre><code># Typical parameters\ntypical_params = TwoCompOralParams(1.2, 8.0, 25.0, 12.0, 60.0)\n\n# IIV: High variability on Ka (50% CV), moderate on others\nomega = OmegaMatrix([\n    0.25 0.0  0.0  0.0  0.0;   # \u03c9\u00b2_Ka (50% CV)\n    0.0  0.09 0.0  0.0  0.0;   # \u03c9\u00b2_CL (30% CV)\n    0.0  0.0  0.04 0.0  0.0;   # \u03c9\u00b2_V1 (20% CV)\n    0.0  0.0  0.0  0.09 0.0;   # \u03c9\u00b2_Q  (30% CV)\n    0.0  0.0  0.0  0.0  0.04   # \u03c9\u00b2_V2 (20% CV)\n])\n\ndoses = [DoseEvent(0.0, 400.0)]\nbase_spec = ModelSpec(TwoCompOral(), \"pop\", typical_params, doses)\n\npop_spec = PopulationSpec(base_spec, 100, omega, 12345)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.5:48.0))\nresult = simulate_population(pop_spec, grid, solver)\n\n# Summarize Cmax and Tmax variability\ncmax_values = Float64[]\ntmax_values = Float64[]\n\nfor ind in result.individuals\n    conc = ind.observations[:conc]\n    t = ind.t\n    cmax, idx = findmax(conc)\n    push!(cmax_values, cmax)\n    push!(tmax_values, t[idx])\nend\n\nusing Statistics\nprintln(\"Cmax: \", round(mean(cmax_values), digits=2),\n        \" (CV: \", round(100*std(cmax_values)/mean(cmax_values), digits=1), \"%)\")\nprintln(\"Tmax: \", round(median(tmax_values), digits=2),\n        \" h (range: \", round(minimum(tmax_values), digits=1), \"-\",\n        round(maximum(tmax_values), digits=1), \")\")\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#food-effect-study-design","title":"Food Effect Study Design","text":"<pre><code># Fasted state: Fast absorption\nparams_fasted = TwoCompOralParams(2.0, 8.0, 25.0, 12.0, 60.0)\n\n# Fed state: Slower absorption, possibly enhanced bioavailability\n# If F increases by 25%, apparent CL decreases\nparams_fed = TwoCompOralParams(0.8, 6.4, 25.0, 12.0, 60.0)\n\ndoses = [DoseEvent(0.0, 400.0)]\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.25:48.0))\n\nspec_fasted = ModelSpec(TwoCompOral(), \"fasted\", params_fasted, doses)\nspec_fed = ModelSpec(TwoCompOral(), \"fed\", params_fed, doses)\n\nresult_fasted = simulate(spec_fasted, grid, solver)\nresult_fed = simulate(spec_fed, grid, solver)\n\n# Compare exposure\nauc_fasted = sum(result_fasted.observations[:conc]) * 0.25  # Approximate AUC\nauc_fed = sum(result_fed.observations[:conc]) * 0.25\n\ncmax_fasted = maximum(result_fasted.observations[:conc])\ncmax_fed = maximum(result_fed.observations[:conc])\n\nprintln(\"Fed/Fasted AUC ratio: \", round(auc_fed/auc_fasted, digits=2))\nprintln(\"Fed/Fasted Cmax ratio: \", round(cmax_fed/cmax_fasted, digits=2))\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#comparison-with-one-compartment-oral","title":"Comparison with One-Compartment Oral","text":"<pre><code># Same total apparent volume and clearance\n# Two-comp oral\nparams_2comp = TwoCompOralParams(1.2, 8.0, 25.0, 12.0, 60.0)\n\n# One-comp oral (same AUC)\nparams_1comp = OneCompOralFirstOrderParams(1.2, 8.0, 85.0)  # V = V1 + V2\n\ndoses = [DoseEvent(0.0, 400.0)]\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.1:48.0))\n\nspec_2comp = ModelSpec(TwoCompOral(), \"2comp\", params_2comp, doses)\nspec_1comp = ModelSpec(OneCompOralFirstOrder(), \"1comp\", params_1comp, doses)\n\nresult_2comp = simulate(spec_2comp, grid, solver)\nresult_1comp = simulate(spec_1comp, grid, solver)\n\n# Key differences:\n# - 2-comp has higher initial peak (smaller V1)\n# - 2-comp has secondary distribution phase\n# - Both have same terminal AUC\n</code></pre>"},{"location":"julia/models/pk/twocomp-oral/#equations-summary","title":"Equations Summary","text":"Quantity Formula dA_gut/dt \\(-K_a \\cdot A_{gut}\\) dA1/dt \\(K_a A_{gut} - (k_{10} + k_{12})A_1 + k_{21}A_2\\) dA2/dt \\(k_{12}A_1 - k_{21}A_2\\) C(t) \\(A_1(t)/V_1\\) AUC \\(D/CL\\) Absorption t\u00bd \\(0.693/K_a\\) Terminal t\u00bd \\(0.693/\\beta\\)"},{"location":"julia/models/pk/twocomp-oral/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - Simpler model</li> <li>Two-Compartment IV - Without absorption</li> <li>Transit Absorption - Complex absorption</li> <li>NCA Reference - Exposure calculations</li> </ul>"},{"location":"julia/nca/","title":"Non-Compartmental Analysis (NCA)","text":"<p>Non-compartmental analysis provides model-independent exposure metrics following FDA and EMA guidelines.</p>"},{"location":"julia/nca/#overview","title":"Overview","text":"<p>NCA calculates pharmacokinetic parameters directly from concentration-time data without assuming a specific compartmental model.</p>"},{"location":"julia/nca/#key-metrics","title":"Key Metrics","text":"Metric Symbol Description Maximum Concentration Cmax Peak observed concentration Time to Maximum Tmax Time of Cmax AUC to Last AUC0-t Area under curve to last observation AUC to Infinity AUC0-\u221e Extrapolated total exposure Terminal Half-life t\u00bd ln(2)/\u03bbz Terminal Rate \u03bbz Slope of terminal phase Clearance CL/F Dose/AUC (apparent) Volume Vz/F CL/(F\u00b7\u03bbz) (apparent) Mean Residence Time MRT AUMC/AUC"},{"location":"julia/nca/#documentation","title":"Documentation","text":"<ul> <li> <p> Exposure Metrics</p> <p>Cmax, Tmax, AUC calculations</p> <p> Exposure Metrics</p> </li> <li> <p> Terminal Phase</p> <p>\u03bbz estimation and half-life</p> <p> Terminal Phase</p> </li> <li> <p> Bioequivalence</p> <p>90% CI and TOST analysis</p> <p> Bioequivalence</p> </li> <li> <p> Population NCA</p> <p>NCA for multiple subjects</p> <p> Population NCA</p> </li> <li> <p> Multiple Dose</p> <p>Steady-state metrics and accumulation</p> <p> Multiple Dose</p> </li> </ul>"},{"location":"julia/nca/#quick-start","title":"Quick Start","text":""},{"location":"julia/nca/#basic-nca","title":"Basic NCA","text":"<pre><code>using OpenPKPDCore\n\n# Concentration-time data\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nconc = [0.0, 1.8, 2.0, 1.5, 1.0, 0.5, 0.25, 0.06]\ndose = 100.0\n\n# Run NCA\nresult = run_nca(times, conc, dose)\n\n# Access results\nprintln(\"Cmax: \", result.cmax, \" mg/L\")\nprintln(\"Tmax: \", result.tmax, \" h\")\nprintln(\"AUC0-t: \", result.auc_0_t, \" mg\u00b7h/L\")\nprintln(\"AUC0-\u221e: \", result.auc_0_inf, \" mg\u00b7h/L\")\nprintln(\"t\u00bd: \", result.t_half, \" h\")\nprintln(\"CL/F: \", result.cl_f, \" L/h\")\n</code></pre>"},{"location":"julia/nca/#with-configuration","title":"With Configuration","text":"<pre><code>config = NCAConfig(\n    method = :log_linear,           # AUC calculation method\n    lambda_z_min_points = 3,        # Min points for \u03bbz\n    lambda_z_r2_threshold = 0.9,    # Quality threshold\n    extrapolation_max_pct = 20.0,   # Warning if &gt;20% extrapolated\n    blq_handling = :zero            # Handle BLQ as zero\n)\n\nresult = run_nca(times, conc, dose; config=config)\n\n# Check quality metrics\nprintln(\"\u03bbz R\u00b2: \", result.lambda_z_r_squared)\nprintln(\"AUC extrapolated: \", result.auc_extrapolated_pct, \"%\")\n</code></pre>"},{"location":"julia/nca/#auc-calculation-methods","title":"AUC Calculation Methods","text":""},{"location":"julia/nca/#linear-trapezoidal","title":"Linear Trapezoidal","text":"\\[AUC_{t_1 \\to t_2} = \\frac{(C_1 + C_2)}{2} \\cdot (t_2 - t_1)\\] <p>Best for: Ascending portions of the curve</p>"},{"location":"julia/nca/#log-linear-trapezoidal","title":"Log-Linear Trapezoidal","text":"\\[AUC_{t_1 \\to t_2} = \\frac{(C_1 - C_2)}{\\ln(C_1/C_2)} \\cdot (t_2 - t_1)\\] <p>Best for: Descending (elimination) portions</p>"},{"location":"julia/nca/#linear-log-mixed-recommended","title":"Linear-Log Mixed (Recommended)","text":"<ul> <li>Linear trapezoidal for ascending</li> <li>Log-linear for descending</li> </ul> <pre><code>config = NCAConfig(method = :lin_log_mixed)\n</code></pre>"},{"location":"julia/nca/#terminal-phase-analysis","title":"Terminal Phase Analysis","text":""},{"location":"julia/nca/#z-estimation","title":"\u03bbz Estimation","text":"<p>The terminal elimination rate constant is estimated by log-linear regression:</p> <pre><code># Manual lambda_z estimation\nlambda_z, r_squared, n_points = estimate_lambda_z(times, conc)\n\n# With custom parameters\nlambda_z, r_squared, n_points = estimate_lambda_z(\n    times, conc;\n    min_points = 3,\n    r2_threshold = 0.9\n)\n</code></pre>"},{"location":"julia/nca/#half-life","title":"Half-life","text":"\\[t_{1/2} = \\frac{\\ln(2)}{\\lambda_z}\\]"},{"location":"julia/nca/#nca-result-structure","title":"NCA Result Structure","text":"<pre><code>struct NCAResult\n    # Primary metrics\n    cmax::Float64\n    tmax::Float64\n    auc_0_t::Float64\n    auc_0_inf::Float64\n    t_half::Float64\n\n    # Terminal phase\n    lambda_z::Float64\n    lambda_z_r_squared::Float64\n    lambda_z_n_points::Int\n\n    # Clearance and volume\n    cl_f::Float64\n    vz_f::Float64\n\n    # Additional metrics\n    mrt::Float64                    # Mean residence time\n    auc_extrapolated_pct::Float64   # % AUC extrapolated\n\n    # Metadata\n    method::Symbol\n    dose::Float64\nend\n</code></pre>"},{"location":"julia/nca/#fdaema-compliance","title":"FDA/EMA Compliance","text":"<p>OpenPKPD NCA calculations follow regulatory guidance:</p> <ul> <li>FDA Guidance for Industry: Bioavailability and Bioequivalence Studies</li> <li>EMA Guideline on the Investigation of Bioequivalence</li> </ul>"},{"location":"julia/nca/#key-requirements","title":"Key Requirements","text":"Requirement OpenPKPD Implementation \u03bbz from \u22653 points Configurable minimum R\u00b2 &gt; 0.9 for \u03bbz Configurable threshold AUC extrapolation &lt;20% Warning flag Log-linear interpolation Supported method BLQ handling Multiple options"},{"location":"julia/nca/#next-steps","title":"Next Steps","text":"<ul> <li>Exposure Metrics - Detailed metric calculations</li> <li>Terminal Phase - Lambda_z and half-life calculation</li> <li>Bioequivalence - BE analysis methods</li> <li>Population NCA - Multi-subject analysis</li> <li>Multiple Dose - Steady-state analysis</li> </ul>"},{"location":"julia/nca/bioequivalence/","title":"Bioequivalence Analysis","text":"<p>Comprehensive documentation for bioequivalence (BE) assessment following FDA, EMA, and Health Canada guidance.</p>"},{"location":"julia/nca/bioequivalence/#overview","title":"Overview","text":"<p>Bioequivalence analysis determines whether two drug formulations have comparable rate and extent of absorption within predefined limits (typically 80-125%).</p>"},{"location":"julia/nca/bioequivalence/#quick-start","title":"Quick Start","text":"<pre><code>using OpenPKPDCore\n\n# Test vs Reference NCA results\ntest_auc = [45.2, 52.1, 38.7, 61.3, 49.8]\nref_auc = [48.1, 55.3, 41.2, 58.9, 52.4]\ntest_cmax = [8.5, 9.2, 7.1, 10.8, 8.9]\nref_cmax = [9.1, 9.8, 7.8, 10.2, 9.5]\n\n# Calculate 90% CI for AUC\nci_auc = bioequivalence_90ci(test_auc, ref_auc)\nprintln(\"AUC GMR: $(ci_auc.gmr)\")\nprintln(\"90% CI: [$(ci_auc.lower), $(ci_auc.upper)]\")\nprintln(\"BE met: $(ci_auc.be_met)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#study-designs","title":"Study Designs","text":""},{"location":"julia/nca/bioequivalence/#2x2-crossover-standard","title":"2x2 Crossover (Standard)","text":"<pre><code>design = Crossover2x2()\n\n# Periods: 1, 2\n# Sequences: TR, RT\n# Each subject receives both test and reference\n</code></pre>"},{"location":"julia/nca/bioequivalence/#2x4-replicate-crossover","title":"2x4 Replicate Crossover","text":"<pre><code>design = Crossover2x4()\n\n# Periods: 1, 2, 3, 4\n# Sequences: TRTR, RTRT\n# For highly variable drugs\n</code></pre>"},{"location":"julia/nca/bioequivalence/#3-way-crossover","title":"3-Way Crossover","text":"<pre><code>design = Crossover3Way()\n\n# For three treatments (e.g., test, reference, fasted reference)\n</code></pre>"},{"location":"julia/nca/bioequivalence/#parallel-group","title":"Parallel Group","text":"<pre><code>design = ParallelGroup()\n\n# Used when crossover not feasible (long half-life drugs)\n</code></pre>"},{"location":"julia/nca/bioequivalence/#90-confidence-intervals","title":"90% Confidence Intervals","text":""},{"location":"julia/nca/bioequivalence/#basic-90-ci-calculation","title":"Basic 90% CI Calculation","text":"<pre><code># Log-transformed data analysis\nci = bioequivalence_90ci(test_values, ref_values)\n\nprintln(\"Geometric Mean Ratio: $(round(ci.gmr * 100, digits=2))%\")\nprintln(\"90% CI: [$(round(ci.lower * 100, digits=2))%, $(round(ci.upper * 100, digits=2))%]\")\nprintln(\"BE criteria (80-125%): $(ci.be_met ? \"MET\" : \"NOT MET\")\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#ci-result-structure","title":"CI Result Structure","text":"<pre><code>struct BioequivalenceResult\n    gmr::Float64           # Geometric mean ratio (Test/Reference)\n    lower::Float64         # 90% CI lower bound\n    upper::Float64         # 90% CI upper bound\n    be_met::Bool           # Within 80-125%\n    cv_within::Float64     # Within-subject CV%\n    n_subjects::Int        # Number of subjects\n    power::Float64         # Statistical power achieved\nend\n</code></pre>"},{"location":"julia/nca/bioequivalence/#crossover-analysis-with-period-effects","title":"Crossover Analysis with Period Effects","text":"<pre><code># Full crossover analysis with period and sequence effects\nresult = analyze_crossover_be(\n    data,\n    treatment_col = :formulation,\n    subject_col = :subject_id,\n    period_col = :period,\n    sequence_col = :sequence,\n    response_col = :auc\n)\n\nprintln(\"Period effect p-value: $(result.period_pvalue)\")\nprintln(\"Sequence effect p-value: $(result.sequence_pvalue)\")\nprintln(\"Carryover effect p-value: $(result.carryover_pvalue)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#tost-analysis","title":"TOST Analysis","text":"<p>Two One-Sided Tests for equivalence:</p> <pre><code># TOST with custom bounds\ntost = tost_analysis(\n    test_values,\n    ref_values,\n    lower_bound = 0.80,\n    upper_bound = 1.25,\n    alpha = 0.05\n)\n\nprintln(\"TOST p-value (lower): $(tost.p_lower)\")\nprintln(\"TOST p-value (upper): $(tost.p_upper)\")\nprintln(\"Overall BE conclusion: $(tost.be_concluded)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#regulatory-acceptance-limits","title":"Regulatory Acceptance Limits","text":"Parameter FDA EMA Health Canada AUC 80-125% 80-125% 80-125% Cmax 80-125% 80-125% 80-125% AUC (HVD) 80-125% or scaled Widened 80-125% Cmax (HVD) 80-125% Widened 80-125%"},{"location":"julia/nca/bioequivalence/#geometric-mean-ratio","title":"Geometric Mean Ratio","text":"<pre><code># Calculate GMR\ngmr = geometric_mean_ratio(test_values, ref_values)\nprintln(\"GMR: $(round(gmr * 100, digits=2))%\")\n\n# Point estimate\npoint_estimate = exp(mean(log.(test_values)) - mean(log.(ref_values)))\n</code></pre>"},{"location":"julia/nca/bioequivalence/#within-subject-variability","title":"Within-Subject Variability","text":""},{"location":"julia/nca/bioequivalence/#cv-calculation","title":"CV% Calculation","text":"<pre><code># From crossover data\ncv_within = within_subject_cv(data, :auc, :subject_id)\nprintln(\"Within-subject CV: $(round(cv_within * 100, digits=1))%\")\n\n# Classification\nif cv_within &lt; 0.30\n    println(\"Standard variability drug\")\nelseif cv_within &lt; 0.40\n    println(\"Moderately variable drug\")\nelse\n    println(\"Highly variable drug (HVD)\")\nend\n</code></pre>"},{"location":"julia/nca/bioequivalence/#intra-subject-variability-from-replicate-design","title":"Intra-Subject Variability from Replicate Design","text":"<pre><code># From 2x4 replicate crossover\nresult = replicate_be_analysis(data, design=Crossover2x4())\n\nprintln(\"Reference CV: $(result.cv_reference)%\")\nprintln(\"Test CV: $(result.cv_test)%\")\nprintln(\"Subject-by-formulation interaction: $(result.sbf_interaction)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#reference-scaled-average-bioequivalence","title":"Reference-Scaled Average Bioequivalence","text":""},{"location":"julia/nca/bioequivalence/#rsabe-fda-approach","title":"RSABE (FDA Approach)","text":"<p>For highly variable drugs (CV &gt; 30%):</p> <pre><code># RSABE analysis\nrsabe = rsabe_analysis(\n    test_values,\n    ref_values,\n    design = FullReplicate2x4(),\n    regulatory = FDAGuidance()\n)\n\nprintln(\"Within-subject CV: $(rsabe.cv_within)%\")\nprintln(\"Scaling applied: $(rsabe.scaling_applied)\")\nprintln(\"Scaled criterion: $(rsabe.scaled_criterion)\")\nprintln(\"Upper bound: $(rsabe.upper_bound)\")\nprintln(\"RSABE conclusion: $(rsabe.be_met)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#fda-rsabe-criterion","title":"FDA RSABE Criterion","text":"<p>For CV &gt; 30%: - Scaled upper bound: \\(\\sqrt{(\\ln GMR)^2 + \\theta \\cdot s_{WR}^2} \\leq \\theta \\cdot \\sigma_{W0}\\) - Where \\(\\sigma_{W0} = 0.25\\) (regulatory constant) - \\(\\theta = (\\ln 1.25)^2 / \\sigma_{W0}^2\\)</p> <pre><code># FDA scaling parameters\nconst FDA_SIGMA_W0 = 0.25\nconst FDA_THETA = (log(1.25))^2 / FDA_SIGMA_W0^2\n</code></pre>"},{"location":"julia/nca/bioequivalence/#abel-ema-approach","title":"ABEL (EMA Approach)","text":"<p>Average Bioequivalence with Expanding Limits:</p> <pre><code># ABEL analysis\nabel = abel_analysis(\n    test_values,\n    ref_values,\n    design = FullReplicate2x4(),\n    regulatory = EMAGuidance()\n)\n\nprintln(\"Reference CV: $(abel.cv_reference)%\")\nprintln(\"Widened limits: [$(abel.lower_limit)%, $(abel.upper_limit)%]\")\nprintln(\"GMR constraint (80-125%): $(abel.gmr_constraint_met)\")\nprintln(\"ABEL conclusion: $(abel.be_met)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#ema-abel-widening","title":"EMA ABEL Widening","text":"<p>For CV &gt; 30%: - Lower limit: \\(\\exp(-k \\cdot s_{WR})\\) - Upper limit: \\(\\exp(k \\cdot s_{WR})\\) - Maximum widening: 69.84% - 143.19% - GMR must remain within 80-125%</p> <pre><code># EMA widening parameters\nconst EMA_K = log(1.25) / 0.25  # Regulatory constant\nconst EMA_MAX_LOWER = 0.6984    # Maximum widened lower\nconst EMA_MAX_UPPER = 1.4319    # Maximum widened upper\n</code></pre>"},{"location":"julia/nca/bioequivalence/#replicate-study-designs","title":"Replicate Study Designs","text":""},{"location":"julia/nca/bioequivalence/#partial-replicate-3x3","title":"Partial Replicate 3x3","text":"<pre><code>design = PartialReplicate3x3()\n\n# Sequences: TRR, RTR, RRT\n# Reference replicated, Test single\n# Used when Test formulation is limited\n\nresult = replicate_be_analysis(data, design=design)\n</code></pre>"},{"location":"julia/nca/bioequivalence/#full-replicate-2x4","title":"Full Replicate 2x4","text":"<pre><code>design = FullReplicate2x4()\n\n# Sequences: TRTR, RTRT\n# Both formulations replicated\n# Gold standard for HVD\n\nresult = replicate_be_analysis(data, design=design)\nprintln(\"Subject-by-formulation variance: $(result.var_sbf)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#full-replicate-2x3","title":"Full Replicate 2x3","text":"<pre><code>design = FullReplicate2x3()\n\n# Sequences: TRT, RTR\n# Shorter than 2x4 but still allows scaling\n</code></pre>"},{"location":"julia/nca/bioequivalence/#sample-size-calculation","title":"Sample Size Calculation","text":""},{"location":"julia/nca/bioequivalence/#standard-be-study","title":"Standard BE Study","text":"<pre><code># Calculate required sample size\nn = be_sample_size(\n    cv = 0.25,          # Expected CV (25%)\n    gmr = 0.95,         # Expected GMR\n    power = 0.80,       # Target power\n    alpha = 0.05,       # Significance level\n    design = Crossover2x2()\n)\n\nprintln(\"Required subjects: $n per sequence\")\nprintln(\"Total subjects: $(2 * n)\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#power-calculation","title":"Power Calculation","text":"<pre><code># Calculate power for given sample size\npower = be_power(\n    n = 24,\n    cv = 0.25,\n    gmr = 0.95,\n    design = Crossover2x2()\n)\n\nprintln(\"Expected power: $(round(power * 100, digits=1))%\")\n</code></pre>"},{"location":"julia/nca/bioequivalence/#sample-size-table","title":"Sample Size Table","text":"CV GMR=0.95 GMR=0.90 GMR=1.00 15% 10 14 8 20% 16 24 12 25% 24 36 18 30% 34 50 26 35% 46 68 36"},{"location":"julia/nca/bioequivalence/#regulatory-guidance","title":"Regulatory Guidance","text":""},{"location":"julia/nca/bioequivalence/#fda-guidance","title":"FDA Guidance","text":"<pre><code>config = BEConfig(\n    regulatory = FDAGuidance(),\n    acceptance_lower = 0.80,\n    acceptance_upper = 1.25,\n    alpha = 0.05\n)\n\n# FDA requires:\n# - Fasted and fed studies (where applicable)\n# - AUC0-t, AUC0-inf, Cmax\n# - Log transformation\n</code></pre>"},{"location":"julia/nca/bioequivalence/#ema-guidance","title":"EMA Guidance","text":"<pre><code>config = BEConfig(\n    regulatory = EMAGuidance(),\n    acceptance_lower = 0.80,\n    acceptance_upper = 1.25,\n    alpha = 0.05,\n    tmax_analysis = true  # EMA includes Tmax\n)\n\n# EMA requires:\n# - Usually fasted only\n# - AUC0-t, Cmax (and Tmax as supportive)\n# - Widened limits for HVD Cmax\n</code></pre>"},{"location":"julia/nca/bioequivalence/#health-canada","title":"Health Canada","text":"<pre><code>config = BEConfig(\n    regulatory = HealthCanadaGuidance(),\n    acceptance_lower = 0.80,\n    acceptance_upper = 1.25\n)\n</code></pre>"},{"location":"julia/nca/bioequivalence/#example-complete-be-analysis","title":"Example: Complete BE Analysis","text":"<pre><code>using OpenPKPDCore, DataFrames\n\n# Crossover study data\ndata = DataFrame(\n    subject = repeat(1:24, inner=2),\n    period = repeat([1, 2], 24),\n    sequence = repeat([\"TR\", \"RT\"], inner=24),\n    formulation = vcat(\n        repeat([\"T\", \"R\"], 12),  # TR sequence\n        repeat([\"R\", \"T\"], 12)   # RT sequence\n    ),\n    auc = [45.2, 48.1, 52.1, 55.3, ...],  # AUC values\n    cmax = [8.5, 9.1, 9.2, 9.8, ...]       # Cmax values\n)\n\n# Configure analysis\nconfig = BEConfig(\n    regulatory = FDAGuidance(),\n    design = Crossover2x2(),\n    alpha = 0.05\n)\n\n# Analyze AUC\nauc_result = analyze_be(data, :auc, config)\nprintln(\"=== AUC Bioequivalence ===\")\nprintln(\"GMR: $(round(auc_result.gmr * 100, digits=2))%\")\nprintln(\"90% CI: [$(round(auc_result.lower * 100, digits=2))%, $(round(auc_result.upper * 100, digits=2))%]\")\nprintln(\"Within-subject CV: $(round(auc_result.cv_within * 100, digits=1))%\")\nprintln(\"BE conclusion: $(auc_result.be_met ? \"PASS\" : \"FAIL\")\")\n\n# Analyze Cmax\ncmax_result = analyze_be(data, :cmax, config)\nprintln(\"\\n=== Cmax Bioequivalence ===\")\nprintln(\"GMR: $(round(cmax_result.gmr * 100, digits=2))%\")\nprintln(\"90% CI: [$(round(cmax_result.lower * 100, digits=2))%, $(round(cmax_result.upper * 100, digits=2))%]\")\nprintln(\"Within-subject CV: $(round(cmax_result.cv_within * 100, digits=1))%\")\nprintln(\"BE conclusion: $(cmax_result.be_met ? \"PASS\" : \"FAIL\")\")\n\n# Overall conclusion\noverall_be = auc_result.be_met &amp;&amp; cmax_result.be_met\nprintln(\"\\n=== Overall Conclusion ===\")\nprintln(\"Bioequivalence: $(overall_be ? \"ESTABLISHED\" : \"NOT ESTABLISHED\")\")\n\n# Generate regulatory report\nreport = be_regulatory_report(\n    auc_result,\n    cmax_result,\n    regulatory = FDAGuidance()\n)\nprintln(report)\n</code></pre>"},{"location":"julia/nca/bioequivalence/#highly-variable-drug-example","title":"Highly Variable Drug Example","text":"<pre><code># HVD with CV &gt; 30%\ndata_hvd = load_hvd_study_data()\n\n# Check variability\ncv = within_subject_cv(data_hvd, :auc, :subject_id)\nprintln(\"Within-subject CV: $(round(cv * 100, digits=1))%\")\n\nif cv &gt; 0.30\n    println(\"HVD criteria met - applying reference scaling\")\n\n    # Use replicate design analysis\n    result = rsabe_analysis(\n        data_hvd,\n        design = FullReplicate2x4(),\n        regulatory = FDAGuidance()\n    )\n\n    println(\"\\n=== RSABE Analysis ===\")\n    println(\"GMR: $(round(result.gmr * 100, digits=2))%\")\n    println(\"Reference CV: $(round(result.cv_reference * 100, digits=1))%\")\n    println(\"Scaling applied: $(result.scaling_applied)\")\n    println(\"Scaled criterion met: $(result.scaled_criterion_met)\")\n    println(\"Point estimate constraint: $(result.point_estimate_met)\")\n    println(\"RSABE conclusion: $(result.be_met ? \"PASS\" : \"FAIL\")\")\nelse\n    # Standard ABE\n    result = analyze_be(data_hvd, :auc, BEConfig())\nend\n</code></pre>"},{"location":"julia/nca/bioequivalence/#formulas-summary","title":"Formulas Summary","text":"Parameter Formula GMR \\(\\exp(\\bar{X}_T - \\bar{X}_R)\\) where X = ln(value) 90% CI \\(GMR \\cdot \\exp(\\pm t_{0.95,df} \\cdot SE)\\) Within-subject CV \\(\\sqrt{\\exp(MSE) - 1}\\) RSABE criterion \\(\\sqrt{(\\ln GMR)^2 + \\theta \\cdot s_{WR}^2}\\) ABEL limits \\(\\exp(\\pm k \\cdot s_{WR})\\)"},{"location":"julia/nca/bioequivalence/#see-also","title":"See Also","text":"<ul> <li>Exposure Metrics - AUC and Cmax calculation</li> <li>Population NCA - Multi-subject analysis</li> <li>Terminal Phase - Lambda_z and half-life</li> </ul>"},{"location":"julia/nca/exposure-metrics/","title":"Exposure Metrics","text":"<p>Complete documentation for primary and secondary exposure metrics in NCA following FDA/EMA guidance.</p>"},{"location":"julia/nca/exposure-metrics/#overview","title":"Overview","text":"<p>Exposure metrics characterize drug exposure from concentration-time profiles without assuming a specific model structure.</p>"},{"location":"julia/nca/exposure-metrics/#primary-exposure-metrics","title":"Primary Exposure Metrics","text":""},{"location":"julia/nca/exposure-metrics/#cmax-maximum-concentration","title":"Cmax - Maximum Concentration","text":"<p>The highest observed concentration:</p> <pre><code>using OpenPKPDCore\n\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nconc = [0.0, 1.8, 2.5, 2.0, 1.2, 0.6, 0.3, 0.075]\n\n# From NCA result\nresult = run_nca(times, conc, 100.0)\nprintln(\"Cmax: $(result.cmax)\")\n\n# Direct calculation\ncmax = nca_cmax(conc)\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#tmax-time-of-maximum-concentration","title":"Tmax - Time of Maximum Concentration","text":"<p>Time at which Cmax occurs:</p> <pre><code># From NCA result\nprintln(\"Tmax: $(result.tmax)\")\n\n# Direct calculation\ntmax = nca_tmax(times, conc)\n</code></pre> <p>When multiple points have the same maximum concentration, Tmax is the first occurrence.</p>"},{"location":"julia/nca/exposure-metrics/#cmin-minimum-concentration","title":"Cmin - Minimum Concentration","text":"<p>For multiple dose/steady-state analysis:</p> <pre><code># Multiple dose NCA\nresult = run_nca(times, conc, 100.0; dosing_type=:multiple, tau=24.0)\nprintln(\"Cmin: $(result.cmin)\")\n\n# Direct calculation\ncmin = nca_cmin(conc)\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#clast-and-tlast-last-measurable-concentration","title":"Clast and Tlast - Last Measurable Concentration","text":"<p>Last concentration above the LLOQ:</p> <pre><code># From NCA result\nprintln(\"Clast: $(result.clast)\")\nprintln(\"Tlast: $(result.tlast)\")\n\n# With LLOQ specification\nconfig = NCAConfig(lloq=0.05)\nresult = run_nca(times, conc, 100.0; config=config)\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#cavg-average-concentration","title":"Cavg - Average Concentration","text":"<p>Average concentration over a dosing interval (AUC0-tau/tau):</p> <pre><code>result = run_nca(times, conc, 100.0; dosing_type=:steady_state, tau=24.0)\nprintln(\"Cavg: $(result.cavg)\")\n\n# Direct calculation\ncavg = nca_cavg(times, conc, 24.0, NCAConfig())\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#auc-calculations","title":"AUC Calculations","text":""},{"location":"julia/nca/exposure-metrics/#auc-methods","title":"AUC Methods","text":"<p>OpenPKPD supports three AUC calculation methods:</p> Method Usage Formula <code>LinearMethod()</code> Ascending phases \\((C_1 + C_2) \\cdot \\Delta t / 2\\) <code>LogLinearMethod()</code> Descending phases \\((C_1 - C_2) / \\ln(C_1/C_2) \\cdot \\Delta t\\) <code>LinLogMixedMethod()</code> Recommended default Linear up, log-linear down <pre><code># Linear trapezoidal\nconfig_linear = NCAConfig(method=LinearMethod())\n\n# Log-linear trapezoidal\nconfig_log = NCAConfig(method=LogLinearMethod())\n\n# Lin-Log Mixed (FDA/EMA recommended)\nconfig_mixed = NCAConfig(method=LinLogMixedMethod())\n\nresult = run_nca(times, conc, 100.0; config=config_mixed)\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#auc0-t-auc-to-last","title":"AUC0-t (AUC to Last)","text":"<p>Area under the curve from time 0 to the last measurable concentration:</p> <pre><code>result = run_nca(times, conc, 100.0)\nprintln(\"AUC0-t: $(result.auc_0_t)\")\n\n# Direct calculation\nauc_0t = auc_0_t(times, conc, NCAConfig())\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#auc0-inf-auc-to-infinity","title":"AUC0-inf (AUC to Infinity)","text":"<p>AUC extrapolated to infinity using lambda_z:</p> \\[AUC_{0-\\infty} = AUC_{0-t} + \\frac{C_{last}}{\\lambda_z}\\] <pre><code>println(\"AUC0-inf: $(result.auc_0_inf)\")\nprintln(\"Extrapolation: $(result.auc_extra_pct)%\")\n\n# Direct calculation (requires lambda_z)\nlambda_z = result.lambda_z_result.lambda_z\nauc_inf, extra_pct = auc_0_inf(times, conc, lambda_z, result.clast, NCAConfig())\n</code></pre> <p>Quality Warning: If <code>auc_extra_pct &gt; 20%</code>, the AUC0-inf may be unreliable.</p>"},{"location":"julia/nca/exposure-metrics/#auc0-tau-auc-over-dosing-interval","title":"AUC0-tau (AUC over Dosing Interval)","text":"<p>For multiple dose or steady-state analysis:</p> <pre><code>result = run_nca(times, conc, 100.0; dosing_type=:multiple, tau=24.0)\nprintln(\"AUC0-tau: $(result.auc_0_tau)\")\n\n# Direct calculation\nauc_tau = auc_0_tau(times, conc, 24.0, NCAConfig())\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#partial-auc","title":"Partial AUC","text":"<p>AUC between any two time points:</p> <pre><code># AUC from t=0 to t=4\nauc_0_4 = auc_partial(times, conc, 0.0, 4.0, NCAConfig())\n\n# AUC from t=4 to t=12\nauc_4_12 = auc_partial(times, conc, 4.0, 12.0, NCAConfig())\n</code></pre> <p>Useful for assessing early exposure (e.g., AUC0-4h for rapid-acting drugs).</p>"},{"location":"julia/nca/exposure-metrics/#aumc-area-under-moment-curve","title":"AUMC (Area Under Moment Curve)","text":"<p>First moment curve for MRT calculation:</p> \\[AUMC = \\int_0^{t_{last}} t \\cdot C(t) \\, dt\\] <pre><code>println(\"AUMC0-t: $(result.aumc_0_t)\")\nprintln(\"AUMC0-inf: $(result.aumc_0_inf)\")\n\n# Direct calculation\naumc_0t = aumc_0_t(times, conc, NCAConfig())\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#dose-normalized-metrics","title":"Dose-Normalized Metrics","text":"<p>For dose proportionality assessment:</p> <pre><code># Dose-normalized Cmax\ncmax_dn = nca_dose_normalized_cmax(result.cmax, 100.0)\n\n# Dose-normalized AUC\nauc_dn = nca_dose_normalized_auc(result.auc_0_inf, 100.0)\n\n# From NCA result\nprintln(\"Cmax/D: $(result.cmax_dn)\")\nprintln(\"AUC/D: $(result.auc_dn)\")\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#time-above-concentration","title":"Time Above Concentration","text":"<p>Time above a specified concentration threshold:</p> <pre><code># Time above MIC of 1.0 mg/L\nt_above_mic = time_above_concentration(times, conc, 1.0)\nprintln(\"Time above MIC: $t_above_mic h\")\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#concentration-at-specific-time","title":"Concentration at Specific Time","text":"<p>Interpolated concentration at any time point:</p> <pre><code># Concentration at t=3h (interpolated)\nc_at_3h = nca_c_at_time(times, conc, 3.0)\n\n# Concentration at t=6h\nc_at_6h = nca_c_at_time(times, conc, 6.0)\n</code></pre> <p>Uses linear interpolation for ascending and log-linear for descending phases.</p>"},{"location":"julia/nca/exposure-metrics/#c0-initial-concentration-iv","title":"C0 - Initial Concentration (IV)","text":""},{"location":"julia/nca/exposure-metrics/#back-extrapolation","title":"Back-Extrapolation","text":"<p>For IV bolus, estimate C0 by back-extrapolation:</p> <pre><code># Back-extrapolation from first two points\nc0 = nca_c0_backextrap(times, conc)\n\n# From terminal phase regression\nc0_reg = nca_c0_from_regression(times, conc, lambda_z, intercept)\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#validation","title":"Validation","text":"<pre><code>validation = validate_c0_extrapolation(times, conc, c0)\nprintln(\"Extrapolation valid: $(validation.is_valid)\")\nprintln(\"Warnings: $(validation.warnings)\")\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#blq-handling","title":"BLQ Handling","text":"<p>Below Limit of Quantification handling:</p> <pre><code># Treat BLQ as zero\nconfig = NCAConfig(blq_handling=BLQZero(), lloq=0.05)\n\n# Treat BLQ as LLOQ/2\nconfig = NCAConfig(blq_handling=BLQLLOQHalf(), lloq=0.05)\n\n# Exclude BLQ from calculations\nconfig = NCAConfig(blq_handling=BLQMissing(), lloq=0.05)\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#example-complete-exposure-analysis","title":"Example: Complete Exposure Analysis","text":"<pre><code>using OpenPKPDCore\n\n# PK data\ntimes = [0.0, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 24.0]\nconc = [0.0, 2.5, 4.8, 5.2, 4.5, 3.8, 2.6, 1.9, 1.0, 0.55, 0.18, 0.02]\ndose = 500.0  # mg\n\n# Configure NCA\nconfig = NCAConfig(\n    method = LinLogMixedMethod(),\n    lambda_z_min_points = 3,\n    lambda_z_r2_threshold = 0.9,\n    extrapolation_max_pct = 20.0,\n    lloq = 0.01\n)\n\n# Run analysis\nresult = run_nca(times, conc, dose; config=config, route=:extravascular)\n\n# Report primary exposure\nprintln(\"=== Primary Exposure Metrics ===\")\nprintln(\"Cmax:     $(round(result.cmax, digits=2)) mg/L\")\nprintln(\"Tmax:     $(result.tmax) h\")\nprintln(\"AUC0-t:   $(round(result.auc_0_t, digits=2)) mg\u00b7h/L\")\nprintln(\"AUC0-inf: $(round(result.auc_0_inf, digits=2)) mg\u00b7h/L\")\nprintln(\"AUC extrapolated: $(round(result.auc_extra_pct, digits=1))%\")\n\n# Report PK parameters\nprintln(\"\\n=== PK Parameters ===\")\nprintln(\"t1/2:  $(round(result.t_half, digits=2)) h\")\nprintln(\"CL/F:  $(round(result.cl_f, digits=2)) L/h\")\nprintln(\"Vz/F:  $(round(result.vz_f, digits=1)) L\")\nprintln(\"MRT:   $(round(result.mrt, digits=2)) h\")\n\n# Quality check\nprintln(\"\\n=== Quality Assessment ===\")\nprintln(\"Lambda_z R\u00b2: $(round(result.lambda_z_result.r_squared, digits=4))\")\nprintln(\"Points used: $(result.lambda_z_result.n_points)\")\nprintln(\"Quality flags: $(result.quality_flags)\")\nif !isempty(result.warnings)\n    println(\"Warnings: $(result.warnings)\")\nend\n</code></pre>"},{"location":"julia/nca/exposure-metrics/#formulas-summary","title":"Formulas Summary","text":"Metric Formula Cmax \\(\\max(C)\\) AUC (linear) \\(\\sum \\frac{(C_i + C_{i+1})}{2} \\cdot (t_{i+1} - t_i)\\) AUC (log-linear) \\(\\sum \\frac{(C_i - C_{i+1})}{\\ln(C_i/C_{i+1})} \\cdot (t_{i+1} - t_i)\\) AUC0-inf \\(AUC_{0-t} + C_{last}/\\lambda_z\\) AUC%extrap \\(100 \\cdot (C_{last}/\\lambda_z) / AUC_{0-\\infty}\\) Cavg \\(AUC_{0-\\tau} / \\tau\\) Cmax/D \\(C_{max} / Dose\\) AUC/D \\(AUC / Dose\\)"},{"location":"julia/nca/exposure-metrics/#see-also","title":"See Also","text":"<ul> <li>Terminal Phase Analysis - Lambda_z estimation</li> <li>Bioequivalence - BE analysis</li> <li>Multiple Dose - Steady-state metrics</li> <li>Population NCA - Multi-subject analysis</li> </ul>"},{"location":"julia/nca/multiple-dose/","title":"Multiple Dose NCA","text":"<p>Comprehensive documentation for non-compartmental analysis of multiple dose and steady-state pharmacokinetic data.</p>"},{"location":"julia/nca/multiple-dose/#overview","title":"Overview","text":"<p>Multiple dose NCA extends single-dose analysis to repeated dosing scenarios, providing additional metrics relevant to chronic therapy and steady-state characterization.</p>"},{"location":"julia/nca/multiple-dose/#quick-start","title":"Quick Start","text":"<pre><code>using OpenPKPDCore\n\n# Steady-state data (after multiple doses)\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0]  # Within dosing interval\nconc = [2.1, 5.8, 5.2, 4.1, 2.8, 1.9, 1.3]    # Steady-state concentrations\ndose = 100.0\ntau = 12.0  # Dosing interval (hours)\n\n# Run steady-state NCA\nresult = run_nca(times, conc, dose; dosing_type=:steady_state, tau=tau)\n\nprintln(\"Cmax,ss: $(result.cmax)\")\nprintln(\"Cmin,ss: $(result.cmin)\")\nprintln(\"Cavg,ss: $(result.cavg)\")\nprintln(\"AUC0-tau: $(result.auc_0_tau)\")\nprintln(\"Fluctuation: $(result.fluctuation)%\")\n</code></pre>"},{"location":"julia/nca/multiple-dose/#dosing-types","title":"Dosing Types","text":""},{"location":"julia/nca/multiple-dose/#single-dose","title":"Single Dose","text":"<pre><code># First dose analysis (default)\nresult = run_nca(times, conc, dose; dosing_type=:single)\n</code></pre>"},{"location":"julia/nca/multiple-dose/#multiple-dose-non-steady-state","title":"Multiple Dose (Non-Steady-State)","text":"<pre><code># Analysis during accumulation phase\nresult = run_nca(times, conc, dose; dosing_type=:multiple, tau=12.0)\n</code></pre>"},{"location":"julia/nca/multiple-dose/#steady-state","title":"Steady State","text":"<pre><code># Analysis at steady state\nresult = run_nca(times, conc, dose; dosing_type=:steady_state, tau=12.0)\n</code></pre>"},{"location":"julia/nca/multiple-dose/#steady-state-metrics","title":"Steady-State Metrics","text":""},{"location":"julia/nca/multiple-dose/#cmaxss-and-cminss","title":"Cmax,ss and Cmin,ss","text":"<p>Peak and trough concentrations at steady state:</p> <pre><code>result = run_nca(times, conc, dose; dosing_type=:steady_state, tau=12.0)\n\n# Maximum concentration at steady state\nprintln(\"Cmax,ss: $(result.cmax)\")\n\n# Minimum concentration (trough) at steady state\nprintln(\"Cmin,ss: $(result.cmin)\")\nprintln(\"Cmin at time: $(result.tmin)\")\n</code></pre>"},{"location":"julia/nca/multiple-dose/#cavg-average-concentration","title":"Cavg (Average Concentration)","text":"\\[C_{avg} = \\frac{AUC_{0-\\tau}}{\\tau}\\] <pre><code># Average concentration over dosing interval\nprintln(\"Cavg: $(result.cavg)\")\n\n# Direct calculation\ncavg = result.auc_0_tau / tau\n</code></pre>"},{"location":"julia/nca/multiple-dose/#auc0-tau","title":"AUC0-tau","text":"<p>Area under the curve over one dosing interval:</p> <pre><code># AUC over dosing interval\nprintln(\"AUC0-tau: $(result.auc_0_tau)\")\n\n# Relates to total exposure per dose at steady state\n</code></pre>"},{"location":"julia/nca/multiple-dose/#fluctuation-metrics","title":"Fluctuation Metrics","text":""},{"location":"julia/nca/multiple-dose/#peak-trough-fluctuation-ptf","title":"Peak-Trough Fluctuation (PTF)","text":"\\[PTF = \\frac{C_{max} - C_{min}}{C_{avg}} \\times 100\\%\\] <pre><code>result = run_nca(times, conc, dose; dosing_type=:steady_state, tau=12.0)\n\nprintln(\"PTF: $(result.fluctuation)%\")\n\n# Manual calculation\nptf = (result.cmax - result.cmin) / result.cavg * 100\n</code></pre>"},{"location":"julia/nca/multiple-dose/#swing","title":"Swing","text":"\\[Swing = \\frac{C_{max} - C_{min}}{C_{min}} \\times 100\\%\\] <pre><code>println(\"Swing: $(result.swing)%\")\n\n# Manual calculation\nswing = (result.cmax - result.cmin) / result.cmin * 100\n</code></pre>"},{"location":"julia/nca/multiple-dose/#interpretation","title":"Interpretation","text":"PTF Interpretation &lt; 100% Low fluctuation (extended release) 100-200% Moderate fluctuation (typical IR) &gt; 200% High fluctuation (may need dosing adjustment)"},{"location":"julia/nca/multiple-dose/#accumulation-metrics","title":"Accumulation Metrics","text":""},{"location":"julia/nca/multiple-dose/#accumulation-index-racc","title":"Accumulation Index (Racc)","text":"<p>Ratio of steady-state to first-dose exposure:</p> \\[R_{acc} = \\frac{AUC_{0-\\tau,ss}}{AUC_{0-\\tau,sd}}\\] <pre><code># From steady-state result\nprintln(\"Accumulation Index: $(result.accumulation_index)\")\n\n# Theoretical accumulation (from t1/2)\ntheoretical_racc = 1 / (1 - exp(-log(2) * tau / result.t_half))\n</code></pre>"},{"location":"julia/nca/multiple-dose/#observed-vs-theoretical-accumulation","title":"Observed vs Theoretical Accumulation","text":"<pre><code># Compare observed accumulation to theoretical\nobserved_racc = result.accumulation_index\ntheoretical_racc = nca_theoretical_accumulation(result.t_half, tau)\n\nratio = observed_racc / theoretical_racc\nif abs(ratio - 1.0) &lt; 0.2\n    println(\"Accumulation consistent with linear kinetics\")\nelse\n    println(\"Possible time-dependent kinetics (ratio: $(ratio))\")\nend\n</code></pre>"},{"location":"julia/nca/multiple-dose/#time-to-steady-state","title":"Time to Steady State","text":"<p>Approximate time to reach steady state (~5 half-lives):</p> <pre><code>t_ss = 5 * result.t_half\nprintln(\"Time to steady state: ~$t_ss hours\")\n\n# More precise: time to 90% steady state\nt_90_ss = log(10) / log(2) * result.t_half  # ~3.3 \u00d7 t1/2\nprintln(\"Time to 90% SS: ~$t_90_ss hours\")\n</code></pre>"},{"location":"julia/nca/multiple-dose/#multiple-dose-analysis","title":"Multiple Dose Analysis","text":""},{"location":"julia/nca/multiple-dose/#non-steady-state-multiple-dose","title":"Non-Steady-State Multiple Dose","text":"<p>When steady state has not yet been achieved:</p> <pre><code># Day 3 data (before steady state)\ntimes_d3 = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0]\nconc_d3 = [1.5, 4.2, 4.0, 3.2, 2.1, 1.4, 0.9]\n\nresult = run_nca(\n    times_d3, conc_d3, dose;\n    dosing_type = :multiple,\n    tau = 12.0,\n    dose_number = 5  # 5th dose\n)\n\n# Compare to single dose\nsd_result = run_nca(times_sd, conc_sd, dose)\naccumulation_ratio = result.auc_0_tau / sd_result.auc_0_tau\nprintln(\"Accumulation after 5 doses: $(accumulation_ratio)\")\n</code></pre>"},{"location":"julia/nca/multiple-dose/#predicting-steady-state-from-single-dose","title":"Predicting Steady State from Single Dose","text":"<pre><code># Single dose analysis\nsd_result = run_nca(times, conc, dose)\n\n# Predict steady-state metrics\npredicted_ss = predict_steady_state(sd_result, tau=12.0)\n\nprintln(\"Predicted Cmax,ss: $(predicted_ss.cmax_ss)\")\nprintln(\"Predicted Cmin,ss: $(predicted_ss.cmin_ss)\")\nprintln(\"Predicted Cavg,ss: $(predicted_ss.cavg_ss)\")\nprintln(\"Predicted Racc: $(predicted_ss.accumulation_index)\")\n</code></pre>"},{"location":"julia/nca/multiple-dose/#superposition-principle","title":"Superposition Principle","text":"<p>For linear PK, predict multiple dose profiles from single dose:</p> <pre><code># Single dose data\nsd_times = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nsd_conc = [0.0, 2.1, 2.5, 2.0, 1.2, 0.5, 0.2, 0.02]\n\n# Predict steady-state profile using superposition\nss_times, ss_conc = superposition_predict(\n    sd_times, sd_conc;\n    tau = 12.0,\n    n_doses = 10  # Number of doses to reach SS\n)\n\n# Run NCA on predicted SS profile\nss_result = run_nca(ss_times, ss_conc, dose; dosing_type=:steady_state, tau=12.0)\n</code></pre>"},{"location":"julia/nca/multiple-dose/#trough-concentration-analysis","title":"Trough Concentration Analysis","text":""},{"location":"julia/nca/multiple-dose/#ctrough-timing","title":"Ctrough Timing","text":"<pre><code># Ensure trough is at end of interval\nresult = run_nca(times, conc, dose; dosing_type=:steady_state, tau=12.0)\n\n# Verify trough timing\nif result.tmin \u2248 tau\n    println(\"Trough at expected time (end of interval)\")\nelse\n    println(\"Trough at $(result.tmin)h, expected at $(tau)h\")\nend\n</code></pre>"},{"location":"julia/nca/multiple-dose/#ctrough-target","title":"Ctrough Target","text":"<p>For drugs with therapeutic targets:</p> <pre><code># Check if trough meets target\ntarget_ctrough = 1.0  # mg/L (e.g., MIC for antibiotics)\n\nif result.cmin &gt;= target_ctrough\n    println(\"Trough concentration meets target\")\nelse\n    # Calculate dose adjustment needed\n    dose_factor = target_ctrough / result.cmin\n    new_dose = dose * dose_factor\n    println(\"Consider dose increase to $(new_dose) mg\")\nend\n</code></pre>"},{"location":"julia/nca/multiple-dose/#time-above-threshold","title":"Time Above Threshold","text":""},{"location":"julia/nca/multiple-dose/#time-above-mic-antibiotics","title":"Time Above MIC (Antibiotics)","text":"<pre><code># Calculate %T&gt;MIC over dosing interval\nmic = 0.5  # mg/L\nt_above_mic = time_above_concentration(times, conc, mic)\npct_above_mic = t_above_mic / tau * 100\n\nprintln(\"Time above MIC: $t_above_mic h ($(pct_above_mic)% of interval)\")\n\n# Target interpretation (depends on antibiotic class)\n# Time-dependent: Need &gt;40-50% of interval\n# Concentration-dependent: Cmax/MIC &gt; 8-10\n</code></pre>"},{"location":"julia/nca/multiple-dose/#aucmic-ratio","title":"AUC/MIC Ratio","text":"<pre><code>auc_mic_ratio = result.auc_0_tau / mic\nprintln(\"AUC0-tau/MIC: $auc_mic_ratio\")\n\n# Target varies by drug class\n# Fluoroquinolones: typically &gt;100-125\n</code></pre>"},{"location":"julia/nca/multiple-dose/#effective-half-life","title":"Effective Half-Life","text":"<p>At steady state, the effective half-life describes drug elimination:</p> <pre><code># From accumulation index\nt_half_eff = nca_effective_half_life(result.accumulation_index, tau)\nprintln(\"Effective t1/2: $t_half_eff h\")\n\n# Compare to terminal half-life\nprintln(\"Terminal t1/2: $(result.t_half) h\")\n\n# Difference indicates multi-compartment kinetics\nif t_half_eff &lt; result.t_half * 0.8\n    println(\"Effective t1/2 shorter than terminal - multi-compartment behavior\")\nend\n</code></pre>"},{"location":"julia/nca/multiple-dose/#example-complete-multiple-dose-analysis","title":"Example: Complete Multiple Dose Analysis","text":"<pre><code>using OpenPKPDCore\n\n# Drug administered Q12H at steady state\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0]\nconc = [2.8, 8.5, 9.2, 7.5, 5.1, 3.8, 3.0, 2.5, 2.2]\ndose = 250.0  # mg\ntau = 12.0    # hours\n\n# Configure NCA\nconfig = NCAConfig(\n    method = LinLogMixedMethod(),\n    lambda_z_min_points = 3\n)\n\n# Run steady-state NCA\nresult = run_nca(\n    times, conc, dose;\n    config = config,\n    dosing_type = :steady_state,\n    tau = tau,\n    route = :extravascular\n)\n\n# Report steady-state metrics\nprintln(\"=== Steady-State PK Parameters ===\")\nprintln(\"Dose: $dose mg Q$(Int(tau))H\")\nprintln(\"\")\nprintln(\"Exposure Metrics:\")\nprintln(\"  Cmax,ss:    $(round(result.cmax, digits=2)) mg/L at $(result.tmax)h\")\nprintln(\"  Cmin,ss:    $(round(result.cmin, digits=2)) mg/L\")\nprintln(\"  Cavg,ss:    $(round(result.cavg, digits=2)) mg/L\")\nprintln(\"  AUC0-tau:   $(round(result.auc_0_tau, digits=2)) mg\u00b7h/L\")\nprintln(\"\")\nprintln(\"Variability Metrics:\")\nprintln(\"  PTF:        $(round(result.fluctuation, digits=1))%\")\nprintln(\"  Swing:      $(round(result.swing, digits=1))%\")\nprintln(\"\")\nprintln(\"Accumulation:\")\nprintln(\"  Racc:       $(round(result.accumulation_index, digits=2))\")\nprintln(\"  Effective t1/2: $(round(nca_effective_half_life(result.accumulation_index, tau), digits=2)) h\")\nprintln(\"  Terminal t1/2:  $(round(result.t_half, digits=2)) h\")\nprintln(\"\")\nprintln(\"Clearance:\")\nprintln(\"  CLss/F:     $(round(result.cl_f, digits=2)) L/h\")\n\n# Target assessment (e.g., for antibiotics)\nmic = 0.5  # mg/L\nprintln(\"\\n=== Target Assessment (MIC = $mic mg/L) ===\")\nprintln(\"  Cmax/MIC:   $(round(result.cmax / mic, digits=1))\")\nprintln(\"  Cmin/MIC:   $(round(result.cmin / mic, digits=1))\")\nprintln(\"  AUC/MIC:    $(round(result.auc_0_tau / mic, digits=1))\")\n\nt_above = time_above_concentration(times, conc, mic)\nprintln(\"  %T&gt;MIC:     $(round(t_above / tau * 100, digits=1))%\")\n\n# Dosing recommendation\nif result.cmin &lt; mic\n    println(\"\\n\u26a0 Trough below MIC - consider dose adjustment\")\n    suggested_dose = dose * (mic / result.cmin) * 1.1  # 10% margin\n    println(\"  Suggested dose: $(round(suggested_dose, digits=0)) mg Q$(Int(tau))H\")\nelse\n    println(\"\\n\u2713 Trough concentration adequate\")\nend\n</code></pre>"},{"location":"julia/nca/multiple-dose/#formulas-summary","title":"Formulas Summary","text":"Parameter Formula Cavg \\(AUC_{0-\\tau} / \\tau\\) PTF \\((C_{max} - C_{min}) / C_{avg} \\times 100\\%\\) Swing \\((C_{max} - C_{min}) / C_{min} \\times 100\\%\\) Racc \\(AUC_{0-\\tau,ss} / AUC_{0-\\tau,sd}\\) Racc (theoretical) \\(1 / (1 - e^{-\\lambda_z \\cdot \\tau})\\) t1/2,eff \\(\\ln(2) \\cdot \\tau / \\ln(R_{acc} / (R_{acc} - 1))\\)"},{"location":"julia/nca/multiple-dose/#see-also","title":"See Also","text":"<ul> <li>Exposure Metrics - Single dose metrics</li> <li>Terminal Phase - Lambda_z and t1/2</li> <li>Population NCA - Multi-subject analysis</li> <li>Bioequivalence - Steady-state BE studies</li> </ul>"},{"location":"julia/nca/population-nca/","title":"Population NCA","text":"<p>Comprehensive documentation for multi-subject non-compartmental analysis including summary statistics and stratification.</p>"},{"location":"julia/nca/population-nca/#overview","title":"Overview","text":"<p>Population NCA applies non-compartmental analysis to multiple subjects simultaneously, generating individual results and summary statistics across the population.</p>"},{"location":"julia/nca/population-nca/#quick-start","title":"Quick Start","text":"<pre><code>using OpenPKPDCore, DataFrames\n\n# Multi-subject PK data\ndata = DataFrame(\n    subject_id = repeat(1:12, inner=8),\n    time = repeat([0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0], 12),\n    conc = [...],  # Concentration values\n    dose = repeat([100.0], 96)\n)\n\n# Run population NCA\npop_result = run_population_nca(data; dose_col=:dose)\n\n# View summary\nsummary = summarize_population_nca(pop_result)\nprintln(summary)\n</code></pre>"},{"location":"julia/nca/population-nca/#data-format","title":"Data Format","text":""},{"location":"julia/nca/population-nca/#required-columns","title":"Required Columns","text":"<pre><code>data = DataFrame(\n    subject_id = [1, 1, 1, 2, 2, 2, ...],  # Subject identifier\n    time = [0.0, 1.0, 4.0, 0.0, 1.0, 4.0, ...],  # Time points\n    conc = [0.0, 5.2, 2.1, 0.0, 4.8, 1.9, ...],  # Concentrations\n    dose = [100.0, 100.0, 100.0, 150.0, ...]      # Dose per subject\n)\n</code></pre>"},{"location":"julia/nca/population-nca/#optional-columns","title":"Optional Columns","text":"<pre><code># With covariates and grouping\ndata = DataFrame(\n    subject_id = [...],\n    time = [...],\n    conc = [...],\n    dose = [...],\n    weight = [70.0, 85.0, ...],        # Body weight\n    sex = [\"M\", \"F\", ...],              # Sex\n    formulation = [\"Test\", \"Ref\", ...], # Treatment group\n    period = [1, 1, 2, 2, ...]          # Study period\n)\n</code></pre>"},{"location":"julia/nca/population-nca/#running-population-nca","title":"Running Population NCA","text":""},{"location":"julia/nca/population-nca/#basic-usage","title":"Basic Usage","text":"<pre><code>pop_result = run_population_nca(\n    data;\n    subject_col = :subject_id,\n    time_col = :time,\n    conc_col = :conc,\n    dose_col = :dose\n)\n\n# Access individual results\nfor (subj, result) in pop_result.individual_results\n    println(\"Subject $subj: AUC=$(result.auc_0_inf), Cmax=$(result.cmax)\")\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#with-configuration","title":"With Configuration","text":"<pre><code>config = NCAConfig(\n    method = LinLogMixedMethod(),\n    lambda_z_min_points = 3,\n    lambda_z_r2_threshold = 0.9,\n    lloq = 0.05,\n    blq_handling = BLQMissing()\n)\n\npop_result = run_population_nca(\n    data;\n    config = config,\n    route = :extravascular\n)\n</code></pre>"},{"location":"julia/nca/population-nca/#multiple-dose-analysis","title":"Multiple Dose Analysis","text":"<pre><code>pop_result = run_population_nca(\n    data;\n    dosing_type = :multiple,\n    tau = 24.0,  # Dosing interval\n    dose_col = :dose\n)\n</code></pre>"},{"location":"julia/nca/population-nca/#summary-statistics","title":"Summary Statistics","text":""},{"location":"julia/nca/population-nca/#generate-summary","title":"Generate Summary","text":"<pre><code>summary = summarize_population_nca(pop_result)\n\n# Access statistics\nprintln(\"=== AUC0-inf Summary ===\")\nprintln(\"N: $(summary.auc_0_inf.n)\")\nprintln(\"Mean: $(summary.auc_0_inf.mean)\")\nprintln(\"SD: $(summary.auc_0_inf.sd)\")\nprintln(\"CV%: $(summary.auc_0_inf.cv_pct)\")\nprintln(\"Median: $(summary.auc_0_inf.median)\")\nprintln(\"Min: $(summary.auc_0_inf.min)\")\nprintln(\"Max: $(summary.auc_0_inf.max)\")\nprintln(\"Geometric Mean: $(summary.auc_0_inf.geomean)\")\nprintln(\"Geometric CV%: $(summary.auc_0_inf.geocv_pct)\")\n</code></pre>"},{"location":"julia/nca/population-nca/#summary-table-format","title":"Summary Table Format","text":"<pre><code># Get formatted summary table\ntable = population_nca_summary_table(pop_result)\n\n# Output format:\n# Parameter     N    Mean    SD     CV%    Median   Min    Max    GeoMean  GeoCV%\n# ---------------------------------------------------------------------------\n# Cmax          12   5.23    1.12   21.4   5.15     3.42   7.81   5.12     22.1\n# Tmax          12   1.25    0.35   28.0   1.00     0.50   2.00   -        -\n# AUC0-t        12   45.2    8.7    19.3   44.1     31.2   62.5   44.5     19.8\n# AUC0-inf      12   48.1    9.2    19.1   47.2     33.5   68.2   47.4     19.5\n# t1/2          12   4.52    0.85   18.8   4.35     3.12   6.21   4.45     19.2\n# CL/F          12   2.12    0.42   19.8   2.08     1.47   3.01   2.08     20.1\n</code></pre>"},{"location":"julia/nca/population-nca/#custom-statistics","title":"Custom Statistics","text":"<pre><code># Select specific parameters\nsummary = summarize_population_nca(\n    pop_result;\n    parameters = [:cmax, :auc_0_inf, :t_half, :cl_f]\n)\n\n# Include percentiles\nsummary = summarize_population_nca(\n    pop_result;\n    percentiles = [5, 25, 50, 75, 95]\n)\n</code></pre>"},{"location":"julia/nca/population-nca/#stratified-analysis","title":"Stratified Analysis","text":""},{"location":"julia/nca/population-nca/#by-single-variable","title":"By Single Variable","text":"<pre><code># Stratify by formulation\nstratified = stratified_population_nca(\n    data,\n    strat_col = :formulation\n)\n\nfor (stratum, result) in stratified\n    println(\"=== $stratum ===\")\n    summary = summarize_population_nca(result)\n    println(\"AUC0-inf mean: $(summary.auc_0_inf.mean)\")\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#by-multiple-variables","title":"By Multiple Variables","text":"<pre><code># Stratify by formulation and fed/fasted\nstratified = stratified_population_nca(\n    data,\n    strat_cols = [:formulation, :fed_state]\n)\n\n# Results grouped by combination\n# e.g., (\"Test\", \"Fed\"), (\"Test\", \"Fasted\"), (\"Ref\", \"Fed\"), (\"Ref\", \"Fasted\")\n</code></pre>"},{"location":"julia/nca/population-nca/#comparison-between-strata","title":"Comparison Between Strata","text":"<pre><code># Compare Test vs Reference\ntest_summary = summarize_population_nca(stratified[\"Test\"])\nref_summary = summarize_population_nca(stratified[\"Ref\"])\n\n# Geometric mean ratio\ngmr_auc = test_summary.auc_0_inf.geomean / ref_summary.auc_0_inf.geomean\ngmr_cmax = test_summary.cmax.geomean / ref_summary.cmax.geomean\n\nprintln(\"AUC GMR: $(round(gmr_auc * 100, digits=2))%\")\nprintln(\"Cmax GMR: $(round(gmr_cmax * 100, digits=2))%\")\n</code></pre>"},{"location":"julia/nca/population-nca/#individual-results-access","title":"Individual Results Access","text":""},{"location":"julia/nca/population-nca/#accessing-all-results","title":"Accessing All Results","text":"<pre><code>pop_result = run_population_nca(data)\n\n# Iterate through individuals\nfor (subject_id, result) in pop_result.individual_results\n    println(\"Subject $subject_id:\")\n    println(\"  Cmax: $(result.cmax) at Tmax: $(result.tmax)\")\n    println(\"  AUC0-t: $(result.auc_0_t)\")\n    println(\"  AUC0-inf: $(result.auc_0_inf)\")\n    println(\"  t1/2: $(result.t_half)\")\n    println(\"  Lambda_z R\u00b2: $(result.lambda_z_result.r_squared)\")\n    println(\"\")\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#export-to-dataframe","title":"Export to DataFrame","text":"<pre><code># Convert results to DataFrame\nresults_df = population_nca_to_dataframe(pop_result)\n\n# Columns: subject_id, cmax, tmax, auc_0_t, auc_0_inf, t_half, cl_f, vz_f, ...\n</code></pre>"},{"location":"julia/nca/population-nca/#filter-by-quality","title":"Filter by Quality","text":"<pre><code># Only include subjects with good lambda_z fit\nquality_results = filter(pop_result.individual_results) do (_, result)\n    !isnothing(result.lambda_z_result) &amp;&amp;\n    result.lambda_z_result.r_squared &gt;= 0.9 &amp;&amp;\n    result.auc_extra_pct &lt;= 20.0\nend\n\nprintln(\"Subjects meeting quality criteria: $(length(quality_results))/$(length(pop_result.individual_results))\")\n</code></pre>"},{"location":"julia/nca/population-nca/#dose-normalization","title":"Dose Normalization","text":""},{"location":"julia/nca/population-nca/#normalize-by-dose","title":"Normalize by Dose","text":"<pre><code># Dose-normalized population NCA\npop_result = run_population_nca(\n    data;\n    dose_normalize = true,\n    dose_col = :dose\n)\n\n# Access normalized values\nfor (subj, result) in pop_result.individual_results\n    println(\"Subject $subj: AUC/D = $(result.auc_dn), Cmax/D = $(result.cmax_dn)\")\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#weight-normalized-dose","title":"Weight-Normalized Dose","text":"<pre><code># Dose per kg body weight\ndata.dose_per_kg = data.dose ./ data.weight\n\npop_result = run_population_nca(\n    data;\n    dose_col = :dose_per_kg,\n    dose_normalize = true\n)\n</code></pre>"},{"location":"julia/nca/population-nca/#handling-missing-data","title":"Handling Missing Data","text":""},{"location":"julia/nca/population-nca/#subjects-with-insufficient-data","title":"Subjects with Insufficient Data","text":"<pre><code>pop_result = run_population_nca(data; config=config)\n\n# Check for failed subjects\nif !isempty(pop_result.failed_subjects)\n    println(\"Subjects with NCA failures:\")\n    for (subj, reason) in pop_result.failed_subjects\n        println(\"  Subject $subj: $reason\")\n    end\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#partial-results","title":"Partial Results","text":"<pre><code># Some parameters may be missing for individual subjects\nfor (subj, result) in pop_result.individual_results\n    if isnan(result.auc_0_inf)\n        println(\"Subject $subj: AUC0-inf not calculable (lambda_z failed)\")\n    end\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#covariate-analysis","title":"Covariate Analysis","text":""},{"location":"julia/nca/population-nca/#summary-by-covariate","title":"Summary by Covariate","text":"<pre><code># Summarize by weight category\ndata.wt_cat = ifelse.(data.weight .&lt; 70, \"Low\", \"High\")\n\nstratified = stratified_population_nca(data, strat_col=:wt_cat)\n\nfor (cat, result) in stratified\n    summary = summarize_population_nca(result)\n    println(\"$cat weight: CL/F = $(summary.cl_f.mean) \u00b1 $(summary.cl_f.sd)\")\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#correlation-analysis","title":"Correlation Analysis","text":"<pre><code># Extract PK parameters and covariates\nresults_df = population_nca_to_dataframe(pop_result)\n\n# Merge with covariate data\nmerged = leftjoin(results_df, unique(data[:, [:subject_id, :weight, :age]]), on=:subject_id)\n\n# Calculate correlations\nusing Statistics\nr_cl_wt = cor(merged.cl_f, merged.weight)\nr_vz_wt = cor(merged.vz_f, merged.weight)\n\nprintln(\"CL/F vs Weight correlation: $(round(r_cl_wt, digits=3))\")\nprintln(\"Vz/F vs Weight correlation: $(round(r_vz_wt, digits=3))\")\n</code></pre>"},{"location":"julia/nca/population-nca/#example-complete-population-nca","title":"Example: Complete Population NCA","text":"<pre><code>using OpenPKPDCore, DataFrames\n\n# Load multi-subject PK data\ndata = DataFrame(\n    subject_id = repeat(1:24, inner=10),\n    time = repeat([0.0, 0.25, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 12.0, 24.0], 24),\n    conc = [...],  # 240 concentration values\n    dose = repeat([500.0], 240),\n    weight = repeat([65.0, 72.0, 80.0, ...], inner=10),  # 24 weights\n    formulation = repeat([\"Test\", \"Reference\"], inner=120)\n)\n\n# Configure NCA\nconfig = NCAConfig(\n    method = LinLogMixedMethod(),\n    lambda_z_min_points = 3,\n    lambda_z_r2_threshold = 0.9,\n    extrapolation_max_pct = 20.0,\n    lloq = 0.1\n)\n\n# Run population NCA\npop_result = run_population_nca(\n    data;\n    config = config,\n    route = :extravascular,\n    dose_col = :dose\n)\n\n# Overall summary\nprintln(\"=== Population NCA Summary ===\")\nprintln(\"Total subjects: $(length(pop_result.individual_results))\")\nprintln(\"Failed subjects: $(length(pop_result.failed_subjects))\")\n\nsummary = summarize_population_nca(pop_result)\nprintln(\"\\nParameter    N    Mean\u00b1SD         CV%    GeoMean  GeoCV%\")\nprintln(\"-\" ^ 60)\nfor param in [:cmax, :tmax, :auc_0_t, :auc_0_inf, :t_half, :cl_f, :vz_f]\n    s = getfield(summary, param)\n    if param == :tmax\n        @printf(\"%-10s  %d   %.2f\u00b1%.2f    %.1f%%   -        -\\n\",\n            string(param), s.n, s.mean, s.sd, s.cv_pct)\n    else\n        @printf(\"%-10s  %d   %.2f\u00b1%.2f    %.1f%%   %.2f     %.1f%%\\n\",\n            string(param), s.n, s.mean, s.sd, s.cv_pct, s.geomean, s.geocv_pct)\n    end\nend\n\n# Stratified by formulation\nprintln(\"\\n=== By Formulation ===\")\nstratified = stratified_population_nca(data, strat_col=:formulation)\n\nfor form in [\"Test\", \"Reference\"]\n    s = summarize_population_nca(stratified[form])\n    println(\"\\n$form:\")\n    println(\"  AUC0-inf: $(round(s.auc_0_inf.geomean, digits=2)) (GeoCV $(round(s.auc_0_inf.geocv_pct, digits=1))%)\")\n    println(\"  Cmax:     $(round(s.cmax.geomean, digits=2)) (GeoCV $(round(s.cmax.geocv_pct, digits=1))%)\")\nend\n\n# GMR calculation\ntest_s = summarize_population_nca(stratified[\"Test\"])\nref_s = summarize_population_nca(stratified[\"Reference\"])\ngmr_auc = test_s.auc_0_inf.geomean / ref_s.auc_0_inf.geomean\ngmr_cmax = test_s.cmax.geomean / ref_s.cmax.geomean\n\nprintln(\"\\n=== Geometric Mean Ratios (Test/Reference) ===\")\nprintln(\"AUC GMR: $(round(gmr_auc * 100, digits=2))%\")\nprintln(\"Cmax GMR: $(round(gmr_cmax * 100, digits=2))%\")\n\n# Quality assessment\nprintln(\"\\n=== Quality Assessment ===\")\nn_good_lz = count(r -&gt; r.lambda_z_result.r_squared &gt;= 0.9, values(pop_result.individual_results))\nn_low_extrap = count(r -&gt; r.auc_extra_pct &lt;= 20.0, values(pop_result.individual_results))\ntotal = length(pop_result.individual_results)\n\nprintln(\"Lambda_z R\u00b2 \u2265 0.9: $n_good_lz/$total ($(round(100*n_good_lz/total, digits=1))%)\")\nprintln(\"AUC extrap \u2264 20%: $n_low_extrap/$total ($(round(100*n_low_extrap/total, digits=1))%)\")\n\n# Export for further analysis\nresults_df = population_nca_to_dataframe(pop_result)\nprintln(\"\\nResults exported to DataFrame with $(nrow(results_df)) subjects\")\n</code></pre>"},{"location":"julia/nca/population-nca/#output-formats","title":"Output Formats","text":""},{"location":"julia/nca/population-nca/#summary-statistics-structure","title":"Summary Statistics Structure","text":"<pre><code>struct NCAParameterSummary\n    n::Int              # Number of subjects\n    mean::Float64       # Arithmetic mean\n    sd::Float64         # Standard deviation\n    cv_pct::Float64     # CV% (100 * SD/mean)\n    median::Float64     # Median\n    min::Float64        # Minimum\n    max::Float64        # Maximum\n    geomean::Float64    # Geometric mean\n    geocv_pct::Float64  # Geometric CV%\n    percentiles::Dict{Int,Float64}  # Requested percentiles\nend\n</code></pre>"},{"location":"julia/nca/population-nca/#export-formats","title":"Export Formats","text":"<pre><code># CSV export\npopulation_nca_to_csv(pop_result, \"nca_results.csv\")\n\n# JSON export\npopulation_nca_to_json(pop_result, \"nca_results.json\")\n\n# DataFrame (in-memory)\ndf = population_nca_to_dataframe(pop_result)\n</code></pre>"},{"location":"julia/nca/population-nca/#see-also","title":"See Also","text":"<ul> <li>Exposure Metrics - Individual NCA metrics</li> <li>Terminal Phase - Lambda_z estimation</li> <li>Bioequivalence - BE analysis from population NCA</li> <li>Multiple Dose - Steady-state population analysis</li> </ul>"},{"location":"julia/nca/terminal-phase/","title":"Terminal Phase Analysis","text":"<p>Comprehensive documentation for terminal elimination phase characterization including lambda_z estimation and half-life calculation.</p>"},{"location":"julia/nca/terminal-phase/#overview","title":"Overview","text":"<p>Terminal phase analysis estimates the elimination rate constant (lambda_z) from the terminal portion of the concentration-time profile, enabling calculation of half-life and extrapolation of AUC to infinity.</p>"},{"location":"julia/nca/terminal-phase/#lambda_z-estimation","title":"Lambda_z Estimation","text":""},{"location":"julia/nca/terminal-phase/#basic-usage","title":"Basic Usage","text":"<pre><code>using OpenPKPDCore\n\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nconc = [0.0, 1.8, 2.5, 2.0, 1.2, 0.6, 0.3, 0.075]\n\n# From NCA result\nresult = run_nca(times, conc, 100.0)\nprintln(\"Lambda_z: $(result.lambda_z_result.lambda_z)\")\nprintln(\"t1/2: $(result.t_half)\")\n\n# Direct estimation\nlambda_z_result = estimate_lambda_z(times, conc, NCAConfig())\n</code></pre>"},{"location":"julia/nca/terminal-phase/#lambda_z-result-structure","title":"Lambda_z Result Structure","text":"<pre><code>struct LambdaZResult\n    lambda_z::Float64           # Elimination rate constant (1/h)\n    intercept::Float64          # Y-intercept of log-linear regression\n    r_squared::Float64          # Coefficient of determination\n    adjusted_r_squared::Float64 # Adjusted R\u00b2\n    n_points::Int               # Number of points used\n    start_idx::Int              # Index of first point used\n    end_idx::Int                # Index of last point used\n    times_used::Vector{Float64} # Time points included\n    conc_used::Vector{Float64}  # Concentrations included\nend\n</code></pre>"},{"location":"julia/nca/terminal-phase/#point-selection-methods","title":"Point Selection Methods","text":""},{"location":"julia/nca/terminal-phase/#minpointsfirst-fdaema-default","title":"MinPointsFirst (FDA/EMA Default)","text":"<p>Uses minimum required points starting from the latest time points:</p> <pre><code>config = NCAConfig(\n    lambda_z_selection = MinPointsFirst(),\n    lambda_z_min_points = 3,\n    lambda_z_r2_threshold = 0.9\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n</code></pre> <p>This method: 1. Starts with the last 3 points (minimum) 2. Calculates R\u00b2 for log-linear regression 3. Adds earlier points if R\u00b2 improves 4. Stops when R\u00b2 drops below threshold</p>"},{"location":"julia/nca/terminal-phase/#maxadjr2","title":"MaxAdjR2","text":"<p>Selects points that maximize adjusted R\u00b2:</p> <pre><code>config = NCAConfig(\n    lambda_z_selection = MaxAdjR2(),\n    lambda_z_min_points = 3,\n    lambda_z_max_points = 10\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n</code></pre> <p>This method: 1. Tests all valid combinations of terminal points 2. Selects combination with highest adjusted R\u00b2 3. Ensures minimum number of points is met</p>"},{"location":"julia/nca/terminal-phase/#manual-point-selection","title":"Manual Point Selection","text":"<p>Specify exact points to use:</p> <pre><code># Use points from index 5 to 8\nconfig = NCAConfig(\n    lambda_z_start_idx = 5,\n    lambda_z_end_idx = 8\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n</code></pre>"},{"location":"julia/nca/terminal-phase/#quality-criteria","title":"Quality Criteria","text":""},{"location":"julia/nca/terminal-phase/#r2-threshold","title":"R\u00b2 Threshold","text":"<pre><code># Require R\u00b2 \u2265 0.95 for lambda_z estimation\nconfig = NCAConfig(\n    lambda_z_r2_threshold = 0.95\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n\n# Check if threshold was met\nif result.lambda_z_result.r_squared &gt;= 0.95\n    println(\"Lambda_z estimation meets quality criteria\")\nelse\n    println(\"WARNING: R\u00b2 below threshold\")\nend\n</code></pre>"},{"location":"julia/nca/terminal-phase/#minimum-points","title":"Minimum Points","text":"<pre><code># Require at least 4 points for lambda_z\nconfig = NCAConfig(\n    lambda_z_min_points = 4\n)\n</code></pre>"},{"location":"julia/nca/terminal-phase/#extrapolation-warning","title":"Extrapolation Warning","text":"<pre><code># Warn if AUC extrapolation exceeds 20%\nconfig = NCAConfig(\n    extrapolation_max_pct = 20.0\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n\nif result.auc_extra_pct &gt; 20.0\n    println(\"WARNING: $(result.auc_extra_pct)% extrapolation exceeds threshold\")\nend\n</code></pre>"},{"location":"julia/nca/terminal-phase/#half-life-calculation","title":"Half-Life Calculation","text":""},{"location":"julia/nca/terminal-phase/#terminal-half-life","title":"Terminal Half-Life","text":"\\[t_{1/2} = \\frac{\\ln(2)}{\\lambda_z} = \\frac{0.693}{\\lambda_z}\\] <pre><code>result = run_nca(times, conc, 100.0)\nprintln(\"t1/2: $(result.t_half) hours\")\n\n# Direct calculation\nt_half = log(2) / result.lambda_z_result.lambda_z\n</code></pre>"},{"location":"julia/nca/terminal-phase/#effective-half-life-multiple-dose","title":"Effective Half-Life (Multiple Dose)","text":"<p>For multiple dose analysis:</p> <pre><code>result = run_nca(times, conc, 100.0; dosing_type=:multiple, tau=24.0)\n\n# Effective half-life from accumulation\nt_half_eff = nca_effective_half_life(result.accumulation_index, result.tau)\n</code></pre>"},{"location":"julia/nca/terminal-phase/#mean-residence-time-mrt","title":"Mean Residence Time (MRT)","text":""},{"location":"julia/nca/terminal-phase/#mrt-for-extravascular-administration","title":"MRT for Extravascular Administration","text":"\\[MRT = \\frac{AUMC_{0-\\infty}}{AUC_{0-\\infty}}\\] <pre><code>result = run_nca(times, conc, 100.0; route=:extravascular)\nprintln(\"MRT: $(result.mrt) hours\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#mrt-for-iv-bolus","title":"MRT for IV Bolus","text":"\\[MRT = \\frac{AUMC_{0-\\infty}}{AUC_{0-\\infty}} - \\frac{T_{inf}}{2}\\] <p>For IV bolus (instantaneous), no infusion time correction:</p> <pre><code>result = run_nca(times, conc, 100.0; route=:iv_bolus)\nprintln(\"MRT (IV): $(result.mrt) hours\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#mrt-for-iv-infusion","title":"MRT for IV Infusion","text":"<pre><code># 1-hour infusion\nresult = run_nca(times, conc, 100.0; route=:iv_infusion, infusion_time=1.0)\nprintln(\"MRT (corrected): $(result.mrt) hours\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#pk-parameters-from-terminal-phase","title":"PK Parameters from Terminal Phase","text":""},{"location":"julia/nca/terminal-phase/#clearance-clf","title":"Clearance (CL/F)","text":"\\[CL/F = \\frac{Dose}{AUC_{0-\\infty}}\\] <pre><code>result = run_nca(times, conc, 100.0)\nprintln(\"CL/F: $(result.cl_f) L/h\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#volume-of-distribution-at-terminal-phase-vzf","title":"Volume of Distribution at Terminal Phase (Vz/F)","text":"\\[V_z/F = \\frac{CL/F}{\\lambda_z} = \\frac{Dose}{AUC_{0-\\infty} \\cdot \\lambda_z}\\] <pre><code>println(\"Vz/F: $(result.vz_f) L\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#volume-of-distribution-at-steady-state-vssf","title":"Volume of Distribution at Steady State (Vss/F)","text":"\\[V_{ss}/F = MRT \\cdot CL/F\\] <pre><code>println(\"Vss/F: $(result.vss_f) L\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#terminal-phase-regression-diagnostics","title":"Terminal Phase Regression Diagnostics","text":""},{"location":"julia/nca/terminal-phase/#visualizing-the-fit","title":"Visualizing the Fit","text":"<pre><code># Get regression data\nlz = result.lambda_z_result\ntimes_used = lz.times_used\nconc_used = lz.conc_used\n\n# Log-linear regression\nlog_conc = log.(conc_used)\npredicted = lz.intercept .- lz.lambda_z .* times_used\n\nprintln(\"Points used: $(lz.n_points)\")\nprintln(\"R\u00b2: $(round(lz.r_squared, digits=4))\")\nprintln(\"Adjusted R\u00b2: $(round(lz.adjusted_r_squared, digits=4))\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#residual-analysis","title":"Residual Analysis","text":"<pre><code># Calculate residuals\nlog_conc_obs = log.(lz.conc_used)\nlog_conc_pred = lz.intercept .- lz.lambda_z .* lz.times_used\nresiduals = log_conc_obs .- log_conc_pred\n\n# Summary statistics\nprintln(\"Mean residual: $(mean(residuals))\")\nprintln(\"SD residual: $(std(residuals))\")\n</code></pre>"},{"location":"julia/nca/terminal-phase/#handling-special-cases","title":"Handling Special Cases","text":""},{"location":"julia/nca/terminal-phase/#insufficient-terminal-points","title":"Insufficient Terminal Points","text":"<pre><code># Short profile with few points\nshort_times = [0.0, 1.0, 2.0]\nshort_conc = [0.0, 2.5, 1.5]\n\nconfig = NCAConfig(lambda_z_min_points = 3)\nresult = run_nca(short_times, short_conc, 100.0; config=config)\n\nif isnothing(result.lambda_z_result) || isnan(result.lambda_z_result.lambda_z)\n    println(\"WARNING: Insufficient data for lambda_z estimation\")\n    println(\"AUC0-inf cannot be calculated\")\nend\n</code></pre>"},{"location":"julia/nca/terminal-phase/#multi-phasic-elimination","title":"Multi-Phasic Elimination","text":"<p>For drugs with multiple elimination phases:</p> <pre><code># Focus on terminal phase only\n# Exclude distribution phase points\nconfig = NCAConfig(\n    lambda_z_start_time = 4.0,  # Start after distribution\n    lambda_z_min_points = 3\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n</code></pre>"},{"location":"julia/nca/terminal-phase/#concentration-below-lloq","title":"Concentration Below LLOQ","text":"<pre><code># Handle BLQ in terminal phase\nconfig = NCAConfig(\n    lloq = 0.05,\n    blq_handling = BLQMissing()  # Exclude BLQ from lambda_z\n)\n\nresult = run_nca(times, conc, 100.0; config=config)\n</code></pre>"},{"location":"julia/nca/terminal-phase/#example-complete-terminal-phase-analysis","title":"Example: Complete Terminal Phase Analysis","text":"<pre><code>using OpenPKPDCore\n\n# PK data (oral administration)\ntimes = [0.0, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 24.0]\nconc = [0.0, 2.1, 4.5, 5.8, 5.2, 4.5, 3.2, 2.4, 1.3, 0.72, 0.24, 0.02]\ndose = 500.0  # mg\n\n# Configure terminal phase analysis\nconfig = NCAConfig(\n    method = LinLogMixedMethod(),\n    lambda_z_selection = MinPointsFirst(),\n    lambda_z_min_points = 3,\n    lambda_z_r2_threshold = 0.9,\n    extrapolation_max_pct = 20.0,\n    lloq = 0.01\n)\n\n# Run NCA\nresult = run_nca(times, conc, dose; config=config, route=:extravascular)\n\n# Terminal phase results\nlz = result.lambda_z_result\n\nprintln(\"=== Terminal Phase Analysis ===\")\nprintln(\"Lambda_z: $(round(lz.lambda_z, digits=4)) 1/h\")\nprintln(\"t1/2: $(round(result.t_half, digits=2)) h\")\nprintln(\"MRT: $(round(result.mrt, digits=2)) h\")\nprintln(\"\")\nprintln(\"=== Regression Quality ===\")\nprintln(\"R\u00b2: $(round(lz.r_squared, digits=4))\")\nprintln(\"Adjusted R\u00b2: $(round(lz.adjusted_r_squared, digits=4))\")\nprintln(\"Points used: $(lz.n_points) (indices $(lz.start_idx) to $(lz.end_idx))\")\nprintln(\"Times used: $(lz.times_used)\")\nprintln(\"\")\nprintln(\"=== PK Parameters ===\")\nprintln(\"CL/F: $(round(result.cl_f, digits=2)) L/h\")\nprintln(\"Vz/F: $(round(result.vz_f, digits=1)) L\")\nprintln(\"Vss/F: $(round(result.vss_f, digits=1)) L\")\nprintln(\"\")\nprintln(\"=== AUC Extrapolation ===\")\nprintln(\"AUC0-t: $(round(result.auc_0_t, digits=2)) mg\u00b7h/L\")\nprintln(\"AUC0-inf: $(round(result.auc_0_inf, digits=2)) mg\u00b7h/L\")\nprintln(\"Extrapolation: $(round(result.auc_extra_pct, digits=1))%\")\n\n# Quality assessment\nprintln(\"\\n=== Quality Assessment ===\")\nif lz.r_squared &gt;= 0.9\n    println(\"\u2713 R\u00b2 meets threshold (\u22650.9)\")\nelse\n    println(\"\u26a0 R\u00b2 below threshold\")\nend\n\nif result.auc_extra_pct &lt;= 20.0\n    println(\"\u2713 AUC extrapolation acceptable (\u226420%)\")\nelse\n    println(\"\u26a0 High AUC extrapolation\")\nend\n\nif lz.n_points &gt;= 3\n    println(\"\u2713 Sufficient terminal points\")\nelse\n    println(\"\u26a0 Insufficient terminal points\")\nend\n</code></pre>"},{"location":"julia/nca/terminal-phase/#formulas-summary","title":"Formulas Summary","text":"Parameter Formula Lambda_z Slope of ln(C) vs time regression t1/2 \\(\\ln(2) / \\lambda_z\\) MRT (extravascular) \\(AUMC_{0-\\infty} / AUC_{0-\\infty}\\) MRT (IV infusion) \\(AUMC_{0-\\infty} / AUC_{0-\\infty} - T_{inf}/2\\) CL/F \\(Dose / AUC_{0-\\infty}\\) Vz/F \\(Dose / (AUC_{0-\\infty} \\cdot \\lambda_z)\\) Vss/F \\(MRT \\cdot CL/F\\)"},{"location":"julia/nca/terminal-phase/#see-also","title":"See Also","text":"<ul> <li>Exposure Metrics - AUC calculations</li> <li>Multiple Dose - Steady-state analysis</li> <li>Population NCA - Multi-subject analysis</li> <li>Bioequivalence - BE studies</li> </ul>"},{"location":"julia/population/","title":"Population Modeling","text":"<p>Population pharmacokinetic/pharmacodynamic (PopPK/PD) modeling accounts for variability between and within individuals, enabling more accurate predictions and personalized dosing.</p>"},{"location":"julia/population/#overview","title":"Overview","text":"<p>OpenPKPD supports comprehensive population modeling including:</p> <ul> <li>Inter-Individual Variability (IIV) - Parameter differences between subjects</li> <li>Inter-Occasion Variability (IOV) - Parameter changes within a subject over time</li> <li>Covariate Effects - Patient characteristics affecting parameters</li> <li>Residual Error Models - Unexplained variability in observations</li> </ul> <pre><code>graph LR\n    A[Typical Parameters] --&gt; B[IIV]\n    B --&gt; C[Individual Parameters]\n    D[Covariates] --&gt; C\n    E[IOV] --&gt; C\n    C --&gt; F[Simulation]\n    F --&gt; G[Predictions]\n    H[Residual Error] --&gt; G\n</code></pre>"},{"location":"julia/population/#documentation","title":"Documentation","text":"<ul> <li> <p> Inter-Individual Variability</p> <p>Log-normal distribution of parameters across subjects</p> <p> IIV Reference</p> </li> <li> <p> Inter-Occasion Variability</p> <p>Parameter variation between dosing occasions</p> <p> IOV Reference</p> </li> <li> <p> Covariate Models</p> <p>Weight, age, renal function effects</p> <p> Covariates</p> </li> <li> <p> Residual Error</p> <p>Additive, proportional, combined error models</p> <p> Residual Error</p> </li> </ul>"},{"location":"julia/population/#quick-start","title":"Quick Start","text":""},{"location":"julia/population/#basic-population-simulation","title":"Basic Population Simulation","text":"<pre><code>using OpenPKPDCore\n\n# Typical parameters\ntypical_params = OneCompIVBolusParams(5.0, 50.0)  # CL=5, V=50\n\n# Omega matrix (variance of random effects)\n# Diagonal: 30% CV on CL, 20% CV on V\nomega = OmegaMatrix([\n    0.09 0.0;   # \u03c9\u00b2_CL\n    0.0  0.04   # \u03c9\u00b2_V\n])\n\n# Base specification\ndoses = [DoseEvent(0.0, 100.0)]\nbase_spec = ModelSpec(OneCompIVBolus(), \"pop_sim\", typical_params, doses)\n\n# Population specification\npop_spec = PopulationSpec(\n    base_spec,\n    n = 100,           # Number of subjects\n    omega = omega,\n    seed = 12345       # For reproducibility\n)\n\n# Simulate\ngrid = SimGrid(0.0, 24.0, collect(0.0:1.0:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nresult = simulate_population(pop_spec, grid, solver)\n\n# Access results\nprintln(\"Number of individuals: \", length(result.individuals))\nprintln(\"Median Cmax: \", maximum(result.summaries[:conc].median))\n</code></pre>"},{"location":"julia/population/#adding-covariates","title":"Adding Covariates","text":"<pre><code># Weight-based allometric scaling\ncovariate_model = CovariateModel([\n    CovariateEffect(:CL, :WT, 70.0, :power, 0.75),  # CL ~ WT^0.75\n    CovariateEffect(:V, :WT, 70.0, :power, 1.0)     # V ~ WT^1.0\n])\n\n# Generate subject weights\nusing Random\nRandom.seed!(42)\nweights = 50.0 .+ 40.0 .* rand(100)  # 50-90 kg\ncovariates = [Dict(:WT =&gt; w) for w in weights]\n\n# Population with covariates\npop_spec = PopulationSpec(\n    base_spec,\n    n = 100,\n    omega = omega,\n    seed = 12345,\n    covariate_model = covariate_model,\n    covariates = covariates\n)\n\nresult = simulate_population(pop_spec, grid, solver)\n</code></pre>"},{"location":"julia/population/#key-concepts","title":"Key Concepts","text":""},{"location":"julia/population/#random-effects","title":"Random Effects","text":"<p>Individual parameters are derived from typical values and random effects:</p> \\[P_i = \\theta \\cdot e^{\\eta_i}\\] <p>Where: - \\(P_i\\) = Individual parameter - \\(\\theta\\) = Typical (population) value - \\(\\eta_i\\) = Random effect, \\(\\eta_i \\sim N(0, \\omega^2)\\)</p>"},{"location":"julia/population/#omega-matrix","title":"Omega Matrix","text":"<p>The omega matrix defines the variance-covariance of random effects:</p> <pre><code># Diagonal (independent parameters)\nomega = OmegaMatrix([\n    0.09 0.0;\n    0.0  0.04\n])\n\n# Full (correlated parameters)\nomega = OmegaMatrix([\n    0.09 0.03;   # Correlation between CL and V\n    0.03 0.04\n])\n</code></pre>"},{"location":"julia/population/#coefficient-of-variation","title":"Coefficient of Variation","text":"<p>For log-normal distribution, the relationship between omega and CV is:</p> \\[CV = \\sqrt{e^{\\omega^2} - 1} \\approx \\omega \\text{ (for small \u03c9)}\\] \u03c9\u00b2 \u03c9 Approximate CV 0.04 0.20 20% 0.09 0.30 30% 0.16 0.40 42% 0.25 0.50 53%"},{"location":"julia/population/#population-result-structure","title":"Population Result Structure","text":"<pre><code>struct PopulationResult\n    individuals::Vector{SimResult}        # Individual simulation results\n    realized_params::Vector{Dict}         # Realized parameter values\n    etas::Matrix{Float64}                 # Random effects (n \u00d7 p)\n    summaries::Dict{Symbol, Summary}      # Population summary statistics\n    metadata::Dict                        # Additional information\nend\n\nstruct Summary\n    mean::Vector{Float64}\n    median::Vector{Float64}\n    sd::Vector{Float64}\n    quantiles::Dict{Float64, Vector{Float64}}\nend\n</code></pre>"},{"location":"julia/population/#summary-statistics","title":"Summary Statistics","text":"<pre><code># Access population summaries\nsummary = result.summaries[:conc]\n\n# Central tendency\nsummary.mean      # Mean concentration at each time\nsummary.median    # Median concentration\n\n# Variability\nsummary.sd        # Standard deviation\n\n# Percentiles\nsummary.quantiles[0.05]   # 5th percentile\nsummary.quantiles[0.25]   # 25th percentile\nsummary.quantiles[0.50]   # Median\nsummary.quantiles[0.75]   # 75th percentile\nsummary.quantiles[0.95]   # 95th percentile\n</code></pre>"},{"location":"julia/population/#next-steps","title":"Next Steps","text":"<ul> <li>IIV Details - Understanding inter-individual variability</li> <li>Covariate Modeling - Adding patient characteristics</li> <li>Parameter Estimation - Fitting population models</li> <li>VPC - Visual predictive checks for validation</li> </ul>"},{"location":"julia/population/covariates/","title":"Covariate Models","text":"<p>Comprehensive guide for incorporating patient characteristics into population PK/PD models.</p>"},{"location":"julia/population/covariates/#overview","title":"Overview","text":"<p>Covariate models explain part of the inter-individual variability by relating parameters to measurable patient characteristics.</p> <pre><code>using OpenPKPDCore\n\n# Allometric scaling: CL and V based on weight\ncovariate_model = CovariateModel([\n    CovariateEffect(:CL, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V, :WT, 70.0, PowerCovariate(), 1.0)\n])\n</code></pre>"},{"location":"julia/population/covariates/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"julia/population/covariates/#general-covariate-model","title":"General Covariate Model","text":"<p>Parameters are adjusted based on covariate values:</p> \\[\\theta_i = \\theta_{pop} \\cdot f(cov_i, \\beta)\\] <p>Where: - \\(\\theta_i\\) = Individual parameter - \\(\\theta_{pop}\\) = Population typical value - \\(f(cov_i, \\beta)\\) = Covariate function - \\(\\beta\\) = Covariate coefficient</p>"},{"location":"julia/population/covariates/#order-of-application","title":"Order of Application","text":"<ol> <li>Covariates first: Adjust typical value for covariates</li> <li>IIV second: Apply random effects to covariate-adjusted value</li> <li>IOV third: Apply occasion-specific effects</li> </ol> \\[\\theta_{ij} = \\theta_{pop} \\cdot f(cov_i) \\cdot e^{\\eta_i + \\kappa_{ij}}\\]"},{"location":"julia/population/covariates/#covariate-effect-types","title":"Covariate Effect Types","text":""},{"location":"julia/population/covariates/#power-model","title":"Power Model","text":"<p>Most common for body size effects:</p> \\[\\theta_i = \\theta_{pop} \\cdot \\left(\\frac{cov_i}{ref}\\right)^{\\beta}\\] <pre><code># Allometric scaling\npower_effect = CovariateEffect(\n    :CL,                    # Target parameter\n    :WT,                    # Covariate name\n    70.0,                   # Reference value\n    PowerCovariate(),       # Effect type\n    0.75                    # Exponent (\u03b2)\n)\n\n# Common allometric exponents:\n# Clearance: 0.75 (3/4 power)\n# Volume: 1.0 (proportional to body size)\n# Half-life: 0.25 (1/4 power)\n</code></pre>"},{"location":"julia/population/covariates/#linear-model","title":"Linear Model","text":"<p>For effects proportional to deviation from reference:</p> \\[\\theta_i = \\theta_{pop} \\cdot (1 + \\beta \\cdot (cov_i - ref))\\] <pre><code># Age effect on clearance\nlinear_effect = CovariateEffect(\n    :CL,\n    :AGE,\n    45.0,                   # Reference age\n    LinearCovariate(),\n    -0.01                   # -1% per year above reference\n)\n\n# For a 65-year-old:\n# CL = CL_pop * (1 + (-0.01) * (65 - 45))\n# CL = CL_pop * (1 - 0.20) = 0.80 * CL_pop\n</code></pre>"},{"location":"julia/population/covariates/#exponential-model","title":"Exponential Model","text":"<p>For multiplicative effects:</p> \\[\\theta_i = \\theta_{pop} \\cdot e^{\\beta \\cdot (cov_i - ref)}\\] <pre><code># Renal function effect\nexp_effect = CovariateEffect(\n    :CL,\n    :CRCL,                  # Creatinine clearance\n    100.0,                  # Reference (normal)\n    ExpCovariate(),\n    0.005                   # Effect coefficient\n)\n\n# For CRCL = 50 mL/min:\n# CL = CL_pop * exp(0.005 * (50 - 100))\n# CL = CL_pop * exp(-0.25) = 0.78 * CL_pop\n</code></pre>"},{"location":"julia/population/covariates/#covariateeffect-structure","title":"CovariateEffect Structure","text":""},{"location":"julia/population/covariates/#class-definition","title":"Class Definition","text":"<pre><code>struct CovariateEffect{K&lt;:CovariateKind}\n    param::Symbol              # Target parameter (:CL, :V, etc.)\n    covariate::Symbol          # Covariate name (:WT, :AGE, etc.)\n    ref::Float64               # Reference value\n    kind::K                    # PowerCovariate, LinearCovariate, ExpCovariate\n    beta::Float64              # Effect coefficient\nend\n</code></pre>"},{"location":"julia/population/covariates/#creating-effects","title":"Creating Effects","text":"<pre><code># Power effect\neffect1 = CovariateEffect(:CL, :WT, 70.0, PowerCovariate(), 0.75)\n\n# Linear effect\neffect2 = CovariateEffect(:CL, :AGE, 45.0, LinearCovariate(), -0.008)\n\n# Exponential effect\neffect3 = CovariateEffect(:CLR, :CRCL, 100.0, ExpCovariate(), 0.007)\n</code></pre>"},{"location":"julia/population/covariates/#covariatemodel-structure","title":"CovariateModel Structure","text":""},{"location":"julia/population/covariates/#class-definition_1","title":"Class Definition","text":"<pre><code>struct CovariateModel\n    name::String\n    effects::Vector{CovariateEffect}\nend\n</code></pre>"},{"location":"julia/population/covariates/#creating-models","title":"Creating Models","text":"<pre><code># Full covariate model\ncovariate_model = CovariateModel(\n    \"standard_allometry\",\n    [\n        # Body size effects\n        CovariateEffect(:CL, :WT, 70.0, PowerCovariate(), 0.75),\n        CovariateEffect(:V1, :WT, 70.0, PowerCovariate(), 1.0),\n        CovariateEffect(:Q, :WT, 70.0, PowerCovariate(), 0.75),\n        CovariateEffect(:V2, :WT, 70.0, PowerCovariate(), 1.0),\n\n        # Age effect\n        CovariateEffect(:CL, :AGE, 45.0, LinearCovariate(), -0.005),\n\n        # Renal function effect on renal clearance\n        CovariateEffect(:CLR, :CRCL, 100.0, LinearCovariate(), 0.006)\n    ]\n)\n</code></pre>"},{"location":"julia/population/covariates/#applying-covariates","title":"Applying Covariates","text":"<pre><code>function apply_covariates(\n    params::Dict{Symbol, Float64},\n    model::CovariateModel,\n    covariates::Dict{Symbol, Float64}\n)\n    adjusted = copy(params)\n\n    for effect in model.effects\n        if haskey(covariates, effect.covariate)\n            cov_val = covariates[effect.covariate]\n            adjusted[effect.param] = apply_effect(\n                adjusted[effect.param],\n                cov_val,\n                effect\n            )\n        end\n    end\n\n    return adjusted\nend\n\nfunction apply_effect(\n    param_val::Float64,\n    cov_val::Float64,\n    effect::CovariateEffect{PowerCovariate}\n)\n    return param_val * (cov_val / effect.ref) ^ effect.beta\nend\n\nfunction apply_effect(\n    param_val::Float64,\n    cov_val::Float64,\n    effect::CovariateEffect{LinearCovariate}\n)\n    return param_val * (1 + effect.beta * (cov_val - effect.ref))\nend\n\nfunction apply_effect(\n    param_val::Float64,\n    cov_val::Float64,\n    effect::CovariateEffect{ExpCovariate}\n)\n    return param_val * exp(effect.beta * (cov_val - effect.ref))\nend\n</code></pre>"},{"location":"julia/population/covariates/#individualcovariates-structure","title":"IndividualCovariates Structure","text":""},{"location":"julia/population/covariates/#class-definition_2","title":"Class Definition","text":"<pre><code>struct IndividualCovariates\n    values::Dict{Symbol, Float64}                # Static covariates\n    time_varying::Union{TimeVaryingCovariates, Nothing}  # Dynamic covariates\nend\n</code></pre>"},{"location":"julia/population/covariates/#creating-individual-covariates","title":"Creating Individual Covariates","text":"<pre><code># Static covariates\nsubject_covs = IndividualCovariates(\n    Dict(:WT =&gt; 80.0, :AGE =&gt; 55.0, :SEX =&gt; 1.0, :CRCL =&gt; 85.0),\n    nothing\n)\n\n# With time-varying covariate\ntime_cov = TimeVaryingCovariates(Dict(\n    :CRCL =&gt; TimeCovariateSeries(\n        StepTimeCovariate(),\n        [0.0, 24.0, 48.0, 72.0],\n        [85.0, 80.0, 75.0, 78.0]\n    )\n))\n\nsubject_covs = IndividualCovariates(\n    Dict(:WT =&gt; 80.0, :AGE =&gt; 55.0),\n    time_cov\n)\n</code></pre>"},{"location":"julia/population/covariates/#time-varying-covariates","title":"Time-Varying Covariates","text":""},{"location":"julia/population/covariates/#step-interpolation","title":"Step Interpolation","text":"<p>Value held constant until next time point:</p> <pre><code># Creatinine clearance declining stepwise\ncrcl_series = TimeCovariateSeries(\n    StepTimeCovariate(),\n    [0.0, 24.0, 48.0, 72.0, 96.0],    # Times\n    [100.0, 90.0, 75.0, 80.0, 85.0]   # Values\n)\n\n# At t=30: CRCL = 90.0 (from t=24 value)\n# At t=50: CRCL = 75.0 (from t=48 value)\n</code></pre>"},{"location":"julia/population/covariates/#linear-interpolation","title":"Linear Interpolation","text":"<p>Smooth transition between values:</p> <pre><code># Body weight changing gradually\nwt_series = TimeCovariateSeries(\n    LinearTimeCovariate(),\n    [0.0, 168.0, 336.0],              # Weekly\n    [80.0, 78.0, 76.0]                # Decreasing\n)\n\n# At t=84 (halfway between 0 and 168):\n# WT = 80.0 + (78.0 - 80.0) * (84/168) = 79.0\n</code></pre>"},{"location":"julia/population/covariates/#timevaryingcovariates-structure","title":"TimeVaryingCovariates Structure","text":"<pre><code>struct TimeVaryingCovariates\n    series::Dict{Symbol, TimeCovariateSeries}\nend\n\n# Usage\ntime_covs = TimeVaryingCovariates(Dict(\n    :CRCL =&gt; TimeCovariateSeries(StepTimeCovariate(), t_crcl, v_crcl),\n    :WT =&gt; TimeCovariateSeries(LinearTimeCovariate(), t_wt, v_wt)\n))\n</code></pre>"},{"location":"julia/population/covariates/#applying-at-specific-time","title":"Applying at Specific Time","text":"<pre><code>function apply_covariates_at_time(\n    params::Dict{Symbol, Float64},\n    model::CovariateModel,\n    covs::IndividualCovariates,\n    t::Float64\n)\n    # Get covariate values at time t\n    current_covs = get_covariates_at_time(covs, t)\n\n    # Apply effects\n    return apply_covariates(params, model, current_covs)\nend\n\nfunction get_covariates_at_time(\n    covs::IndividualCovariates,\n    t::Float64\n)\n    result = copy(covs.values)\n\n    if covs.time_varying !== nothing\n        for (name, series) in covs.time_varying.series\n            result[name] = interpolate_at_time(series, t)\n        end\n    end\n\n    return result\nend\n</code></pre>"},{"location":"julia/population/covariates/#common-covariate-effects","title":"Common Covariate Effects","text":""},{"location":"julia/population/covariates/#body-size-allometric-scaling","title":"Body Size (Allometric Scaling)","text":"<pre><code># Standard allometry based on weight\nallometric = CovariateModel([\n    CovariateEffect(:CL, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V, :WT, 70.0, PowerCovariate(), 1.0),\n    CovariateEffect(:Q, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V2, :WT, 70.0, PowerCovariate(), 1.0)\n])\n\n# Alternative using lean body mass\nlbm_model = CovariateModel([\n    CovariateEffect(:CL, :LBM, 55.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V, :LBM, 55.0, PowerCovariate(), 1.0)\n])\n\n# BSA-based dosing\nbsa_model = CovariateModel([\n    CovariateEffect(:CL, :BSA, 1.73, PowerCovariate(), 1.0)\n])\n</code></pre>"},{"location":"julia/population/covariates/#renal-function","title":"Renal Function","text":"<pre><code># Creatinine clearance effect\nrenal_model = CovariateModel([\n    # Renal clearance\n    CovariateEffect(:CLR, :CRCL, 100.0, LinearCovariate(), 0.007),\n    # Or as fraction of total CL\n    CovariateEffect(:CL, :CRCL, 100.0, PowerCovariate(), 0.5)\n])\n\n# eGFR-based\negfr_model = CovariateModel([\n    CovariateEffect(:CL, :EGFR, 90.0, LinearCovariate(), 0.005)\n])\n</code></pre>"},{"location":"julia/population/covariates/#age-effects","title":"Age Effects","text":"<pre><code># Linear age effect\nage_linear = CovariateEffect(:CL, :AGE, 40.0, LinearCovariate(), -0.006)\n\n# Pediatric maturation\nmaturation = CovariateEffect(:CL, :PMA, 40.0, PowerCovariate(), 0.75)\n\n# Elderly decline (exponential)\nelderly = CovariateEffect(:CL, :AGE, 50.0, ExpCovariate(), -0.01)\n</code></pre>"},{"location":"julia/population/covariates/#sexgender","title":"Sex/Gender","text":"<pre><code># Categorical: use indicator variable\n# SEX = 0 for male (reference), SEX = 1 for female\nsex_effect = CovariateEffect(:CL, :SEX, 0.0, LinearCovariate(), -0.15)\n\n# Female CL = CL_pop * (1 + (-0.15) * (1 - 0)) = 0.85 * CL_pop\n</code></pre>"},{"location":"julia/population/covariates/#genetic-polymorphisms","title":"Genetic Polymorphisms","text":"<pre><code># CYP2D6 metabolizer status\n# PM=0, IM=0.5, EM=1.0 (reference), UM=1.5\ncyp2d6_effect = CovariateEffect(:CLM, :CYP2D6, 1.0, PowerCovariate(), 1.0)\n\n# Or as categories with separate effects\n# Implement using indicator variables for each category\n</code></pre>"},{"location":"julia/population/covariates/#population-simulation-with-covariates","title":"Population Simulation with Covariates","text":""},{"location":"julia/population/covariates/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Random\n\n# 1. Define model and typical parameters\nmodel = TwoCompOral()\ntypical = TwoCompOralParams(\n    Ka = 1.5,\n    CL = 10.0,\n    V1 = 50.0,\n    Q = 5.0,\n    V2 = 100.0\n)\n\n# 2. Define covariate model\ncov_model = CovariateModel(\"full_model\", [\n    # Allometric scaling\n    CovariateEffect(:CL, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V1, :WT, 70.0, PowerCovariate(), 1.0),\n    CovariateEffect(:Q, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V2, :WT, 70.0, PowerCovariate(), 1.0),\n\n    # Age effect on CL\n    CovariateEffect(:CL, :AGE, 45.0, LinearCovariate(), -0.005),\n\n    # Renal function\n    CovariateEffect(:CL, :CRCL, 100.0, LinearCovariate(), 0.003)\n])\n\n# 3. Generate population covariates\nRandom.seed!(42)\nn_subjects = 100\n\ncovariates = Vector{IndividualCovariates}()\nfor i in 1:n_subjects\n    wt = 70.0 + randn() * 15.0\n    age = 45.0 + randn() * 12.0\n    # CRCL depends on age\n    crcl = max(30.0, 120.0 - age * 0.8 + randn() * 15.0)\n\n    push!(covariates, IndividualCovariates(\n        Dict(:WT =&gt; wt, :AGE =&gt; age, :CRCL =&gt; crcl),\n        nothing\n    ))\nend\n\n# 4. IIV (residual after covariate adjustment)\nomega = OmegaMatrix([\n    0.04 0.0;    # CL: 20% CV (reduced from 30% without covariates)\n    0.04 0.0;    # V1: 20% CV\n    0.0  0.16    # Ka: 40% CV\n])\n\n# 5. Create population specification\ndoses = [DoseEvent(0.0, 500.0)]\nbase_spec = ModelSpec(model, \"cov_sim\", typical, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = n_subjects,\n    omega = omega,\n    covariate_model = cov_model,\n    covariates = covariates,\n    seed = 12345\n)\n\n# 6. Simulate\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.5:48.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nresult = simulate_population(pop_spec, grid, solver)\n</code></pre>"},{"location":"julia/population/covariates/#analyzing-covariate-effects","title":"Analyzing Covariate Effects","text":"<pre><code>using Statistics\n\n# Extract realized parameters and covariates\ncl_values = [p[:CL] for p in result.params]\nwt_values = [c.values[:WT] for c in covariates]\nage_values = [c.values[:AGE] for c in covariates]\n\n# Correlation with covariates\ncorr_cl_wt = cor(cl_values, wt_values)\ncorr_cl_age = cor(cl_values, age_values)\n\nprintln(\"Correlation CL vs WT: $(round(corr_cl_wt, digits=3))\")\nprintln(\"Correlation CL vs AGE: $(round(corr_cl_age, digits=3))\")\n\n# CL by weight quartiles\nwt_q = quantile(wt_values, [0.25, 0.5, 0.75])\nlow_wt = cl_values[wt_values .&lt;= wt_q[1]]\nhigh_wt = cl_values[wt_values .&gt;= wt_q[3]]\n\nprintln(\"\\nCL by weight quartile:\")\nprintln(\"  Low WT (\u2264$(round(wt_q[1], digits=1)) kg): $(round(mean(low_wt), digits=2)) L/hr\")\nprintln(\"  High WT (\u2265$(round(wt_q[3], digits=1)) kg): $(round(mean(high_wt), digits=2)) L/hr\")\n</code></pre>"},{"location":"julia/population/covariates/#covariate-model-building","title":"Covariate Model Building","text":""},{"location":"julia/population/covariates/#stepwise-selection","title":"Stepwise Selection","text":"<pre><code># Forward selection approach\nfunction stepwise_covariate_selection(\n    base_model::PopulationModel,\n    candidate_effects::Vector{CovariateEffect},\n    data::PopulationData;\n    alpha_forward = 0.05,\n    alpha_backward = 0.01\n)\n    selected = CovariateEffect[]\n    remaining = copy(candidate_effects)\n\n    # Forward selection\n    improved = true\n    while improved &amp;&amp; !isempty(remaining)\n        improved = false\n        best_effect = nothing\n        best_delta_ofv = 0.0\n\n        for effect in remaining\n            # Fit model with this effect\n            test_model = add_covariate(base_model, effect)\n            fit = fit_population(data, test_model)\n\n            delta_ofv = base_model.ofv - fit.ofv\n            p_value = 1 - cdf(Chisq(1), delta_ofv)\n\n            if p_value &lt; alpha_forward &amp;&amp; delta_ofv &gt; best_delta_ofv\n                best_delta_ofv = delta_ofv\n                best_effect = effect\n                improved = true\n            end\n        end\n\n        if improved\n            push!(selected, best_effect)\n            filter!(e -&gt; e != best_effect, remaining)\n            base_model = add_covariate(base_model, best_effect)\n        end\n    end\n\n    return CovariateModel(selected)\nend\n</code></pre>"},{"location":"julia/population/covariates/#covariate-significance","title":"Covariate Significance","text":"<pre><code># Test significance of covariate effect\nfunction test_covariate_significance(\n    full_model::PopulationModel,\n    reduced_model::PopulationModel,  # Without the covariate\n    n_params_diff::Int = 1\n)\n    delta_ofv = reduced_model.ofv - full_model.ofv\n    p_value = 1 - cdf(Chisq(n_params_diff), delta_ofv)\n\n    return (\n        delta_ofv = delta_ofv,\n        p_value = p_value,\n        significant = p_value &lt; 0.05\n    )\nend\n</code></pre>"},{"location":"julia/population/covariates/#complete-example_1","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Statistics\nusing Random\n\n# ============================================\n# Population PK with Comprehensive Covariates\n# ============================================\n\nprintln(\"=== Covariate Modeling Example ===\\n\")\n\n# 1. Model setup\nmodel = TwoCompOral()\ntypical = TwoCompOralParams(Ka=1.5, CL=10.0, V1=50.0, Q=5.0, V2=100.0)\n\n# 2. Full covariate model\nprintln(\"--- Covariate Model ---\")\ncov_model = CovariateModel(\"comprehensive\", [\n    # Allometry\n    CovariateEffect(:CL, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V1, :WT, 70.0, PowerCovariate(), 1.0),\n    CovariateEffect(:Q, :WT, 70.0, PowerCovariate(), 0.75),\n    CovariateEffect(:V2, :WT, 70.0, PowerCovariate(), 1.0),\n    # Demographics\n    CovariateEffect(:CL, :AGE, 45.0, LinearCovariate(), -0.006),\n    CovariateEffect(:CL, :SEX, 0.0, LinearCovariate(), -0.12),\n    # Renal function\n    CovariateEffect(:CL, :CRCL, 100.0, LinearCovariate(), 0.004)\n])\n\nfor eff in cov_model.effects\n    println(\"  $(eff.param) ~ $(eff.covariate): $(eff.kind) (\u03b2=$(eff.beta), ref=$(eff.ref))\")\nend\n\n# 3. Generate realistic population\nRandom.seed!(42)\nn = 200\n\ncovariates = Vector{IndividualCovariates}()\nfor i in 1:n\n    sex = rand() &lt; 0.5 ? 0.0 : 1.0\n    age = 20.0 + 40.0 * rand()\n    wt = sex == 0 ? 75.0 + randn() * 12.0 : 65.0 + randn() * 10.0\n    crcl = max(30.0, 130.0 - age * 0.9 + randn() * 15.0)\n\n    push!(covariates, IndividualCovariates(\n        Dict(:WT =&gt; wt, :AGE =&gt; age, :SEX =&gt; sex, :CRCL =&gt; crcl),\n        nothing\n    ))\nend\n\n# 4. Summarize covariates\nprintln(\"\\n--- Population Covariates ---\")\nwts = [c.values[:WT] for c in covariates]\nages = [c.values[:AGE] for c in covariates]\ncrcls = [c.values[:CRCL] for c in covariates]\nsexes = [c.values[:SEX] for c in covariates]\n\nprintln(\"  WT: $(round(mean(wts), digits=1)) \u00b1 $(round(std(wts), digits=1)) kg\")\nprintln(\"  AGE: $(round(mean(ages), digits=1)) \u00b1 $(round(std(ages), digits=1)) years\")\nprintln(\"  CRCL: $(round(mean(crcls), digits=1)) \u00b1 $(round(std(crcls), digits=1)) mL/min\")\nprintln(\"  Female: $(round(mean(sexes) * 100, digits=0))%\")\n\n# 5. IIV (residual variability after covariates)\nomega = OmegaMatrix([\n    0.0225 0.0 0.0;   # CL: 15% residual CV\n    0.0225 0.0 0.0;   # V1: 15% residual CV\n    0.0 0.0 0.09      # Ka: 30% CV\n])\n\n# 6. Simulate\ndoses = [DoseEvent(0.0, 500.0)]\nbase_spec = ModelSpec(model, \"cov_example\", typical, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = n,\n    omega = omega,\n    covariate_model = cov_model,\n    covariates = covariates,\n    seed = 12345\n)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.5:48.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nprintln(\"\\n--- Simulation ---\")\nresult = simulate_population(pop_spec, grid, solver)\nprintln(\"Simulated $(length(result.individuals)) subjects\")\n\n# 7. Analyze covariate impact\nprintln(\"\\n--- Covariate Impact on CL ---\")\ncl_values = [p[:CL] for p in result.params]\n\n# By sex\nmale_cl = cl_values[sexes .== 0]\nfemale_cl = cl_values[sexes .== 1]\nprintln(\"  Male CL: $(round(mean(male_cl), digits=2)) L/hr\")\nprintln(\"  Female CL: $(round(mean(female_cl), digits=2)) L/hr\")\nprintln(\"  Ratio (F/M): $(round(mean(female_cl)/mean(male_cl), digits=2))\")\n\n# By age tertiles\nage_t = quantile(ages, [0.33, 0.67])\nyoung_cl = cl_values[ages .&lt; age_t[1]]\nold_cl = cl_values[ages .&gt; age_t[2]]\nprintln(\"\\n  Young (&lt;$(round(age_t[1], digits=0)) y): $(round(mean(young_cl), digits=2)) L/hr\")\nprintln(\"  Old (&gt;$(round(age_t[2], digits=0)) y): $(round(mean(old_cl), digits=2)) L/hr\")\n\n# By renal function\nnormal_crcl = cl_values[crcls .&gt;= 90]\nimpaired_crcl = cl_values[crcls .&lt; 60]\nprintln(\"\\n  Normal CRCL (\u226590): $(round(mean(normal_crcl), digits=2)) L/hr\")\nprintln(\"  Impaired CRCL (&lt;60): $(round(mean(impaired_crcl), digits=2)) L/hr\")\n\n# 8. PK outcomes\nprintln(\"\\n--- PK Outcomes ---\")\ncmax = [maximum(ind.observations[:conc]) for ind in result.individuals]\nprintln(\"Cmax: $(round(mean(cmax), digits=2)) \u00b1 $(round(std(cmax), digits=2)) mg/L\")\nprintln(\"CV(Cmax): $(round(std(cmax)/mean(cmax)*100, digits=1))%\")\n</code></pre>"},{"location":"julia/population/covariates/#see-also","title":"See Also","text":"<ul> <li>IIV - Inter-individual variability</li> <li>IOV - Inter-occasion variability</li> <li>Residual Error - Observation error</li> <li>Parameter Estimation - Estimating covariate effects</li> </ul>"},{"location":"julia/population/iiv/","title":"Inter-Individual Variability (IIV)","text":"<p>Comprehensive guide for modeling between-subject variability in population PK/PD models.</p>"},{"location":"julia/population/iiv/#overview","title":"Overview","text":"<p>Inter-individual variability (IIV) captures the differences in pharmacokinetic and pharmacodynamic parameters between subjects in a population.</p> <pre><code>using OpenPKPDCore\n\n# Define IIV with 30% CV on CL and 20% CV on V\nomega = OmegaMatrix([\n    0.09 0.0;   # \u03c9\u00b2_CL (30% CV)\n    0.0  0.04   # \u03c9\u00b2_V  (20% CV)\n])\n</code></pre>"},{"location":"julia/population/iiv/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"julia/population/iiv/#log-normal-distribution","title":"Log-Normal Distribution","text":"<p>Individual parameters are derived from population values using log-normal random effects:</p> \\[P_i = \\theta \\cdot e^{\\eta_i}\\] <p>Where: - \\(P_i\\) = Individual parameter value for subject \\(i\\) - \\(\\theta\\) = Typical (population) parameter value - \\(\\eta_i\\) = Random effect, \\(\\eta_i \\sim N(0, \\omega^2)\\)</p>"},{"location":"julia/population/iiv/#omega-to-cv-relationship","title":"Omega to CV Relationship","text":"<p>For log-normal distributions:</p> \\[CV = \\sqrt{e^{\\omega^2} - 1}\\] <p>For small \u03c9 (&lt; 0.5), this approximates to:</p> \\[CV \\approx \\omega\\] \u03c9\u00b2 \u03c9 Exact CV Approx CV 0.01 0.10 10.0% 10% 0.04 0.20 20.1% 20% 0.09 0.30 30.9% 30% 0.16 0.40 43.3% 40% 0.25 0.50 58.4% 50% 0.36 0.60 77.3% 60%"},{"location":"julia/population/iiv/#omegamatrix-structure","title":"OmegaMatrix Structure","text":""},{"location":"julia/population/iiv/#class-definition","title":"Class Definition","text":"<pre><code>struct OmegaMatrix\n    param_names::Vector{Symbol}      # Parameter names [:CL, :V, ...]\n    matrix::Matrix{Float64}          # Full variance-covariance matrix\n    cholesky_L::LowerTriangular      # Lower Cholesky factor for sampling\nend\n</code></pre>"},{"location":"julia/population/iiv/#creating-omega-matrices","title":"Creating Omega Matrices","text":"<pre><code># Diagonal (uncorrelated parameters)\nomega = OmegaMatrix([\n    0.09 0.0;    # CL\n    0.0  0.04    # V\n])\n\n# Full covariance (correlated parameters)\nomega = OmegaMatrix([\n    0.09 0.03;   # CL, correlation with V\n    0.03 0.04    # V\n])\n\n# With explicit parameter names\nomega = OmegaMatrix(\n    [:CL, :V, :Ka],\n    [\n        0.09 0.02 0.0;\n        0.02 0.04 0.0;\n        0.0  0.0  0.16\n    ]\n)\n</code></pre>"},{"location":"julia/population/iiv/#omega-matrix-properties","title":"Omega Matrix Properties","text":"<pre><code># Check if correlations exist\nhas_corr = has_correlations(omega)\n\n# Get diagonal elements only\ndiag_omegas = get_diagonal_omegas(omega)\n# Returns: Dict(:CL =&gt; 0.09, :V =&gt; 0.04)\n\n# Get correlation matrix\ncorr = get_correlation_matrix(omega)\n# Returns correlation coefficients (-1 to 1)\n\n# Ensure positive definite\nomega_pd = ensure_positive_definite_omega(omega)\n</code></pre>"},{"location":"julia/population/iiv/#iivspec-structure","title":"IIVSpec Structure","text":""},{"location":"julia/population/iiv/#class-definition_1","title":"Class Definition","text":"<pre><code>struct IIVSpec{K&lt;:RandomEffectKind}\n    kind::K                          # LogNormalIIV()\n    omegas::Dict{Symbol, Float64}    # Diagonal omegas (backward compatible)\n    omega_matrix::Union{OmegaMatrix, Nothing}  # Full covariance (optional)\n    seed::Int                        # Random seed for reproducibility\n    n::Int                           # Number of subjects\nend\n</code></pre>"},{"location":"julia/population/iiv/#creating-iiv-specifications","title":"Creating IIV Specifications","text":"<pre><code># Simple diagonal IIV\niiv = IIVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.09, :V =&gt; 0.04),\n    seed = 12345,\n    n = 100\n)\n\n# Full covariance IIV\nomega = OmegaMatrix([\n    0.09 0.03;\n    0.03 0.04\n])\n\niiv = IIVSpec(\n    LogNormalIIV(),\n    omega_matrix = omega,\n    seed = 12345,\n    n = 100\n)\n</code></pre>"},{"location":"julia/population/iiv/#sampling-random-effects","title":"Sampling Random Effects","text":""},{"location":"julia/population/iiv/#diagonal-sampling","title":"Diagonal Sampling","text":"<pre><code># Sample uncorrelated etas\nfunction sample_etas_diagonal(\n    omegas::Dict{Symbol, Float64},\n    n::Int;\n    seed::Int = nothing\n)\n    if seed !== nothing\n        Random.seed!(seed)\n    end\n\n    etas = Dict{Symbol, Vector{Float64}}()\n    for (param, omega_sq) in omegas\n        omega = sqrt(omega_sq)\n        etas[param] = randn(n) .* omega\n    end\n\n    return etas\nend\n\n# Usage\netas = sample_etas_diagonal(Dict(:CL =&gt; 0.09, :V =&gt; 0.04), 100, seed=42)\n# etas[:CL] is Vector{Float64} of length 100\n# etas[:V] is Vector{Float64} of length 100\n</code></pre>"},{"location":"julia/population/iiv/#correlated-sampling-cholesky","title":"Correlated Sampling (Cholesky)","text":"<pre><code># Sample correlated etas using Cholesky decomposition\nfunction sample_etas_correlated(\n    omega::OmegaMatrix,\n    n::Int;\n    seed::Int = nothing\n)\n    if seed !== nothing\n        Random.seed!(seed)\n    end\n\n    p = size(omega.matrix, 1)\n    Z = randn(n, p)                    # Standard normal samples\n    etas = Z * omega.cholesky_L'       # Transform to correlated\n\n    # Convert to Dict\n    result = Dict{Symbol, Vector{Float64}}()\n    for (i, param) in enumerate(omega.param_names)\n        result[param] = etas[:, i]\n    end\n\n    return result\nend\n\n# Usage\nomega = OmegaMatrix([0.09 0.03; 0.03 0.04])\netas = sample_etas_correlated(omega, 100, seed=42)\n</code></pre>"},{"location":"julia/population/iiv/#applying-iiv","title":"Applying IIV","text":""},{"location":"julia/population/iiv/#log-normal-application","title":"Log-Normal Application","text":"<pre><code># Apply etas to typical parameters\nfunction apply_etas_lognormal(\n    typical_params::Dict{Symbol, Float64},\n    etas::Dict{Symbol, Vector{Float64}},\n    subject_index::Int\n)\n    individual_params = Dict{Symbol, Float64}()\n\n    for (param, theta) in typical_params\n        if haskey(etas, param)\n            eta = etas[param][subject_index]\n            individual_params[param] = theta * exp(eta)\n        else\n            individual_params[param] = theta\n        end\n    end\n\n    return individual_params\nend\n\n# Example\ntypical = Dict(:CL =&gt; 10.0, :V =&gt; 50.0, :Ka =&gt; 1.5)\netas = Dict(:CL =&gt; [-0.2, 0.1, 0.3], :V =&gt; [0.1, -0.1, 0.0])\n\nfor i in 1:3\n    ind = apply_etas_lognormal(typical, etas, i)\n    println(\"Subject $i: CL=$(round(ind[:CL], digits=2)), V=$(round(ind[:V], digits=2))\")\nend\n# Subject 1: CL=8.19, V=55.26\n# Subject 2: CL=11.05, V=45.24\n# Subject 3: CL=13.50, V=50.00\n</code></pre>"},{"location":"julia/population/iiv/#population-simulation-with-iiv","title":"Population Simulation with IIV","text":""},{"location":"julia/population/iiv/#basic-simulation","title":"Basic Simulation","text":"<pre><code>using OpenPKPDCore\n\n# 1. Define typical parameters\ntypical_params = TwoCompOralParams(\n    Ka = 1.5,\n    CL = 10.0,\n    V1 = 50.0,\n    Q = 5.0,\n    V2 = 100.0\n)\n\n# 2. Define IIV\nomega = OmegaMatrix([\n    0.09 0.02 0.0;    # CL (correlated with V1)\n    0.02 0.04 0.0;    # V1\n    0.0  0.0  0.16    # Ka (uncorrelated)\n])\n\n# 3. Create base specification\ndoses = [DoseEvent(0.0, 100.0)]\nbase_spec = ModelSpec(\n    TwoCompOral(),\n    \"pop_sim\",\n    typical_params,\n    doses\n)\n\n# 4. Create population specification\npop_spec = PopulationSpec(\n    base_spec,\n    n = 100,\n    omega = omega,\n    seed = 12345\n)\n\n# 5. Simulate\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nresult = simulate_population(pop_spec, grid, solver)\n</code></pre>"},{"location":"julia/population/iiv/#accessing-results","title":"Accessing Results","text":"<pre><code># Individual results\nfor (i, ind) in enumerate(result.individuals[1:5])\n    println(\"Subject $i:\")\n    println(\"  Cmax = $(maximum(ind.observations[:conc]))\")\n    println(\"  Parameters: $(result.params[i])\")\nend\n\n# Population summaries\nsummary = result.summaries[:conc]\nprintln(\"\\nPopulation Summary:\")\nprintln(\"Mean Cmax: $(maximum(summary.mean))\")\nprintln(\"Median Cmax: $(maximum(summary.median))\")\nprintln(\"5th percentile: $(maximum(summary.quantiles[0.05]))\")\nprintln(\"95th percentile: $(maximum(summary.quantiles[0.95]))\")\n\n# Eta values\nprintln(\"\\nEta distribution:\")\nprintln(\"\u03b7_CL: mean=$(mean(result.etas[:CL])), sd=$(std(result.etas[:CL]))\")\nprintln(\"\u03b7_V1: mean=$(mean(result.etas[:V1])), sd=$(std(result.etas[:V1]))\")\n</code></pre>"},{"location":"julia/population/iiv/#correlation-between-parameters","title":"Correlation Between Parameters","text":""},{"location":"julia/population/iiv/#interpreting-correlations","title":"Interpreting Correlations","text":"<pre><code># Full omega matrix with correlation\nomega = OmegaMatrix([\n    0.09 0.04;    # \u03c9\u00b2_CL = 0.09, cov(CL,V) = 0.04\n    0.04 0.16     # \u03c9\u00b2_V = 0.16\n])\n\n# Calculate correlation coefficient\nomega_cl = sqrt(0.09)   # 0.30\nomega_v = sqrt(0.16)    # 0.40\ncovariance = 0.04\ncorrelation = covariance / (omega_cl * omega_v)  # 0.04 / (0.30 * 0.40) = 0.33\n\nprintln(\"Correlation between CL and V: $(round(correlation, digits=2))\")\n# Subjects with higher CL tend to have higher V\n</code></pre>"},{"location":"julia/population/iiv/#positive-vs-negative-correlations","title":"Positive vs Negative Correlations","text":"<pre><code># Positive correlation: CL and V increase together\nomega_pos = OmegaMatrix([\n    0.09  0.04;\n    0.04  0.09\n])\n\n# Negative correlation: as CL increases, V decreases\nomega_neg = OmegaMatrix([\n    0.09 -0.04;\n   -0.04  0.09\n])\n\n# Common physiological correlations:\n# - CL and V often positively correlated (larger subjects have both)\n# - Ka and F may be negatively correlated (fast absorption, lower F)\n</code></pre>"},{"location":"julia/population/iiv/#iiv-on-different-parameter-types","title":"IIV on Different Parameter Types","text":""},{"location":"julia/population/iiv/#volume-parameters","title":"Volume Parameters","text":"<pre><code># Volume typically scales with body size\n# Common CV: 20-40%\nomega_v = 0.04 to 0.16  # \u03c9\u00b2 values\n</code></pre>"},{"location":"julia/population/iiv/#clearance-parameters","title":"Clearance Parameters","text":"<pre><code># Clearance also scales with body size and organ function\n# Common CV: 20-50%\nomega_cl = 0.04 to 0.25\n</code></pre>"},{"location":"julia/population/iiv/#absorption-parameters-ka","title":"Absorption Parameters (Ka)","text":"<pre><code># Absorption rate often highly variable\n# Common CV: 30-60%\nomega_ka = 0.09 to 0.36\n</code></pre>"},{"location":"julia/population/iiv/#bioavailability-f","title":"Bioavailability (F)","text":"<pre><code># Bioavailability constrained 0-1, use logit transform\n# Or use proportional model with constraints\n# Common CV: 20-40%\n</code></pre>"},{"location":"julia/population/iiv/#shrinkage","title":"Shrinkage","text":""},{"location":"julia/population/iiv/#eta-shrinkage","title":"Eta Shrinkage","text":"<p>Shrinkage indicates how much individual estimates are pulled toward population values:</p> <pre><code>function calculate_eta_shrinkage(etas::Vector{Float64}, omega::Float64)\n    var_eta = var(etas)\n    shrinkage = 1 - sqrt(var_eta) / sqrt(omega)\n    return shrinkage * 100  # As percentage\nend\n\n# Interpretation:\n# &lt; 20%: Good, individual estimates reliable\n# 20-40%: Moderate, some uncertainty\n# &gt; 40%: High, individual estimates unreliable\n</code></pre>"},{"location":"julia/population/iiv/#causes-of-high-shrinkage","title":"Causes of High Shrinkage","text":"<ul> <li>Sparse sampling (few observations per subject)</li> <li>Low IIV relative to residual error</li> <li>Parameters not well estimated from data</li> </ul>"},{"location":"julia/population/iiv/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Statistics\n\n# ============================================\n# Population PK Simulation with IIV\n# ============================================\n\nprintln(\"=== Population PK with IIV ===\\n\")\n\n# 1. Define model and typical parameters\nmodel = TwoCompOral()\ntypical = TwoCompOralParams(\n    Ka = 1.5,     # /hr\n    CL = 10.0,    # L/hr\n    V1 = 50.0,    # L\n    Q = 5.0,      # L/hr\n    V2 = 100.0    # L\n)\n\n# 2. Define IIV with correlations\nprintln(\"--- IIV Specification ---\")\nomega = OmegaMatrix(\n    [:CL, :V1, :Ka],\n    [\n        0.09 0.03 0.00;   # CL: 30% CV, correlated with V1\n        0.03 0.04 0.00;   # V1: 20% CV\n        0.00 0.00 0.16    # Ka: 40% CV, uncorrelated\n    ]\n)\n\nprintln(\"Omega matrix:\")\ndisplay(omega.matrix)\n\ncorr = get_correlation_matrix(omega)\nprintln(\"\\nCorrelation matrix:\")\ndisplay(corr)\n\n# 3. Setup simulation\ndoses = [DoseEvent(0.0, 500.0)]  # 500 mg single dose\nbase_spec = ModelSpec(model, \"iiv_demo\", typical, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = 200,\n    omega = omega,\n    seed = 42\n)\n\ngrid = SimGrid(0.0, 48.0, collect(0.0:0.5:48.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# 4. Simulate\nprintln(\"\\n--- Running Simulation ---\")\nresult = simulate_population(pop_spec, grid, solver)\nprintln(\"Simulated $(length(result.individuals)) subjects\")\n\n# 5. Parameter distribution\nprintln(\"\\n--- Realized Parameters ---\")\ncl_values = [p[:CL] for p in result.params]\nv1_values = [p[:V1] for p in result.params]\nka_values = [p[:Ka] for p in result.params]\n\nprintln(\"CL: $(round(mean(cl_values), digits=2)) \u00b1 $(round(std(cl_values), digits=2)) L/hr\")\nprintln(\"V1: $(round(mean(v1_values), digits=2)) \u00b1 $(round(std(v1_values), digits=2)) L\")\nprintln(\"Ka: $(round(mean(ka_values), digits=2)) \u00b1 $(round(std(ka_values), digits=2)) /hr\")\n\n# 6. Check correlation in realized parameters\ncorr_cl_v1 = cor(cl_values, v1_values)\ncorr_cl_ka = cor(cl_values, ka_values)\nprintln(\"\\nParameter correlations:\")\nprintln(\"\u03c1(CL, V1) = $(round(corr_cl_v1, digits=3))\")\nprintln(\"\u03c1(CL, Ka) = $(round(corr_cl_ka, digits=3))\")\n\n# 7. PK metrics\nprintln(\"\\n--- PK Metrics ---\")\ncmax_values = [maximum(ind.observations[:conc]) for ind in result.individuals]\ntmax_values = [ind.times[argmax(ind.observations[:conc])] for ind in result.individuals]\n\n# Approximate AUC using trapezoidal rule\nfunction approx_auc(times, conc)\n    auc = 0.0\n    for i in 2:length(times)\n        auc += 0.5 * (conc[i] + conc[i-1]) * (times[i] - times[i-1])\n    end\n    return auc\nend\n\nauc_values = [approx_auc(ind.times, ind.observations[:conc]) for ind in result.individuals]\n\nprintln(\"Cmax: $(round(mean(cmax_values), digits=2)) \u00b1 $(round(std(cmax_values), digits=2)) mg/L\")\nprintln(\"Tmax: $(round(mean(tmax_values), digits=2)) \u00b1 $(round(std(tmax_values), digits=2)) hr\")\nprintln(\"AUC:  $(round(mean(auc_values), digits=1)) \u00b1 $(round(std(auc_values), digits=1)) mg*hr/L\")\n\n# 8. Percentiles\nprintln(\"\\n--- Population Percentiles (Cmax) ---\")\npercentiles = [5, 25, 50, 75, 95]\nfor p in percentiles\n    val = quantile(cmax_values, p/100)\n    println(\"  $(p)th percentile: $(round(val, digits=2)) mg/L\")\nend\n\n# 9. CV calculation\ncv_cmax = std(cmax_values) / mean(cmax_values) * 100\ncv_auc = std(auc_values) / mean(auc_values) * 100\nprintln(\"\\n--- Variability ---\")\nprintln(\"CV(Cmax): $(round(cv_cmax, digits=1))%\")\nprintln(\"CV(AUC): $(round(cv_auc, digits=1))%\")\n</code></pre>"},{"location":"julia/population/iiv/#see-also","title":"See Also","text":"<ul> <li>IOV - Inter-occasion variability</li> <li>Covariates - Covariate effects on parameters</li> <li>Residual Error - Observation error models</li> <li>Parameter Estimation - Fitting population models</li> </ul>"},{"location":"julia/population/iov/","title":"Inter-Occasion Variability (IOV)","text":"<p>Comprehensive guide for modeling within-subject variability across different dosing occasions.</p>"},{"location":"julia/population/iov/#overview","title":"Overview","text":"<p>Inter-occasion variability (IOV) captures the random fluctuations in an individual's parameters from one dosing occasion to another, representing \"day-to-day\" or \"visit-to-visit\" variability.</p> <pre><code>using OpenPKPDCore\n\n# Define IOV with 15% CV on CL and 10% CV on Ka per occasion\niov = IOVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.0225, :Ka =&gt; 0.01),  # \u03c0\u00b2 values\n    occasion_def = OccasionDefinition(:dose_times)\n)\n</code></pre>"},{"location":"julia/population/iov/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"julia/population/iov/#nested-random-effects","title":"Nested Random Effects","text":"<p>IOV is nested within IIV, meaning each subject has both: - A subject-specific deviation from the population (\u03b7) - Occasion-specific deviations from their individual value (\u03ba)</p> \\[P_{ij} = \\theta \\cdot e^{\\eta_i + \\kappa_{ij}}\\] <p>Where: - \\(P_{ij}\\) = Parameter for subject \\(i\\) on occasion \\(j\\) - \\(\\theta\\) = Population typical value - \\(\\eta_i\\) = IIV random effect, \\(\\eta_i \\sim N(0, \\omega^2)\\) - \\(\\kappa_{ij}\\) = IOV random effect, \\(\\kappa_{ij} \\sim N(0, \\pi^2)\\)</p>"},{"location":"julia/population/iov/#variance-decomposition","title":"Variance Decomposition","text":"<p>Total variance in the log-domain:</p> \\[Var(\\log P_{ij}) = \\omega^2 + \\pi^2\\] <p>Between-subject variance is \\(\\omega^2\\), within-subject variance is \\(\\pi^2\\).</p>"},{"location":"julia/population/iov/#iovspec-structure","title":"IOVSpec Structure","text":""},{"location":"julia/population/iov/#class-definition","title":"Class Definition","text":"<pre><code>struct IOVSpec{K&lt;:RandomEffectKind}\n    kind::K                              # LogNormalIIV()\n    pis::Dict{Symbol, Float64}           # \u03c0\u00b2 values for each parameter\n    seed::Int                            # Random seed\n    occasion_def::OccasionDefinition     # How to define occasions\nend\n\nstruct OccasionDefinition\n    mode::Symbol                         # :dose_times, :custom, :fixed_duration\n    dose_compartment::Int                # CMT for dose-based occasions\n    duration::Float64                    # For fixed duration mode\n    custom_times::Vector{Float64}        # For custom mode\nend\n</code></pre>"},{"location":"julia/population/iov/#creating-iov-specifications","title":"Creating IOV Specifications","text":"<pre><code># IOV based on dose times\niov = IOVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.0225, :Ka =&gt; 0.01),\n    seed = 12345,\n    occasion_def = OccasionDefinition(:dose_times)\n)\n\n# IOV with fixed occasion duration (e.g., weekly)\niov = IOVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.0225),\n    seed = 12345,\n    occasion_def = OccasionDefinition(:fixed_duration, duration=168.0)  # 7 days\n)\n\n# IOV with custom occasion boundaries\niov = IOVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.0225),\n    seed = 12345,\n    occasion_def = OccasionDefinition(:custom, custom_times=[0.0, 24.0, 48.0, 72.0])\n)\n</code></pre>"},{"location":"julia/population/iov/#occasion-determination","title":"Occasion Determination","text":""},{"location":"julia/population/iov/#dose-based-occasions","title":"Dose-Based Occasions","text":"<p>Each dose defines a new occasion:</p> <pre><code># Multiple dose regimen\ndoses = [\n    DoseEvent(0.0, 100.0),    # Occasion 1\n    DoseEvent(24.0, 100.0),   # Occasion 2\n    DoseEvent(48.0, 100.0),   # Occasion 3\n    DoseEvent(72.0, 100.0)    # Occasion 4\n]\n\n# Occasion boundaries at dose times\noccasion_def = OccasionDefinition(:dose_times)\n</code></pre>"},{"location":"julia/population/iov/#fixed-duration-occasions","title":"Fixed Duration Occasions","text":"<pre><code># Weekly dosing with variable timing\n# Still want occasions to align with weeks\noccasion_def = OccasionDefinition(:fixed_duration, duration=168.0)\n\n# For a simulation 0-336 hours:\n# Occasion 1: 0-168 hours\n# Occasion 2: 168-336 hours\n</code></pre>"},{"location":"julia/population/iov/#finding-occasion-at-time","title":"Finding Occasion at Time","text":"<pre><code>function occasion_index_at_time(\n    t::Float64,\n    occasion_def::OccasionDefinition,\n    doses::Vector{DoseEvent}\n)\n    if occasion_def.mode == :dose_times\n        # Find most recent dose\n        occ = 1\n        for (i, dose) in enumerate(doses)\n            if dose.time &lt;= t\n                occ = i\n            end\n        end\n        return occ\n    elseif occasion_def.mode == :fixed_duration\n        return floor(Int, t / occasion_def.duration) + 1\n    elseif occasion_def.mode == :custom\n        for (i, boundary) in enumerate(occasion_def.custom_times)\n            if t &lt; boundary\n                return i\n            end\n        end\n        return length(occasion_def.custom_times)\n    end\nend\n</code></pre>"},{"location":"julia/population/iov/#sampling-iov-kappas","title":"Sampling IOV Kappas","text":""},{"location":"julia/population/iov/#basic-sampling","title":"Basic Sampling","text":"<pre><code>function sample_iov_kappas(\n    pis::Dict{Symbol, Float64},\n    n_subjects::Int,\n    n_occasions::Int;\n    seed::Int = nothing\n)\n    if seed !== nothing\n        Random.seed!(seed)\n    end\n\n    kappas = Dict{Symbol, Matrix{Float64}}()\n    for (param, pi_sq) in pis\n        pi = sqrt(pi_sq)\n        # Matrix: n_subjects \u00d7 n_occasions\n        kappas[param] = randn(n_subjects, n_occasions) .* pi\n    end\n\n    return kappas\nend\n\n# Usage\nkappas = sample_iov_kappas(\n    Dict(:CL =&gt; 0.0225, :Ka =&gt; 0.01),\n    n_subjects = 50,\n    n_occasions = 4,\n    seed = 42\n)\n\n# kappas[:CL] is 50 \u00d7 4 matrix\n# kappas[:CL][i, j] is \u03ba for subject i, occasion j\n</code></pre>"},{"location":"julia/population/iov/#applying-iov","title":"Applying IOV","text":"<pre><code>function apply_iov(\n    base_param::Float64,\n    eta::Float64,          # Subject's IIV\n    kappa::Float64         # Occasion-specific IOV\n)\n    return base_param * exp(eta + kappa)\nend\n\n# Full application\nfunction get_individual_occasion_param(\n    typical::Float64,\n    eta::Float64,\n    kappa::Float64\n)\n    return typical * exp(eta + kappa)\nend\n\n# Example\ntypical_cl = 10.0\neta_cl = 0.2       # Subject has 20% higher CL than typical\nkappa_cl = -0.1    # This occasion 10% lower than subject's average\n\ncl_this_occasion = typical_cl * exp(eta_cl + kappa_cl)\n# = 10.0 * exp(0.2 - 0.1) = 10.0 * exp(0.1) = 11.05 L/hr\n</code></pre>"},{"location":"julia/population/iov/#population-simulation-with-iov","title":"Population Simulation with IOV","text":""},{"location":"julia/population/iov/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\n\n# 1. Define model and parameters\nmodel = TwoCompOral()\ntypical = TwoCompOralParams(\n    Ka = 1.5,\n    CL = 10.0,\n    V1 = 50.0,\n    Q = 5.0,\n    V2 = 100.0\n)\n\n# 2. Define IIV\nomega = OmegaMatrix([\n    0.09 0.0 0.0;    # CL: 30% CV\n    0.0  0.04 0.0;   # V1: 20% CV\n    0.0  0.0 0.16    # Ka: 40% CV\n])\n\niiv = IIVSpec(\n    LogNormalIIV(),\n    omega_matrix = omega,\n    seed = 12345,\n    n = 50\n)\n\n# 3. Define IOV\niov = IOVSpec(\n    LogNormalIIV(),\n    Dict(:CL =&gt; 0.0225, :Ka =&gt; 0.01),  # 15% on CL, 10% on Ka\n    seed = 54321,\n    occasion_def = OccasionDefinition(:dose_times)\n)\n\n# 4. Multiple dose regimen (4 occasions)\ndoses = [\n    DoseEvent(0.0, 100.0),\n    DoseEvent(24.0, 100.0),\n    DoseEvent(48.0, 100.0),\n    DoseEvent(72.0, 100.0)\n]\n\n# 5. Create specifications\nbase_spec = ModelSpec(model, \"iov_demo\", typical, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    iiv = iiv,\n    iov = iov\n)\n\n# 6. Simulate\ngrid = SimGrid(0.0, 96.0, collect(0.0:0.5:96.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nresult = simulate_population(pop_spec, grid, solver)\n</code></pre>"},{"location":"julia/population/iov/#accessing-iov-results","title":"Accessing IOV Results","text":"<pre><code># Parameters vary by occasion for each subject\nfor (i, subject) in enumerate(result.individuals[1:3])\n    println(\"Subject $i:\")\n    for occ in 1:4\n        # Get parameters at a time point in this occasion\n        t = occ * 24.0 - 12.0  # Middle of each occasion\n        params = result.occasion_params[i][occ]\n        println(\"  Occasion $occ: CL=$(round(params[:CL], digits=2)), Ka=$(round(params[:Ka], digits=2))\")\n    end\nend\n</code></pre>"},{"location":"julia/population/iov/#iov-vs-iiv-comparison","title":"IOV vs IIV Comparison","text":""},{"location":"julia/population/iov/#typical-magnitude-relationships","title":"Typical Magnitude Relationships","text":"Variability Typical CV Represents IIV (\u03c9) 20-50% Between-subject differences IOV (\u03c0) 10-25% Within-subject fluctuation Residual (\u03c3) 10-30% Measurement/model error"},{"location":"julia/population/iov/#rule-of-thumb","title":"Rule of Thumb","text":"<p>IOV is typically smaller than IIV (often 30-50% of the IIV magnitude):</p> <pre><code># If IIV CV is 30%\nomega_cl = 0.09  # \u03c9\u00b2 for ~30% CV\n\n# IOV might be 15% (half of IIV)\npi_cl = 0.0225   # \u03c0\u00b2 for ~15% CV\n</code></pre>"},{"location":"julia/population/iov/#when-to-include-iov","title":"When to Include IOV","text":""},{"location":"julia/population/iov/#strong-candidates-for-iov","title":"Strong Candidates for IOV","text":"<ol> <li>Absorption parameters (Ka, F)</li> <li>Food effects</li> <li>Formulation dissolution variability</li> <li> <p>GI motility changes</p> </li> <li> <p>Clearance (CL)</p> </li> <li>Enzyme activity fluctuations</li> <li>Time-of-day effects</li> <li> <p>Disease state changes</p> </li> <li> <p>First-pass effect (FG, FH)</p> </li> <li>Hepatic blood flow changes</li> <li>Enzyme induction/inhibition</li> </ol>"},{"location":"julia/population/iov/#less-common","title":"Less Common","text":"<ol> <li>Volumes (V, V2)</li> <li>Usually more stable</li> <li> <p>Body composition doesn't change quickly</p> </li> <li> <p>Distribution (Q)</p> </li> <li>Relatively stable physiological parameter</li> </ol>"},{"location":"julia/population/iov/#model-diagnostics-with-iov","title":"Model Diagnostics with IOV","text":""},{"location":"julia/population/iov/#detecting-need-for-iov","title":"Detecting Need for IOV","text":"<pre><code># Signs that IOV may be needed:\n# 1. High residual variability despite good IIV fit\n# 2. Individual plots show period-to-period variation\n# 3. CWRES show patterns within subjects over time\n\n# Compare models\nmodel_no_iov = fit_population(data, spec_no_iov)\nmodel_with_iov = fit_population(data, spec_with_iov)\n\n# Likelihood ratio test\ndelta_ofv = model_no_iov.ofv - model_with_iov.ofv\nn_additional_params = 2  # Added \u03c0\u00b2 parameters\np_value = 1 - cdf(Chisq(n_additional_params), delta_ofv)\n\nif p_value &lt; 0.05\n    println(\"IOV significantly improves fit (p = $(round(p_value, digits=4)))\")\nend\n</code></pre>"},{"location":"julia/population/iov/#kappa-shrinkage","title":"Kappa Shrinkage","text":"<pre><code>function calculate_kappa_shrinkage(\n    kappas::Matrix{Float64},  # n_subjects \u00d7 n_occasions\n    pi_sq::Float64\n)\n    # Pool all kappas\n    all_kappas = vec(kappas)\n    var_kappa = var(all_kappas)\n    shrinkage = 1 - sqrt(var_kappa) / sqrt(pi_sq)\n    return shrinkage * 100\nend\n\n# High kappa shrinkage indicates:\n# - Few observations per occasion\n# - Low IOV relative to residual error\n# - Difficulty distinguishing IOV from noise\n</code></pre>"},{"location":"julia/population/iov/#complete-example_1","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Statistics\n\n# ============================================\n# Multiple Dose Simulation with IIV and IOV\n# ============================================\n\nprintln(\"=== Population PK with IIV + IOV ===\\n\")\n\n# 1. Model and parameters\nmodel = OneCompOral()\ntypical = OneCompOralParams(\n    Ka = 1.2,\n    CL = 8.0,\n    V = 60.0\n)\n\n# 2. IIV specification (between-subject)\nprintln(\"--- Inter-Individual Variability ---\")\nomega = OmegaMatrix([\n    0.09 0.0;    # CL: 30% CV\n    0.16 0.0;    # Ka: 40% CV\n    0.0  0.04    # V:  20% CV\n])\n\niiv = IIVSpec(LogNormalIIV(), omega_matrix=omega, seed=111, n=40)\n\nfor param in [:CL, :Ka, :V]\n    cv = sqrt(exp(omega.matrix[findfirst(==(param), omega.param_names), findfirst(==(param), omega.param_names)]) - 1) * 100\n    println(\"  $(param): $(round(cv, digits=1))% CV\")\nend\n\n# 3. IOV specification (within-subject)\nprintln(\"\\n--- Inter-Occasion Variability ---\")\npis = Dict(:CL =&gt; 0.0225, :Ka =&gt; 0.01)  # 15% on CL, 10% on Ka\niov = IOVSpec(\n    LogNormalIIV(),\n    pis,\n    seed = 222,\n    occasion_def = OccasionDefinition(:dose_times)\n)\n\nfor (param, pi) in pis\n    cv = sqrt(exp(pi) - 1) * 100\n    println(\"  $(param): $(round(cv, digits=1))% CV\")\nend\n\n# 4. Multiple dose regimen (7 days QD)\nn_occasions = 7\ndoses = [DoseEvent(i * 24.0, 500.0) for i in 0:n_occasions-1]\n\nprintln(\"\\n--- Dosing Regimen ---\")\nprintln(\"  $(n_occasions) doses of 500 mg QD\")\n\n# 5. Simulation\nbase_spec = ModelSpec(model, \"iov_example\", typical, doses)\npop_spec = PopulationSpec(base_spec, iiv=iiv, iov=iov)\n\ngrid = SimGrid(0.0, 168.0, collect(0.0:0.5:168.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\nprintln(\"\\n--- Running Simulation ---\")\nresult = simulate_population(pop_spec, grid, solver)\nprintln(\"Simulated $(length(result.individuals)) subjects over $(n_occasions) occasions\")\n\n# 6. Analyze occasion-to-occasion variability for one subject\nprintln(\"\\n--- Example Subject (ID=1) ---\")\nsubject = 1\nprintln(\"Base CL (with IIV): $(round(result.params[subject][:CL], digits=2)) L/hr\")\n\nfor occ in 1:n_occasions\n    occ_params = result.occasion_params[subject][occ]\n    println(\"  Occasion $occ: CL=$(round(occ_params[:CL], digits=2)), Ka=$(round(occ_params[:Ka], digits=2))\")\nend\n\n# 7. Calculate observed variability\nprintln(\"\\n--- Observed Variability ---\")\n\n# Between-subject: variability in subject means\nsubject_mean_cmax = Float64[]\nfor ind in result.individuals\n    # Get Cmax from last occasion (steady-state)\n    t_start = (n_occasions - 1) * 24.0\n    t_end = n_occasions * 24.0\n    indices = findall(t -&gt; t_start &lt;= t &lt;= t_end, ind.times)\n    push!(subject_mean_cmax, maximum(ind.observations[:conc][indices]))\nend\ncv_between = std(subject_mean_cmax) / mean(subject_mean_cmax) * 100\nprintln(\"Between-subject CV(Cmax at SS): $(round(cv_between, digits=1))%\")\n\n# Within-subject: variability across occasions for each subject\ncv_within_values = Float64[]\nfor ind in result.individuals\n    occasion_cmax = Float64[]\n    for occ in 1:n_occasions\n        t_start = (occ - 1) * 24.0\n        t_end = occ * 24.0\n        indices = findall(t -&gt; t_start &lt;= t &lt; t_end, ind.times)\n        push!(occasion_cmax, maximum(ind.observations[:conc][indices]))\n    end\n    cv_occ = std(occasion_cmax) / mean(occasion_cmax) * 100\n    push!(cv_within_values, cv_occ)\nend\ncv_within = mean(cv_within_values)\nprintln(\"Within-subject CV(Cmax): $(round(cv_within, digits=1))%\")\n\n# 8. Population summary at steady state\nprintln(\"\\n--- Steady-State Summary (Last Occasion) ---\")\nss_cmax = Float64[]\nfor ind in result.individuals\n    t_start = (n_occasions - 1) * 24.0\n    indices = findall(t -&gt; t &gt;= t_start, ind.times)\n    push!(ss_cmax, maximum(ind.observations[:conc][indices]))\nend\n\nprintln(\"Cmax,ss: $(round(mean(ss_cmax), digits=2)) \u00b1 $(round(std(ss_cmax), digits=2)) mg/L\")\nprintln(\"5th percentile: $(round(quantile(ss_cmax, 0.05), digits=2)) mg/L\")\nprintln(\"95th percentile: $(round(quantile(ss_cmax, 0.95), digits=2)) mg/L\")\n</code></pre>"},{"location":"julia/population/iov/#see-also","title":"See Also","text":"<ul> <li>IIV - Inter-individual variability</li> <li>Covariates - Covariate effects</li> <li>Residual Error - Observation error</li> <li>Multiple Dose NCA - Steady-state analysis</li> </ul>"},{"location":"julia/population/residual-error/","title":"Residual Error Models","text":"<p>Comprehensive guide for modeling unexplained variability in observations.</p>"},{"location":"julia/population/residual-error/#overview","title":"Overview","text":"<p>Residual error models describe the discrepancy between model predictions and observed data, encompassing measurement error, model misspecification, and other unexplained variability.</p> <pre><code>using OpenPKPDCore\n\n# Proportional error (10% CV)\nerror_model = ResidualErrorSpec(\n    ProportionalError(),\n    ProportionalErrorParams(0.10)\n)\n</code></pre>"},{"location":"julia/population/residual-error/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"julia/population/residual-error/#general-form","title":"General Form","text":"<p>Observed concentration relates to predicted concentration:</p> \\[Y_{ij} = F_{ij} + g(F_{ij}, \\sigma) \\cdot \\varepsilon_{ij}\\] <p>Where: - \\(Y_{ij}\\) = Observed concentration for subject \\(i\\) at time \\(j\\) - \\(F_{ij}\\) = Model-predicted concentration (IPRED) - \\(g()\\) = Error magnitude function - \\(\\varepsilon_{ij}\\) = Standard normal random variable, \\(\\varepsilon \\sim N(0, 1)\\) - \\(\\sigma\\) = Error parameter(s)</p>"},{"location":"julia/population/residual-error/#error-model-types","title":"Error Model Types","text":""},{"location":"julia/population/residual-error/#additive-error","title":"Additive Error","text":"<p>Constant error magnitude regardless of concentration:</p> \\[Y = F + \\sigma_{add} \\cdot \\varepsilon\\] <pre><code># Additive error: SD = 0.5 mg/L\nadditive = ResidualErrorSpec(\n    AdditiveError(),\n    AdditiveErrorParams(0.5)\n)\n\n# Variance is constant: Var(Y) = \u03c3\u00b2_add = 0.25\n</code></pre> <p>When to use: - Low concentration range - Assay precision limited by detection - When CV increases at low concentrations</p>"},{"location":"julia/population/residual-error/#proportional-error","title":"Proportional Error","text":"<p>Error scales with prediction (constant CV):</p> \\[Y = F \\cdot (1 + \\sigma_{prop} \\cdot \\varepsilon)\\] <pre><code># Proportional error: CV = 15%\nproportional = ResidualErrorSpec(\n    ProportionalError(),\n    ProportionalErrorParams(0.15)\n)\n\n# SD scales with prediction: SD(Y) = F \u00d7 \u03c3_prop\n# CV is constant: CV(Y) = \u03c3_prop = 15%\n</code></pre> <p>When to use: - Wide concentration range - Consistent assay CV across range - Most common for PK data</p>"},{"location":"julia/population/residual-error/#combined-error","title":"Combined Error","text":"<p>Both additive and proportional components:</p> \\[Y = F + \\sqrt{\\sigma^2_{add} + (\\sigma_{prop} \\cdot F)^2} \\cdot \\varepsilon\\] <pre><code># Combined: additive SD = 0.1, proportional CV = 10%\ncombined = ResidualErrorSpec(\n    CombinedError(),\n    CombinedErrorParams(0.1, 0.10)\n)\n\n# Variance: Var(Y) = \u03c3\u00b2_add + (\u03c3_prop \u00d7 F)\u00b2\n# CV decreases at higher concentrations\n</code></pre> <p>When to use: - Wide dynamic range - Higher CV at low concentrations - Most flexible model</p>"},{"location":"julia/population/residual-error/#exponential-log-normal-error","title":"Exponential (Log-Normal) Error","text":"<p>Error on log scale (multiplicative):</p> \\[Y = F \\cdot e^{\\sigma_{exp} \\cdot \\varepsilon}\\] <p>Or equivalently: $\\(\\log(Y) = \\log(F) + \\sigma_{exp} \\cdot \\varepsilon\\)$</p> <pre><code># Exponential error: 20% CV approximately\nexponential = ResidualErrorSpec(\n    ExponentialError(),\n    ExponentialErrorParams(0.20)\n)\n\n# Assumes log(Y) normally distributed\n# Appropriate for log-transformed data\n</code></pre> <p>When to use: - Log-transformed data analysis - Right-skewed residuals on natural scale - Common in bioequivalence</p>"},{"location":"julia/population/residual-error/#error-parameter-structures","title":"Error Parameter Structures","text":""},{"location":"julia/population/residual-error/#additiveerrorparams","title":"AdditiveErrorParams","text":"<pre><code>struct AdditiveErrorParams\n    sigma::Float64    # Standard deviation (same units as observation)\nend\n\n# Example: If concentration in mg/L\nparams = AdditiveErrorParams(0.5)  # SD = 0.5 mg/L\n</code></pre>"},{"location":"julia/population/residual-error/#proportionalerrorparams","title":"ProportionalErrorParams","text":"<pre><code>struct ProportionalErrorParams\n    sigma::Float64    # Proportional error (as fraction, not %)\nend\n\n# Example: 15% CV\nparams = ProportionalErrorParams(0.15)  # \u03c3 = 0.15, not 15\n</code></pre>"},{"location":"julia/population/residual-error/#combinederrorparams","title":"CombinedErrorParams","text":"<pre><code>struct CombinedErrorParams\n    sigma_add::Float64    # Additive SD\n    sigma_prop::Float64   # Proportional fraction\nend\n\n# Example: SD = 0.1 mg/L + 10% CV\nparams = CombinedErrorParams(0.1, 0.10)\n</code></pre>"},{"location":"julia/population/residual-error/#exponentialerrorparams","title":"ExponentialErrorParams","text":"<pre><code>struct ExponentialErrorParams\n    sigma::Float64    # SD on log scale\nend\n\n# Example: ~20% CV\nparams = ExponentialErrorParams(0.20)\n</code></pre>"},{"location":"julia/population/residual-error/#residualerrorspec-structure","title":"ResidualErrorSpec Structure","text":""},{"location":"julia/population/residual-error/#class-definition","title":"Class Definition","text":"<pre><code>struct ResidualErrorSpec{K&lt;:ErrorModelKind, P&lt;:ErrorParams}\n    kind::K           # AdditiveError(), ProportionalError(), etc.\n    params::P         # Error parameters\n    seed::Int         # Random seed for reproducibility\nend\n</code></pre>"},{"location":"julia/population/residual-error/#creating-specifications","title":"Creating Specifications","text":"<pre><code># Proportional with seed\nerror_spec = ResidualErrorSpec(\n    ProportionalError(),\n    ProportionalErrorParams(0.12),\n    seed = 54321\n)\n\n# Combined without seed (random)\nerror_spec = ResidualErrorSpec(\n    CombinedError(),\n    CombinedErrorParams(0.05, 0.08)\n)\n</code></pre>"},{"location":"julia/population/residual-error/#computing-error-components","title":"Computing Error Components","text":""},{"location":"julia/population/residual-error/#variance-functions","title":"Variance Functions","text":"<pre><code># Compute variance at a prediction\nfunction residual_variance(\n    f::Float64,\n    params::AdditiveErrorParams\n)\n    return params.sigma^2\nend\n\nfunction residual_variance(\n    f::Float64,\n    params::ProportionalErrorParams\n)\n    return (params.sigma * f)^2\nend\n\nfunction residual_variance(\n    f::Float64,\n    params::CombinedErrorParams\n)\n    return params.sigma_add^2 + (params.sigma_prop * f)^2\nend\n\nfunction residual_variance(\n    f::Float64,\n    params::ExponentialErrorParams\n)\n    # Variance on natural scale (approximation)\n    return (f * params.sigma)^2\nend\n</code></pre>"},{"location":"julia/population/residual-error/#standard-deviation-functions","title":"Standard Deviation Functions","text":"<pre><code>function residual_sd(f::Float64, params)\n    return sqrt(residual_variance(f, params))\nend\n\n# Example usage\nf = 5.0  # Predicted concentration\nparams = CombinedErrorParams(0.1, 0.10)\n\nsd = residual_sd(f, params)\n# SD = \u221a(0.1\u00b2 + (0.10 \u00d7 5.0)\u00b2) = \u221a(0.01 + 0.25) = \u221a0.26 = 0.51\n</code></pre>"},{"location":"julia/population/residual-error/#applying-residual-error","title":"Applying Residual Error","text":""},{"location":"julia/population/residual-error/#adding-error-to-predictions","title":"Adding Error to Predictions","text":"<pre><code>using Random\n\nfunction apply_residual_error(\n    predictions::Vector{Float64},\n    error_spec::ResidualErrorSpec;\n    seed::Int = nothing\n)\n    if seed !== nothing\n        Random.seed!(seed)\n    end\n\n    n = length(predictions)\n    observations = similar(predictions)\n    epsilons = randn(n)\n\n    for i in 1:n\n        sd = residual_sd(predictions[i], error_spec.params)\n        observations[i] = predictions[i] + sd * epsilons[i]\n    end\n\n    return observations\nend\n\n# Example\npreds = [10.0, 8.0, 5.0, 2.0, 1.0]\nerror = ResidualErrorSpec(ProportionalError(), ProportionalErrorParams(0.10))\n\nobs = apply_residual_error(preds, error, seed=42)\n</code></pre>"},{"location":"julia/population/residual-error/#type-specific-application","title":"Type-Specific Application","text":"<pre><code># Additive\nfunction apply_error(f::Float64, eps::Float64, params::AdditiveErrorParams)\n    return f + params.sigma * eps\nend\n\n# Proportional\nfunction apply_error(f::Float64, eps::Float64, params::ProportionalErrorParams)\n    return f * (1 + params.sigma * eps)\nend\n\n# Combined\nfunction apply_error(f::Float64, eps::Float64, params::CombinedErrorParams)\n    sd = sqrt(params.sigma_add^2 + (params.sigma_prop * f)^2)\n    return f + sd * eps\nend\n\n# Exponential\nfunction apply_error(f::Float64, eps::Float64, params::ExponentialErrorParams)\n    return f * exp(params.sigma * eps)\nend\n</code></pre>"},{"location":"julia/population/residual-error/#weighted-residuals","title":"Weighted Residuals","text":""},{"location":"julia/population/residual-error/#individual-weighted-residuals-iwres","title":"Individual Weighted Residuals (IWRES)","text":"<p>Standardized residuals using individual predictions:</p> \\[IWRES_{ij} = \\frac{Y_{ij} - IPRED_{ij}}{SD(Y|IPRED_{ij})}\\] <pre><code>function compute_iwres(\n    observed::Float64,\n    ipred::Float64,\n    error_params\n)\n    sd = residual_sd(ipred, error_params)\n    return (observed - ipred) / sd\nend\n\n# Should be approximately N(0,1) for good fit\n</code></pre>"},{"location":"julia/population/residual-error/#conditional-weighted-residuals-cwres","title":"Conditional Weighted Residuals (CWRES)","text":"<p>More sophisticated residuals accounting for random effects:</p> <pre><code>function compute_cwres(\n    observed::Vector{Float64},\n    pred::Vector{Float64},      # Population predictions\n    ipred::Vector{Float64},     # Individual predictions\n    error_params,\n    omega::OmegaMatrix\n)\n    n = length(observed)\n    cwres = similar(observed)\n\n    for i in 1:n\n        # Approximation using FOCE method\n        var_y = residual_variance(pred[i], error_params)\n        # Additional variance from random effects\n        # (simplified - full implementation more complex)\n        cwres[i] = (observed[i] - pred[i]) / sqrt(var_y)\n    end\n\n    return cwres\nend\n</code></pre>"},{"location":"julia/population/residual-error/#model-diagnostics","title":"Model Diagnostics","text":""},{"location":"julia/population/residual-error/#residual-plots","title":"Residual Plots","text":"<pre><code># Key diagnostic plots for error model assessment:\n\n# 1. IWRES vs Time\n# - Should be randomly scattered around 0\n# - Patterns indicate model misspecification\n\n# 2. IWRES vs IPRED\n# - Should be randomly scattered around 0\n# - Funnel shape suggests wrong error model\n\n# 3. |IWRES| vs IPRED\n# - Should be flat\n# - Increasing trend: need proportional component\n# - Decreasing trend: proportional over-estimated\n\n# 4. QQ plot of IWRES\n# - Should follow 45\u00b0 line\n# - Deviations indicate non-normal residuals\n</code></pre>"},{"location":"julia/population/residual-error/#choosing-error-model","title":"Choosing Error Model","text":"<pre><code># Compare error models using likelihood\nfunction compare_error_models(\n    data::PopulationData,\n    base_model::PopulationModel,\n    error_specs::Vector{ResidualErrorSpec}\n)\n    results = []\n\n    for error in error_specs\n        model = set_error_model(base_model, error)\n        fit = fit_population(data, model)\n\n        push!(results, (\n            error_type = typeof(error.kind),\n            n_params = count_error_params(error),\n            ofv = fit.ofv,\n            aic = fit.ofv + 2 * count_error_params(error)\n        ))\n    end\n\n    # Sort by AIC\n    sort!(results, by = r -&gt; r.aic)\n\n    return results\nend\n</code></pre>"},{"location":"julia/population/residual-error/#multi-observation-error","title":"Multi-Observation Error","text":""},{"location":"julia/population/residual-error/#different-error-for-different-outputs","title":"Different Error for Different Outputs","text":"<pre><code># PK and PD may have different error models\nstruct MultiErrorSpec\n    errors::Dict{Symbol, ResidualErrorSpec}\nend\n\nmulti_error = MultiErrorSpec(Dict(\n    :conc =&gt; ResidualErrorSpec(ProportionalError(), ProportionalErrorParams(0.10)),\n    :effect =&gt; ResidualErrorSpec(AdditiveError(), AdditiveErrorParams(5.0))\n))\n</code></pre>"},{"location":"julia/population/residual-error/#multiple-analytes","title":"Multiple Analytes","text":"<pre><code># Parent drug and metabolite\nanalyte_errors = Dict(\n    :parent =&gt; ResidualErrorSpec(CombinedError(), CombinedErrorParams(0.05, 0.08)),\n    :metabolite =&gt; ResidualErrorSpec(ProportionalError(), ProportionalErrorParams(0.15))\n)\n</code></pre>"},{"location":"julia/population/residual-error/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Statistics\nusing Random\n\n# ============================================\n# Residual Error Model Demonstration\n# ============================================\n\nprintln(\"=== Residual Error Models ===\\n\")\n\n# 1. Generate true PK profile\ntypical_cl = 10.0\ntypical_v = 50.0\ndose = 500.0\ntimes = collect(0.0:0.5:24.0)\n\n# True concentrations (one-compartment IV bolus)\nke = typical_cl / typical_v\ntrue_conc = (dose / typical_v) .* exp.(-ke .* times)\n\nprintln(\"--- True Concentration Profile ---\")\nprintln(\"Cmax: $(round(maximum(true_conc), digits=2)) mg/L\")\nprintln(\"t1/2: $(round(log(2)/ke, digits=2)) hr\")\n\n# 2. Define different error models\nerror_models = [\n    (\"Additive (0.5 mg/L)\", ResidualErrorSpec(AdditiveError(), AdditiveErrorParams(0.5))),\n    (\"Proportional (15%)\", ResidualErrorSpec(ProportionalError(), ProportionalErrorParams(0.15))),\n    (\"Combined (0.2 + 10%)\", ResidualErrorSpec(CombinedError(), CombinedErrorParams(0.2, 0.10))),\n    (\"Exponential (15%)\", ResidualErrorSpec(ExponentialError(), ExponentialErrorParams(0.15)))\n]\n\n# 3. Simulate observations with each error model\nRandom.seed!(42)\n\nprintln(\"\\n--- Error Model Comparison ---\")\nprintln(\"Time points: $(length(times))\")\nprintln(\"\")\n\nfor (name, error_spec) in error_models\n    # Generate observations\n    obs = apply_residual_error(true_conc, error_spec, seed=42)\n\n    # Calculate residuals\n    residuals = obs .- true_conc\n\n    # Calculate metrics\n    rmse = sqrt(mean(residuals.^2))\n    mae = mean(abs.(residuals))\n\n    # CV at different concentration levels\n    high_idx = findall(true_conc .&gt; 5.0)\n    low_idx = findall(0.5 .&lt; true_conc .&lt;= 2.0)\n\n    cv_high = std(obs[high_idx] .- true_conc[high_idx]) / mean(true_conc[high_idx]) * 100\n    cv_low = std(obs[low_idx] .- true_conc[low_idx]) / mean(true_conc[low_idx]) * 100\n\n    println(\"$name:\")\n    println(\"  RMSE: $(round(rmse, digits=3)) mg/L\")\n    println(\"  MAE:  $(round(mae, digits=3)) mg/L\")\n    println(\"  CV at high conc: $(round(cv_high, digits=1))%\")\n    println(\"  CV at low conc:  $(round(cv_low, digits=1))%\")\n    println(\"\")\nend\n\n# 4. Detailed analysis of combined error\nprintln(\"--- Combined Error Analysis ---\")\ncombined = ResidualErrorSpec(CombinedError(), CombinedErrorParams(0.2, 0.10))\n\n# Show how SD changes with concentration\nprintln(\"SD by concentration:\")\nfor conc in [10.0, 5.0, 2.0, 1.0, 0.5]\n    sd = residual_sd(conc, combined.params)\n    cv = sd / conc * 100\n    println(\"  Conc = $conc: SD = $(round(sd, digits=3)), CV = $(round(cv, digits=1))%\")\nend\n\n# 5. Compute IWRES\nprintln(\"\\n--- IWRES Analysis ---\")\nobs = apply_residual_error(true_conc, combined, seed=123)\niwres = [(obs[i] - true_conc[i]) / residual_sd(true_conc[i], combined.params) for i in 1:length(obs)]\n\nprintln(\"IWRES statistics:\")\nprintln(\"  Mean: $(round(mean(iwres), digits=4)) (should be ~0)\")\nprintln(\"  SD:   $(round(std(iwres), digits=4)) (should be ~1)\")\nprintln(\"  Min:  $(round(minimum(iwres), digits=2))\")\nprintln(\"  Max:  $(round(maximum(iwres), digits=2))\")\n\n# Check normality\nsorted_iwres = sort(iwres)\nn = length(iwres)\nexpected_quantiles = [quantile(Normal(), (i - 0.5)/n) for i in 1:n]\n\n# Correlation for QQ plot (should be close to 1)\nqq_corr = cor(sorted_iwres, expected_quantiles)\nprintln(\"  QQ correlation: $(round(qq_corr, digits=4)) (should be ~1)\")\n\n# 6. Population simulation with error\nprintln(\"\\n--- Population Simulation with Error ---\")\n\n# Simulate 100 subjects\nn_subjects = 100\nomega = OmegaMatrix([0.09 0.0; 0.0 0.04])  # IIV on CL and V\n\n# Sample etas\nRandom.seed!(42)\neta_cl = randn(n_subjects) .* sqrt(0.09)\neta_v = randn(n_subjects) .* sqrt(0.04)\n\n# Simulate each subject\nall_obs = Matrix{Float64}(undef, n_subjects, length(times))\nall_pred = Matrix{Float64}(undef, n_subjects, length(times))\n\nfor i in 1:n_subjects\n    ind_cl = typical_cl * exp(eta_cl[i])\n    ind_v = typical_v * exp(eta_v[i])\n    ind_ke = ind_cl / ind_v\n\n    # Individual predictions\n    pred = (dose / ind_v) .* exp.(-ind_ke .* times)\n    all_pred[i, :] = pred\n\n    # Add residual error\n    all_obs[i, :] = apply_residual_error(pred, combined)\nend\n\n# Summary statistics\nmean_obs = vec(mean(all_obs, dims=1))\nsd_obs = vec(std(all_obs, dims=1))\ncv_obs = sd_obs ./ mean_obs .* 100\n\nprintln(\"Observed concentration summary:\")\nprintln(\"  Mean Cmax: $(round(maximum(mean_obs), digits=2)) mg/L\")\nprintln(\"  CV at Cmax: $(round(cv_obs[1], digits=1))%\")\nprintln(\"  CV at t=12h: $(round(cv_obs[findfirst(==(12.0), times)], digits=1))%\")\n\n# Partition variance\nprintln(\"\\n--- Variance Components ---\")\n# Total variance = IIV variance + Residual variance\nt_idx = 10  # Example time point\ntotal_var = var(all_obs[:, t_idx])\npred_mean = mean(all_pred[:, t_idx])\niiv_var = var(all_pred[:, t_idx])\nres_var = residual_variance(pred_mean, combined.params)\n\nprintln(\"At t=$(times[t_idx]) hr:\")\nprintln(\"  Total variance: $(round(total_var, digits=3))\")\nprintln(\"  IIV variance:   $(round(iiv_var, digits=3)) ($(round(iiv_var/total_var*100, digits=1))%)\")\nprintln(\"  Residual var:   $(round(res_var, digits=3)) ($(round(res_var/total_var*100, digits=1))%)\")\n</code></pre>"},{"location":"julia/population/residual-error/#error-model-selection-guide","title":"Error Model Selection Guide","text":"Scenario Recommended Model Rationale Wide conc range, constant CV Proportional Simplest when CV uniform Low conc near LLOQ Additive or Combined Accounts for detection limit Very wide range (&gt;100-fold) Combined Flexible across all levels Log-transformed analysis Exponential Matches log-normal assumption PD response data Often Additive Response often has fixed precision Count data Special models Poisson or negative binomial"},{"location":"julia/population/residual-error/#see-also","title":"See Also","text":"<ul> <li>IIV - Inter-individual variability</li> <li>IOV - Inter-occasion variability</li> <li>Covariates - Covariate effects</li> <li>Estimation Diagnostics - Model evaluation</li> </ul>"},{"location":"julia/trial/","title":"Clinical Trial Simulation","text":"<p>OpenPKPD provides comprehensive clinical trial simulation capabilities for study design, power analysis, and decision-making.</p>"},{"location":"julia/trial/#overview","title":"Overview","text":"<p>Clinical trial simulation enables:</p> <ul> <li>Virtual trial execution before enrollment</li> <li>Power and sample size estimation</li> <li>Study design optimization</li> <li>Risk assessment and mitigation</li> </ul> <pre><code>graph TB\n    A[Define Design] --&gt; B[Generate Population]\n    B --&gt; C[Apply Dosing]\n    C --&gt; D[Simulate PK/PD]\n    D --&gt; E[Evaluate Endpoints]\n    E --&gt; F[Statistical Analysis]\n    F --&gt; G[Decision Metrics]\n</code></pre>"},{"location":"julia/trial/#trial-types","title":"Trial Types","text":"<ul> <li> <p> Parallel Design</p> <p>Independent treatment groups</p> <p> Parallel</p> </li> <li> <p> Crossover Design</p> <p>Within-subject comparisons</p> <p> Crossover</p> </li> <li> <p> Dose Escalation</p> <p>3+3, mTPI, CRM designs</p> <p> Escalation</p> </li> <li> <p> Power Analysis</p> <p>Sample size and power estimation</p> <p> Power</p> </li> </ul>"},{"location":"julia/trial/#quick-start","title":"Quick Start","text":""},{"location":"julia/trial/#parallel-design","title":"Parallel Design","text":"<pre><code>using OpenPKPDCore\n\n# Define trial design\ndesign = ParallelDesign(\n    n_arms = 3,\n    arm_names = [\"Placebo\", \"Low Dose\", \"High Dose\"],\n    randomization_ratio = [1, 1, 1]\n)\n\n# Define dosing regimens\nregimens = [\n    DosingRegimen(0.0, 28, 24.0),      # Placebo\n    DosingRegimen(50.0, 28, 24.0),     # 50 mg QD\n    DosingRegimen(100.0, 28, 24.0)     # 100 mg QD\n]\n\n# Generate virtual population\npopulation = generate_population(\n    n = 150,                           # Total subjects\n    spec = HealthyVolunteerSpec(),\n    seed = 42\n)\n\n# Define trial specification\ntrial = TrialSpec(\n    name = \"Phase 2 Dose Finding\",\n    design = design,\n    regimens = regimens,\n    population = population,\n    pk_model = OneCompIVBolus(),\n    pk_params = OneCompIVBolusParams(5.0, 50.0),\n    omega = OmegaMatrix([0.09 0.0; 0.0 0.04])\n)\n\n# Run simulation\nresult = simulate_trial(trial, seed = 12345)\n\n# Analyze results\nfor arm in result.arms\n    println(\"$(arm.name): n=$(arm.n_completed), mean_auc=$(arm.mean_auc)\")\nend\n</code></pre>"},{"location":"julia/trial/#crossover-design","title":"Crossover Design","text":"<pre><code># 2\u00d72 crossover\ndesign = CrossoverDesign(\n    n_periods = 2,\n    n_sequences = 2,\n    sequences = [[\"A\", \"B\"], [\"B\", \"A\"]],\n    washout_days = 14\n)\n\n# Generate balanced population\npopulation = generate_population(\n    n = 24,                            # 12 per sequence\n    spec = HealthyVolunteerSpec(),\n    seed = 42\n)\n\ntrial = TrialSpec(\n    name = \"BE Crossover\",\n    design = design,\n    population = population,\n    ...\n)\n\nresult = simulate_trial(trial, seed = 12345)\n</code></pre>"},{"location":"julia/trial/#population-generation","title":"Population Generation","text":""},{"location":"julia/trial/#demographics","title":"Demographics","text":"<pre><code># Healthy volunteer specification\nspec = DemographicSpec(\n    age_mean = 35.0,\n    age_sd = 10.0,\n    age_min = 18.0,\n    age_max = 55.0,\n    weight_mean = 75.0,\n    weight_sd = 12.0,\n    weight_min = 50.0,\n    weight_max = 100.0,\n    female_fraction = 0.5,\n    race_distribution = Dict(\n        \"white\" =&gt; 0.7,\n        \"black\" =&gt; 0.15,\n        \"asian\" =&gt; 0.10,\n        \"other\" =&gt; 0.05\n    )\n)\n\npop = generate_population(n = 100, spec = spec, seed = 42)\n</code></pre>"},{"location":"julia/trial/#patient-population","title":"Patient Population","text":"<pre><code># Renal impairment study\nspec = DemographicSpec(\n    age_mean = 65.0,\n    age_sd = 12.0,\n    age_min = 18.0,\n    age_max = 85.0,\n    egfr_distribution = Dict(\n        \"normal\" =&gt; 0.0,           # eGFR \u2265 90\n        \"mild\" =&gt; 0.33,            # eGFR 60-89\n        \"moderate\" =&gt; 0.34,        # eGFR 30-59\n        \"severe\" =&gt; 0.33           # eGFR 15-29\n    )\n)\n</code></pre>"},{"location":"julia/trial/#dosing-regimens","title":"Dosing Regimens","text":"<pre><code># Once daily\nregimen = dosing_qd(dose = 100.0, days = 28)\n\n# Twice daily\nregimen = dosing_bid(dose = 50.0, days = 14)\n\n# Custom schedule\nregimen = DosingRegimen(\n    doses = [100.0, 100.0, 100.0],\n    times = [0.0, 8.0, 16.0],\n    repeat_days = 7\n)\n\n# Titration\nregimen = TitrationRegimen(\n    start_dose = 25.0,\n    target_dose = 100.0,\n    steps = [25, 50, 75, 100],\n    days_per_step = 7\n)\n</code></pre>"},{"location":"julia/trial/#power-analysis","title":"Power Analysis","text":""},{"location":"julia/trial/#analytical-power","title":"Analytical Power","text":"<pre><code># Calculate power for given sample size\npower = estimate_power(\n    n_per_arm = 50,\n    effect_size = 0.5,          # Cohen's d\n    sd = 1.0,\n    alpha = 0.05,\n    test = :two_sample_t\n)\n\nprintln(\"Power: \", power.power)\nprintln(\"Effect size: \", power.effect_size)\n</code></pre>"},{"location":"julia/trial/#sample-size-estimation","title":"Sample Size Estimation","text":"<pre><code># Find n for target power\nresult = estimate_sample_size(\n    target_power = 0.80,\n    effect_size = 0.5,\n    sd = 1.0,\n    alpha = 0.05\n)\n\nprintln(\"Required n per arm: \", result.n_per_arm)\nprintln(\"Achieved power: \", result.achieved_power)\n</code></pre>"},{"location":"julia/trial/#simulation-based-power","title":"Simulation-Based Power","text":"<pre><code># Power via simulation (more flexible)\npower = estimate_power_simulation(\n    trial_spec = trial,\n    n_simulations = 1000,\n    endpoint = :auc_comparison,\n    success_criterion = auc_diff -&gt; auc_diff &gt; 0 &amp;&amp; pvalue &lt; 0.05,\n    seed = 42\n)\n\nprintln(\"Simulated power: \", power.power)\nprintln(\"95% CI: \", power.ci)\n</code></pre>"},{"location":"julia/trial/#statistical-analysis","title":"Statistical Analysis","text":""},{"location":"julia/trial/#arm-comparison","title":"Arm Comparison","text":"<pre><code># Compare treatment to control\ncomparison = compare_arms(\n    treatment = result.arms[\"High Dose\"].auc_values,\n    control = result.arms[\"Placebo\"].auc_values,\n    test = :ttest\n)\n\nprintln(\"Difference: \", comparison.difference)\nprintln(\"95% CI: \", comparison.ci)\nprintln(\"p-value: \", comparison.pvalue)\n</code></pre>"},{"location":"julia/trial/#bioequivalence-analysis","title":"Bioequivalence Analysis","text":"<pre><code># 90% CI for geometric mean ratio\nbe_result = bioequivalence_analysis(\n    test = result.arms[\"Test\"].auc_values,\n    reference = result.arms[\"Reference\"].auc_values\n)\n\nprintln(\"GMR: \", be_result.gmr)\nprintln(\"90% CI: \", be_result.ci_90)\nprintln(\"BE conclusion: \", be_result.is_bioequivalent)\n</code></pre>"},{"location":"julia/trial/#trial-result-structure","title":"Trial Result Structure","text":"<pre><code>struct TrialResult\n    # Design info\n    name::String\n    design::TrialDesign\n\n    # Arm results\n    arms::Dict{String, ArmResult}\n\n    # Population summary\n    n_enrolled::Int\n    n_completed::Int\n    dropout_rate::Float64\n\n    # Timing\n    enrollment_duration::Float64\n    study_duration::Float64\nend\n\nstruct ArmResult\n    name::String\n    n_enrolled::Int\n    n_completed::Int\n\n    # PK endpoints\n    auc_values::Vector{Float64}\n    cmax_values::Vector{Float64}\n\n    # Summary statistics\n    mean_auc::Float64\n    sd_auc::Float64\n    cv_auc::Float64\nend\n</code></pre>"},{"location":"julia/trial/#next-steps","title":"Next Steps","text":"<ul> <li>Parallel Design - Detailed parallel trial guide</li> <li>Crossover - Crossover study design</li> <li>Power Analysis - Sample size determination</li> <li>Python Trial Module - Python interface</li> </ul>"},{"location":"julia/trial/crossover/","title":"Crossover Design","text":"<p>Comprehensive guide for crossover clinical trial simulation with within-subject comparisons.</p>"},{"location":"julia/trial/crossover/#overview","title":"Overview","text":"<p>Crossover designs allow each subject to receive multiple treatments in different periods, enabling within-subject comparisons with reduced variability.</p> <pre><code>using OpenPKPDCore\n\ndesign = CrossoverDesign(\n    n_periods = 2,\n    sequences = [[\"Test\", \"Reference\"], [\"Reference\", \"Test\"]],\n    washout_days = 14\n)\n</code></pre>"},{"location":"julia/trial/crossover/#crossoverdesign-structure","title":"CrossoverDesign Structure","text":"<pre><code>struct CrossoverDesign &lt;: TrialDesign\n    n_periods::Int                    # Number of treatment periods\n    n_sequences::Int                  # Number of sequences\n    sequences::Vector{Vector{String}} # Treatment sequences\n    washout_days::Int                 # Washout period between treatments\n    period_duration_days::Int         # Duration of each period\nend\n</code></pre>"},{"location":"julia/trial/crossover/#standard-designs","title":"Standard Designs","text":""},{"location":"julia/trial/crossover/#22-crossover","title":"2\u00d72 Crossover","text":"<pre><code># Classic AB/BA design\ndesign = crossover_2x2(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 14\n)\n\n# Equivalent to:\ndesign = CrossoverDesign(\n    n_periods = 2,\n    sequences = [\n        [\"Test\", \"Reference\"],    # Sequence 1: TR\n        [\"Reference\", \"Test\"]     # Sequence 2: RT\n    ],\n    washout_days = 14\n)\n</code></pre>"},{"location":"julia/trial/crossover/#33-latin-square","title":"3\u00d73 Latin Square","text":"<pre><code># Three treatments, three periods\ndesign = crossover_3x3(\n    treatments = [\"A\", \"B\", \"C\"],\n    washout_days = 7\n)\n\n# Sequences: ABC, BCA, CAB (Latin square)\n</code></pre>"},{"location":"julia/trial/crossover/#williams-design","title":"Williams Design","text":"<pre><code># Balanced for first-order carryover\ndesign = williams_design(\n    n_treatments = 2,\n    washout_days = 14\n)\n# Returns 2\u00d72 design\n\ndesign = williams_design(\n    n_treatments = 3,\n    washout_days = 7\n)\n# Returns 6 sequences (3\u00d76 design)\n\ndesign = williams_design(\n    n_treatments = 4,\n    washout_days = 7\n)\n# Returns 4 sequences (4\u00d74 design)\n</code></pre>"},{"location":"julia/trial/crossover/#replicate-designs","title":"Replicate Designs","text":"<pre><code># 2\u00d74 replicate (TRTR/RTRT)\ndesign = replicate_crossover_2x4(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 7\n)\n\n# Sequences:\n# TRTR, RTRT\n\n# 3\u00d73 partial replicate\ndesign = partial_replicate_3x3(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 7\n)\n\n# Sequences:\n# TRR, RTR, RRT\n</code></pre>"},{"location":"julia/trial/crossover/#trial-specification","title":"Trial Specification","text":""},{"location":"julia/trial/crossover/#complete-crossover-setup","title":"Complete Crossover Setup","text":"<pre><code>using OpenPKPDCore\n\n# Design\ndesign = crossover_2x2(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 14\n)\n\n# Dosing regimens for each treatment\nregimens = Dict(\n    \"Test\" =&gt; dosing_single(dose=100.0),\n    \"Reference\" =&gt; dosing_single(dose=100.0)\n)\n\n# Population (equal allocation to sequences)\nspec = healthy_volunteer_spec()\npopulation = generate_virtual_population(spec, 24)  # 12 per sequence\n\n# PK model\nmodel = TwoCompOral()\nparams = TwoCompOralParams(\n    Ka = 1.5,\n    CL = 10.0,\n    V1 = 50.0,\n    Q = 5.0,\n    V2 = 100.0\n)\n\n# IIV\nomega = OmegaMatrix([\n    0.09 0.0;\n    0.0  0.04\n])\n\n# Formulation effect (Test may have different Ka)\nformulation_effects = Dict(\n    \"Test\" =&gt; Dict(:Ka =&gt; 1.0),      # No change\n    \"Reference\" =&gt; Dict(:Ka =&gt; 1.0)  # Baseline\n)\n\n# Trial spec\ntrial = CrossoverTrialSpec(\n    name = \"BE Crossover Study\",\n    design = design,\n    regimens = regimens,\n    population = population,\n    pk_model = model,\n    pk_params = params,\n    omega = omega,\n    sigma = 0.1,\n    formulation_effects = formulation_effects,\n    observation_times = [0.0, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 24.0]\n)\n</code></pre>"},{"location":"julia/trial/crossover/#simulation","title":"Simulation","text":""},{"location":"julia/trial/crossover/#running-crossover-trial","title":"Running Crossover Trial","text":"<pre><code>result = simulate_crossover_trial(trial, seed=42)\n\n# Access by period\nfor period in 1:result.n_periods\n    println(\"Period $period:\")\n    for treatment in result.treatments\n        period_data = result.period_data[period, treatment]\n        println(\"  $treatment: mean AUC = $(period_data.mean_auc)\")\n    end\nend\n\n# Access by subject\nfor subject in result.subjects\n    println(\"Subject $(subject.id):\")\n    for (period, treatment) in enumerate(subject.sequence)\n        println(\"  Period $period ($treatment): AUC = $(subject.auc[period])\")\n    end\nend\n</code></pre>"},{"location":"julia/trial/crossover/#washout-period","title":"Washout Period","text":""},{"location":"julia/trial/crossover/#configuring-washout","title":"Configuring Washout","text":"<pre><code># Standard washout (5 half-lives recommended)\ndesign = crossover_2x2(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 14  # Adequate for drug with t\u00bd ~ 3 days\n)\n\n# Long-acting drug\ndesign = crossover_2x2(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 28  # For drug with t\u00bd ~ 5-6 days\n)\n</code></pre>"},{"location":"julia/trial/crossover/#washout-verification","title":"Washout Verification","text":"<pre><code># Check washout adequacy\nt_half = 3.0  # days\nrecommended_washout = 5 * t_half\nactual_washout = design.washout_days\n\nif actual_washout &gt;= recommended_washout\n    println(\"\u2713 Washout adequate ($(actual_washout) \u2265 $(recommended_washout) days)\")\nelse\n    println(\"\u26a0 Washout may be insufficient\")\nend\n</code></pre>"},{"location":"julia/trial/crossover/#period-and-sequence-effects","title":"Period and Sequence Effects","text":""},{"location":"julia/trial/crossover/#testing-period-effect","title":"Testing Period Effect","text":"<pre><code>result = simulate_crossover_trial(trial, seed=42)\n\nperiod_effect = test_period_effect(result)\n\nprintln(\"Period effect p-value: $(period_effect.pvalue)\")\nif period_effect.pvalue &lt; 0.05\n    println(\"\u26a0 Significant period effect detected\")\n    println(\"  Period 1 mean: $(period_effect.period1_mean)\")\n    println(\"  Period 2 mean: $(period_effect.period2_mean)\")\nelse\n    println(\"\u2713 No significant period effect\")\nend\n</code></pre>"},{"location":"julia/trial/crossover/#testing-sequence-effect","title":"Testing Sequence Effect","text":"<pre><code>sequence_effect = test_sequence_effect(result)\n\nprintln(\"Sequence effect p-value: $(sequence_effect.pvalue)\")\nif sequence_effect.pvalue &lt; 0.05\n    println(\"\u26a0 Significant sequence (carryover) effect detected\")\nelse\n    println(\"\u2713 No significant sequence effect\")\nend\n</code></pre>"},{"location":"julia/trial/crossover/#within-subject-variability","title":"Within-Subject Variability","text":""},{"location":"julia/trial/crossover/#calculating-intra-subject-cv","title":"Calculating Intra-Subject CV","text":"<pre><code>result = simulate_crossover_trial(trial, seed=42)\n\n# For replicate designs\ncv_within = compute_within_subject_cv(result, :auc)\n\nprintln(\"Within-subject CV (AUC): $(cv_within * 100)%\")\n\n# Classification\nif cv_within &lt; 0.30\n    println(\"Standard variability\")\nelseif cv_within &lt; 0.40\n    println(\"Moderate variability\")\nelse\n    println(\"Highly variable drug (HVD)\")\nend\n</code></pre>"},{"location":"julia/trial/crossover/#subject-by-formulation-interaction","title":"Subject-by-Formulation Interaction","text":"<pre><code># For replicate designs\nsbf = test_subject_by_formulation(result)\n\nprintln(\"Subject \u00d7 Formulation p-value: $(sbf.pvalue)\")\nif sbf.pvalue &lt; 0.05\n    println(\"\u26a0 Significant subject-by-formulation interaction\")\nend\n</code></pre>"},{"location":"julia/trial/crossover/#bioequivalence-analysis","title":"Bioequivalence Analysis","text":""},{"location":"julia/trial/crossover/#standard-be-assessment","title":"Standard BE Assessment","text":"<pre><code>result = simulate_crossover_trial(trial, seed=42)\n\n# Extract paired data\ntest_auc = result.treatment_data[\"Test\"].auc_values\nref_auc = result.treatment_data[\"Reference\"].auc_values\n\n# Assess BE\nbe_auc = assess_bioequivalence(\n    test = test_auc,\n    reference = ref_auc,\n    theta1 = 0.80,\n    theta2 = 1.25,\n    alpha = 0.05\n)\n\nprintln(\"=== AUC Bioequivalence ===\")\nprintln(\"GMR: $(round(be_auc.gmr * 100, digits=2))%\")\nprintln(\"90% CI: [$(round(be_auc.ci_lower * 100, digits=2))%, $(round(be_auc.ci_upper * 100, digits=2))%]\")\nprintln(\"Within-subject CV: $(round(be_auc.cv_within * 100, digits=1))%\")\nprintln(\"BE demonstrated: $(be_auc.is_bioequivalent)\")\n</code></pre>"},{"location":"julia/trial/crossover/#multiple-endpoints","title":"Multiple Endpoints","text":"<pre><code># Assess both AUC and Cmax\nendpoints = [:auc, :cmax]\nbe_results = Dict()\n\nfor endpoint in endpoints\n    test_vals = getfield(result.treatment_data[\"Test\"], endpoint * :_values)\n    ref_vals = getfield(result.treatment_data[\"Reference\"], endpoint * :_values)\n\n    be_results[endpoint] = assess_bioequivalence(\n        test = test_vals,\n        reference = ref_vals\n    )\nend\n\n# Overall BE requires both to pass\noverall_be = all(r.is_bioequivalent for r in values(be_results))\nprintln(\"Overall BE: $(overall_be ? \"PASS\" : \"FAIL\")\")\n</code></pre>"},{"location":"julia/trial/crossover/#highly-variable-drugs","title":"Highly Variable Drugs","text":""},{"location":"julia/trial/crossover/#reference-scaled-be-fda-rsabe","title":"Reference-Scaled BE (FDA RSABE)","text":"<pre><code># For HVD with CV &gt; 30%\nrsabe_result = rsabe_analysis(\n    result,\n    regulatory = :FDA\n)\n\nprintln(\"Reference CV: $(rsabe_result.cv_reference * 100)%\")\nprintln(\"Scaling applied: $(rsabe_result.scaling_applied)\")\nprintln(\"RSABE criterion met: $(rsabe_result.criterion_met)\")\nprintln(\"Point estimate constraint: $(rsabe_result.point_estimate_ok)\")\nprintln(\"RSABE conclusion: $(rsabe_result.is_bioequivalent)\")\n</code></pre>"},{"location":"julia/trial/crossover/#abel-ema","title":"ABEL (EMA)","text":"<pre><code># Average Bioequivalence with Expanding Limits\nabel_result = abel_analysis(\n    result,\n    regulatory = :EMA\n)\n\nprintln(\"Reference CV: $(abel_result.cv_reference * 100)%\")\nprintln(\"Widened limits: [$(abel_result.lower_limit*100)%, $(abel_result.upper_limit*100)%]\")\nprintln(\"ABEL conclusion: $(abel_result.is_bioequivalent)\")\n</code></pre>"},{"location":"julia/trial/crossover/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\n\n# ===================================\n# Bioequivalence Crossover Study\n# ===================================\n\n# 1. Design: 2\u00d72 crossover\ndesign = crossover_2x2(\n    treatments = [\"Test\", \"Reference\"],\n    washout_days = 14\n)\n\n# 2. Dosing: Single dose 500 mg\nregimens = Dict(\n    \"Test\" =&gt; dosing_single(dose=500.0),\n    \"Reference\" =&gt; dosing_single(dose=500.0)\n)\n\n# 3. Population: 24 healthy volunteers\nspec = healthy_volunteer_spec()\npopulation = generate_virtual_population(spec, 24)\n\n# 4. PK Model\nmodel = TwoCompOral()\nparams = TwoCompOralParams(\n    Ka = 1.2,\n    CL = 8.0,\n    V1 = 50.0,\n    Q = 3.0,\n    V2 = 80.0\n)\n\n# 5. Variability\nomega = OmegaMatrix([\n    0.09 0.02 0.0;    # CL\n    0.02 0.04 0.0;    # V1\n    0.0  0.0  0.16    # Ka\n])\n\n# Formulation effect: Test has 5% higher Ka (faster absorption)\nformulation_effects = Dict(\n    \"Test\" =&gt; Dict(:Ka =&gt; 1.05),\n    \"Reference\" =&gt; Dict(:Ka =&gt; 1.0)\n)\n\n# 6. Trial spec\ntrial = CrossoverTrialSpec(\n    name = \"BE Study - Drug X\",\n    design = design,\n    regimens = regimens,\n    population = population,\n    pk_model = model,\n    pk_params = params,\n    omega = omega,\n    sigma = 0.1,\n    formulation_effects = formulation_effects,\n    observation_times = [0.0, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 24.0],\n    endpoints = [:cmax, :auc_0_t, :auc_0_inf, :tmax]\n)\n\n# 7. Simulate\nprintln(\"Simulating crossover trial...\")\nresult = simulate_crossover_trial(trial, seed=12345)\n\n# 8. Report\nprintln(\"\\n\" * \"=\" ^ 60)\nprintln(\"BIOEQUIVALENCE STUDY RESULTS\")\nprintln(\"=\" ^ 60)\n\nprintln(\"\\n--- Study Summary ---\")\nprintln(\"Subjects enrolled: $(result.n_enrolled)\")\nprintln(\"Subjects completed: $(result.n_completed)\")\nprintln(\"Design: $(result.design.n_periods)\u00d7$(result.design.n_sequences) crossover\")\nprintln(\"Washout: $(result.design.washout_days) days\")\n\nprintln(\"\\n--- PK Results by Treatment ---\")\nfor treatment in [\"Test\", \"Reference\"]\n    data = result.treatment_data[treatment]\n    println(\"\\n$treatment:\")\n    println(\"  Cmax:     $(round(data.mean_cmax, digits=2)) \u00b1 $(round(data.sd_cmax, digits=2))\")\n    println(\"  Tmax:     $(round(data.mean_tmax, digits=2)) h\")\n    println(\"  AUC0-t:   $(round(data.mean_auc_0_t, digits=1)) \u00b1 $(round(data.sd_auc_0_t, digits=1))\")\n    println(\"  AUC0-inf: $(round(data.mean_auc_0_inf, digits=1)) \u00b1 $(round(data.sd_auc_0_inf, digits=1))\")\nend\n\n# 9. Period/Sequence effects\nprintln(\"\\n--- Effect Tests ---\")\nperiod = test_period_effect(result)\nsequence = test_sequence_effect(result)\nprintln(\"Period effect p-value: $(round(period.pvalue, digits=4))\")\nprintln(\"Sequence effect p-value: $(round(sequence.pvalue, digits=4))\")\n\n# 10. Within-subject CV\ncv_auc = compute_within_subject_cv(result, :auc_0_inf)\ncv_cmax = compute_within_subject_cv(result, :cmax)\nprintln(\"\\n--- Within-Subject Variability ---\")\nprintln(\"CV (AUC): $(round(cv_auc * 100, digits=1))%\")\nprintln(\"CV (Cmax): $(round(cv_cmax * 100, digits=1))%\")\n\n# 11. Bioequivalence assessment\nprintln(\"\\n--- Bioequivalence Assessment ---\")\n\nbe_auc = assess_bioequivalence(\n    result.treatment_data[\"Test\"].auc_0_inf_values,\n    result.treatment_data[\"Reference\"].auc_0_inf_values\n)\n\nbe_cmax = assess_bioequivalence(\n    result.treatment_data[\"Test\"].cmax_values,\n    result.treatment_data[\"Reference\"].cmax_values\n)\n\nprintln(\"\\nAUC0-inf:\")\nprintln(\"  GMR: $(round(be_auc.gmr * 100, digits=2))%\")\nprintln(\"  90% CI: [$(round(be_auc.ci_lower * 100, digits=2))%, $(round(be_auc.ci_upper * 100, digits=2))%]\")\nprintln(\"  BE: $(be_auc.is_bioequivalent ? \"PASS\" : \"FAIL\")\")\n\nprintln(\"\\nCmax:\")\nprintln(\"  GMR: $(round(be_cmax.gmr * 100, digits=2))%\")\nprintln(\"  90% CI: [$(round(be_cmax.ci_lower * 100, digits=2))%, $(round(be_cmax.ci_upper * 100, digits=2))%]\")\nprintln(\"  BE: $(be_cmax.is_bioequivalent ? \"PASS\" : \"FAIL\")\")\n\n# 12. Overall conclusion\noverall = be_auc.is_bioequivalent &amp;&amp; be_cmax.is_bioequivalent\nprintln(\"\\n\" * \"=\" ^ 60)\nprintln(\"OVERALL CONCLUSION: Bioequivalence $(overall ? \"DEMONSTRATED\" : \"NOT DEMONSTRATED\")\")\nprintln(\"=\" ^ 60)\n</code></pre>"},{"location":"julia/trial/crossover/#see-also","title":"See Also","text":"<ul> <li>Parallel Design - Independent group designs</li> <li>Power Analysis - Sample size for crossover</li> <li>NCA - Non-compartmental analysis</li> </ul>"},{"location":"julia/trial/dose-escalation/","title":"Dose Escalation Designs","text":"<p>Comprehensive guide for Phase I dose escalation trial simulation with multiple escalation rules.</p>"},{"location":"julia/trial/dose-escalation/#overview","title":"Overview","text":"<p>Dose escalation designs are used in Phase I trials to identify the maximum tolerated dose (MTD) while minimizing patient exposure to toxic doses.</p> <pre><code>using OpenPKPDCore\n\n# 3+3 design\ndesign = ThreePlusThree(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_dlt_rate = 0.33,\n    starting_dose_index = 1\n)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#escalation-algorithms","title":"Escalation Algorithms","text":""},{"location":"julia/trial/dose-escalation/#33-design","title":"3+3 Design","text":"<p>The classic rule-based design for oncology Phase I trials.</p> <pre><code>struct ThreePlusThree &lt;: DoseEscalationDesign\n    doses::Vector{Float64}           # Available dose levels\n    target_dlt_rate::Float64         # Target DLT rate (typically 0.33)\n    starting_dose_index::Int         # Index of starting dose\n    max_subjects_per_dose::Int       # Maximum per cohort (typically 6)\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#creating-33-design","title":"Creating 3+3 Design","text":"<pre><code># Standard 3+3\ndesign = ThreePlusThree(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0, 400.0],\n    target_dlt_rate = 0.33,\n    starting_dose_index = 1\n)\n\n# With custom parameters\ndesign = ThreePlusThree(\n    doses = [1.0, 3.0, 10.0, 30.0, 100.0],  # Log-spaced\n    target_dlt_rate = 0.33,\n    starting_dose_index = 1,\n    max_subjects_per_dose = 6\n)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#decision-rules","title":"Decision Rules","text":"<pre><code># Automatic decision based on DLT count\nfunction three_plus_three_decision(n_dlt::Int, n_patients::Int)\n    if n_patients == 3\n        if n_dlt == 0\n            return :escalate       # 0/3 \u2192 escalate\n        elseif n_dlt == 1\n            return :expand         # 1/3 \u2192 expand to 6\n        else\n            return :deescalate     # 2-3/3 \u2192 de-escalate\n        end\n    elseif n_patients == 6\n        if n_dlt &lt;= 1\n            return :escalate       # 0-1/6 \u2192 escalate\n        else\n            return :deescalate     # 2+/6 \u2192 de-escalate, MTD = previous\n        end\n    end\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#modified-toxicity-probability-interval-mtpi","title":"Modified Toxicity Probability Interval (mTPI)","text":"<p>Model-assisted design that uses probability intervals.</p> <pre><code>struct MTPI &lt;: DoseEscalationDesign\n    doses::Vector{Float64}\n    target_toxicity::Float64         # Target DLT probability (e.g., 0.25)\n    epsilon1::Float64                # Lower equivalence margin\n    epsilon2::Float64                # Upper equivalence margin\n    prior_alpha::Float64             # Beta prior alpha\n    prior_beta::Float64              # Beta prior beta\n    starting_dose_index::Int\n    max_sample_size::Int\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#creating-mtpi-design","title":"Creating mTPI Design","text":"<pre><code># Standard mTPI\ndesign = MTPI(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity = 0.25,\n    epsilon1 = 0.05,\n    epsilon2 = 0.05,\n    prior_alpha = 1.0,\n    prior_beta = 1.0,\n    starting_dose_index = 1,\n    max_sample_size = 36\n)\n\n# mTPI-2 (improved version)\ndesign = MTPI2(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity = 0.25,\n    epsilon1 = 0.05,\n    epsilon2 = 0.05,\n    starting_dose_index = 1,\n    max_sample_size = 36\n)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#mtpi-decision-making","title":"mTPI Decision Making","text":"<pre><code># Decision based on posterior probability intervals\nfunction mtpi_decision(n_dlt::Int, n_patients::Int, design::MTPI)\n    # Posterior Beta distribution\n    alpha_post = design.prior_alpha + n_dlt\n    beta_post = design.prior_beta + n_patients - n_dlt\n\n    # Calculate unit probability mass (UPM)\n    p_target = design.target_toxicity\n    e1, e2 = design.epsilon1, design.epsilon2\n\n    # Underdosing interval: (0, p_target - e1)\n    upm_under = cdf(Beta(alpha_post, beta_post), p_target - e1) / (p_target - e1)\n\n    # Target interval: (p_target - e1, p_target + e2)\n    prob_target = cdf(Beta(alpha_post, beta_post), p_target + e2) -\n                  cdf(Beta(alpha_post, beta_post), p_target - e1)\n    upm_target = prob_target / (e1 + e2)\n\n    # Overdosing interval: (p_target + e2, 1)\n    upm_over = (1 - cdf(Beta(alpha_post, beta_post), p_target + e2)) / (1 - p_target - e2)\n\n    # Decision based on maximum UPM\n    if upm_under &gt; upm_target &amp;&amp; upm_under &gt; upm_over\n        return :escalate\n    elseif upm_over &gt; upm_target &amp;&amp; upm_over &gt; upm_under\n        return :deescalate\n    else\n        return :stay\n    end\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#continual-reassessment-method-crm","title":"Continual Reassessment Method (CRM)","text":"<p>Model-based design using a dose-toxicity model.</p> <pre><code>struct CRM &lt;: DoseEscalationDesign\n    doses::Vector{Float64}\n    target_toxicity::Float64         # Target DLT rate\n    skeleton::Vector{Float64}        # Prior toxicity probabilities\n    model::Symbol                    # :power, :logistic, :empiric\n    prior_mean::Float64              # Prior for model parameter\n    prior_sd::Float64                # Prior SD\n    starting_dose_index::Int\n    max_sample_size::Int\n    cohort_size::Int\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#creating-crm-design","title":"Creating CRM Design","text":"<pre><code># Power model CRM\ndesign = CRM(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity = 0.25,\n    skeleton = [0.05, 0.10, 0.25, 0.40, 0.55],  # Prior p(DLT)\n    model = :power,\n    prior_mean = 0.0,\n    prior_sd = 1.34,\n    starting_dose_index = 1,\n    max_sample_size = 30,\n    cohort_size = 1\n)\n\n# Logistic model CRM\ndesign = CRM(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity = 0.25,\n    skeleton = [0.05, 0.10, 0.25, 0.40, 0.55],\n    model = :logistic,\n    prior_mean = 0.0,\n    prior_sd = 2.0,\n    starting_dose_index = 2,  # Start at dose 2 for safety\n    max_sample_size = 30,\n    cohort_size = 3\n)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#crm-model-specification","title":"CRM Model Specification","text":"<pre><code># Power model: p(DLT|dose) = skeleton[i]^exp(a)\nfunction power_model(skeleton::Vector{Float64}, a::Float64)\n    return skeleton .^ exp(a)\nend\n\n# Logistic model: logit(p) = a + b * log(dose)\nfunction logistic_model(doses::Vector{Float64}, a::Float64, b::Float64)\n    logit_p = a .+ b .* log.(doses)\n    return 1.0 ./ (1.0 .+ exp.(-logit_p))\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#crm-decision-algorithm","title":"CRM Decision Algorithm","text":"<pre><code>function crm_next_dose(\n    design::CRM,\n    dose_history::Vector{Int},\n    dlt_history::Vector{Bool}\n)\n    # Fit model using Bayesian update\n    posterior = fit_crm_model(\n        design.skeleton,\n        dose_history,\n        dlt_history,\n        design.prior_mean,\n        design.prior_sd\n    )\n\n    # Estimate toxicity at each dose\n    estimated_toxicity = compute_toxicity_estimates(\n        design.skeleton,\n        posterior\n    )\n\n    # Select dose closest to target\n    distances = abs.(estimated_toxicity .- design.target_toxicity)\n    next_dose_index = argmin(distances)\n\n    # Safety rule: don't skip more than 1 dose\n    current_dose = isempty(dose_history) ? design.starting_dose_index : dose_history[end]\n    if next_dose_index &gt; current_dose + 1\n        next_dose_index = current_dose + 1\n    end\n\n    return next_dose_index\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#bayesian-optimal-interval-boin","title":"Bayesian Optimal Interval (BOIN)","text":"<p>Model-assisted design with optimal boundaries.</p> <pre><code>struct BOIN &lt;: DoseEscalationDesign\n    doses::Vector{Float64}\n    target_toxicity::Float64\n    p1::Float64                      # Highest acceptable DLT rate\n    p2::Float64                      # Lowest unacceptable DLT rate\n    starting_dose_index::Int\n    max_sample_size::Int\n    cohort_size::Int\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#creating-boin-design","title":"Creating BOIN Design","text":"<pre><code># Standard BOIN\ndesign = BOIN(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity = 0.30,\n    p1 = 0.25,                       # Acceptable toxicity\n    p2 = 0.35,                       # Unacceptable toxicity\n    starting_dose_index = 1,\n    max_sample_size = 36,\n    cohort_size = 3\n)\n\n# Calculate optimal boundaries\nlambda_e = log((1 - design.p1) / (1 - design.target_toxicity)) /\n           log(design.target_toxicity * (1 - design.p1) / (design.p1 * (1 - design.target_toxicity)))\n\nlambda_d = log((1 - design.target_toxicity) / (1 - design.p2)) /\n           log(design.p2 * (1 - design.target_toxicity) / (design.target_toxicity * (1 - design.p2)))\n\nprintln(\"Escalation boundary (\u03bbe): $(round(lambda_e, digits=3))\")\nprintln(\"De-escalation boundary (\u03bbd): $(round(lambda_d, digits=3))\")\n</code></pre>"},{"location":"julia/trial/dose-escalation/#boin-decision-rules","title":"BOIN Decision Rules","text":"<pre><code>function boin_decision(\n    n_dlt::Int,\n    n_patients::Int,\n    lambda_e::Float64,\n    lambda_d::Float64\n)\n    observed_rate = n_dlt / n_patients\n\n    if observed_rate &lt;= lambda_e\n        return :escalate\n    elseif observed_rate &gt;= lambda_d\n        return :deescalate\n    else\n        return :stay\n    end\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#dose-toxicity-modeling","title":"Dose-Toxicity Modeling","text":""},{"location":"julia/trial/dose-escalation/#exposure-toxicity-relationship","title":"Exposure-Toxicity Relationship","text":"<pre><code># Link PK exposure to DLT probability\nstruct ExposureToxicityModel\n    pk_model::PKModel\n    pk_params::PKParams\n    exposure_metric::Symbol          # :cmax, :auc, :cmin\n    toxicity_model::Symbol           # :logistic, :probit\n    toxicity_params::Vector{Float64} # [intercept, slope]\nend\n\n# Create exposure-toxicity model\nexp_tox = ExposureToxicityModel(\n    pk_model = TwoCompOral(),\n    pk_params = TwoCompOralParams(Ka=1.5, CL=10.0, V1=50.0, Q=5.0, V2=100.0),\n    exposure_metric = :cmax,\n    toxicity_model = :logistic,\n    toxicity_params = [-3.0, 0.05]   # P(DLT) = logistic(-3 + 0.05*Cmax)\n)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#simulating-dlt-events","title":"Simulating DLT Events","text":"<pre><code># Simulate DLT based on exposure\nfunction simulate_dlt(\n    dose::Float64,\n    exp_tox::ExposureToxicityModel;\n    seed::Int = nothing\n)\n    if seed !== nothing\n        Random.seed!(seed)\n    end\n\n    # Simulate PK\n    pk_result = simulate_pk(\n        exp_tox.pk_model,\n        exp_tox.pk_params,\n        dose,\n        times = 0.0:0.1:72.0\n    )\n\n    # Calculate exposure metric\n    exposure = if exp_tox.exposure_metric == :cmax\n        maximum(pk_result.concentrations)\n    elseif exp_tox.exposure_metric == :auc\n        compute_auc(pk_result)\n    else\n        minimum(pk_result.concentrations[pk_result.times .&gt; 0])\n    end\n\n    # Calculate DLT probability\n    a, b = exp_tox.toxicity_params\n    logit_p = a + b * exposure\n    p_dlt = 1.0 / (1.0 + exp(-logit_p))\n\n    # Simulate DLT\n    return rand() &lt; p_dlt\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#trial-simulation","title":"Trial Simulation","text":""},{"location":"julia/trial/dose-escalation/#running-dose-escalation-trial","title":"Running Dose Escalation Trial","text":"<pre><code># Simulate complete Phase I trial\nfunction simulate_dose_escalation(\n    design::DoseEscalationDesign,\n    exp_tox::ExposureToxicityModel;\n    n_simulations::Int = 1000,\n    seed::Int = 42\n)\n    Random.seed!(seed)\n\n    mtd_selections = zeros(Int, length(design.doses) + 1)  # +1 for \"none\"\n    n_patients_per_sim = Int[]\n    n_dlts_per_sim = Int[]\n\n    for sim in 1:n_simulations\n        result = run_single_escalation(design, exp_tox)\n        push!(n_patients_per_sim, result.n_patients)\n        push!(n_dlts_per_sim, result.n_dlts)\n\n        if result.mtd_index === nothing\n            mtd_selections[end] += 1\n        else\n            mtd_selections[result.mtd_index] += 1\n        end\n    end\n\n    return DoseEscalationSimResult(\n        design = design,\n        n_simulations = n_simulations,\n        mtd_selection_prob = mtd_selections ./ n_simulations,\n        mean_patients = mean(n_patients_per_sim),\n        mean_dlts = mean(n_dlts_per_sim)\n    )\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#single-trial-run","title":"Single Trial Run","text":"<pre><code>function run_single_escalation(\n    design::ThreePlusThree,\n    exp_tox::ExposureToxicityModel\n)\n    current_dose_idx = design.starting_dose_index\n    dose_history = Int[]\n    dlt_history = Bool[]\n    dose_data = Dict{Int, Tuple{Int, Int}}()  # dose_idx =&gt; (n_patients, n_dlt)\n\n    while true\n        # Treat cohort\n        n_treat = 3\n        n_dlt = sum(simulate_dlt(design.doses[current_dose_idx], exp_tox) for _ in 1:n_treat)\n\n        # Update history\n        append!(dose_history, fill(current_dose_idx, n_treat))\n        append!(dlt_history, [n_dlt &gt; i for i in 0:n_treat-1][1:n_treat])\n\n        # Update dose data\n        if haskey(dose_data, current_dose_idx)\n            prev = dose_data[current_dose_idx]\n            dose_data[current_dose_idx] = (prev[1] + n_treat, prev[2] + n_dlt)\n        else\n            dose_data[current_dose_idx] = (n_treat, n_dlt)\n        end\n\n        total_n, total_dlt = dose_data[current_dose_idx]\n\n        # Make decision\n        decision = three_plus_three_decision(total_dlt, total_n)\n\n        if decision == :escalate\n            if current_dose_idx &lt; length(design.doses)\n                current_dose_idx += 1\n            else\n                # At max dose, declare MTD\n                return (mtd_index = current_dose_idx,\n                        n_patients = length(dose_history),\n                        n_dlts = sum(dlt_history))\n            end\n        elseif decision == :expand\n            continue  # Treat 3 more at same dose\n        else  # :deescalate\n            mtd_idx = current_dose_idx &gt; 1 ? current_dose_idx - 1 : nothing\n            return (mtd_index = mtd_idx,\n                    n_patients = length(dose_history),\n                    n_dlts = sum(dlt_history))\n        end\n\n        # Safety stop\n        if length(dose_history) &gt;= 50\n            return (mtd_index = nothing,\n                    n_patients = length(dose_history),\n                    n_dlts = sum(dlt_history))\n        end\n    end\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#operating-characteristics","title":"Operating Characteristics","text":""},{"location":"julia/trial/dose-escalation/#evaluating-design-performance","title":"Evaluating Design Performance","text":"<pre><code># Calculate operating characteristics\nfunction operating_characteristics(\n    design::DoseEscalationDesign,\n    true_toxicity::Vector{Float64};\n    n_simulations::Int = 1000,\n    seed::Int = 42\n)\n    # Find true MTD\n    true_mtd = findfirst(x -&gt; x &gt;= design.target_toxicity, true_toxicity)\n\n    results = simulate_dose_escalation_with_true_tox(\n        design, true_toxicity, n_simulations, seed\n    )\n\n    # Calculate metrics\n    correct_selection = results.mtd_selection_prob[true_mtd]\n    overdose_rate = sum(results.mtd_selection_prob[true_mtd+1:end])\n\n    # Average DLT rate experienced\n    avg_dlt_rate = results.mean_dlts / results.mean_patients\n\n    println(\"=== Operating Characteristics ===\")\n    println(\"True MTD: Dose $(true_mtd) ($(design.doses[true_mtd]))\")\n    println(\"Correct MTD selection: $(round(correct_selection * 100, digits=1))%\")\n    println(\"Overdose selection rate: $(round(overdose_rate * 100, digits=1))%\")\n    println(\"Average patients per trial: $(round(results.mean_patients, digits=1))\")\n    println(\"Average DLT rate: $(round(avg_dlt_rate * 100, digits=1))%\")\n\n    return results\nend\n\n# Example: Compare designs\ntrue_toxicity = [0.05, 0.10, 0.25, 0.40, 0.55]\n\n# 3+3 design\ndesign_3p3 = ThreePlusThree(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_dlt_rate = 0.33\n)\noc_3p3 = operating_characteristics(design_3p3, true_toxicity)\n\n# CRM design\ndesign_crm = CRM(\n    doses = [10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity = 0.25,\n    skeleton = [0.05, 0.10, 0.25, 0.40, 0.55]\n)\noc_crm = operating_characteristics(design_crm, true_toxicity)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#design-comparison","title":"Design Comparison","text":"<pre><code># Compare multiple designs\nfunction compare_escalation_designs(\n    designs::Vector{&lt;:DoseEscalationDesign},\n    true_toxicity::Vector{Float64};\n    n_simulations::Int = 1000\n)\n    results = []\n\n    for design in designs\n        oc = operating_characteristics(design, true_toxicity, n_simulations=n_simulations)\n        push!(results, (design=design, oc=oc))\n    end\n\n    println(\"\\n=== Design Comparison ===\")\n    println(\"Design          Correct%  Overdose%  Avg N  Avg DLT%\")\n    println(\"-\" ^ 55)\n\n    for r in results\n        name = string(typeof(r.design).name.name)[1:12]\n        correct = r.oc.correct_selection * 100\n        overdose = r.oc.overdose_rate * 100\n        avg_n = r.oc.mean_patients\n        avg_dlt = r.oc.mean_dlts / r.oc.mean_patients * 100\n\n        @printf(\"%-15s %6.1f    %6.1f     %5.1f  %6.1f\\n\",\n                name, correct, overdose, avg_n, avg_dlt)\n    end\n\n    return results\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#safety-constraints","title":"Safety Constraints","text":""},{"location":"julia/trial/dose-escalation/#stopping-rules","title":"Stopping Rules","text":"<pre><code># Define safety stopping rules\nstruct SafetyStoppingRules\n    max_total_dlt::Int               # Stop if total DLTs exceed\n    max_dlt_rate::Float64            # Stop if DLT rate at dose 1 exceeds\n    min_patients_dose1::Int          # Min patients at dose 1 before stopping\n    posterior_prob_threshold::Float64 # P(toxicity &gt; target) threshold\nend\n\nrules = SafetyStoppingRules(\n    max_total_dlt = 10,\n    max_dlt_rate = 0.50,\n    min_patients_dose1 = 6,\n    posterior_prob_threshold = 0.95\n)\n\n# Check if should stop for safety\nfunction check_safety_stop(\n    dose_data::Dict{Int, Tuple{Int, Int}},\n    rules::SafetyStoppingRules,\n    design::DoseEscalationDesign\n)\n    # Total DLT check\n    total_dlt = sum(d[2] for d in values(dose_data))\n    if total_dlt &gt;= rules.max_total_dlt\n        return true, \"Exceeded maximum total DLTs\"\n    end\n\n    # Dose 1 toxicity check\n    if haskey(dose_data, 1)\n        n, dlt = dose_data[1]\n        if n &gt;= rules.min_patients_dose1 &amp;&amp; dlt / n &gt;= rules.max_dlt_rate\n            return true, \"Dose 1 toxicity too high\"\n        end\n    end\n\n    return false, \"\"\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#dose-limiting-rules","title":"Dose Limiting Rules","text":"<pre><code># Prevent unsafe escalation\nstruct EscalationConstraints\n    skip_dose_allowed::Bool          # Can skip intermediate doses?\n    max_skip::Int                    # Maximum doses to skip\n    min_patients_before_escalate::Int # Min at current dose before escalating\n    require_dlt_free::Bool           # Must have 0 DLTs to escalate?\nend\n\nconstraints = EscalationConstraints(\n    skip_dose_allowed = false,\n    max_skip = 0,\n    min_patients_before_escalate = 3,\n    require_dlt_free = false\n)\n</code></pre>"},{"location":"julia/trial/dose-escalation/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\n\n# =======================================\n# Phase I Dose Escalation Trial Simulation\n# =======================================\n\n# 1. Define dose levels\ndoses = [10.0, 25.0, 50.0, 100.0, 200.0, 400.0]  # mg\ntrue_toxicity = [0.02, 0.05, 0.15, 0.30, 0.50, 0.70]\n\nprintln(\"=== Phase I Trial Simulation ===\")\nprintln(\"\\nDose Levels and True Toxicity:\")\nfor (i, (d, t)) in enumerate(zip(doses, true_toxicity))\n    println(\"  Dose $i: $d mg \u2192 P(DLT) = $(t * 100)%\")\nend\n\n# 2. Create designs\ndesign_3p3 = ThreePlusThree(\n    doses = doses,\n    target_dlt_rate = 0.33,\n    starting_dose_index = 1\n)\n\ndesign_crm = CRM(\n    doses = doses,\n    target_toxicity = 0.25,\n    skeleton = [0.05, 0.10, 0.20, 0.35, 0.50, 0.65],\n    model = :power,\n    starting_dose_index = 1,\n    max_sample_size = 30,\n    cohort_size = 1\n)\n\ndesign_boin = BOIN(\n    doses = doses,\n    target_toxicity = 0.25,\n    p1 = 0.20,\n    p2 = 0.30,\n    starting_dose_index = 1,\n    max_sample_size = 36,\n    cohort_size = 3\n)\n\n# 3. Run simulations\nprintln(\"\\n--- Running 1000 Simulations ---\")\n\nresults_3p3 = simulate_with_true_toxicity(design_3p3, true_toxicity, n_sim=1000)\nresults_crm = simulate_with_true_toxicity(design_crm, true_toxicity, n_sim=1000)\nresults_boin = simulate_with_true_toxicity(design_boin, true_toxicity, n_sim=1000)\n\n# 4. Display results\nprintln(\"\\n--- MTD Selection Probabilities ---\")\nprintln(\"Dose    True P(DLT)   3+3      CRM      BOIN\")\nprintln(\"-\" ^ 55)\n\nfor i in 1:length(doses)\n    @printf(\"%3d mg    %5.1f%%    %5.1f%%   %5.1f%%   %5.1f%%\\n\",\n            doses[i], true_toxicity[i]*100,\n            results_3p3.mtd_prob[i]*100,\n            results_crm.mtd_prob[i]*100,\n            results_boin.mtd_prob[i]*100)\nend\n\n# 5. Summary statistics\nprintln(\"\\n--- Summary Statistics ---\")\nprintln(\"                     3+3      CRM      BOIN\")\nprintln(\"-\" ^ 45)\n\n# True MTD is dose 4 (30% DLT rate, closest to 25% target)\ntrue_mtd_idx = 4\n@printf(\"Correct MTD (%%):    %5.1f    %5.1f    %5.1f\\n\",\n        results_3p3.mtd_prob[true_mtd_idx]*100,\n        results_crm.mtd_prob[true_mtd_idx]*100,\n        results_boin.mtd_prob[true_mtd_idx]*100)\n\noverdose_3p3 = sum(results_3p3.mtd_prob[5:end]) * 100\noverdose_crm = sum(results_crm.mtd_prob[5:end]) * 100\noverdose_boin = sum(results_boin.mtd_prob[5:end]) * 100\n@printf(\"Overdose (%%):       %5.1f    %5.1f    %5.1f\\n\",\n        overdose_3p3, overdose_crm, overdose_boin)\n\n@printf(\"Avg patients:       %5.1f    %5.1f    %5.1f\\n\",\n        results_3p3.mean_n, results_crm.mean_n, results_boin.mean_n)\n\n@printf(\"Avg DLTs:           %5.1f    %5.1f    %5.1f\\n\",\n        results_3p3.mean_dlt, results_crm.mean_dlt, results_boin.mean_dlt)\n\n# 6. Toxicity at recommended MTD\nprintln(\"\\n--- Safety Analysis ---\")\nfor (name, result) in [(\"3+3\", results_3p3), (\"CRM\", results_crm), (\"BOIN\", results_boin)]\n    avg_tox = sum(result.mtd_prob[i] * true_toxicity[i] for i in 1:length(doses))\n    println(\"$name: Average toxicity at selected MTD = $(round(avg_tox*100, digits=1))%\")\nend\n</code></pre>"},{"location":"julia/trial/dose-escalation/#see-also","title":"See Also","text":"<ul> <li>Parallel Design - Phase II parallel designs</li> <li>Crossover Design - Crossover study designs</li> <li>Power Analysis - Sample size calculation</li> <li>Population Simulation - IIV in PK</li> </ul>"},{"location":"julia/trial/parallel/","title":"Parallel Design","text":"<p>Comprehensive guide for parallel group clinical trial simulation with multiple treatment arms.</p>"},{"location":"julia/trial/parallel/#overview","title":"Overview","text":"<p>Parallel designs assign subjects to independent treatment groups, enabling comparison of interventions without within-subject correlation.</p> <pre><code>using OpenPKPDCore\n\ndesign = ParallelDesign(\n    n_arms = 3,\n    arm_names = [\"Placebo\", \"Low Dose\", \"High Dose\"],\n    randomization_ratio = [1, 1, 1]\n)\n</code></pre>"},{"location":"julia/trial/parallel/#paralleldesign-structure","title":"ParallelDesign Structure","text":"<pre><code>struct ParallelDesign &lt;: TrialDesign\n    n_arms::Int                           # Number of treatment arms\n    arm_names::Vector{String}             # Names for each arm\n    randomization_ratio::Vector{Int}      # Allocation ratio\n    stratification_factors::Vector{Symbol} # Stratification variables\n    block_size::Int                       # Block randomization size\nend\n</code></pre>"},{"location":"julia/trial/parallel/#creating-designs","title":"Creating Designs","text":"<pre><code># Two-arm parallel (1:1)\ndesign = ParallelDesign(\n    n_arms = 2,\n    arm_names = [\"Placebo\", \"Treatment\"],\n    randomization_ratio = [1, 1]\n)\n\n# Three-arm with 2:1:1 randomization\ndesign = ParallelDesign(\n    n_arms = 3,\n    arm_names = [\"Placebo\", \"Low\", \"High\"],\n    randomization_ratio = [2, 1, 1]\n)\n\n# Stratified by sex and age group\ndesign = ParallelDesign(\n    n_arms = 2,\n    arm_names = [\"Control\", \"Active\"],\n    randomization_ratio = [1, 1],\n    stratification_factors = [:sex, :age_group],\n    block_size = 4\n)\n</code></pre>"},{"location":"julia/trial/parallel/#dosing-regimens","title":"Dosing Regimens","text":""},{"location":"julia/trial/parallel/#standard-frequencies","title":"Standard Frequencies","text":"<pre><code># Once daily (QD)\nqd_regimen = dosing_qd(\n    dose = 100.0,\n    days = 28,\n    loading_dose = nothing\n)\n\n# Twice daily (BID)\nbid_regimen = dosing_bid(\n    dose = 50.0,\n    days = 28,\n    loading_dose = 100.0  # Double first dose\n)\n\n# Three times daily (TID)\ntid_regimen = dosing_tid(\n    dose = 25.0,\n    days = 14\n)\n\n# Four times daily (QID)\nqid_regimen = dosing_qid(\n    dose = 20.0,\n    days = 7\n)\n</code></pre>"},{"location":"julia/trial/parallel/#custom-regimens","title":"Custom Regimens","text":"<pre><code># Custom dose times (hours after midnight)\ncustom_regimen = dosing_custom(\n    dose = 100.0,\n    days = 28,\n    dose_times = [8.0, 20.0]  # 8 AM and 8 PM\n)\n\n# Variable doses\nvariable_regimen = DosingRegimen(\n    doses = [100.0, 50.0, 50.0],\n    times = [0.0, 12.0, 24.0],\n    repeat_days = 2\n)\n</code></pre>"},{"location":"julia/trial/parallel/#titration-regimens","title":"Titration Regimens","text":"<pre><code># Gradual dose escalation\ntitration = TitrationRegimen(\n    start_dose = 25.0,\n    target_dose = 100.0,\n    n_steps = 4,\n    days_per_step = 7,\n    frequency = :qd,\n    loading_dose = nothing,\n    maintenance_days = 14\n)\n\n# Example schedule:\n# Week 1: 25 mg QD\n# Week 2: 50 mg QD\n# Week 3: 75 mg QD\n# Week 4+: 100 mg QD (maintenance)\n</code></pre>"},{"location":"julia/trial/parallel/#virtual-population","title":"Virtual Population","text":""},{"location":"julia/trial/parallel/#demographic-specification","title":"Demographic Specification","text":"<pre><code># Healthy volunteer population\nspec = DemographicSpec(\n    age_mean = 35.0,\n    age_sd = 10.0,\n    age_min = 18.0,\n    age_max = 55.0,\n    weight_mean = 75.0,\n    weight_sd = 12.0,\n    weight_min = 50.0,\n    weight_max = 100.0,\n    female_fraction = 0.5,\n    race_distribution = Dict(\n        \"Caucasian\" =&gt; 0.70,\n        \"Asian\" =&gt; 0.15,\n        \"Black\" =&gt; 0.10,\n        \"Other\" =&gt; 0.05\n    )\n)\n\npopulation = generate_virtual_population(spec, 150)\n</code></pre>"},{"location":"julia/trial/parallel/#pre-built-specifications","title":"Pre-Built Specifications","text":"<pre><code># Healthy volunteers (Phase I typical)\nspec = healthy_volunteer_spec()\n# Age: 30 \u00b1 8 years (18-45)\n# Weight: 72 \u00b1 10 kg (55-90)\n# 50% female\n\n# Patient population\nspec = patient_population_spec(:diabetes)\n# Age: 55 \u00b1 12 years\n# Weight: 90 \u00b1 18 kg\n# Includes HbA1c baseline\n\n# Renal impairment\nspec = patient_population_spec(:renal_impairment)\n# Includes eGFR distribution\n\n# Hepatic impairment\nspec = patient_population_spec(:hepatic_impairment)\n# Includes Child-Pugh score\n</code></pre>"},{"location":"julia/trial/parallel/#population-summary","title":"Population Summary","text":"<pre><code>population = generate_virtual_population(spec, 100)\nsummary = summarize_population(population)\n\nprintln(\"Age: $(summary.age_mean) \u00b1 $(summary.age_sd) years\")\nprintln(\"Weight: $(summary.weight_mean) \u00b1 $(summary.weight_sd) kg\")\nprintln(\"Female: $(summary.female_fraction * 100)%\")\nprintln(\"Race distribution: $(summary.race_distribution)\")\n</code></pre>"},{"location":"julia/trial/parallel/#trial-specification","title":"Trial Specification","text":""},{"location":"julia/trial/parallel/#complete-trial-setup","title":"Complete Trial Setup","text":"<pre><code>using OpenPKPDCore\n\n# Design\ndesign = ParallelDesign(\n    n_arms = 3,\n    arm_names = [\"Placebo\", \"50 mg\", \"100 mg\"],\n    randomization_ratio = [1, 1, 1]\n)\n\n# Dosing regimens per arm\nregimens = [\n    dosing_qd(dose=0.0, days=28),     # Placebo\n    dosing_qd(dose=50.0, days=28),    # Low dose\n    dosing_qd(dose=100.0, days=28)    # High dose\n]\n\n# Population\nspec = healthy_volunteer_spec()\npopulation = generate_virtual_population(spec, 150)\n\n# PK model\nmodel = TwoCompOral()\nparams = TwoCompOralParams(\n    Ka = 1.5,\n    CL = 10.0,\n    V1 = 50.0,\n    Q = 5.0,\n    V2 = 100.0\n)\n\n# Inter-individual variability\nomega = OmegaMatrix([\n    0.09 0.03 0.0;    # IIV on CL (30% CV)\n    0.03 0.04 0.0;    # IIV on V1 (20% CV), correlated with CL\n    0.0  0.0  0.16    # IIV on Ka (40% CV)\n])\n\n# Residual error (proportional)\nsigma = 0.1  # 10% CV\n\n# Create trial specification\ntrial = TrialSpec(\n    name = \"Phase 2 Dose Finding Study\",\n    design = design,\n    regimens = regimens,\n    population = population,\n    pk_model = model,\n    pk_params = params,\n    omega = omega,\n    sigma = sigma,\n    observation_times = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0],\n    endpoints = [:cmax, :auc_0_24, :auc_0_inf]\n)\n</code></pre>"},{"location":"julia/trial/parallel/#trial-simulation","title":"Trial Simulation","text":""},{"location":"julia/trial/parallel/#running-simulation","title":"Running Simulation","text":"<pre><code># Simulate trial\nresult = simulate_trial(trial, seed=12345)\n\n# Access results\nprintln(\"Study: $(result.name)\")\nprintln(\"Enrolled: $(result.n_enrolled)\")\nprintln(\"Completed: $(result.n_completed)\")\nprintln(\"Dropout rate: $(result.dropout_rate * 100)%\")\n</code></pre>"},{"location":"julia/trial/parallel/#arm-results","title":"Arm Results","text":"<pre><code>for (arm_name, arm) in result.arms\n    println(\"\\n$(arm_name):\")\n    println(\"  N completed: $(arm.n_completed)\")\n    println(\"  AUC: $(arm.mean_auc) \u00b1 $(arm.sd_auc)\")\n    println(\"  Cmax: $(arm.mean_cmax) \u00b1 $(arm.sd_cmax)\")\n    println(\"  CV%: $(arm.cv_auc * 100)%\")\nend\n</code></pre>"},{"location":"julia/trial/parallel/#individual-subject-data","title":"Individual Subject Data","text":"<pre><code># Access individual-level data\nfor subject in result.subjects\n    println(\"Subject $(subject.id):\")\n    println(\"  Arm: $(subject.arm)\")\n    println(\"  AUC: $(subject.auc)\")\n    println(\"  Cmax: $(subject.cmax)\")\n    println(\"  Completed: $(subject.completed)\")\nend\n</code></pre>"},{"location":"julia/trial/parallel/#compliance-modeling","title":"Compliance Modeling","text":""},{"location":"julia/trial/parallel/#compliance-patterns","title":"Compliance Patterns","text":"<pre><code># Random compliance (probabilistic missed doses)\ncompliance = ComplianceSpec(\n    pattern = :random,\n    rate = 0.85  # 85% compliance\n)\n\n# Weekend-miss pattern\ncompliance = ComplianceSpec(\n    pattern = :weekend_miss,\n    weekday_rate = 0.95,\n    weekend_rate = 0.70\n)\n\n# Decay pattern (decreasing over time)\ncompliance = ComplianceSpec(\n    pattern = :decay,\n    initial_rate = 0.95,\n    final_rate = 0.75,\n    half_time_days = 14\n)\n\n# Early-good pattern\ncompliance = ComplianceSpec(\n    pattern = :early_good,\n    initial_rate = 0.95,\n    later_rate = 0.80,\n    transition_day = 14\n)\n</code></pre>"},{"location":"julia/trial/parallel/#adding-compliance-to-trial","title":"Adding Compliance to Trial","text":"<pre><code>trial = TrialSpec(\n    name = \"Phase 2 with Compliance\",\n    design = design,\n    regimens = regimens,\n    population = population,\n    pk_model = model,\n    pk_params = params,\n    omega = omega,\n    sigma = sigma,\n    compliance = ComplianceSpec(pattern=:random, rate=0.85)\n)\n</code></pre>"},{"location":"julia/trial/parallel/#dropout-modeling","title":"Dropout Modeling","text":""},{"location":"julia/trial/parallel/#dropout-specification","title":"Dropout Specification","text":"<pre><code># Constant dropout rate\ndropout = DropoutSpec(\n    rate = 0.15,  # 15% dropout\n    pattern = :constant\n)\n\n# Time-dependent dropout\ndropout = DropoutSpec(\n    pattern = :increasing,\n    initial_rate = 0.05,\n    final_rate = 0.20,\n    shape = :linear\n)\n\n# Exposure-dependent dropout (adverse events)\ndropout = DropoutSpec(\n    pattern = :exposure_dependent,\n    threshold = 100.0,  # If Cmax &gt; threshold\n    rate_below = 0.10,\n    rate_above = 0.30\n)\n</code></pre>"},{"location":"julia/trial/parallel/#adding-dropout-to-trial","title":"Adding Dropout to Trial","text":"<pre><code>trial = TrialSpec(\n    ...,\n    dropout = DropoutSpec(rate=0.15, pattern=:constant)\n)\n</code></pre>"},{"location":"julia/trial/parallel/#statistical-analysis","title":"Statistical Analysis","text":""},{"location":"julia/trial/parallel/#arm-comparisons","title":"Arm Comparisons","text":"<pre><code># Compare active to placebo\ncomparison = compare_arms(\n    result.arms[\"100 mg\"].auc_values,\n    result.arms[\"Placebo\"].auc_values,\n    arm1_name = \"100 mg\",\n    arm2_name = \"Placebo\",\n    alpha = 0.05\n)\n\nprintln(\"Mean difference: $(comparison.difference)\")\nprintln(\"95% CI: [$(comparison.ci_lower), $(comparison.ci_upper)]\")\nprintln(\"p-value: $(comparison.pvalue)\")\nprintln(\"Significant: $(comparison.significant)\")\n</code></pre>"},{"location":"julia/trial/parallel/#dose-response-analysis","title":"Dose-Response Analysis","text":"<pre><code># Analyze dose-response\ndoses = [0.0, 50.0, 100.0]\nmeans = [\n    result.arms[\"Placebo\"].mean_auc,\n    result.arms[\"50 mg\"].mean_auc,\n    result.arms[\"100 mg\"].mean_auc\n]\n\n# Linear trend test\ntrend = dose_response_trend(doses, means)\nprintln(\"Slope: $(trend.slope)\")\nprintln(\"p-value (trend): $(trend.pvalue)\")\n</code></pre>"},{"location":"julia/trial/parallel/#responder-analysis","title":"Responder Analysis","text":"<pre><code># Count responders (AUC &gt; threshold)\nthreshold = 50.0  # Target exposure\n\nfor (arm_name, arm) in result.arms\n    resp = responder_analysis(\n        arm.auc_values,\n        threshold = threshold,\n        direction = :above,\n        confidence = 0.95\n    )\n\n    println(\"$(arm_name):\")\n    println(\"  Responders: $(resp.n_responders)/$(resp.n_total)\")\n    println(\"  Rate: $(resp.rate * 100)% [$(resp.ci_lower*100), $(resp.ci_upper*100)]\")\nend\n</code></pre>"},{"location":"julia/trial/parallel/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\n\n# ======================\n# Phase 2 Dose Finding Study\n# ======================\n\n# 1. Define design\ndesign = ParallelDesign(\n    n_arms = 4,\n    arm_names = [\"Placebo\", \"25 mg\", \"50 mg\", \"100 mg\"],\n    randomization_ratio = [1, 1, 1, 1],\n    stratification_factors = [:sex],\n    block_size = 4\n)\n\n# 2. Define dosing regimens\nregimens = [\n    dosing_qd(dose=0.0, days=28),\n    dosing_qd(dose=25.0, days=28),\n    dosing_qd(dose=50.0, days=28),\n    dosing_qd(dose=100.0, days=28)\n]\n\n# 3. Generate population\nspec = healthy_volunteer_spec()\npopulation = generate_virtual_population(spec, 200)\n\n# 4. Define PK model\nmodel = OneCompOralFirstOrder()\nparams = OneCompOralFirstOrderParams(\n    Ka = 1.2,\n    CL = 8.0,\n    V = 60.0\n)\n\nomega = OmegaMatrix([\n    0.09 0.02;    # IIV CL\n    0.02 0.04     # IIV V\n])\n\n# 5. Create trial specification\ntrial = TrialSpec(\n    name = \"Phase 2 Dose Finding\",\n    design = design,\n    regimens = regimens,\n    population = population,\n    pk_model = model,\n    pk_params = params,\n    omega = omega,\n    sigma = 0.1,\n    observation_times = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0],\n    endpoints = [:cmax, :auc_0_24],\n    compliance = ComplianceSpec(pattern=:random, rate=0.90),\n    dropout = DropoutSpec(rate=0.10, pattern=:constant)\n)\n\n# 6. Run simulation\nprintln(\"Running trial simulation...\")\nresult = simulate_trial(trial, seed=42)\n\n# 7. Report results\nprintln(\"\\n\" * \"=\" ^ 60)\nprintln(\"PHASE 2 DOSE FINDING STUDY RESULTS\")\nprintln(\"=\" ^ 60)\n\nprintln(\"\\n--- Enrollment Summary ---\")\nprintln(\"Total enrolled: $(result.n_enrolled)\")\nprintln(\"Total completed: $(result.n_completed)\")\nprintln(\"Dropout rate: $(round(result.dropout_rate * 100, digits=1))%\")\n\nprintln(\"\\n--- PK Results by Arm ---\")\nprintln(\"Arm          N    AUC Mean\u00b1SD        Cmax Mean\u00b1SD\")\nprintln(\"-\" ^ 60)\n\nfor arm_name in [\"Placebo\", \"25 mg\", \"50 mg\", \"100 mg\"]\n    arm = result.arms[arm_name]\n    auc_str = \"$(round(arm.mean_auc, digits=1)) \u00b1 $(round(arm.sd_auc, digits=1))\"\n    cmax_str = \"$(round(arm.mean_cmax, digits=2)) \u00b1 $(round(arm.sd_cmax, digits=2))\"\n    println(\"$(rpad(arm_name, 12)) $(arm.n_completed)    $(rpad(auc_str, 18)) $(cmax_str)\")\nend\n\n# 8. Statistical comparisons\nprintln(\"\\n--- Statistical Comparisons vs Placebo ---\")\nplacebo_auc = result.arms[\"Placebo\"].auc_values\n\nfor dose in [\"25 mg\", \"50 mg\", \"100 mg\"]\n    comp = compare_arms(\n        result.arms[dose].auc_values,\n        placebo_auc,\n        arm1_name = dose,\n        arm2_name = \"Placebo\"\n    )\n\n    sig = comp.significant ? \"*\" : \"\"\n    println(\"$(dose) vs Placebo: \u0394=$(round(comp.difference, digits=1)), \" *\n            \"95% CI [$(round(comp.ci_lower, digits=1)), $(round(comp.ci_upper, digits=1))], \" *\n            \"p=$(round(comp.pvalue, digits=4))$sig\")\nend\n\n# 9. Dose-response\nprintln(\"\\n--- Dose-Response Analysis ---\")\ndoses = [0.0, 25.0, 50.0, 100.0]\nmean_aucs = [result.arms[arm].mean_auc for arm in [\"Placebo\", \"25 mg\", \"50 mg\", \"100 mg\"]]\ntrend = dose_response_trend(doses, mean_aucs)\nprintln(\"Linear trend slope: $(round(trend.slope, digits=3)) per mg\")\nprintln(\"Trend p-value: $(round(trend.pvalue, digits=4))\")\n\n# 10. Responder analysis\nprintln(\"\\n--- Responder Analysis (AUC &gt; 30) ---\")\nfor arm_name in [\"Placebo\", \"25 mg\", \"50 mg\", \"100 mg\"]\n    arm = result.arms[arm_name]\n    resp = responder_analysis(arm.auc_values, threshold=30.0, direction=:above)\n    println(\"$(arm_name): $(resp.n_responders)/$(resp.n_total) \" *\n            \"($(round(resp.rate*100, digits=1))%)\")\nend\n</code></pre>"},{"location":"julia/trial/parallel/#see-also","title":"See Also","text":"<ul> <li>Crossover Design - Within-subject designs</li> <li>Dose Escalation - Phase I designs</li> <li>Power Analysis - Sample size calculation</li> <li>Population Generation - IIV modeling</li> </ul>"},{"location":"julia/trial/power/","title":"Power Analysis","text":"<p>Comprehensive guide for sample size calculation and power analysis in clinical trial simulation.</p>"},{"location":"julia/trial/power/#overview","title":"Overview","text":"<p>Power analysis enables determination of the sample size required to detect a clinically meaningful effect with adequate statistical power.</p> <pre><code>using OpenPKPDCore\n\n# Calculate sample size for parallel design\nresult = power_analysis(\n    design = :parallel,\n    effect_size = 0.5,\n    alpha = 0.05,\n    power = 0.80,\n    cv = 0.30\n)\n\nprintln(\"Required N per arm: $(result.n_per_arm)\")\n</code></pre>"},{"location":"julia/trial/power/#key-concepts","title":"Key Concepts","text":""},{"location":"julia/trial/power/#statistical-power","title":"Statistical Power","text":"<p>Power is the probability of detecting an effect when one truly exists:</p> <ul> <li>Power = 1 - \u03b2 (\u03b2 = Type II error rate)</li> <li>Typical target: 80% or 90%</li> <li>Higher power requires larger sample size</li> </ul>"},{"location":"julia/trial/power/#effect-size","title":"Effect Size","text":"<p>The magnitude of the difference to detect:</p> <pre><code># Cohen's d for continuous outcomes\ncohens_d = (mean1 - mean2) / pooled_sd\n\n# Geometric Mean Ratio (GMR) for PK\ngmr = exp(mean_log_test - mean_log_reference)\n\n# Relative difference\nrelative_diff = (mean_test - mean_reference) / mean_reference\n</code></pre>"},{"location":"julia/trial/power/#parallel-design-power","title":"Parallel Design Power","text":""},{"location":"julia/trial/power/#two-arm-comparison","title":"Two-Arm Comparison","text":"<pre><code>struct ParallelPowerSpec\n    effect_size::Float64        # Expected difference / SD\n    alpha::Float64              # Type I error rate\n    power::Float64              # Target power\n    cv::Float64                 # Coefficient of variation\n    allocation_ratio::Float64   # N_treatment / N_control\n    test::Symbol                # :two_sided, :one_sided\nend\n\n# Create specification\nspec = ParallelPowerSpec(\n    effect_size = 0.5,          # Medium effect\n    alpha = 0.05,\n    power = 0.80,\n    cv = 0.30,\n    allocation_ratio = 1.0,\n    test = :two_sided\n)\n\n# Calculate sample size\nresult = calculate_sample_size(spec)\nprintln(\"N per arm: $(result.n_per_arm)\")\nprintln(\"Total N: $(result.n_total)\")\n</code></pre>"},{"location":"julia/trial/power/#sample-size-formula","title":"Sample Size Formula","text":"<pre><code>function sample_size_parallel(\n    effect_size::Float64,\n    alpha::Float64,\n    power::Float64;\n    test::Symbol = :two_sided\n)\n    # Z values\n    z_alpha = test == :two_sided ? quantile(Normal(), 1 - alpha/2) : quantile(Normal(), 1 - alpha)\n    z_beta = quantile(Normal(), power)\n\n    # Sample size per group\n    n = 2 * ((z_alpha + z_beta) / effect_size)^2\n\n    return ceil(Int, n)\nend\n\n# Example\nn = sample_size_parallel(0.5, 0.05, 0.80)\nprintln(\"Required n per arm: $n\")  # 64 per arm\n</code></pre>"},{"location":"julia/trial/power/#multi-arm-designs","title":"Multi-Arm Designs","text":"<pre><code># Sample size for multiple treatment arms\nfunction sample_size_multiarm(\n    n_arms::Int,\n    effect_size::Float64,\n    alpha::Float64,\n    power::Float64;\n    comparison::Symbol = :dunnett  # :dunnett, :bonferroni, :none\n)\n    # Adjust alpha for multiple comparisons\n    adjusted_alpha = if comparison == :bonferroni\n        alpha / (n_arms - 1)\n    elseif comparison == :dunnett\n        dunnett_alpha(alpha, n_arms - 1)\n    else\n        alpha\n    end\n\n    # Per-arm sample size\n    z_alpha = quantile(Normal(), 1 - adjusted_alpha/2)\n    z_beta = quantile(Normal(), power)\n\n    n_per_arm = ceil(Int, 2 * ((z_alpha + z_beta) / effect_size)^2)\n\n    return (\n        n_per_arm = n_per_arm,\n        n_total = n_per_arm * n_arms,\n        adjusted_alpha = adjusted_alpha\n    )\nend\n</code></pre>"},{"location":"julia/trial/power/#crossover-design-power","title":"Crossover Design Power","text":""},{"location":"julia/trial/power/#22-crossover","title":"2\u00d72 Crossover","text":"<pre><code>struct CrossoverPowerSpec\n    gmr::Float64                # Expected geometric mean ratio\n    cv_within::Float64          # Within-subject CV\n    theta1::Float64             # Lower BE limit (e.g., 0.80)\n    theta2::Float64             # Upper BE limit (e.g., 1.25)\n    alpha::Float64              # Type I error rate\n    power::Float64              # Target power\nend\n\n# BE study sample size\nspec = CrossoverPowerSpec(\n    gmr = 0.95,                 # Expected GMR of 95%\n    cv_within = 0.25,           # 25% within-subject CV\n    theta1 = 0.80,\n    theta2 = 1.25,\n    alpha = 0.05,\n    power = 0.80\n)\n\nresult = calculate_be_sample_size(spec)\nprintln(\"Required N: $(result.n_total)\")\n</code></pre>"},{"location":"julia/trial/power/#sample-size-calculation","title":"Sample Size Calculation","text":"<pre><code>function sample_size_crossover_be(\n    gmr::Float64,\n    cv_within::Float64,\n    theta1::Float64,\n    theta2::Float64,\n    alpha::Float64,\n    power::Float64\n)\n    # Convert CV to log-scale SD\n    sigma_w = sqrt(log(1 + cv_within^2))\n\n    # Z values\n    z_alpha = quantile(Normal(), 1 - alpha)\n    z_beta = quantile(Normal(), power)\n\n    # Distance from GMR to nearest limit\n    delta = min(log(gmr) - log(theta1), log(theta2) - log(gmr))\n\n    # Sample size (2\u00d72 crossover)\n    n = 2 * ((z_alpha + z_beta) * sigma_w / delta)^2\n\n    return ceil(Int, n)\nend\n\n# Example: 25% CV, GMR = 0.95\nn = sample_size_crossover_be(0.95, 0.25, 0.80, 1.25, 0.05, 0.80)\nprintln(\"Required N: $n\")  # ~24 subjects\n</code></pre>"},{"location":"julia/trial/power/#replicate-crossover-designs","title":"Replicate Crossover Designs","text":"<pre><code># Sample size for 4-period replicate design\nfunction sample_size_replicate_be(\n    gmr::Float64,\n    cv_within::Float64,\n    theta1::Float64,\n    theta2::Float64,\n    alpha::Float64,\n    power::Float64;\n    design::Symbol = :trtr_rtrt  # :trtr_rtrt, :trt_rtr, etc.\n)\n    # Design efficiency factors\n    efficiency = Dict(\n        :trtr_rtrt =&gt; 2.0,      # Full replicate\n        :trt_rtr =&gt; 1.5,        # Partial replicate (TRR, RTR, RRT)\n        :tr_rt =&gt; 1.0           # Standard 2\u00d72\n    )\n\n    # Adjusted sample size\n    n_2x2 = sample_size_crossover_be(gmr, cv_within, theta1, theta2, alpha, power)\n    n_rep = ceil(Int, n_2x2 / efficiency[design])\n\n    return n_rep\nend\n</code></pre>"},{"location":"julia/trial/power/#highly-variable-drugs","title":"Highly Variable Drugs","text":""},{"location":"julia/trial/power/#rsabe-sample-size-fda","title":"RSABE Sample Size (FDA)","text":"<pre><code>function sample_size_rsabe(\n    gmr::Float64,\n    cv_reference::Float64;\n    theta_s::Float64 = 0.8928,  # Scaling factor\n    sigma_w0::Float64 = 0.25,   # Regulatory cutoff\n    alpha::Float64 = 0.05,\n    power::Float64 = 0.80\n)\n    sigma_wr = sqrt(log(1 + cv_reference^2))\n\n    # Use scaled limits if CV &gt; 30%\n    if sigma_wr &gt; sigma_w0\n        # Scaled limits\n        scaled_limit = exp(theta_s * sigma_wr)\n        n = sample_size_scaled_be(gmr, cv_reference, scaled_limit, alpha, power)\n    else\n        # Standard limits\n        n = sample_size_crossover_be(gmr, cv_reference, 0.80, 1.25, alpha, power)\n    end\n\n    return n\nend\n\n# HVD with 45% CV\nn = sample_size_rsabe(0.95, 0.45)\nprintln(\"RSABE sample size: $n\")\n</code></pre>"},{"location":"julia/trial/power/#abel-sample-size-ema","title":"ABEL Sample Size (EMA)","text":"<pre><code>function sample_size_abel(\n    gmr::Float64,\n    cv_reference::Float64;\n    cv_cutoff::Float64 = 0.30,\n    max_widening::Float64 = 0.50,  # Up to 69.84%-143.19%\n    alpha::Float64 = 0.05,\n    power::Float64 = 0.80\n)\n    if cv_reference &gt; cv_cutoff\n        # Calculate widened limits\n        k = 0.760  # Regulatory constant\n        sigma_wr = sqrt(log(1 + cv_reference^2))\n        widening = min(k * sigma_wr, max_widening)\n\n        lower = exp(log(0.80) - widening)\n        upper = exp(log(1.25) + widening)\n\n        n = sample_size_crossover_be(gmr, cv_reference, lower, upper, alpha, power)\n    else\n        n = sample_size_crossover_be(gmr, cv_reference, 0.80, 1.25, alpha, power)\n    end\n\n    return n\nend\n</code></pre>"},{"location":"julia/trial/power/#power-curves","title":"Power Curves","text":""},{"location":"julia/trial/power/#generating-power-curves","title":"Generating Power Curves","text":"<pre><code>function power_curve(\n    design_spec::PowerSpec,\n    n_range::UnitRange{Int}\n)\n    powers = Float64[]\n\n    for n in n_range\n        pow = calculate_power(design_spec, n)\n        push!(powers, pow)\n    end\n\n    return (n = collect(n_range), power = powers)\nend\n\n# Example\nspec = ParallelPowerSpec(effect_size=0.5, alpha=0.05, cv=0.30)\ncurve = power_curve(spec, 10:100)\n\n# Find minimum N for 80% power\nmin_n = findfirst(p -&gt; p &gt;= 0.80, curve.power)\nprintln(\"Minimum N for 80% power: $(curve.n[min_n])\")\n</code></pre>"},{"location":"julia/trial/power/#effect-size-sensitivity","title":"Effect Size Sensitivity","text":"<pre><code>function effect_sensitivity(\n    n::Int,\n    alpha::Float64,\n    effect_sizes::Vector{Float64}\n)\n    powers = Float64[]\n\n    for es in effect_sizes\n        spec = ParallelPowerSpec(effect_size=es, alpha=alpha)\n        pow = calculate_power(spec, n)\n        push!(powers, pow)\n    end\n\n    return (effect_size = effect_sizes, power = powers)\nend\n\n# What effect sizes can we detect with N=50 per arm?\nsens = effect_sensitivity(50, 0.05, 0.1:0.1:1.0)\n</code></pre>"},{"location":"julia/trial/power/#dropout-adjustment","title":"Dropout Adjustment","text":""},{"location":"julia/trial/power/#adjusting-for-anticipated-dropout","title":"Adjusting for Anticipated Dropout","text":"<pre><code>function adjust_for_dropout(\n    n_calculated::Int,\n    dropout_rate::Float64\n)\n    n_adjusted = ceil(Int, n_calculated / (1 - dropout_rate))\n    return n_adjusted\nend\n\n# Example: 20% anticipated dropout\nn_base = 64\nn_adjusted = adjust_for_dropout(n_base, 0.20)\nprintln(\"Enroll: $n_adjusted to retain $n_base\")  # 80 subjects\n</code></pre>"},{"location":"julia/trial/power/#per-period-dropout-crossover","title":"Per-Period Dropout (Crossover)","text":"<pre><code>function adjust_crossover_dropout(\n    n_calculated::Int,\n    dropout_per_period::Float64,\n    n_periods::Int\n)\n    # Expected completers\n    retention = (1 - dropout_per_period)^n_periods\n\n    n_adjusted = ceil(Int, n_calculated / retention)\n    return n_adjusted\nend\n\n# 2\u00d72 crossover with 5% dropout per period\nn = adjust_crossover_dropout(24, 0.05, 2)  # ~27 subjects\n</code></pre>"},{"location":"julia/trial/power/#simulation-based-power","title":"Simulation-Based Power","text":""},{"location":"julia/trial/power/#monte-carlo-power-estimation","title":"Monte Carlo Power Estimation","text":"<pre><code>function simulate_power(\n    trial_spec::TrialSpec,\n    n_subjects::Int,\n    n_simulations::Int = 1000;\n    alpha::Float64 = 0.05,\n    seed::Int = 42\n)\n    Random.seed!(seed)\n    significant_count = 0\n\n    for _ in 1:n_simulations\n        # Simulate trial\n        result = simulate_trial(trial_spec, n=n_subjects)\n\n        # Perform test\n        pvalue = perform_test(result)\n\n        if pvalue &lt; alpha\n            significant_count += 1\n        end\n    end\n\n    power = significant_count / n_simulations\n    se = sqrt(power * (1 - power) / n_simulations)\n\n    return (power = power, se = se, ci_lower = power - 1.96*se, ci_upper = power + 1.96*se)\nend\n</code></pre>"},{"location":"julia/trial/power/#power-for-be-studies","title":"Power for BE Studies","text":"<pre><code>function simulate_be_power(\n    pk_model::PKModel,\n    pk_params::PKParams,\n    omega::Matrix{Float64},\n    n_subjects::Int;\n    formulation_effect::Dict = Dict(:Ka =&gt; 1.05),\n    n_simulations::Int = 1000,\n    seed::Int = 42\n)\n    Random.seed!(seed)\n    be_pass = 0\n\n    for _ in 1:n_simulations\n        # Simulate crossover trial\n        result = simulate_crossover_be(\n            pk_model, pk_params, omega,\n            n = n_subjects,\n            formulation_effect = formulation_effect\n        )\n\n        # Assess BE\n        be = assess_bioequivalence(result.test_auc, result.ref_auc)\n\n        if be.is_bioequivalent\n            be_pass += 1\n        end\n    end\n\n    return be_pass / n_simulations\nend\n\n# Example: Power analysis for BE study\npower = simulate_be_power(\n    TwoCompOral(),\n    TwoCompOralParams(Ka=1.5, CL=10.0, V1=50.0, Q=5.0, V2=100.0),\n    [0.09 0.0; 0.0 0.04],\n    24\n)\nprintln(\"BE power with N=24: $(round(power*100, digits=1))%\")\n</code></pre>"},{"location":"julia/trial/power/#special-populations","title":"Special Populations","text":""},{"location":"julia/trial/power/#pediatric-trial-power","title":"Pediatric Trial Power","text":"<pre><code>function pediatric_power_adjustment(\n    adult_n::Int,\n    age_groups::Vector{Tuple{Int, Int}},  # (min_age, max_age)\n    group_weights::Vector{Float64};\n    variability_inflation::Float64 = 1.2\n)\n    # Adjust for higher variability in pediatrics\n    adjusted_n = ceil(Int, adult_n * variability_inflation)\n\n    # Distribute across age groups\n    group_n = [ceil(Int, adjusted_n * w) for w in group_weights]\n\n    return (\n        total_n = sum(group_n),\n        group_allocation = Dict(zip(age_groups, group_n))\n    )\nend\n\n# Example: Pediatric study\nresult = pediatric_power_adjustment(\n    64,  # Adult study N\n    [(2, 6), (6, 12), (12, 18)],  # Age groups\n    [0.3, 0.4, 0.3]  # Allocation weights\n)\n</code></pre>"},{"location":"julia/trial/power/#renalhepatic-impairment","title":"Renal/Hepatic Impairment","text":"<pre><code>function impairment_study_size(\n    base_effect::Float64,\n    cv::Float64;\n    impairment_groups::Vector{Symbol} = [:mild, :moderate, :severe],\n    alpha::Float64 = 0.05,\n    power::Float64 = 0.80\n)\n    # Typically 6-8 per group for PK studies\n    # Calculate based on detecting specified fold-change\n\n    n_per_group = sample_size_parallel(base_effect, alpha, power) \u00f7 2\n\n    # Ensure minimum of 6 per group (FDA guidance)\n    n_per_group = max(n_per_group, 6)\n\n    return (\n        n_per_group = n_per_group,\n        n_total = n_per_group * (length(impairment_groups) + 1),  # +1 for normal\n        groups = [:normal; impairment_groups]\n    )\nend\n</code></pre>"},{"location":"julia/trial/power/#adaptive-sample-size","title":"Adaptive Sample Size","text":""},{"location":"julia/trial/power/#sample-size-re-estimation","title":"Sample Size Re-estimation","text":"<pre><code>struct AdaptiveSampleSizeSpec\n    initial_n::Int              # Initial sample size\n    interim_fraction::Float64   # Fraction for interim (e.g., 0.5)\n    conditional_power_target::Float64  # Target conditional power\n    max_n::Int                  # Maximum total N\n    min_increase::Int           # Minimum increase if needed\nend\n\nfunction sample_size_reestimation(\n    spec::AdaptiveSampleSizeSpec,\n    interim_result::InterimResult\n)\n    # Calculate observed effect size\n    observed_es = interim_result.effect_estimate / interim_result.se\n\n    # Calculate conditional power at current N\n    n_remaining = spec.initial_n - interim_result.n\n    cp_current = conditional_power(observed_es, interim_result.n, n_remaining)\n\n    if cp_current &gt;= spec.conditional_power_target\n        return spec.initial_n  # No increase needed\n    end\n\n    # Calculate new sample size for target conditional power\n    new_n = find_n_for_conditional_power(\n        observed_es,\n        interim_result.n,\n        spec.conditional_power_target\n    )\n\n    new_n = min(new_n, spec.max_n)\n    new_n = max(new_n, spec.initial_n + spec.min_increase)\n\n    return new_n\nend\n</code></pre>"},{"location":"julia/trial/power/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\n\n# ============================================\n# Power Analysis for Phase III Parallel Study\n# ============================================\n\nprintln(\"=== Power Analysis ===\\n\")\n\n# 1. Study Parameters\nprintln(\"--- Study Parameters ---\")\neffect_size = 0.40            # Expected treatment effect (Cohen's d)\ncv = 0.35                     # Between-subject CV\nalpha = 0.05                  # Type I error\ntarget_power = 0.80           # Target power\ndropout_rate = 0.15           # Expected dropout\n\nprintln(\"Effect size (Cohen's d): $effect_size\")\nprintln(\"Between-subject CV: $(cv * 100)%\")\nprintln(\"Alpha: $alpha\")\nprintln(\"Target power: $(target_power * 100)%\")\nprintln(\"Expected dropout: $(dropout_rate * 100)%\")\n\n# 2. Calculate base sample size\nprintln(\"\\n--- Sample Size Calculation ---\")\nn_per_arm = sample_size_parallel(effect_size, alpha, target_power)\nprintln(\"Base sample size: $n_per_arm per arm\")\n\n# 3. Adjust for dropout\nn_adjusted = adjust_for_dropout(n_per_arm, dropout_rate)\nprintln(\"Adjusted for dropout: $n_adjusted per arm\")\nprintln(\"Total enrollment: $(2 * n_adjusted)\")\n\n# 4. Power curve\nprintln(\"\\n--- Power by Sample Size ---\")\nprintln(\"N/arm    Power\")\nprintln(\"-\" ^ 20)\n\nfor n in [30, 40, 50, 60, 70, 80, 90, 100]\n    pow = calculate_power_parallel(effect_size, alpha, n)\n    marker = pow &gt;= 0.80 ? \"*\" : \"\"\n    @printf(\"%4d    %5.1f%%%s\\n\", n, pow * 100, marker)\nend\n\n# 5. Effect size sensitivity\nprintln(\"\\n--- Detectable Effect Sizes ---\")\nprintln(\"With N = $n_per_arm per arm:\")\n\nfor power_target in [0.70, 0.80, 0.90]\n    min_es = minimum_detectable_effect(n_per_arm, alpha, power_target)\n    @printf(\"  For %d%% power: Cohen's d = %.3f\\n\", Int(power_target*100), min_es)\nend\n\n# 6. Simulation-based verification\nprintln(\"\\n--- Simulation Verification ---\")\nprintln(\"Running 1000 simulations...\")\n\n# Define trial\ndesign = ParallelDesign(\n    n_arms = 2,\n    arm_names = [\"Placebo\", \"Treatment\"],\n    randomization_ratio = [1, 1]\n)\n\npk_model = OneCompOral()\npk_params = OneCompOralParams(Ka=1.5, CL=10.0, V=60.0)\nomega = [0.09 0.0; 0.0 0.04]\n\n# Simulate power\nsimulated_power = simulate_trial_power(\n    design = design,\n    pk_model = pk_model,\n    pk_params = pk_params,\n    omega = omega,\n    n_per_arm = n_per_arm,\n    treatment_effect = effect_size,\n    n_simulations = 1000\n)\n\nprintln(\"Simulated power: $(round(simulated_power.power * 100, digits=1))%\")\nprintln(\"95% CI: [$(round(simulated_power.ci_lower * 100, digits=1))%, \" *\n        \"$(round(simulated_power.ci_upper * 100, digits=1))%]\")\n\n# 7. Summary\nprintln(\"\\n\" * \"=\" ^ 50)\nprintln(\"RECOMMENDATION\")\nprintln(\"=\" ^ 50)\nprintln(\"\\nEnroll $(2 * n_adjusted) subjects ($(n_adjusted) per arm)\")\nprintln(\"Expected completers: ~$(2 * n_per_arm)\")\nprintln(\"Achieves $(Int(target_power * 100))% power to detect effect size = $effect_size\")\n</code></pre>"},{"location":"julia/trial/power/#power-tables","title":"Power Tables","text":""},{"location":"julia/trial/power/#parallel-design-reference","title":"Parallel Design Reference","text":"Effect Size CV N per Arm (80% power) N per Arm (90% power) 0.3 30% 176 235 0.4 30% 99 132 0.5 30% 64 85 0.6 30% 44 59 0.3 40% 176 235 0.4 40% 99 132 0.5 40% 64 85"},{"location":"julia/trial/power/#crossover-be-reference","title":"Crossover BE Reference","text":"CV Within GMR N (80% power) N (90% power) 15% 0.95 10 14 20% 0.95 16 22 25% 0.95 24 32 30% 0.95 36 48 25% 1.00 18 24 25% 0.90 40 54"},{"location":"julia/trial/power/#see-also","title":"See Also","text":"<ul> <li>Parallel Design - Parallel trial simulation</li> <li>Crossover Design - Crossover trial simulation</li> <li>Dose Escalation - Phase I designs</li> <li>Bioequivalence - BE analysis methods</li> </ul>"},{"location":"julia/vpc/","title":"Visual Predictive Check (VPC)","text":"<p>Visual Predictive Checks are essential diagnostic tools for validating population PK/PD models by comparing observed data to model predictions.</p>"},{"location":"julia/vpc/#overview","title":"Overview","text":"<p>VPC compares the distribution of observed data to simulations from the final model, assessing whether the model adequately captures:</p> <ul> <li>Central tendency (median)</li> <li>Variability (prediction intervals)</li> <li>Temporal patterns</li> </ul> <pre><code>graph LR\n    A[Final Model] --&gt; B[Simulate n Replicates]\n    B --&gt; C[Calculate Percentiles]\n    D[Observed Data] --&gt; E[Calculate Percentiles]\n    C --&gt; F[Compare &amp; Plot]\n    E --&gt; F\n</code></pre>"},{"location":"julia/vpc/#vpc-types","title":"VPC Types","text":"<ul> <li> <p> Standard VPC</p> <p>Basic VPC with observed vs simulated percentiles</p> <p> Standard VPC</p> </li> <li> <p> Prediction-Corrected VPC</p> <p>Corrects for design differences across bins</p> <p> pcVPC</p> </li> <li> <p> Stratified VPC</p> <p>Separate VPC by covariate strata</p> <p> Stratified</p> </li> </ul>"},{"location":"julia/vpc/#quick-start","title":"Quick Start","text":""},{"location":"julia/vpc/#standard-vpc","title":"Standard VPC","text":"<pre><code>using OpenPKPDCore\n\n# Observed data\nobserved = VPCData(\n    times = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0],\n    dv = [...],  # Observed concentrations\n    ids = [...],\n    strata = nothing\n)\n\n# Final model parameters\nmodel_spec = ModelSpec(...)\n\n# VPC configuration\nconfig = VPCConfig(\n    n_simulations = 1000,\n    prediction_intervals = [0.05, 0.50, 0.95],\n    bin_method = :jenks,          # Optimal binning\n    bin_n = 8,                    # Number of bins\n    seed = 12345\n)\n\n# Compute VPC\nresult = compute_vpc(observed, model_spec, config)\n\n# Access results\nprintln(\"Observed percentiles: \", result.observed_percentiles)\nprintln(\"Simulated percentiles: \", result.simulated_percentiles)\nprintln(\"Simulated CI: \", result.simulated_ci)\n</code></pre>"},{"location":"julia/vpc/#prediction-corrected-vpc","title":"Prediction-Corrected VPC","text":"<pre><code>config = VPCConfig(\n    n_simulations = 1000,\n    prediction_intervals = [0.05, 0.50, 0.95],\n    prediction_correction = true,  # Enable pcVPC\n    bin_method = :jenks,\n    seed = 12345\n)\n\nresult = compute_vpc(observed, model_spec, config)\n</code></pre>"},{"location":"julia/vpc/#vpc-components","title":"VPC Components","text":""},{"location":"julia/vpc/#observed-percentiles","title":"Observed Percentiles","text":"<p>Percentiles calculated from observed data within each time bin:</p> <ul> <li>5th percentile: Lower bound of variability</li> <li>50th percentile: Median (central tendency)</li> <li>95th percentile: Upper bound of variability</li> </ul>"},{"location":"julia/vpc/#simulated-percentiles","title":"Simulated Percentiles","text":"<p>For each simulation replicate, percentiles are calculated within bins, then the distribution of these percentiles provides:</p> <ul> <li>Median of simulated percentiles: Expected percentile</li> <li>95% CI of simulated percentiles: Prediction uncertainty</li> </ul>"},{"location":"julia/vpc/#interpretation","title":"Interpretation","text":"Observation Interpretation Observed within CI Model adequate Observed outside CI Potential model misspecification Systematic deviation Structural model issue Random deviation May be sampling variability"},{"location":"julia/vpc/#binning-strategies","title":"Binning Strategies","text":""},{"location":"julia/vpc/#available-methods","title":"Available Methods","text":"Method Description Use Case <code>:jenks</code> Natural breaks optimization Default, uneven sampling <code>:equal_n</code> Equal observations per bin Sparse data <code>:equal_width</code> Equal time intervals Dense, even sampling <code>:manual</code> User-specified boundaries Custom requirements"},{"location":"julia/vpc/#configuration","title":"Configuration","text":"<pre><code># Jenks natural breaks (default)\nconfig = VPCConfig(bin_method = :jenks, bin_n = 8)\n\n# Equal observations per bin\nconfig = VPCConfig(bin_method = :equal_n, bin_n = 10)\n\n# Manual bin boundaries\nconfig = VPCConfig(\n    bin_method = :manual,\n    bin_boundaries = [0, 1, 2, 4, 8, 12, 24]\n)\n</code></pre>"},{"location":"julia/vpc/#vpc-result-structure","title":"VPC Result Structure","text":"<pre><code>struct VPCResult\n    # Binning\n    bins::Vector{Tuple{Float64, Float64}}\n    bin_midpoints::Vector{Float64}\n\n    # Observed statistics\n    observed_percentiles::Dict{Float64, Vector{Float64}}\n    observed_n::Vector{Int}\n\n    # Simulated statistics\n    simulated_percentiles::Dict{Float64, Vector{Float64}}\n    simulated_ci::Dict{Float64, Matrix{Float64}}\n\n    # Configuration\n    prediction_intervals::Vector{Float64}\n    n_simulations::Int\n\n    # Optional BLQ\n    observed_blq_fraction::Vector{Float64}\n    simulated_blq_fraction::Vector{Float64}\n    simulated_blq_ci::Matrix{Float64}\nend\n</code></pre>"},{"location":"julia/vpc/#stratified-vpc","title":"Stratified VPC","text":"<p>For models with covariates, stratify VPC by subgroups:</p> <pre><code># Define strata\nobserved = VPCData(\n    times = [...],\n    dv = [...],\n    ids = [...],\n    strata = [:high_dose, :high_dose, :low_dose, ...]  # Covariate groups\n)\n\nconfig = VPCConfig(\n    n_simulations = 1000,\n    stratify_by = :strata\n)\n\nresult = compute_vpc(observed, model_spec, config)\n\n# Results are stratified\nfor stratum in unique(observed.strata)\n    println(\"Stratum: \", stratum)\n    println(\"  Observed median: \", result.observed_percentiles[stratum][0.50])\nend\n</code></pre>"},{"location":"julia/vpc/#blq-handling","title":"BLQ Handling","text":"<p>Below Limit of Quantification observations require special handling:</p> <pre><code>config = VPCConfig(\n    n_simulations = 1000,\n    lloq = 0.1,                   # Lower limit of quantification\n    blq_handling = :censor        # Censor BLQ observations\n)\n\n# Result includes BLQ fractions\nprintln(\"Observed BLQ fraction: \", result.observed_blq_fraction)\nprintln(\"Simulated BLQ fraction: \", result.simulated_blq_fraction)\n</code></pre>"},{"location":"julia/vpc/#next-steps","title":"Next Steps","text":"<ul> <li>Standard VPC - Detailed standard VPC</li> <li>pcVPC - Prediction-corrected VPC</li> <li>Stratified VPC - Covariate stratification</li> <li>Python Visualization - Plotting VPC results</li> </ul>"},{"location":"julia/vpc/pcvpc/","title":"Prediction-Corrected VPC (pcVPC)","text":"<p>Comprehensive guide to prediction-corrected Visual Predictive Checks for models with variable dosing or covariates.</p>"},{"location":"julia/vpc/pcvpc/#overview","title":"Overview","text":"<p>Prediction-Corrected VPC (pcVPC) normalizes both observed and simulated data by the population prediction, removing structural model trends and enabling meaningful comparisons when:</p> <ul> <li>Doses vary between subjects</li> <li>Covariates affect predictions</li> <li>Sampling designs differ across subjects</li> </ul>"},{"location":"julia/vpc/pcvpc/#the-problem-with-standard-vpc","title":"The Problem with Standard VPC","text":"<p>Standard VPC assumes homogeneous design across subjects. When doses or covariates vary:</p> <pre><code>Subject 1: 100 mg dose \u2192 Expected Cmax \u2248 10 mg/L\nSubject 2: 200 mg dose \u2192 Expected Cmax \u2248 20 mg/L\n\nStandard VPC bins mix these, creating artificial variability\n</code></pre>"},{"location":"julia/vpc/pcvpc/#pcvpc-solution","title":"pcVPC Solution","text":"<p>pcVPC corrects each observation by the population prediction:</p> \\[pcDV_{ij} = DV_{ij} \\times \\frac{PRED_{bin}}{PRED_{ij}}\\] <p>Where: - \\(DV_{ij}\\) = Observed concentration for subject \\(i\\) at time \\(j\\) - \\(PRED_{ij}\\) = Population prediction for subject \\(i\\) at time \\(j\\) - \\(PRED_{bin}\\) = Median population prediction for the time bin</p>"},{"location":"julia/vpc/pcvpc/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"julia/vpc/pcvpc/#prediction-correction-formula","title":"Prediction Correction Formula","text":"<p>For each observation:</p> <ol> <li>Compute individual PRED: \\(PRED_{ij}\\) from population model (no IIV)</li> <li>Compute bin PRED: \\(PRED_{bin} = \\text{median}(PRED_{ij})\\) for all \\(j\\) in bin</li> <li>Correct observation: \\(pcDV_{ij} = DV_{ij} \\times \\frac{PRED_{bin}}{PRED_{ij}}\\)</li> </ol>"},{"location":"julia/vpc/pcvpc/#effect-of-correction","title":"Effect of Correction","text":"Scenario Before Correction After Correction High dose subject High DV Normalized to bin median Low dose subject Low DV Normalized to bin median Heavy patient (CL\u2191) Low DV Normalized Light patient (CL\u2193) High DV Normalized"},{"location":"julia/vpc/pcvpc/#computing-pcvpc","title":"Computing pcVPC","text":""},{"location":"julia/vpc/pcvpc/#basic-usage","title":"Basic Usage","text":"<pre><code>using OpenPKPDCore\n\n# Observed data with variable dosing\nobserved = ObservedData(\n    subject_ids = subject_ids,\n    times = obs_times,\n    dv = obs_dv,\n    dvid = fill(:conc, length(obs_dv))\n)\n\n# Population model\ntypical_params = OneCompOralParams(1.5, 5.0, 50.0)\nomega = OmegaMatrix([\n    0.09 0.0  0.0;\n    0.0  0.09 0.0;\n    0.0  0.0  0.04\n])\n\n# Variable doses per subject\ndoses_per_subject = Dict(\n    \"S1\" =&gt; [DoseEvent(0.0, 100.0)],\n    \"S2\" =&gt; [DoseEvent(0.0, 200.0)],\n    \"S3\" =&gt; [DoseEvent(0.0, 150.0)],\n    # ...\n)\n\nbase_spec = ModelSpec(OneCompOral(), \"pcvpc_model\", typical_params, doses_per_subject)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = length(unique(observed.subject_ids)),\n    omega = omega,\n    seed = 12345\n)\n\n# VPC configuration with prediction correction\nconfig = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    prediction_corrected = true,    # Enable pcVPC\n    binning = QuantileBinning(8),\n    n_simulations = 500,\n    seed = 42\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Compute pcVPC\nresult = compute_pcvpc(observed, pop_spec, grid, solver; config=config)\n</code></pre>"},{"location":"julia/vpc/pcvpc/#dedicated-pcvpc-function","title":"Dedicated pcVPC Function","text":"<pre><code># Using dedicated function (equivalent to above)\nresult = compute_pcvpc(\n    observed,\n    pop_spec,\n    grid,\n    solver;\n    config = VPCConfig(\n        pi_levels = [0.05, 0.50, 0.95],\n        n_simulations = 500,\n        binning = QuantileBinning(8)\n    )\n)\n</code></pre>"},{"location":"julia/vpc/pcvpc/#when-to-use-pcvpc","title":"When to Use pcVPC","text":""},{"location":"julia/vpc/pcvpc/#use-pcvpc-when","title":"Use pcVPC When","text":"<ol> <li> <p>Variable dosing across subjects <pre><code># Different doses\ndoses = [100, 200, 300, 400, 500]  # mg\n</code></pre></p> </li> <li> <p>Significant covariate effects <pre><code># Weight-based dosing\ncovariate_model = CovariateModel([\n    CovariateEffect(:CL, :WT, 70.0, :power, 0.75),\n    CovariateEffect(:V, :WT, 70.0, :power, 1.0)\n])\n</code></pre></p> </li> <li> <p>Multiple formulations or routes <pre><code># Different bioavailability\nformulations = [:tablet, :capsule, :solution]\n</code></pre></p> </li> <li> <p>Dose escalation studies <pre><code># Phase 1 with escalating doses\ncohorts = [10, 30, 100, 300, 1000]  # mg\n</code></pre></p> </li> </ol>"},{"location":"julia/vpc/pcvpc/#use-standard-vpc-when","title":"Use Standard VPC When","text":"<ul> <li>All subjects receive same dose</li> <li>No significant covariate effects</li> <li>Homogeneous study design</li> </ul>"},{"location":"julia/vpc/pcvpc/#pcvpc-internals","title":"pcVPC Internals","text":""},{"location":"julia/vpc/pcvpc/#prediction-computation","title":"Prediction Computation","text":"<pre><code># Internal: Compute base model predictions\nfunction _compute_prediction_correction_data(\n    observed::ObservedData,\n    pop_spec::PopulationSpec,\n    grid::SimGrid,\n    solver::SolverSpec,\n    bin_defs::Vector{BinDefinition}\n)\n    # 1. Simulate population with IIV=0 (typical subject)\n    # 2. Interpolate to exact observation times\n    # 3. Compute bin median predictions\n    return (obs_preds, bin_pred_medians)\nend\n</code></pre>"},{"location":"julia/vpc/pcvpc/#correction-application","title":"Correction Application","text":"<pre><code># Internal: Apply correction to observations\nfunction _apply_prediction_correction(\n    obs_values::Vector{Float64},\n    obs_times::Vector{Float64},\n    obs_preds::Vector{Float64},\n    bin_defs::Vector{BinDefinition},\n    bin_pred_medians::Dict{Int, Float64}\n)\n    corrected = similar(obs_values)\n    for i in eachindex(obs_values)\n        bin_id = _find_bin(obs_times[i], bin_defs)\n        if bin_id !== nothing\n            corrected[i] = obs_values[i] * bin_pred_medians[bin_id] / obs_preds[i]\n        end\n    end\n    return corrected\nend\n</code></pre>"},{"location":"julia/vpc/pcvpc/#covariate-effects-in-pcvpc","title":"Covariate Effects in pcVPC","text":""},{"location":"julia/vpc/pcvpc/#with-covariate-model","title":"With Covariate Model","text":"<pre><code># Define covariate effects\ncovariate_model = CovariateModel([\n    CovariateEffect(:CL, :WT, 70.0, :power, 0.75),   # Allometric\n    CovariateEffect(:V, :WT, 70.0, :power, 1.0),     # Allometric\n    CovariateEffect(:CL, :CRCL, 100.0, :linear, 0.5) # Renal function\n])\n\n# Subject covariates\ncovariates = [\n    Dict(:WT =&gt; 65.0, :CRCL =&gt; 90.0),\n    Dict(:WT =&gt; 85.0, :CRCL =&gt; 120.0),\n    Dict(:WT =&gt; 55.0, :CRCL =&gt; 60.0),\n    # ...\n]\n\n# Population with covariates\npop_spec = PopulationSpec(\n    base_spec,\n    n = n_subjects,\n    omega = omega,\n    covariate_model = covariate_model,\n    covariates = covariates,\n    seed = 12345\n)\n\n# pcVPC automatically handles covariate-adjusted predictions\nresult = compute_pcvpc(observed, pop_spec, grid, solver; config=config)\n</code></pre>"},{"location":"julia/vpc/pcvpc/#covariate-impact-on-pred","title":"Covariate Impact on PRED","text":"<p>The prediction correction accounts for:</p> \\[PRED_i = f(\\theta, X_i)\\] <p>Where \\(X_i\\) are individual covariates. Heavy patients have higher PRED due to:</p> <pre><code># For CL with power covariate\nCL_i = CL_pop * (WT_i / 70)^0.75\n\n# PRED is computed using this adjusted CL\n</code></pre>"},{"location":"julia/vpc/pcvpc/#result-structure","title":"Result Structure","text":"<p>pcVPC results have the same structure as standard VPC:</p> <pre><code>struct VPCResult\n    config::VPCConfig\n    bins::Vector{VPCBin}\n    n_subjects_observed::Int\n    n_observations_observed::Int\n    n_simulations::Int\n    strata::String\n    simulation_seed::UInt64\nend\n</code></pre>"},{"location":"julia/vpc/pcvpc/#accessing-pcvpc-results","title":"Accessing pcVPC Results","text":"<pre><code># Same accessor functions work\ntimes = bin_midpoints(result)\n\nobs_median = observed_percentile(result, 0.50)\nsim_median = simulated_median(result, 0.50)\nsim_lower = simulated_lower(result, 0.50)\nsim_upper = simulated_upper(result, 0.50)\n\n# These are now prediction-corrected values\nprintln(\"Prediction-corrected observed median: \", obs_median)\nprintln(\"Prediction-corrected simulated CI: [$sim_lower, $sim_upper]\")\n</code></pre>"},{"location":"julia/vpc/pcvpc/#interpretation","title":"Interpretation","text":""},{"location":"julia/vpc/pcvpc/#pcvpc-vs-standard-vpc","title":"pcVPC vs Standard VPC","text":"Aspect Standard VPC pcVPC Y-axis Concentration Prediction-corrected concentration Variability source Structural + IIV IIV only Dose differences Visible as variability Normalized out Covariate effects Visible as variability Normalized out Model assessment Overall fit Random effects fit"},{"location":"julia/vpc/pcvpc/#what-pcvpc-shows","title":"What pcVPC Shows","text":"<ol> <li>Residual variability capture - Is omega correctly estimated?</li> <li>IIV distribution shape - Log-normal assumption valid?</li> <li>Time-varying effects - Any model misspecification over time?</li> </ol>"},{"location":"julia/vpc/pcvpc/#what-pcvpc-hides","title":"What pcVPC Hides","text":"<ol> <li>Dose-response relationship - Already normalized</li> <li>Covariate relationships - Already corrected</li> <li>Structural model trends - Removed by correction</li> </ol>"},{"location":"julia/vpc/pcvpc/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Random\n\n# ================================================\n# pcVPC Example: Variable Dosing Study\n# ================================================\n\nprintln(\"=== Prediction-Corrected VPC ===\\n\")\n\n# 1. Simulate variable-dose study\nRandom.seed!(456)\nn_subjects = 60\n\n# Dose levels (mg)\ndose_levels = [50.0, 100.0, 200.0]\nn_per_dose = 20\n\nsubject_ids = String[]\nobs_times = Float64[]\nobs_dv = Float64[]\ndoses_dict = Dict{String, Vector{DoseEvent}}()\n\n# True parameters\ntrue_ka = 1.5\ntrue_cl = 5.0\ntrue_v = 50.0\nomega_ka = 0.16\nomega_cl = 0.09\nomega_v = 0.04\n\nsampling_times = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\n\nsubject_idx = 1\nfor dose in dose_levels\n    for _ in 1:n_per_dose\n        sid = \"S$subject_idx\"\n        doses_dict[sid] = [DoseEvent(0.0, dose)]\n\n        # Individual parameters\n        ka_i = true_ka * exp(randn() * sqrt(omega_ka))\n        cl_i = true_cl * exp(randn() * sqrt(omega_cl))\n        v_i = true_v * exp(randn() * sqrt(omega_v))\n\n        for t in sampling_times\n            # One-compartment oral\n            conc = dose * ka_i / (v_i * (ka_i - cl_i/v_i)) *\n                   (exp(-cl_i/v_i * t) - exp(-ka_i * t))\n\n            # Proportional error\n            conc_obs = conc * (1 + 0.1 * randn())\n            conc_obs = max(0.01, conc_obs)\n\n            push!(subject_ids, sid)\n            push!(obs_times, t)\n            push!(obs_dv, conc_obs)\n        end\n\n        subject_idx += 1\n    end\nend\n\n# 2. Create observed data\nobserved = ObservedData(\n    subject_ids = subject_ids,\n    times = obs_times,\n    dv = obs_dv,\n    dvid = fill(:conc, length(obs_dv))\n)\n\nprintln(\"Variable-dose study:\")\nprintln(\"  Dose levels: $dose_levels mg\")\nprintln(\"  Subjects per dose: $n_per_dose\")\nprintln(\"  Total subjects: $n_subjects\")\nprintln(\"  Total observations: $(length(obs_dv))\")\n\n# 3. Define population model\ntypical_params = OneCompOralParams(true_ka, true_cl, true_v)\nomega = OmegaMatrix([\n    omega_ka 0.0      0.0;\n    0.0      omega_cl 0.0;\n    0.0      0.0      omega_v\n])\n\n# Need subject-specific doses for pcVPC\nbase_spec = ModelSpec(OneCompOral(), \"variable_dose_model\", typical_params, doses_dict)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = n_subjects,\n    omega = omega,\n    seed = 12345\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# 4. Compare Standard VPC vs pcVPC\nprintln(\"\\n--- Computing Standard VPC ---\")\nconfig_standard = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    prediction_corrected = false,\n    binning = QuantileBinning(7),\n    n_simulations = 500,\n    seed = 42\n)\n\nresult_standard = compute_vpc(observed, pop_spec, grid, solver; config=config_standard)\n\nprintln(\"\\n--- Computing pcVPC ---\")\nconfig_pc = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    prediction_corrected = true,\n    binning = QuantileBinning(7),\n    n_simulations = 500,\n    seed = 42\n)\n\nresult_pcvpc = compute_pcvpc(observed, pop_spec, grid, solver; config=config_pc)\n\n# 5. Compare results\nprintln(\"\\n--- Comparison: Standard vs pcVPC ---\")\nprintln(\"\\nStandard VPC (affected by dose variability):\")\nprintln(\"Bin | Obs P50 Range | Sim P50 CI Width\")\nfor bin in result_standard.bins\n    p50 = filter(p -&gt; p.percentile == 0.50, bin.percentiles)[1]\n    ci_width = p50.simulated_upper - p50.simulated_lower\n    println(\"$(bin.bin_id)   | $(round(p50.observed, digits=2)) | $(round(ci_width, digits=2))\")\nend\n\nprintln(\"\\npcVPC (normalized for dose):\")\nprintln(\"Bin | Obs P50 Range | Sim P50 CI Width\")\nfor bin in result_pcvpc.bins\n    p50 = filter(p -&gt; p.percentile == 0.50, bin.percentiles)[1]\n    ci_width = p50.simulated_upper - p50.simulated_lower\n    println(\"$(bin.bin_id)   | $(round(p50.observed, digits=2)) | $(round(ci_width, digits=2))\")\nend\n\n# 6. Coverage comparison\nprintln(\"\\n--- Coverage Comparison ---\")\nfor level in [0.05, 0.50, 0.95]\n    cov_std = vpc_coverage(result_standard, level)\n    cov_pc = vpc_coverage(result_pcvpc, level)\n    println(\"P$(Int(level*100)): Standard=$(round(cov_std*100, digits=1))%, pcVPC=$(round(cov_pc*100, digits=1))%\")\nend\n\nprintln(\"\\n\u2713 pcVPC computation complete\")\nprintln(\"\\nNote: pcVPC shows tighter CI as dose variability is normalized\")\n</code></pre>"},{"location":"julia/vpc/pcvpc/#best-practices","title":"Best Practices","text":""},{"location":"julia/vpc/pcvpc/#when-computing-pcvpc","title":"When Computing pcVPC","text":"<ol> <li>Ensure accurate PRED - Use final model parameters</li> <li>Include all covariates - That affect PRED</li> <li>Match dosing exactly - Subject-specific doses</li> <li>Sufficient simulations - 500+ for stable CI</li> </ol>"},{"location":"julia/vpc/pcvpc/#reporting","title":"Reporting","text":"<p>When presenting pcVPC:</p> <ol> <li>Label axes clearly - \"Prediction-Corrected Concentration\"</li> <li>Note correction method - \"pcVPC per Bergstrand et al. (2011)\"</li> <li>Report uncorrected alongside - When relevant</li> <li>Explain interpretation - For non-expert audience</li> </ol>"},{"location":"julia/vpc/pcvpc/#references","title":"References","text":"<ul> <li>Bergstrand M, Hooker AC, Wallin JE, Karlsson MO. Prediction-corrected visual predictive checks for diagnosing nonlinear mixed-effects models. AAPS J. 2011;13(2):143-151.</li> </ul>"},{"location":"julia/vpc/pcvpc/#see-also","title":"See Also","text":"<ul> <li>Standard VPC - Basic VPC methodology</li> <li>Stratified VPC - Covariate stratification</li> <li>VPC Index - Overview</li> <li>Python pcVPC - Python visualization</li> </ul>"},{"location":"julia/vpc/standard/","title":"Standard VPC","text":"<p>Comprehensive guide to standard Visual Predictive Checks for model validation.</p>"},{"location":"julia/vpc/standard/#overview","title":"Overview","text":"<p>Standard VPC compares observed data percentiles to simulated percentile distributions within time bins. It's the foundational diagnostic tool for assessing whether a population model adequately captures the central tendency and variability of observed data.</p> \\[\\text{VPC validates: } P_{obs}(q) \\in CI_{sim}(q) \\text{ for each percentile } q\\] <pre><code>graph TB\n    A[Observed Data] --&gt; B[Bin by Time]\n    B --&gt; C[Calculate Percentiles]\n    D[Population Model] --&gt; E[Simulate N Replicates]\n    E --&gt; F[Bin by Time]\n    F --&gt; G[Calculate Percentiles per Replicate]\n    G --&gt; H[Bootstrap CI on Percentiles]\n    C --&gt; I[Compare &amp; Plot]\n    H --&gt; I\n</code></pre>"},{"location":"julia/vpc/standard/#vpcconfig","title":"VPCConfig","text":"<p>The <code>VPCConfig</code> struct controls all VPC behavior:</p> <pre><code>struct VPCConfig\n    pi_levels::Vector{Float64}       # Prediction interval levels\n    ci_level::Float64                # Confidence interval level\n    binning::BinningStrategy         # Binning method\n    prediction_corrected::Bool       # Enable pcVPC\n    stratify_by::Vector{Symbol}      # Stratification variables\n    lloq::Union{Nothing,Float64}     # Lower limit of quantitation\n    n_simulations::Int               # Number of simulation replicates\n    n_bootstrap::Int                 # Bootstrap samples for CI\n    seed::UInt64                     # Random seed\nend\n</code></pre>"},{"location":"julia/vpc/standard/#default-configuration","title":"Default Configuration","text":"<pre><code>config = VPCConfig()\n# Defaults:\n#   pi_levels = [0.05, 0.50, 0.95]\n#   ci_level = 0.95\n#   binning = QuantileBinning(10)\n#   prediction_corrected = false\n#   stratify_by = Symbol[]\n#   lloq = nothing\n#   n_simulations = 200\n#   n_bootstrap = 500\n#   seed = 12345\n</code></pre>"},{"location":"julia/vpc/standard/#custom-configuration","title":"Custom Configuration","text":"<pre><code>config = VPCConfig(\n    pi_levels = [0.10, 0.50, 0.90],     # 10th, 50th, 90th percentiles\n    ci_level = 0.90,                     # 90% CI\n    binning = QuantileBinning(8),        # 8 bins with equal obs\n    n_simulations = 500,                 # More simulations\n    n_bootstrap = 1000,                  # More bootstrap samples\n    seed = 42                            # Reproducible\n)\n</code></pre>"},{"location":"julia/vpc/standard/#binning-strategies","title":"Binning Strategies","text":"<p>Binning groups observations by time for percentile calculation.</p>"},{"location":"julia/vpc/standard/#quantilebinning-default","title":"QuantileBinning (Default)","text":"<p>Creates bins with approximately equal numbers of observations:</p> <pre><code>using OpenPKPDCore\n\n# 10 bins with equal observation counts\nbinning = QuantileBinning(10)\n\n# Specify number of bins\nconfig = VPCConfig(binning = QuantileBinning(8))\n</code></pre> <p>Best for: Sparse or uneven sampling designs.</p>"},{"location":"julia/vpc/standard/#equalwidthbinning","title":"EqualWidthBinning","text":"<p>Creates bins with equal time ranges:</p> <pre><code># 10 bins with equal time width\nbinning = EqualWidthBinning(10)\n\nconfig = VPCConfig(binning = EqualWidthBinning(12))\n</code></pre> <p>Best for: Dense, uniformly sampled data.</p>"},{"location":"julia/vpc/standard/#kmeansbinning","title":"KMeansBinning","text":"<p>Uses k-means clustering to find natural time groupings:</p> <pre><code># K-means with 8 clusters\nbinning = KMeansBinning(8)\n\n# With custom max iterations\nbinning = KMeansBinning(8, max_iter=200)\n\nconfig = VPCConfig(binning = KMeansBinning(10))\n</code></pre> <p>Best for: Data with natural time clusters (e.g., sparse PK sampling).</p>"},{"location":"julia/vpc/standard/#binning-comparison","title":"Binning Comparison","text":"Strategy Description Advantages Disadvantages Quantile Equal obs per bin Stable percentiles Uneven time coverage EqualWidth Equal time ranges Even time coverage Variable precision KMeans Natural clusters Adaptive May find unintuitive bins"},{"location":"julia/vpc/standard/#computing-standard-vpc","title":"Computing Standard VPC","text":""},{"location":"julia/vpc/standard/#basic-usage","title":"Basic Usage","text":"<pre><code>using OpenPKPDCore\n\n# Define observed data structure\nobserved = ObservedData(\n    subject_ids = [\"S1\", \"S1\", \"S2\", \"S2\", ...],\n    times = [0.5, 2.0, 0.5, 2.0, ...],\n    dv = [10.5, 5.2, 12.1, 6.8, ...],\n    dvid = fill(:conc, length(times))\n)\n\n# Population specification (final model)\ntypical_params = OneCompOralParams(1.5, 5.0, 50.0)  # Ka, CL, V\nomega = OmegaMatrix([\n    0.09 0.0  0.0;\n    0.0  0.09 0.0;\n    0.0  0.0  0.04\n])\n\ndoses = [DoseEvent(0.0, 100.0)]\nbase_spec = ModelSpec(OneCompOral(), \"vpc_model\", typical_params, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = length(unique(observed.subject_ids)),\n    omega = omega,\n    seed = 12345\n)\n\n# Simulation grid matching observed times\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# VPC configuration\nconfig = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    n_simulations = 500,\n    binning = QuantileBinning(8),\n    seed = 42\n)\n\n# Compute VPC\nresult = compute_vpc(observed, pop_spec, grid, solver; config=config)\n</code></pre>"},{"location":"julia/vpc/standard/#with-residual-error","title":"With Residual Error","text":"<pre><code># Add residual error model\nerror_spec = ResidualErrorSpec(\n    kind = :combined,\n    sigma_add = 0.1,\n    sigma_prop = 0.1\n)\n\nresult = compute_vpc(\n    observed, pop_spec, grid, solver;\n    config = config,\n    error_spec = error_spec\n)\n</code></pre>"},{"location":"julia/vpc/standard/#vpcresult-structure","title":"VPCResult Structure","text":"<pre><code>struct VPCResult\n    config::VPCConfig                    # Configuration used\n    bins::Vector{VPCBin}                 # Computed bins\n    n_subjects_observed::Int             # Number of subjects\n    n_observations_observed::Int         # Total observations\n    n_simulations::Int                   # Simulations performed\n    strata::String                       # Strata label\n    simulation_seed::UInt64              # Seed used\nend\n\nstruct VPCBin\n    bin_id::Int                          # Bin identifier\n    time_min::Float64                    # Lower time bound\n    time_max::Float64                    # Upper time bound\n    time_midpoint::Float64               # Midpoint for plotting\n    n_observed::Int                      # Observations in bin\n    n_simulated::Int                     # Simulated per replicate\n    percentiles::Vector{VPCPercentileData}\nend\n\nstruct VPCPercentileData\n    percentile::Float64                  # Percentile level (e.g., 0.50)\n    observed::Float64                    # Observed percentile value\n    simulated_median::Float64            # Median of simulated percentiles\n    simulated_lower::Float64             # Lower CI bound\n    simulated_upper::Float64             # Upper CI bound\nend\n</code></pre>"},{"location":"julia/vpc/standard/#accessing-results","title":"Accessing Results","text":""},{"location":"julia/vpc/standard/#bin-information","title":"Bin Information","text":"<pre><code># Get all bin midpoints for plotting\ntimes = bin_midpoints(result)\nprintln(\"Bin midpoints: \", times)\n\n# Access individual bins\nfor bin in result.bins\n    println(\"Bin $(bin.bin_id): [$(bin.time_min), $(bin.time_max)]\")\n    println(\"  N observed: $(bin.n_observed)\")\n    println(\"  Midpoint: $(bin.time_midpoint)\")\nend\n</code></pre>"},{"location":"julia/vpc/standard/#percentile-data","title":"Percentile Data","text":"<pre><code># Extract observed percentiles\nobs_p05 = observed_percentile(result, 0.05)\nobs_p50 = observed_percentile(result, 0.50)\nobs_p95 = observed_percentile(result, 0.95)\n\n# Extract simulated median percentiles\nsim_p05 = simulated_median(result, 0.05)\nsim_p50 = simulated_median(result, 0.50)\nsim_p95 = simulated_median(result, 0.95)\n\n# Extract simulated CI bounds\nsim_p50_lower = simulated_lower(result, 0.50)\nsim_p50_upper = simulated_upper(result, 0.50)\n</code></pre>"},{"location":"julia/vpc/standard/#detailed-percentile-access","title":"Detailed Percentile Access","text":"<pre><code>for bin in result.bins\n    for pdata in bin.percentiles\n        println(\"Bin $(bin.bin_id), P$(Int(pdata.percentile*100)):\")\n        println(\"  Observed: $(pdata.observed)\")\n        println(\"  Simulated median: $(pdata.simulated_median)\")\n        println(\"  Simulated 95% CI: [$(pdata.simulated_lower), $(pdata.simulated_upper)]\")\n    end\nend\n</code></pre>"},{"location":"julia/vpc/standard/#interpretation-guide","title":"Interpretation Guide","text":""},{"location":"julia/vpc/standard/#good-model-fit","title":"Good Model Fit","text":"<p>A well-specified model shows:</p> <ol> <li>Observed percentiles within CI ribbons for most bins</li> <li>No systematic trends in deviations</li> <li>Similar patterns across the time course</li> </ol> <pre><code>\u2713 Median (50th) within simulated CI\n\u2713 5th/95th percentiles within their CIs\n\u2713 No consistent over/under-prediction\n</code></pre>"},{"location":"julia/vpc/standard/#potential-issues","title":"Potential Issues","text":"Pattern Interpretation Action Observed median above CI Under-prediction Check structural model Observed 95th above CI Under-estimated variability Increase omega values Observed 5th below CI Over-estimated variability Decrease omega values Early deviation only Absorption misspecification Consider transit model Late deviation only Elimination misspecification Check clearance model All bins offset Systematic bias Review typical values"},{"location":"julia/vpc/standard/#quantitative-assessment","title":"Quantitative Assessment","text":"<pre><code># Count bins where observed is within CI\nfunction vpc_coverage(result::VPCResult, level::Float64)\n    in_ci = 0\n    total = length(result.bins)\n\n    for bin in result.bins\n        for pdata in bin.percentiles\n            if pdata.percentile == level\n                if pdata.simulated_lower &lt;= pdata.observed &lt;= pdata.simulated_upper\n                    in_ci += 1\n                end\n            end\n        end\n    end\n\n    return in_ci / total\nend\n\ncoverage_50 = vpc_coverage(result, 0.50)\ncoverage_05 = vpc_coverage(result, 0.05)\ncoverage_95 = vpc_coverage(result, 0.95)\n\nprintln(\"Coverage (expected ~95%):\")\nprintln(\"  Median: $(coverage_50 * 100)%\")\nprintln(\"  5th percentile: $(coverage_05 * 100)%\")\nprintln(\"  95th percentile: $(coverage_95 * 100)%\")\n</code></pre>"},{"location":"julia/vpc/standard/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Random\n\n# ================================================\n# Standard VPC Example: One-Compartment Oral Model\n# ================================================\n\nprintln(\"=== Standard VPC Computation ===\\n\")\n\n# 1. Generate synthetic observed data\nRandom.seed!(123)\nn_subjects = 50\ntimes_per_subject = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\n\nsubject_ids = String[]\nobs_times = Float64[]\nobs_dv = Float64[]\n\n# True parameters with IIV\ntrue_ka = 1.5\ntrue_cl = 5.0\ntrue_v = 50.0\nomega_ka = 0.16  # 40% CV\nomega_cl = 0.09  # 30% CV\nomega_v = 0.04   # 20% CV\n\nfor i in 1:n_subjects\n    # Individual parameters\n    eta_ka = randn() * sqrt(omega_ka)\n    eta_cl = randn() * sqrt(omega_cl)\n    eta_v = randn() * sqrt(omega_v)\n\n    ka_i = true_ka * exp(eta_ka)\n    cl_i = true_cl * exp(eta_cl)\n    v_i = true_v * exp(eta_v)\n\n    dose = 100.0\n\n    for t in times_per_subject\n        # One-compartment oral analytical solution\n        conc = dose * ka_i / (v_i * (ka_i - cl_i/v_i)) *\n               (exp(-cl_i/v_i * t) - exp(-ka_i * t))\n\n        # Add residual error (proportional 10%)\n        conc_obs = conc * (1 + 0.1 * randn())\n        conc_obs = max(0.01, conc_obs)  # Ensure positive\n\n        push!(subject_ids, \"S$i\")\n        push!(obs_times, t)\n        push!(obs_dv, conc_obs)\n    end\nend\n\n# 2. Create observed data structure\nobserved = ObservedData(\n    subject_ids = subject_ids,\n    times = obs_times,\n    dv = obs_dv,\n    dvid = fill(:conc, length(obs_dv))\n)\n\nprintln(\"Observed data:\")\nprintln(\"  Subjects: $(length(unique(subject_ids)))\")\nprintln(\"  Observations: $(length(obs_dv))\")\n\n# 3. Define population model (final model estimates)\ntypical_params = OneCompOralParams(true_ka, true_cl, true_v)\nomega = OmegaMatrix([\n    omega_ka 0.0      0.0;\n    0.0      omega_cl 0.0;\n    0.0      0.0      omega_v\n])\n\ndoses = [DoseEvent(0.0, 100.0)]\nbase_spec = ModelSpec(OneCompOral(), \"final_model\", typical_params, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = n_subjects,\n    omega = omega,\n    seed = 12345\n)\n\n# 4. Configure VPC\nconfig = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    ci_level = 0.95,\n    binning = QuantileBinning(7),  # Match sampling times\n    n_simulations = 500,\n    n_bootstrap = 500,\n    seed = 42\n)\n\n# 5. Simulation settings\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# 6. Compute VPC\nprintln(\"\\nComputing VPC with $(config.n_simulations) simulations...\")\nresult = compute_vpc(observed, pop_spec, grid, solver; config=config)\n\n# 7. Report results\nprintln(\"\\n--- VPC Results ---\")\nprintln(\"Bins: $(length(result.bins))\")\nprintln(\"Simulations: $(result.n_simulations)\")\n\n# 8. Detailed bin analysis\nprintln(\"\\n--- Bin-by-Bin Analysis ---\")\nprintln(\"Bin | Time Range    | N Obs | Obs P50 | Sim P50 CI\")\nprintln(\"-\" ^ 60)\n\nfor bin in result.bins\n    p50_data = filter(p -&gt; p.percentile == 0.50, bin.percentiles)[1]\n\n    time_range = @sprintf(\"[%5.1f, %5.1f]\", bin.time_min, bin.time_max)\n    obs_val = @sprintf(\"%7.2f\", p50_data.observed)\n    ci_str = @sprintf(\"[%6.2f, %6.2f]\", p50_data.simulated_lower, p50_data.simulated_upper)\n\n    # Check if observed is within CI\n    in_ci = p50_data.simulated_lower &lt;= p50_data.observed &lt;= p50_data.simulated_upper\n    status = in_ci ? \"\u2713\" : \"\u2717\"\n\n    println(\"$(bin.bin_id)   | $time_range | $(bin.n_observed)     | $obs_val | $ci_str $status\")\nend\n\n# 9. Coverage statistics\nprintln(\"\\n--- Coverage Statistics ---\")\nfor level in [0.05, 0.50, 0.95]\n    coverage = vpc_coverage(result, level)\n    println(\"P$(Int(level*100)) coverage: $(round(coverage * 100, digits=1))%\")\nend\n\nprintln(\"\\n\u2713 VPC computation complete\")\n</code></pre>"},{"location":"julia/vpc/standard/#troubleshooting","title":"Troubleshooting","text":""},{"location":"julia/vpc/standard/#common-issues","title":"Common Issues","text":"Issue Cause Solution Wide CI ribbons Few simulations Increase <code>n_simulations</code> Jagged percentiles Few obs per bin Reduce <code>n_bins</code> Empty bins Sparse data Use <code>QuantileBinning</code> Slow computation Many simulations Reduce <code>n_simulations</code>"},{"location":"julia/vpc/standard/#performance-tips","title":"Performance Tips","text":"<ol> <li>Start with fewer simulations (100-200) for exploration</li> <li>Increase for final VPC (500-1000) for publication</li> <li>Use appropriate binning based on sampling design</li> <li>Set seed for reproducibility</li> </ol>"},{"location":"julia/vpc/standard/#see-also","title":"See Also","text":"<ul> <li>Prediction-Corrected VPC - For variable dosing designs</li> <li>Stratified VPC - Covariate-based stratification</li> <li>VPC Index - Overview and quick start</li> <li>Python VPC Visualization - Plotting VPC results</li> </ul>"},{"location":"julia/vpc/stratified/","title":"Stratified VPC","text":"<p>Comprehensive guide to stratified Visual Predictive Checks for evaluating model performance across covariate subgroups.</p>"},{"location":"julia/vpc/stratified/#overview","title":"Overview","text":"<p>Stratified VPC computes separate VPCs for different subgroups of the population, enabling assessment of model performance across:</p> <ul> <li>Dose groups</li> <li>Formulations</li> <li>Disease severity</li> <li>Demographic subgroups</li> <li>Study sites or regions</li> </ul> <pre><code>graph TB\n    A[Observed Data] --&gt; B[Stratify by Covariate]\n    B --&gt; C1[Stratum 1: Low Dose]\n    B --&gt; C2[Stratum 2: Medium Dose]\n    B --&gt; C3[Stratum 3: High Dose]\n    C1 --&gt; D1[VPC for Stratum 1]\n    C2 --&gt; D2[VPC for Stratum 2]\n    C3 --&gt; D3[VPC for Stratum 3]\n    D1 --&gt; E[Multi-Panel Plot]\n    D2 --&gt; E\n    D3 --&gt; E\n</code></pre>"},{"location":"julia/vpc/stratified/#when-to-stratify","title":"When to Stratify","text":""},{"location":"julia/vpc/stratified/#use-stratified-vpc-when","title":"Use Stratified VPC When","text":"Scenario Stratification Variable Purpose Dose-finding study Dose group Assess dose-response Multiple formulations Formulation Compare PK profiles Renal impairment eGFR category Validate covariate model Pediatric extension Age group Assess scaling Global trial Region Detect ethnic differences Disease progression Disease stage Validate disease model"},{"location":"julia/vpc/stratified/#choosing-stratification-variables","title":"Choosing Stratification Variables","text":"<pre><code># Good stratification choices:\n# - Categorical or easily binned continuous\n# - Sufficient observations per stratum (\u226520 subjects)\n# - Clinically meaningful groups\n\n# Examples:\nstratify_by = [:DOSE]           # Dose groups\nstratify_by = [:FORM]           # Formulation\nstratify_by = [:RENAL]          # Renal function category\nstratify_by = [:DOSE, :FORM]    # Multiple variables\n</code></pre>"},{"location":"julia/vpc/stratified/#stratifiedvpcresult-structure","title":"StratifiedVPCResult Structure","text":"<pre><code>struct StratifiedVPCResult\n    results::Vector{VPCResult}        # One VPCResult per stratum\n    stratify_by::Vector{Symbol}       # Stratification variables\n    strata_names::Vector{String}      # Labels for each stratum\nend\n</code></pre> <p>Each stratum contains a complete <code>VPCResult</code> with all percentile data.</p>"},{"location":"julia/vpc/stratified/#computing-stratified-vpc","title":"Computing Stratified VPC","text":""},{"location":"julia/vpc/stratified/#basic-usage","title":"Basic Usage","text":"<pre><code>using OpenPKPDCore\n\n# Observed data with stratum information\nobserved = ObservedData(\n    subject_ids = subject_ids,\n    times = obs_times,\n    dv = obs_dv,\n    dvid = fill(:conc, length(obs_dv))\n)\n\n# Strata data: maps subject ID to stratum values\nstrata_data = Dict(\n    \"S1\" =&gt; Dict(:DOSE =&gt; \"100mg\"),\n    \"S2\" =&gt; Dict(:DOSE =&gt; \"200mg\"),\n    \"S3\" =&gt; Dict(:DOSE =&gt; \"100mg\"),\n    \"S4\" =&gt; Dict(:DOSE =&gt; \"400mg\"),\n    # ...\n)\n\n# Population model\ntypical_params = OneCompOralParams(1.5, 5.0, 50.0)\nomega = OmegaMatrix([0.09 0.0; 0.0 0.04])\n\ndoses = [DoseEvent(0.0, 100.0)]  # Reference dose\nbase_spec = ModelSpec(OneCompOral(), \"stratified_model\", typical_params, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = length(unique(observed.subject_ids)),\n    omega = omega,\n    seed = 12345\n)\n\n# VPC configuration with stratification\nconfig = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    stratify_by = [:DOSE],          # Stratification variable\n    binning = QuantileBinning(6),\n    n_simulations = 500,\n    seed = 42\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.5:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# Compute stratified VPC\nresult = compute_stratified_vpc(\n    observed, pop_spec, grid, solver;\n    config = config,\n    strata_data = strata_data\n)\n</code></pre>"},{"location":"julia/vpc/stratified/#multiple-stratification-variables","title":"Multiple Stratification Variables","text":"<pre><code># Stratify by dose AND formulation\nstrata_data = Dict(\n    \"S1\" =&gt; Dict(:DOSE =&gt; \"100mg\", :FORM =&gt; \"tablet\"),\n    \"S2\" =&gt; Dict(:DOSE =&gt; \"100mg\", :FORM =&gt; \"capsule\"),\n    \"S3\" =&gt; Dict(:DOSE =&gt; \"200mg\", :FORM =&gt; \"tablet\"),\n    \"S4\" =&gt; Dict(:DOSE =&gt; \"200mg\", :FORM =&gt; \"capsule\"),\n    # ...\n)\n\nconfig = VPCConfig(\n    stratify_by = [:DOSE, :FORM],   # Multiple variables\n    # Creates strata: \"100mg_tablet\", \"100mg_capsule\", etc.\n    n_simulations = 500\n)\n\nresult = compute_stratified_vpc(\n    observed, pop_spec, grid, solver;\n    config = config,\n    strata_data = strata_data\n)\n</code></pre>"},{"location":"julia/vpc/stratified/#accessing-stratified-results","title":"Accessing Stratified Results","text":""},{"location":"julia/vpc/stratified/#iterate-over-strata","title":"Iterate Over Strata","text":"<pre><code># Access each stratum's VPC\nfor (i, vpc_result) in enumerate(result.results)\n    stratum_name = result.strata_names[i]\n\n    println(\"=== Stratum: $stratum_name ===\")\n    println(\"  Subjects: $(vpc_result.n_subjects_observed)\")\n    println(\"  Observations: $(vpc_result.n_observations_observed)\")\n\n    # Access percentile data\n    times = bin_midpoints(vpc_result)\n    obs_median = observed_percentile(vpc_result, 0.50)\n\n    println(\"  Median at t=1: $(obs_median[1])\")\nend\n</code></pre>"},{"location":"julia/vpc/stratified/#extract-specific-stratum","title":"Extract Specific Stratum","text":"<pre><code># Get VPC for specific stratum\nfunction get_stratum_vpc(result::StratifiedVPCResult, stratum_name::String)\n    idx = findfirst(==(stratum_name), result.strata_names)\n    return isnothing(idx) ? nothing : result.results[idx]\nend\n\n# Example\nhigh_dose_vpc = get_stratum_vpc(result, \"400mg\")\nif high_dose_vpc !== nothing\n    println(\"High dose coverage: \", vpc_coverage(high_dose_vpc, 0.50))\nend\n</code></pre>"},{"location":"julia/vpc/stratified/#compare-across-strata","title":"Compare Across Strata","text":"<pre><code># Compare model performance across strata\nprintln(\"\\nStratum Comparison:\")\nprintln(\"Stratum      | N Subj | Coverage P50 | Coverage P05 | Coverage P95\")\nprintln(\"-\" ^ 70)\n\nfor (i, vpc_result) in enumerate(result.results)\n    name = result.strata_names[i]\n    n_subj = vpc_result.n_subjects_observed\n    cov_50 = vpc_coverage(vpc_result, 0.50)\n    cov_05 = vpc_coverage(vpc_result, 0.05)\n    cov_95 = vpc_coverage(vpc_result, 0.95)\n\n    @printf(\"%-12s | %6d | %11.1f%% | %11.1f%% | %11.1f%%\\n\",\n            name, n_subj, cov_50*100, cov_05*100, cov_95*100)\nend\n</code></pre>"},{"location":"julia/vpc/stratified/#stratification-by-dose","title":"Stratification by Dose","text":""},{"location":"julia/vpc/stratified/#dose-group-stratification","title":"Dose Group Stratification","text":"<pre><code># Define dose groups\ndose_groups = Dict(\n    \"S1\" =&gt; Dict(:DOSE_GROUP =&gt; \"Low\"),      # 50-100 mg\n    \"S2\" =&gt; Dict(:DOSE_GROUP =&gt; \"Medium\"),   # 150-250 mg\n    \"S3\" =&gt; Dict(:DOSE_GROUP =&gt; \"High\"),     # 300-500 mg\n    # ...\n)\n\nconfig = VPCConfig(\n    stratify_by = [:DOSE_GROUP],\n    pi_levels = [0.05, 0.50, 0.95],\n    n_simulations = 500\n)\n\n# For dose-proportional drugs, consider pcVPC + stratification\n# to separate dose-proportionality from IIV assessment\n</code></pre>"},{"location":"julia/vpc/stratified/#dose-specific-simulations","title":"Dose-Specific Simulations","text":"<pre><code># When doses differ between strata, provide dose-specific specs\ndose_specs = Dict(\n    \"Low\" =&gt; [DoseEvent(0.0, 75.0)],\n    \"Medium\" =&gt; [DoseEvent(0.0, 200.0)],\n    \"High\" =&gt; [DoseEvent(0.0, 400.0)]\n)\n\n# Or use subject-specific dosing\ndoses_per_subject = Dict(\n    \"S1\" =&gt; [DoseEvent(0.0, 75.0)],\n    \"S2\" =&gt; [DoseEvent(0.0, 200.0)],\n    # ...\n)\n</code></pre>"},{"location":"julia/vpc/stratified/#stratification-by-covariate","title":"Stratification by Covariate","text":""},{"location":"julia/vpc/stratified/#continuous-covariate-binning","title":"Continuous Covariate Binning","text":"<pre><code># Bin continuous covariates for stratification\nfunction bin_covariate(value::Float64, breaks::Vector{Float64}, labels::Vector{String})\n    for (i, break_point) in enumerate(breaks)\n        if value &lt; break_point\n            return labels[i]\n        end\n    end\n    return labels[end]\nend\n\n# Weight categories\nwt_breaks = [60.0, 80.0, 100.0]\nwt_labels = [\"&lt;60kg\", \"60-80kg\", \"80-100kg\", \"&gt;100kg\"]\n\nstrata_data = Dict(\n    sid =&gt; Dict(:WT_CAT =&gt; bin_covariate(covariates[sid][:WT], wt_breaks, wt_labels))\n    for sid in subject_ids\n)\n\nconfig = VPCConfig(stratify_by = [:WT_CAT])\n</code></pre>"},{"location":"julia/vpc/stratified/#renal-function-stratification","title":"Renal Function Stratification","text":"<pre><code># Renal impairment categories (FDA guidance)\nfunction classify_renal(egfr::Float64)\n    if egfr &gt;= 90\n        return \"Normal\"\n    elseif egfr &gt;= 60\n        return \"Mild\"\n    elseif egfr &gt;= 30\n        return \"Moderate\"\n    elseif egfr &gt;= 15\n        return \"Severe\"\n    else\n        return \"ESRD\"\n    end\nend\n\nstrata_data = Dict(\n    sid =&gt; Dict(:RENAL =&gt; classify_renal(covariates[sid][:EGFR]))\n    for sid in subject_ids\n)\n\nconfig = VPCConfig(\n    stratify_by = [:RENAL],\n    n_simulations = 500\n)\n\n# Assess if renal covariate model is adequate\nresult = compute_stratified_vpc(...)\n</code></pre>"},{"location":"julia/vpc/stratified/#interpretation-guide","title":"Interpretation Guide","text":""},{"location":"julia/vpc/stratified/#what-stratified-vpc-shows","title":"What Stratified VPC Shows","text":"Observation Interpretation All strata within CI Model adequate across subgroups One stratum outside CI Potential subgroup-specific misspecification Systematic pattern across strata Covariate effect under/over-estimated Different variability by stratum Heteroscedastic IIV"},{"location":"julia/vpc/stratified/#diagnostic-patterns","title":"Diagnostic Patterns","text":"<pre><code>Pattern: High dose stratum shows over-prediction\nInterpretation: Non-linear PK at high doses?\nAction: Consider saturable clearance (Michaelis-Menten)\n\nPattern: Low weight stratum shows under-prediction\nInterpretation: Weight covariate effect may be too strong\nAction: Re-evaluate allometric scaling\n\nPattern: Elderly stratum shows increased variability\nInterpretation: Age-related IIV increase?\nAction: Consider age-dependent omega\n</code></pre>"},{"location":"julia/vpc/stratified/#stratified-pcvpc","title":"Stratified pcVPC","text":"<p>Combine stratification with prediction correction:</p> <pre><code># Stratified pcVPC for variable-dose study with covariates\nconfig = VPCConfig(\n    prediction_corrected = true,\n    stratify_by = [:DOSE_GROUP],\n    pi_levels = [0.05, 0.50, 0.95],\n    n_simulations = 500\n)\n\n# This:\n# 1. Applies prediction correction within each stratum\n# 2. Computes separate VPC per stratum\n# 3. Allows assessment of IIV fit per dose group\n\nresult = compute_stratified_vpc(\n    observed, pop_spec, grid, solver;\n    config = config,\n    strata_data = strata_data\n)\n</code></pre>"},{"location":"julia/vpc/stratified/#complete-example","title":"Complete Example","text":"<pre><code>using OpenPKPDCore\nusing Random\n\n# ================================================\n# Stratified VPC Example: Dose-Finding Study\n# ================================================\n\nprintln(\"=== Stratified VPC by Dose Group ===\\n\")\n\n# 1. Generate synthetic dose-finding study data\nRandom.seed!(789)\n\ndose_levels = [50.0, 150.0, 300.0]\ndose_labels = [\"50mg\", \"150mg\", \"300mg\"]\nn_per_dose = 30\nsampling_times = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\n\n# True parameters\ntrue_ka = 1.5\ntrue_cl = 5.0\ntrue_v = 50.0\nomega_ka = 0.16\nomega_cl = 0.09\nomega_v = 0.04\n\nsubject_ids = String[]\nobs_times = Float64[]\nobs_dv = Float64[]\nstrata_data = Dict{String, Dict{Symbol, Any}}()\n\nsubject_idx = 1\nfor (dose, label) in zip(dose_levels, dose_labels)\n    for _ in 1:n_per_dose\n        sid = \"S$subject_idx\"\n\n        # Store stratum info\n        strata_data[sid] = Dict(:DOSE_GROUP =&gt; label)\n\n        # Individual parameters\n        ka_i = true_ka * exp(randn() * sqrt(omega_ka))\n        cl_i = true_cl * exp(randn() * sqrt(omega_cl))\n        v_i = true_v * exp(randn() * sqrt(omega_v))\n\n        for t in sampling_times\n            conc = dose * ka_i / (v_i * (ka_i - cl_i/v_i)) *\n                   (exp(-cl_i/v_i * t) - exp(-ka_i * t))\n\n            conc_obs = conc * (1 + 0.1 * randn())\n            conc_obs = max(0.01, conc_obs)\n\n            push!(subject_ids, sid)\n            push!(obs_times, t)\n            push!(obs_dv, conc_obs)\n        end\n\n        subject_idx += 1\n    end\nend\n\nn_total = subject_idx - 1\n\n# 2. Create observed data\nobserved = ObservedData(\n    subject_ids = subject_ids,\n    times = obs_times,\n    dv = obs_dv,\n    dvid = fill(:conc, length(obs_dv))\n)\n\nprintln(\"Dose-finding study:\")\nfor (dose, label) in zip(dose_levels, dose_labels)\n    n_in_group = count(v -&gt; v[:DOSE_GROUP] == label, values(strata_data))\n    println(\"  $label: $n_in_group subjects\")\nend\nprintln(\"  Total: $n_total subjects, $(length(obs_dv)) observations\")\n\n# 3. Define population model\ntypical_params = OneCompOralParams(true_ka, true_cl, true_v)\nomega = OmegaMatrix([\n    omega_ka 0.0      0.0;\n    0.0      omega_cl 0.0;\n    0.0      0.0      omega_v\n])\n\n# Reference dose (will be adjusted per stratum)\ndoses = [DoseEvent(0.0, 150.0)]\nbase_spec = ModelSpec(OneCompOral(), \"dose_finding\", typical_params, doses)\n\npop_spec = PopulationSpec(\n    base_spec,\n    n = n_total,\n    omega = omega,\n    seed = 12345\n)\n\ngrid = SimGrid(0.0, 24.0, collect(0.0:0.25:24.0))\nsolver = SolverSpec(:Tsit5, 1e-10, 1e-12, 10_000_000)\n\n# 4. VPC configuration with stratification\nconfig = VPCConfig(\n    pi_levels = [0.05, 0.50, 0.95],\n    stratify_by = [:DOSE_GROUP],\n    binning = QuantileBinning(7),\n    n_simulations = 500,\n    n_bootstrap = 500,\n    seed = 42\n)\n\n# 5. Compute stratified VPC\nprintln(\"\\nComputing stratified VPC...\")\nresult = compute_stratified_vpc(\n    observed, pop_spec, grid, solver;\n    config = config,\n    strata_data = strata_data\n)\n\n# 6. Report results\nprintln(\"\\n--- Stratified VPC Results ---\")\nprintln(\"Number of strata: $(length(result.results))\")\nprintln(\"Stratified by: $(result.stratify_by)\")\nprintln(\"Strata: $(result.strata_names)\")\n\n# 7. Detailed results per stratum\nprintln(\"\\n--- Per-Stratum Analysis ---\")\nfor (i, vpc_result) in enumerate(result.results)\n    stratum = result.strata_names[i]\n\n    println(\"\\n=== $stratum ===\")\n    println(\"  Subjects: $(vpc_result.n_subjects_observed)\")\n    println(\"  Observations: $(vpc_result.n_observations_observed)\")\n    println(\"  Bins: $(length(vpc_result.bins))\")\n\n    # Coverage\n    cov_05 = vpc_coverage(vpc_result, 0.05)\n    cov_50 = vpc_coverage(vpc_result, 0.50)\n    cov_95 = vpc_coverage(vpc_result, 0.95)\n\n    println(\"  Coverage:\")\n    println(\"    5th percentile: $(round(cov_05*100, digits=1))%\")\n    println(\"    50th percentile: $(round(cov_50*100, digits=1))%\")\n    println(\"    95th percentile: $(round(cov_95*100, digits=1))%\")\n\n    # Median comparison\n    println(\"  Median at select bins:\")\n    for bin in vpc_result.bins[1:3:end]\n        p50 = filter(p -&gt; p.percentile == 0.50, bin.percentiles)[1]\n        status = p50.simulated_lower &lt;= p50.observed &lt;= p50.simulated_upper ? \"\u2713\" : \"\u2717\"\n        println(\"    t=$(round(bin.time_midpoint, digits=1)): obs=$(round(p50.observed, digits=2)), CI=[$(round(p50.simulated_lower, digits=2)), $(round(p50.simulated_upper, digits=2))] $status\")\n    end\nend\n\n# 8. Overall summary\nprintln(\"\\n--- Summary Across Strata ---\")\nprintln(\"Stratum  | Coverage P50 | Assessment\")\nprintln(\"-\" ^ 50)\n\nfor (i, vpc_result) in enumerate(result.results)\n    stratum = result.strata_names[i]\n    cov_50 = vpc_coverage(vpc_result, 0.50)\n\n    assessment = if cov_50 &gt;= 0.90\n        \"Excellent\"\n    elseif cov_50 &gt;= 0.80\n        \"Good\"\n    elseif cov_50 &gt;= 0.70\n        \"Acceptable\"\n    else\n        \"Poor - investigate\"\n    end\n\n    @printf(\"%-8s | %11.1f%% | %s\\n\", stratum, cov_50*100, assessment)\nend\n\nprintln(\"\\n\u2713 Stratified VPC complete\")\n</code></pre>"},{"location":"julia/vpc/stratified/#best-practices","title":"Best Practices","text":""},{"location":"julia/vpc/stratified/#sample-size-considerations","title":"Sample Size Considerations","text":"Subjects per Stratum Recommendation &lt; 10 Insufficient - combine strata 10-20 Marginal - interpret with caution 20-50 Acceptable for most analyses &gt; 50 Good statistical power"},{"location":"julia/vpc/stratified/#number-of-strata","title":"Number of Strata","text":"<ul> <li>2-4 strata: Ideal for clear interpretation</li> <li>5-8 strata: Acceptable with sufficient data</li> <li>&gt; 8 strata: Consider combining or using different approach</li> </ul>"},{"location":"julia/vpc/stratified/#avoiding-over-stratification","title":"Avoiding Over-Stratification","text":"<pre><code># Bad: Too many strata\nconfig = VPCConfig(stratify_by = [:DOSE, :FORM, :SEX, :RACE, :RENAL])\n# Results in 2\u00d73\u00d72\u00d74\u00d74 = 192 potential strata!\n\n# Good: Focus on key variables\nconfig = VPCConfig(stratify_by = [:DOSE])  # Primary interest\n\n# Or separate analyses\nconfig_dose = VPCConfig(stratify_by = [:DOSE])\nconfig_renal = VPCConfig(stratify_by = [:RENAL])\n</code></pre>"},{"location":"julia/vpc/stratified/#see-also","title":"See Also","text":"<ul> <li>Standard VPC - Basic VPC methodology</li> <li>Prediction-Corrected VPC - Variable dosing designs</li> <li>VPC Index - Overview</li> <li>Python Stratified VPC - Visualization</li> </ul>"},{"location":"python/","title":"Python Documentation","text":"<p>Welcome to the Python documentation for OpenPKPD. The <code>openpkpd</code> package provides Pythonic access to all core functionality with seamless NumPy/Pandas integration.</p>"},{"location":"python/#why-python","title":"Why Python?","text":"<p>While OpenPKPD's core is written in Julia for performance, Python bindings enable:</p> <ul> <li>Data Science Integration - NumPy, Pandas, SciPy ecosystem</li> <li>Visualization - Matplotlib and Plotly dual backends</li> <li>Accessibility - Familiar syntax for most scientists</li> <li>Reproducibility - Jupyter notebook workflows</li> </ul>"},{"location":"python/#quick-start","title":"Quick Start","text":"<pre><code>import openpkpd\n\n# Initialize Julia (required once per session)\nopenpkpd.init_julia()\n\n# One-compartment IV bolus simulation\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0,              # Clearance (L/h)\n    v=50.0,              # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[float(t) for t in range(25)]\n)\n\nprint(\"Concentrations:\", result[\"observations\"][\"conc\"])\n</code></pre>"},{"location":"python/#documentation-sections","title":"Documentation Sections","text":"<ul> <li> <p> Tutorial</p> <p>Step-by-step introduction to the Python API</p> <p> Start Tutorial</p> </li> <li> <p> Models</p> <p>PK and PD simulation functions</p> <p> Models Reference</p> </li> <li> <p> Population Modeling</p> <p>Population simulation with IIV</p> <p> Population</p> </li> <li> <p> NCA</p> <p>Non-compartmental analysis</p> <p> NCA Reference</p> </li> <li> <p> Parameter Estimation</p> <p>NLME estimation methods</p> <p> Estimation</p> </li> <li> <p> Clinical Trials</p> <p>Trial simulation and power analysis</p> <p> Trial Reference</p> </li> <li> <p> Visualization</p> <p>55+ plotting functions with dual backends</p> <p> Visualization</p> </li> <li> <p> Data Import</p> <p>CDISC and CSV data handling</p> <p> Data Import</p> </li> </ul>"},{"location":"python/#installation","title":"Installation","text":"<pre><code>cd packages/python\n\n# Create virtual environment\npython3 -m venv .venv\nsource .venv/bin/activate\n\n# Install with all dependencies\npip install -e \".[all]\"\n</code></pre>"},{"location":"python/#optional-dependencies","title":"Optional Dependencies","text":"Extra Packages Install Command <code>viz</code> matplotlib, plotly <code>pip install -e \".[viz]\"</code> <code>data</code> pandas, pyarrow <code>pip install -e \".[data]\"</code> <code>all</code> All optional deps <code>pip install -e \".[all]\"</code>"},{"location":"python/#module-overview","title":"Module Overview","text":""},{"location":"python/#core-module-openpkpd","title":"Core Module (<code>openpkpd</code>)","text":"<pre><code>import openpkpd\n\nopenpkpd.init_julia()              # Initialize Julia runtime\nopenpkpd.version()                 # Get version string\n\n# Simulation functions\nopenpkpd.simulate_pk_iv_bolus(...)\nopenpkpd.simulate_pk_oral_first_order(...)\nopenpkpd.simulate_population_iv_bolus(...)\n</code></pre>"},{"location":"python/#nca-module-openpkpdnca","title":"NCA Module (<code>openpkpd.nca</code>)","text":"<pre><code>from openpkpd import nca\n\nresult = nca.run_nca(times, conc, dose)\nsummary = nca.summarize_population_nca(pop_results)\nbe_result = nca.bioequivalence_90ci(test, reference)\n</code></pre>"},{"location":"python/#trial-module-openpkpdtrial","title":"Trial Module (<code>openpkpd.trial</code>)","text":"<pre><code>from openpkpd import trial\n\ndesign = trial.parallel_design(n_arms=2)\nregimen = trial.dosing_qd(dose=100.0, duration_days=28)\npop = trial.generate_virtual_population(n=100)\n</code></pre>"},{"location":"python/#visualization-module-openpkpdviz","title":"Visualization Module (<code>openpkpd.viz</code>)","text":"<pre><code>from openpkpd import viz\n\nviz.set_backend(\"matplotlib\")\nfig = viz.plot_conc_time(result)\nfig = viz.plot_vpc_detailed(vpc_result)\n</code></pre>"},{"location":"python/#result-structure","title":"Result Structure","text":"<p>All simulation functions return dictionaries with consistent structure:</p> <pre><code>result = {\n    \"t\": [0.0, 1.0, 2.0, ...],           # Time points\n    \"states\": {\n        \"A_central\": [100.0, 90.5, ...]   # State variables\n    },\n    \"observations\": {\n        \"conc\": [2.0, 1.81, ...]          # Concentrations\n    },\n    \"metadata\": {\n        \"model\": \"OneCompIVBolus\",\n        \"version\": \"0.1.0\"\n    }\n}\n</code></pre>"},{"location":"python/#population-results","title":"Population Results","text":"<pre><code>pop_result = {\n    \"individuals\": [                       # List of individual results\n        {\"t\": [...], \"observations\": {...}},\n        ...\n    ],\n    \"params\": [                            # Realized parameters\n        {\"CL\": 4.8, \"V\": 52.1},\n        ...\n    ],\n    \"summaries\": {                         # Population statistics\n        \"conc\": {\n            \"mean\": [...],\n            \"median\": [...],\n            \"quantiles\": {\n                \"0.05\": [...],\n                \"0.95\": [...]\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"python/#integration-examples","title":"Integration Examples","text":""},{"location":"python/#with-numpy","title":"With NumPy","text":"<pre><code>import numpy as np\nimport openpkpd\n\nopenpkpd.init_julia()\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=list(np.linspace(0, 24, 49))\n)\n\nconc = np.array(result[\"observations\"][\"conc\"])\nprint(f\"Cmax: {np.max(conc):.2f}\")\nprint(f\"AUC: {np.trapz(conc, result['t']):.2f}\")\n</code></pre>"},{"location":"python/#with-pandas","title":"With Pandas","text":"<pre><code>import pandas as pd\nimport openpkpd\n\nopenpkpd.init_julia()\n\nresult = openpkpd.simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)],\n    n=100, seed=12345,\n    omegas={\"CL\": 0.3, \"V\": 0.2}\n)\n\n# Parameters DataFrame\nparams_df = pd.DataFrame(result[\"params\"])\nprint(params_df.describe())\n\n# Concentration DataFrame\ndata = []\nfor i, ind in enumerate(result[\"individuals\"]):\n    for t, c in zip(ind[\"t\"], ind[\"observations\"][\"conc\"]):\n        data.append({\"id\": i, \"time\": t, \"conc\": c})\n\nconc_df = pd.DataFrame(data)\nprint(conc_df.groupby(\"time\")[\"conc\"].describe())\n</code></pre>"},{"location":"python/#performance-tips","title":"Performance Tips","text":"<ol> <li>Initialize Once: Call <code>init_julia()</code> once at session start</li> <li>Batch Simulations: Julia JIT makes subsequent calls faster</li> <li>Sparse Output: Use fewer <code>saveat</code> points for large populations</li> <li>Parallel Populations: Population simulations are internally parallelized</li> </ol> <pre><code># Good: Initialize once\nimport openpkpd\nopenpkpd.init_julia()\n\nfor params in parameter_sets:\n    result = openpkpd.simulate_pk_iv_bolus(...)\n</code></pre>"},{"location":"python/#next-steps","title":"Next Steps","text":"<ul> <li>Start the Tutorial \u2192</li> <li>Explore Simulation Functions \u2192</li> <li>Learn Visualization \u2192</li> </ul>"},{"location":"python/tutorial/","title":"Tutorial: Getting Started with Python","text":"<p>This tutorial provides a comprehensive introduction to using OpenPKPD with Python. By the end, you'll be able to run simulations, analyze data, and create professional visualizations.</p>"},{"location":"python/tutorial/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have:</p> <ul> <li>Python 3.10 or later</li> <li>Julia 1.10 or later installed</li> <li>OpenPKPD Python package installed</li> </ul> <pre><code>cd packages/python\npython3 -m venv .venv\nsource .venv/bin/activate\npip install -e \".[all]\"\n</code></pre>"},{"location":"python/tutorial/#part-1-your-first-simulation","title":"Part 1: Your First Simulation","text":""},{"location":"python/tutorial/#initialization","title":"Initialization","text":"<pre><code>import openpkpd\n\n# Initialize Julia runtime (required once per session)\nopenpkpd.init_julia()\n\n# Check version\nprint(openpkpd.version())  # \"0.1.0\"\n</code></pre> <p>First-time initialization</p> <p>The first call to <code>init_julia()</code> takes 2-5 seconds due to Julia JIT compilation. Subsequent calls are instant.</p>"},{"location":"python/tutorial/#one-compartment-iv-bolus","title":"One-Compartment IV Bolus","text":"<pre><code># Simulate IV bolus: 100 mg at time 0\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0,              # Clearance (L/h)\n    v=50.0,              # Volume of distribution (L)\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,              # Start time\n    t1=24.0,             # End time\n    saveat=[float(t) for t in range(25)]  # Output every hour\n)\n\n# Access results\nprint(\"Time points:\", result[\"t\"])\nprint(\"Concentrations:\", result[\"observations\"][\"conc\"][:5])\n</code></pre> <p>Expected output: <pre><code>Time points: [0.0, 1.0, 2.0, ..., 24.0]\nConcentrations: [2.0, 1.809..., 1.637..., 1.481..., 1.340...]\n</code></pre></p>"},{"location":"python/tutorial/#understanding-the-result","title":"Understanding the Result","text":"<pre><code># Result structure\nresult.keys()  # dict_keys(['t', 'states', 'observations', 'metadata'])\n\n# Time points\nresult[\"t\"]  # [0.0, 1.0, 2.0, ..., 24.0]\n\n# Observations (concentrations)\nresult[\"observations\"][\"conc\"]  # [2.0, 1.81, ...]\n\n# State variables (amount in compartment)\nresult[\"states\"][\"A_central\"]  # [100.0, 90.5, ...]\n\n# Metadata\nresult[\"metadata\"]  # {\"model\": \"OneCompIVBolus\", ...}\n</code></pre>"},{"location":"python/tutorial/#calculate-pk-metrics","title":"Calculate PK Metrics","text":"<pre><code>import numpy as np\n\nconc = np.array(result[\"observations\"][\"conc\"])\nt = np.array(result[\"t\"])\n\n# Cmax and Tmax\ncmax = np.max(conc)\ntmax = t[np.argmax(conc)]\nprint(f\"Cmax: {cmax:.2f} mg/L at Tmax: {tmax:.1f} h\")\n\n# AUC by trapezoidal rule\nauc = np.trapz(conc, t)\nprint(f\"AUC0-24: {auc:.2f} mg\u00b7h/L\")\n\n# Half-life\nt_half = 0.693 * 50.0 / 5.0  # t\u00bd = 0.693 * V / CL\nprint(f\"Half-life: {t_half:.2f} h\")\n</code></pre>"},{"location":"python/tutorial/#part-2-multiple-doses","title":"Part 2: Multiple Doses","text":""},{"location":"python/tutorial/#repeated-dosing","title":"Repeated Dosing","text":"<pre><code># 100 mg every 12 hours for 3 days\ndoses = [\n    {\"time\": 0.0, \"amount\": 100.0},\n    {\"time\": 12.0, \"amount\": 100.0},\n    {\"time\": 24.0, \"amount\": 100.0},\n    {\"time\": 36.0, \"amount\": 100.0},\n    {\"time\": 48.0, \"amount\": 100.0},\n    {\"time\": 60.0, \"amount\": 100.0},\n]\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=72.0,\n    saveat=[t * 0.5 for t in range(145)]  # Every 30 min\n)\n\n# Find steady-state trough (just before 6th dose)\nconc = np.array(result[\"observations\"][\"conc\"])\nt = np.array(result[\"t\"])\nidx_trough = np.argmin(np.abs(t - 59.5))\nprint(f\"Steady-state trough: {conc[idx_trough]:.2f} mg/L\")\n</code></pre>"},{"location":"python/tutorial/#iv-infusion","title":"IV Infusion","text":"<pre><code># 100 mg infused over 1 hour\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0, \"duration\": 1.0}],\n    t0=0.0, t1=24.0,\n    saveat=[t * 0.25 for t in range(97)]\n)\n\n# Cmax occurs at end of infusion\nconc = np.array(result[\"observations\"][\"conc\"])\nt = np.array(result[\"t\"])\nidx_1h = np.argmin(np.abs(t - 1.0))\nprint(f\"Cmax at end of infusion: {conc[idx_1h]:.2f} mg/L\")\n</code></pre>"},{"location":"python/tutorial/#part-3-different-models","title":"Part 3: Different Models","text":""},{"location":"python/tutorial/#oral-first-order-absorption","title":"Oral First-Order Absorption","text":"<pre><code>result = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5,              # Absorption rate constant (1/h)\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 200.0}],\n    t0=0.0, t1=24.0,\n    saveat=[t * 0.25 for t in range(97)]\n)\n\nconc = np.array(result[\"observations\"][\"conc\"])\nt = np.array(result[\"t\"])\n\n# Tmax is delayed for oral\ntmax = t[np.argmax(conc)]\ncmax = np.max(conc)\nprint(f\"Oral: Cmax = {cmax:.2f} mg/L at Tmax = {tmax:.2f} h\")\n</code></pre>"},{"location":"python/tutorial/#two-compartment-iv","title":"Two-Compartment IV","text":"<pre><code>result = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0,             # Clearance (L/h)\n    v1=20.0,             # Central volume (L)\n    q=15.0,              # Inter-compartmental clearance (L/h)\n    v2=50.0,             # Peripheral volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[t * 0.1 for t in range(481)]\n)\n\n# Bi-exponential decline\nconc = np.array(result[\"observations\"][\"conc\"])\nprint(f\"C at 0.5h: {conc[5]:.2f} (distribution)\")\nprint(f\"C at 24h: {conc[240]:.2f} (terminal)\")\n</code></pre>"},{"location":"python/tutorial/#transit-absorption","title":"Transit Absorption","text":"<pre><code>result = openpkpd.simulate_pk_transit_absorption(\n    n_transit=5,         # 5 transit compartments\n    ktr=0.5,             # Transit rate (1/h)\n    ka=2.0,              # Final absorption rate (1/h)\n    cl=10.0,\n    v=70.0,\n    doses=[{\"time\": 0.0, \"amount\": 300.0}],\n    t0=0.0, t1=24.0,\n    saveat=[t * 0.1 for t in range(241)]\n)\n\n# Delayed, broader peak\nconc = np.array(result[\"observations\"][\"conc\"])\nt = np.array(result[\"t\"])\ntmax = t[np.argmax(conc)]\nprint(f\"Transit absorption Tmax: {tmax:.2f} h\")\n</code></pre>"},{"location":"python/tutorial/#part-4-pk-pd-models","title":"Part 4: PK-PD Models","text":""},{"location":"python/tutorial/#direct-emax","title":"Direct Emax","text":"<pre><code>result = openpkpd.simulate_pkpd_direct_emax(\n    # PK parameters\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    # PD parameters\n    e0=0.0,              # Baseline effect\n    emax=100.0,          # Maximum effect\n    ec50=2.0,            # EC50 (mg/L)\n    # Simulation grid\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)]\n)\n\n# Both concentration and effect\nprint(\"Concentration:\", result[\"observations\"][\"conc\"][:5])\nprint(\"Effect:\", result[\"observations\"][\"effect\"][:5])\n</code></pre>"},{"location":"python/tutorial/#indirect-response","title":"Indirect Response","text":"<pre><code>result = openpkpd.simulate_pkpd_indirect_response(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    kin=10.0,            # Production rate\n    kout=0.5,            # Elimination rate\n    ic50=2.0,            # IC50\n    imax=0.9,            # Max inhibition\n    baseline=None,       # Auto-calculate: kin/kout\n    t0=0.0, t1=72.0,\n    saveat=[float(t) for t in range(73)]\n)\n\n# Delayed response\nresponse = result[\"observations\"][\"response\"]\nprint(f\"Baseline: {response[0]:.1f}\")\nprint(f\"Max suppression (at ~12h): {min(response):.1f}\")\nprint(f\"Return to baseline: {response[-1]:.1f}\")\n</code></pre>"},{"location":"python/tutorial/#part-5-population-simulation","title":"Part 5: Population Simulation","text":""},{"location":"python/tutorial/#inter-individual-variability","title":"Inter-Individual Variability","text":"<pre><code>result = openpkpd.simulate_population_iv_bolus(\n    cl=5.0,              # Typical CL\n    v=50.0,              # Typical V\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)],\n    n=100,               # 100 subjects\n    seed=12345,          # Reproducibility\n    omegas={             # IIV (coefficient of variation)\n        \"CL\": 0.3,       # 30% CV on CL\n        \"V\": 0.2         # 20% CV on V\n    }\n)\n\n# Access individual results\nprint(f\"Number of subjects: {len(result['individuals'])}\")\n\nfor i in range(3):\n    cmax = max(result[\"individuals\"][i][\"observations\"][\"conc\"])\n    print(f\"Subject {i+1} Cmax: {cmax:.2f} mg/L\")\n\n# Access realized parameters\nfor i in range(3):\n    cl = result[\"params\"][i][\"CL\"]\n    v = result[\"params\"][i][\"V\"]\n    print(f\"Subject {i+1}: CL={cl:.2f}, V={v:.2f}\")\n\n# Population summary\nsummary = result[\"summaries\"][\"conc\"]\nprint(f\"\\nPopulation median Cmax: {max(summary['median']):.2f}\")\nprint(f\"90% PI: {max(summary['quantiles']['0.05']):.2f} - \"\n      f\"{max(summary['quantiles']['0.95']):.2f}\")\n</code></pre>"},{"location":"python/tutorial/#convert-to-dataframe","title":"Convert to DataFrame","text":"<pre><code>import pandas as pd\n\n# Create long-format concentration DataFrame\ndata = []\nfor i, ind in enumerate(result[\"individuals\"]):\n    cl = result[\"params\"][i][\"CL\"]\n    v = result[\"params\"][i][\"V\"]\n    for t, c in zip(ind[\"t\"], ind[\"observations\"][\"conc\"]):\n        data.append({\n            \"id\": i + 1,\n            \"time\": t,\n            \"conc\": c,\n            \"CL\": cl,\n            \"V\": v\n        })\n\ndf = pd.DataFrame(data)\nprint(df.head(10))\nprint(df.groupby(\"time\")[\"conc\"].describe())\n</code></pre>"},{"location":"python/tutorial/#part-6-visualization","title":"Part 6: Visualization","text":""},{"location":"python/tutorial/#setup","title":"Setup","text":"<pre><code>from openpkpd import viz\n\n# Set backend\nviz.set_backend(\"matplotlib\")\n\n# Check available backends\nprint(viz.available_backends())  # [\"matplotlib\", \"plotly\"]\n</code></pre>"},{"location":"python/tutorial/#concentration-time-plot","title":"Concentration-Time Plot","text":"<pre><code>result = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[t * 0.5 for t in range(49)]\n)\n\nfig = viz.plot_conc_time(result, title=\"One-Compartment IV Bolus\")\nfig.savefig(\"conc_time.png\", dpi=300)\n</code></pre>"},{"location":"python/tutorial/#population-spaghetti-plot","title":"Population Spaghetti Plot","text":"<pre><code>pop_result = openpkpd.simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)],\n    n=50, seed=42,\n    omegas={\"CL\": 0.3, \"V\": 0.2}\n)\n\nfig = viz.plot_spaghetti(pop_result, alpha=0.3)\nfig.savefig(\"spaghetti.png\", dpi=300)\n</code></pre>"},{"location":"python/tutorial/#mean-with-confidence-ribbon","title":"Mean with Confidence Ribbon","text":"<pre><code>fig = viz.plot_mean_ribbon(\n    pop_result,\n    ci_levels=[0.05, 0.95],\n    show_median=True\n)\nfig.savefig(\"mean_ribbon.png\", dpi=300)\n</code></pre>"},{"location":"python/tutorial/#interactive-plotly","title":"Interactive Plotly","text":"<pre><code>viz.set_backend(\"plotly\")\n\nfig = viz.plot_conc_time(result)\nfig.write_html(\"conc_time_interactive.html\")\nfig.show()  # Opens in browser\n</code></pre>"},{"location":"python/tutorial/#part-7-non-compartmental-analysis","title":"Part 7: Non-Compartmental Analysis","text":""},{"location":"python/tutorial/#basic-nca","title":"Basic NCA","text":"<pre><code>from openpkpd.nca import run_nca, NCAConfig\n\n# Concentration-time data\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nconc = [0.0, 1.8, 2.0, 1.5, 1.0, 0.5, 0.25, 0.06]\ndose = 100.0\n\n# Run NCA\nresult = run_nca(times, conc, dose)\n\nprint(f\"Cmax: {result.cmax:.2f} mg/L\")\nprint(f\"Tmax: {result.tmax:.2f} h\")\nprint(f\"AUC0-t: {result.auc_0_t:.2f} mg\u00b7h/L\")\nprint(f\"AUC0-inf: {result.auc_0_inf:.2f} mg\u00b7h/L\")\nprint(f\"t\u00bd: {result.t_half:.2f} h\")\nprint(f\"CL/F: {result.cl_f:.2f} L/h\")\n</code></pre>"},{"location":"python/tutorial/#nca-with-configuration","title":"NCA with Configuration","text":"<pre><code>config = NCAConfig(\n    method=\"log_linear\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9,\n    extrapolation_max_pct=20.0\n)\n\nresult = run_nca(times, conc, dose, config=config)\nprint(f\"\u03bbz R\u00b2: {result.lambda_z_r_squared:.4f}\")\n</code></pre>"},{"location":"python/tutorial/#part-8-clinical-trial-simulation","title":"Part 8: Clinical Trial Simulation","text":""},{"location":"python/tutorial/#power-analysis","title":"Power Analysis","text":"<pre><code>from openpkpd import trial\n\n# Calculate power for given sample size\npower = trial.estimate_power_analytical(\n    n_per_arm=50,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\nprint(f\"Power: {power.power:.1%}\")\n\n# Calculate required sample size\nsample = trial.estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\nprint(f\"Required n per arm: {sample.n_per_arm}\")\n</code></pre>"},{"location":"python/tutorial/#generate-virtual-population","title":"Generate Virtual Population","text":"<pre><code>pop = trial.generate_virtual_population(\n    n=100,\n    spec=trial.healthy_volunteer_spec(),\n    seed=42\n)\n\nsummary = trial.summarize_population(pop)\nprint(f\"Age: {summary['age']['mean']:.1f} years\")\nprint(f\"Weight: {summary['weight']['mean']:.1f} kg\")\n</code></pre>"},{"location":"python/tutorial/#summary","title":"Summary","text":"<p>In this tutorial, you learned:</p> <ol> <li>Initialization: <code>openpkpd.init_julia()</code></li> <li>Simulation Functions: IV bolus, oral, two-compartment, transit</li> <li>PK-PD Models: Direct Emax, indirect response</li> <li>Population: IIV with omega, summary statistics</li> <li>Visualization: Matplotlib/Plotly dual backend</li> <li>NCA: Exposure metrics, configuration</li> <li>Trials: Power analysis, virtual populations</li> </ol>"},{"location":"python/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Models Reference - All simulation functions</li> <li>Visualization Guide - 55+ plotting functions</li> <li>NCA Reference - Detailed NCA documentation</li> <li>Trial Module - Clinical trial simulation</li> </ul>"},{"location":"python/data/","title":"Data Import","text":"<p>The <code>openpkpd.data</code> module provides utilities for importing and preparing PK/PD data from various formats.</p>"},{"location":"python/data/#supported-formats","title":"Supported Formats","text":"<ul> <li> <p> CDISC Formats</p> <p>SDTM PC, EX, DM domains</p> <p> CDISC Import</p> </li> <li> <p> NONMEM Import</p> <p>Parse NONMEM control files</p> <p> NONMEM</p> </li> <li> <p> Monolix Import</p> <p>Parse Monolix project files</p> <p> Monolix</p> </li> <li> <p> CSV Files</p> <p>Standard CSV data import</p> <p> CSV Import</p> </li> </ul>"},{"location":"python/data/#quick-start","title":"Quick Start","text":""},{"location":"python/data/#import-cdisc-data","title":"Import CDISC Data","text":"<pre><code>from openpkpd.data import import_cdisc\n\n# Import from CSV files\ndata = import_cdisc(\n    pc_path=\"pc.csv\",      # Pharmacokinetic Concentrations\n    ex_path=\"ex.csv\",      # Exposure (Dosing)\n    dm_path=\"dm.csv\",      # Demographics\n    format=\"csv\"\n)\n\n# Access standardized data\nprint(f\"Subjects: {len(set(data.usubjid))}\")\nprint(f\"Observations: {len(data.dv)}\")\n</code></pre>"},{"location":"python/data/#import-from-xpt","title":"Import from XPT","text":"<pre><code>from openpkpd.data import import_cdisc\n\ndata = import_cdisc(\n    pc_path=\"pc.xpt\",\n    ex_path=\"ex.xpt\",\n    dm_path=\"dm.xpt\",\n    format=\"xpt\"\n)\n</code></pre>"},{"location":"python/data/#cdisc-domains","title":"CDISC Domains","text":""},{"location":"python/data/#pc-pharmacokinetic-concentrations","title":"PC (Pharmacokinetic Concentrations)","text":"<p>Required variables:</p> Variable Description Required USUBJID Unique subject identifier Yes PCDTC Collection datetime Yes PCSTRESN Numeric result Yes PCTEST Analyte name Yes PCSPEC Specimen type No PCBLFL Baseline flag No"},{"location":"python/data/#ex-exposure","title":"EX (Exposure)","text":"<p>Required variables:</p> Variable Description Required USUBJID Unique subject identifier Yes EXSTDTC Start datetime Yes EXDOSE Dose amount Yes EXDOSU Dose units Yes EXROUTE Route of administration No EXDUR Duration (for infusions) No"},{"location":"python/data/#dm-demographics","title":"DM (Demographics)","text":"<p>Common variables:</p> Variable Description Required USUBJID Unique subject identifier Yes AGE Age No SEX Sex No RACE Race No WEIGHT Weight (from VS or custom) No"},{"location":"python/data/#csv-import","title":"CSV Import","text":""},{"location":"python/data/#standard-format","title":"Standard Format","text":"<pre><code>from openpkpd.data import read_pk_data\n\n# Expected columns: ID, TIME, DV, AMT, EVID, CMT\ndata = read_pk_data(\"pk_data.csv\")\n\n# Custom column mapping\ndata = read_pk_data(\n    \"pk_data.csv\",\n    column_map={\n        \"subject_id\": \"ID\",\n        \"time_hr\": \"TIME\",\n        \"concentration\": \"DV\",\n        \"dose_mg\": \"AMT\"\n    }\n)\n</code></pre>"},{"location":"python/data/#nonmem-format","title":"NONMEM Format","text":"<pre><code>from openpkpd.data import read_nonmem_data\n\n# Standard NONMEM dataset\ndata = read_nonmem_data(\"data.csv\")\n\n# Access as DataFrame or structured data\nprint(data.to_dataframe())\n</code></pre>"},{"location":"python/data/#xpt-import","title":"XPT Import","text":"<pre><code>from openpkpd.data import read_xpt\n\n# Single file\npc_data = read_xpt(\"pc.xpt\")\n\n# Multiple files\ndata = {\n    \"pc\": read_xpt(\"pc.xpt\"),\n    \"ex\": read_xpt(\"ex.xpt\"),\n    \"dm\": read_xpt(\"dm.xpt\")\n}\n</code></pre>"},{"location":"python/data/#data-preparation","title":"Data Preparation","text":""},{"location":"python/data/#time-calculation","title":"Time Calculation","text":"<pre><code>from openpkpd.data import calculate_time_after_dose\n\ndata = calculate_time_after_dose(\n    observations=obs_df,\n    dosing=dose_df,\n    time_column=\"PCDTC\",\n    dose_time_column=\"EXSTDTC\"\n)\n</code></pre>"},{"location":"python/data/#blq-handling","title":"BLQ Handling","text":"<pre><code>from openpkpd.data import handle_blq\n\n# Replace BLQ with LLOQ/2\ndata = handle_blq(\n    data,\n    lloq=0.1,\n    method=\"lloq_half\"\n)\n\n# Or set to zero\ndata = handle_blq(data, lloq=0.1, method=\"zero\")\n\n# Or drop\ndata = handle_blq(data, lloq=0.1, method=\"drop\")\n</code></pre>"},{"location":"python/data/#merge-demographics","title":"Merge Demographics","text":"<pre><code>from openpkpd.data import merge_demographics\n\nmerged = merge_demographics(\n    pk_data=pc_data,\n    demographics=dm_data,\n    on=\"USUBJID\"\n)\n</code></pre>"},{"location":"python/data/#data-classes","title":"Data Classes","text":""},{"location":"python/data/#pkdata","title":"PKData","text":"<pre><code>class PKData:\n    ids: list[str]           # Subject IDs\n    times: list[float]       # Time points\n    dv: list[float]          # Observations\n    amt: list[float]         # Doses\n    evid: list[int]          # Event IDs\n    cmt: list[int]           # Compartments\n    covariates: dict         # Covariate data\n\n    def to_dataframe(self) -&gt; pd.DataFrame: ...\n    def to_dict(self) -&gt; dict: ...\n    def subset(self, ids: list) -&gt; PKData: ...\n</code></pre>"},{"location":"python/data/#cdiscdata","title":"CDISCData","text":"<pre><code>class CDISCData:\n    usubjid: list[str]\n    subjid: list[int]\n    times: list[float]\n    dv: list[float]\n    doses: list[DoseEvent]\n    demographics: dict\n\n    def to_estimation_data(self) -&gt; EstimationData: ...\n</code></pre>"},{"location":"python/data/#examples","title":"Examples","text":""},{"location":"python/data/#complete-workflow","title":"Complete Workflow","text":"<pre><code>from openpkpd.data import import_cdisc, handle_blq, calculate_time_after_dose\nimport openpkpd\n\n# Import CDISC data\ndata = import_cdisc(\n    pc_path=\"pc.csv\",\n    ex_path=\"ex.csv\",\n    dm_path=\"dm.csv\"\n)\n\n# Handle BLQ\ndata = handle_blq(data, lloq=0.1, method=\"lloq_half\")\n\n# Calculate time after first dose\ndata = calculate_time_after_dose(data)\n\n# Convert to estimation format\nest_data = data.to_estimation_data()\n\n# Run NCA\nfrom openpkpd.nca import run_population_nca\nnca_results = run_population_nca(est_data)\n</code></pre>"},{"location":"python/data/#next-steps","title":"Next Steps","text":"<ul> <li>CDISC Import Details - SDTM and ADaM data</li> <li>NONMEM Import - Import control stream files</li> <li>Monolix Import - Import mlxtran projects</li> <li>NCA Module - Non-compartmental analysis</li> <li>Estimation - Population modeling</li> </ul>"},{"location":"python/data/cdisc/","title":"CDISC Data Import","text":"<p>Comprehensive guide for importing CDISC/SDTM and ADaM formatted data in Python.</p>"},{"location":"python/data/cdisc/#overview","title":"Overview","text":"<p>The <code>openpkpd.data</code> module provides utilities for importing data from CDISC (Clinical Data Interchange Standards Consortium) formats.</p> <pre><code>from openpkpd.data import import_cdisc\n\ndata = import_cdisc(\n    pc_path=\"pc.csv\",\n    ex_path=\"ex.csv\",\n    dm_path=\"dm.csv\"\n)\n</code></pre>"},{"location":"python/data/cdisc/#quick-start","title":"Quick Start","text":""},{"location":"python/data/cdisc/#basic-import","title":"Basic Import","text":"<pre><code>from openpkpd.data import import_cdisc\n\n# Import from CSV files\ndata = import_cdisc(\n    pc_path=\"pc.csv\",      # Pharmacokinetic Concentrations\n    ex_path=\"ex.csv\",      # Exposure (Dosing)\n    dm_path=\"dm.csv\"       # Demographics\n)\n\n# Access data\nprint(f\"Subjects: {data.n_subjects}\")\nprint(f\"Observations: {data.n_observations}\")\n</code></pre>"},{"location":"python/data/cdisc/#import-from-sas-transport-xpt","title":"Import from SAS Transport (XPT)","text":"<pre><code>data = import_cdisc(\n    pc_path=\"pc.xpt\",\n    ex_path=\"ex.xpt\",\n    dm_path=\"dm.xpt\",\n    format=\"xpt\"\n)\n</code></pre>"},{"location":"python/data/cdisc/#supported-domains","title":"Supported Domains","text":""},{"location":"python/data/cdisc/#pc-domain-pharmacokinetic-concentrations","title":"PC Domain (Pharmacokinetic Concentrations)","text":""},{"location":"python/data/cdisc/#required-variables","title":"Required Variables","text":"Variable Label Type Description STUDYID Study ID str Study identifier USUBJID Subject ID str Unique subject identifier PCTESTCD Test Code str Short test name PCSTRESN Numeric Result float Standardized numeric result PCSTRESU Unit str Units (ng/mL, \u00b5g/L, etc.) PCELTM Elapsed Time str Time from reference (ISO 8601)"},{"location":"python/data/cdisc/#optional-variables","title":"Optional Variables","text":"Variable Label Description PCLLOQ Lower LOQ Lower limit of quantification PCSTAT Status Completion status PCBLFL Baseline Flag \"Y\" for baseline PCSPEC Specimen PLASMA, SERUM, etc. PCDTC Datetime ISO 8601 datetime PCDY Study Day Study day"},{"location":"python/data/cdisc/#example-data","title":"Example Data","text":"<pre><code>import pandas as pd\n\npc_data = pd.DataFrame({\n    'STUDYID': ['STUDY01'] * 7,\n    'USUBJID': ['SUBJ001'] * 7,\n    'PCTESTCD': ['DRUGA'] * 7,\n    'PCSTRESN': [0.0, 125.3, 89.7, 52.1, 28.4, 12.1, 3.2],\n    'PCSTRESU': ['ng/mL'] * 7,\n    'PCELTM': ['PT0H', 'PT1H', 'PT2H', 'PT4H', 'PT8H', 'PT12H', 'PT24H'],\n    'PCLLOQ': [0.5] * 7,\n    'PCSPEC': ['PLASMA'] * 7\n})\n</code></pre>"},{"location":"python/data/cdisc/#ex-domain-exposure","title":"EX Domain (Exposure)","text":""},{"location":"python/data/cdisc/#required-variables_1","title":"Required Variables","text":"Variable Label Type Description STUDYID Study ID str Study identifier USUBJID Subject ID str Unique subject identifier EXDOSE Dose float Administered dose EXDOSU Units str Dose units (mg, \u00b5g) EXROUTE Route str Route of administration EXSTDTC Start Datetime str Dose start (ISO 8601)"},{"location":"python/data/cdisc/#optional-variables_1","title":"Optional Variables","text":"Variable Label Description EXENDTC End Datetime Dose end (infusions) EXDOSFRM Dose Form TABLET, CAPSULE, etc. EXDOSFRQ Frequency QD, BID, Q12H EXDUR Duration ISO 8601 duration EXTRT Treatment Treatment name EXDY Study Day Study day"},{"location":"python/data/cdisc/#route-mapping","title":"Route Mapping","text":"EX Route OpenPKPD Route ORAL <code>\"oral\"</code> INTRAVENOUS <code>\"iv_bolus\"</code> INTRAVENOUS INFUSION <code>\"iv_infusion\"</code> SUBCUTANEOUS <code>\"subcutaneous\"</code> INTRAMUSCULAR <code>\"intramuscular\"</code>"},{"location":"python/data/cdisc/#dm-domain-demographics","title":"DM Domain (Demographics)","text":""},{"location":"python/data/cdisc/#required-variables_2","title":"Required Variables","text":"Variable Label Type Description STUDYID Study ID str Study identifier USUBJID Subject ID str Unique subject identifier RFSTDTC Reference Start str Reference start date"},{"location":"python/data/cdisc/#optional-variables_2","title":"Optional Variables","text":"Variable Label Description AGE Age Age at screening AGEU Age Units YEARS, MONTHS SEX Sex M, F, U RACE Race Racial designation ETHNIC Ethnicity Ethnic group ARMCD Arm Code Treatment arm code ARM Arm Arm description COUNTRY Country Country SITEID Site ID Study site"},{"location":"python/data/cdisc/#import-functions","title":"Import Functions","text":""},{"location":"python/data/cdisc/#import_cdisc","title":"import_cdisc()","text":"<pre><code>from openpkpd.data import import_cdisc\n\ndef import_cdisc(\n    pc_path: str,\n    ex_path: str,\n    dm_path: str,\n    *,\n    format: str = \"csv\",\n    blq_handling: str = \"zero\",\n    lloq: float | None = None,\n    time_reference: str = \"first_dose\"\n) -&gt; CDISCData:\n    \"\"\"\n    Import CDISC data from PC, EX, and DM domains.\n\n    Parameters\n    ----------\n    pc_path : str\n        Path to PC domain file\n    ex_path : str\n        Path to EX domain file\n    dm_path : str\n        Path to DM domain file\n    format : str\n        \"csv\" or \"xpt\"\n    blq_handling : str\n        \"zero\", \"lloq_half\", or \"missing\"\n    lloq : float, optional\n        Lower limit of quantification\n    time_reference : str\n        \"first_dose\" or \"rfstdtc\"\n\n    Returns\n    -------\n    CDISCData\n        Imported data object\n    \"\"\"\n</code></pre>"},{"location":"python/data/cdisc/#individual-domain-functions","title":"Individual Domain Functions","text":"<pre><code>from openpkpd.data import read_cdisc_pc, read_cdisc_ex, read_cdisc_dm\n\n# Read individual domains\npc = read_cdisc_pc(\"pc.csv\")\nex = read_cdisc_ex(\"ex.csv\")\ndm = read_cdisc_dm(\"dm.csv\")\n\n# Combine manually\nfrom openpkpd.data import cdisc_to_observed_data\ndata = cdisc_to_observed_data(pc, ex, dm)\n</code></pre>"},{"location":"python/data/cdisc/#cdiscdata-class","title":"CDISCData Class","text":""},{"location":"python/data/cdisc/#structure","title":"Structure","text":"<pre><code>@dataclass\nclass CDISCData:\n    \"\"\"Container for imported CDISC data.\"\"\"\n\n    # Study information\n    study_id: str\n    analyte: str\n    units: str\n    time_units: str\n\n    # Subject data\n    subjects: list[SubjectData]\n\n    # Validation\n    validation_warnings: list[str]\n\n    # Properties\n    @property\n    def n_subjects(self) -&gt; int: ...\n\n    @property\n    def n_observations(self) -&gt; int: ...\n\n    @property\n    def subject_ids(self) -&gt; list[str]: ...\n\n    # Methods\n    def get_subject(self, subject_id: str) -&gt; SubjectData: ...\n    def to_dataframe(self) -&gt; pd.DataFrame: ...\n    def to_estimation_data(self) -&gt; EstimationData: ...\n</code></pre>"},{"location":"python/data/cdisc/#subjectdata-class","title":"SubjectData Class","text":"<pre><code>@dataclass\nclass SubjectData:\n    \"\"\"Individual subject data.\"\"\"\n\n    subject_id: str\n    times: list[float]           # Hours from first dose\n    observations: list[float]    # Concentrations\n    doses: list[DoseEvent]       # Dose events\n    covariates: dict[str, Any]   # Demographics\n    lloq: float                  # LLOQ value\n    blq_flags: list[bool]        # BLQ indicators\n</code></pre>"},{"location":"python/data/cdisc/#accessing-data","title":"Accessing Data","text":"<pre><code>from openpkpd.data import import_cdisc\n\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\")\n\n# Iterate through subjects\nfor subj in data.subjects:\n    print(f\"Subject: {subj.subject_id}\")\n    print(f\"  Time points: {len(subj.times)}\")\n    print(f\"  Max conc: {max(subj.observations):.2f}\")\n    print(f\"  Age: {subj.covariates.get('age', 'N/A')}\")\n    print(f\"  Doses: {len(subj.doses)}\")\n\n# Get specific subject\nsubj = data.get_subject(\"SUBJ001\")\n\n# Convert to DataFrame\ndf = data.to_dataframe()\nprint(df.head())\n</code></pre>"},{"location":"python/data/cdisc/#time-handling","title":"Time Handling","text":""},{"location":"python/data/cdisc/#elapsed-time-parsing","title":"Elapsed Time Parsing","text":"<pre><code># PCELTM format (ISO 8601 duration)\n# PT0H     \u2192 0.0 hours\n# PT1H     \u2192 1.0 hours\n# PT2H30M  \u2192 2.5 hours\n# P1DT2H   \u2192 26.0 hours\n\n# Parsed automatically during import\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\")\n\n# Times are relative to first dose (in hours)\nfor subj in data.subjects:\n    print(f\"Time range: {min(subj.times)} to {max(subj.times)} h\")\n</code></pre>"},{"location":"python/data/cdisc/#reference-time-options","title":"Reference Time Options","text":"<pre><code># Times relative to first dose (default)\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\",\n    time_reference=\"first_dose\"\n)\n\n# Times relative to reference start date (RFSTDTC)\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\",\n    time_reference=\"rfstdtc\"\n)\n</code></pre>"},{"location":"python/data/cdisc/#blq-handling","title":"BLQ Handling","text":""},{"location":"python/data/cdisc/#detection","title":"Detection","text":"<p>BLQ values are detected from: - <code>PCSTRESN == 0</code> or missing - <code>PCSTAT == \"NOT DONE\"</code> - <code>PCORRES</code> contains \"&lt;\", \"BLQ\", \"BLOQ\" - <code>PCSTRESN &lt; PCLLOQ</code></p> <pre><code># Check BLQ flags\nfor subj in data.subjects:\n    n_blq = sum(subj.blq_flags)\n    if n_blq &gt; 0:\n        print(f\"Subject {subj.subject_id}: {n_blq} BLQ samples\")\n</code></pre>"},{"location":"python/data/cdisc/#handling-options","title":"Handling Options","text":"<pre><code># Set BLQ to zero (default)\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\",\n    blq_handling=\"zero\"\n)\n\n# Set BLQ to LLOQ/2\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\",\n    blq_handling=\"lloq_half\",\n    lloq=0.5\n)\n\n# Keep as NaN (missing)\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\",\n    blq_handling=\"missing\"\n)\n</code></pre>"},{"location":"python/data/cdisc/#validation","title":"Validation","text":""},{"location":"python/data/cdisc/#automatic-validation","title":"Automatic Validation","text":"<pre><code>data = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\")\n\n# Check for warnings\nif data.validation_warnings:\n    print(\"Validation warnings:\")\n    for warning in data.validation_warnings:\n        print(f\"  \u26a0\ufe0f {warning}\")\n</code></pre>"},{"location":"python/data/cdisc/#manual-validation","title":"Manual Validation","text":"<pre><code>from openpkpd.data import validate_cdisc_dataset\n\nvalidation = validate_cdisc_dataset(\n    pc_path=\"pc.csv\",\n    ex_path=\"ex.csv\",\n    dm_path=\"dm.csv\"\n)\n\nif validation.valid:\n    print(\"\u2713 Dataset passes validation\")\nelse:\n    print(\"\u274c Validation failed:\")\n    for error in validation.errors:\n        print(f\"  - {error}\")\n</code></pre>"},{"location":"python/data/cdisc/#validation-checks","title":"Validation Checks","text":"Check Description Required columns All required variables present Data types Correct types for each column Subject consistency IDs match across domains Dose availability All PK subjects have dosing data Concentration values No negative concentrations Time sequence Valid time progression"},{"location":"python/data/cdisc/#covariate-extraction","title":"Covariate Extraction","text":""},{"location":"python/data/cdisc/#standard-covariates","title":"Standard Covariates","text":"<pre><code># Covariates extracted from DM domain:\n# - age (AGE)\n# - sex (SEX \u2192 \"M\", \"F\")\n# - race (RACE)\n# - ethnicity (ETHNIC)\n# - treatment arm (ARM, ARMCD)\n\ndata = import_cdisc(\"pc.csv\", \"ex.csv\", \"dm.csv\")\n\nfor subj in data.subjects:\n    print(f\"Subject {subj.subject_id}:\")\n    print(f\"  Age: {subj.covariates.get('age', 'N/A')}\")\n    print(f\"  Sex: {subj.covariates.get('sex', 'N/A')}\")\n    print(f\"  Weight: {subj.covariates.get('weight', 'N/A')}\")\n</code></pre>"},{"location":"python/data/cdisc/#additional-covariates-from-vs","title":"Additional Covariates from VS","text":"<pre><code># Include vital signs for weight, height\ndata = import_cdisc(\n    pc_path=\"pc.csv\",\n    ex_path=\"ex.csv\",\n    dm_path=\"dm.csv\",\n    vs_path=\"vs.csv\",  # Optional vital signs\n    covariates=[\"weight\", \"height\", \"bmi\"]\n)\n</code></pre>"},{"location":"python/data/cdisc/#export-options","title":"Export Options","text":""},{"location":"python/data/cdisc/#to-dataframe","title":"To DataFrame","text":"<pre><code>df = data.to_dataframe()\n\n# DataFrame columns:\n# SUBJID, TIME, DV, AMT, EVID, MDV, CMT, AGE, SEX, WT, ...\nprint(df.head())\n</code></pre>"},{"location":"python/data/cdisc/#to-nonmem-format","title":"To NONMEM Format","text":"<pre><code>from openpkpd.data import export_nonmem_data\n\nexport_nonmem_data(data, \"nonmem_data.csv\")\n\n# Creates NONMEM-compatible dataset with:\n# ID, TIME, DV, AMT, EVID, MDV, CMT, ...\n</code></pre>"},{"location":"python/data/cdisc/#to-nca-input","title":"To NCA Input","text":"<pre><code># Direct use with NCA\nfrom openpkpd.nca import run_population_nca\n\npop_result = run_population_nca(\n    data.to_dataframe(),\n    subject_col='SUBJID',\n    time_col='TIME',\n    conc_col='DV',\n    dose_col='AMT'\n)\n</code></pre>"},{"location":"python/data/cdisc/#complete-example","title":"Complete Example","text":"<pre><code>import pandas as pd\nfrom openpkpd.data import import_cdisc, validate_cdisc_dataset\n\n# Step 1: Validate data\nprint(\"Validating CDISC data...\")\nvalidation = validate_cdisc_dataset(\n    pc_path=\"pc.csv\",\n    ex_path=\"ex.csv\",\n    dm_path=\"dm.csv\"\n)\n\nif not validation.valid:\n    print(\"Validation failed:\")\n    for error in validation.errors:\n        print(f\"  - {error}\")\n    exit(1)\n\nprint(\"\u2713 Validation passed\")\n\n# Step 2: Import data\nprint(\"\\nImporting CDISC data...\")\ndata = import_cdisc(\n    pc_path=\"pc.csv\",\n    ex_path=\"ex.csv\",\n    dm_path=\"dm.csv\",\n    blq_handling=\"lloq_half\",\n    lloq=0.5\n)\n\n# Step 3: Display summary\nprint(\"\\n\" + \"=\" * 50)\nprint(\"CDISC Data Import Summary\")\nprint(\"=\" * 50)\n\nprint(f\"\\nStudy: {data.study_id}\")\nprint(f\"Analyte: {data.analyte}\")\nprint(f\"Units: {data.units}\")\n\nprint(f\"\\nSubjects: {data.n_subjects}\")\nprint(f\"Total observations: {data.n_observations}\")\n\n# Step 4: Subject details\nprint(\"\\n--- Subject Details ---\")\nfor subj in data.subjects[:5]:  # First 5 subjects\n    n_obs = len(subj.times)\n    n_doses = len(subj.doses)\n    age = subj.covariates.get('age', 'N/A')\n    sex = subj.covariates.get('sex', 'N/A')\n    n_blq = sum(subj.blq_flags)\n\n    print(f\"\\n{subj.subject_id}:\")\n    print(f\"  Observations: {n_obs}\")\n    print(f\"  Time range: {min(subj.times):.1f} - {max(subj.times):.1f} h\")\n    print(f\"  Doses: {n_doses}\")\n    print(f\"  Age: {age}, Sex: {sex}\")\n    if n_blq &gt; 0:\n        print(f\"  BLQ samples: {n_blq}\")\n\n# Step 5: Check warnings\nif data.validation_warnings:\n    print(\"\\n--- Warnings ---\")\n    for w in data.validation_warnings:\n        print(f\"  \u26a0\ufe0f {w}\")\n\n# Step 6: Use with NCA\nprint(\"\\n--- Running Population NCA ---\")\nfrom openpkpd.nca import run_population_nca, summarize_population_nca\n\ndf = data.to_dataframe()\npop_result = run_population_nca(\n    df,\n    subject_col='SUBJID',\n    time_col='TIME',\n    conc_col='DV',\n    dose_col='AMT'\n)\n\nsummary = summarize_population_nca(pop_result)\nprint(f\"\\nCmax: {summary['cmax']['mean']:.2f} \u00b1 {summary['cmax']['sd']:.2f} {data.units}\")\nprint(f\"AUC: {summary['auc_0_inf']['mean']:.2f} \u00b1 {summary['auc_0_inf']['sd']:.2f} {data.units}\u00b7h\")\n\n# Step 7: Export\nprint(\"\\n--- Exporting Data ---\")\ndf.to_csv(\"analysis_dataset.csv\", index=False)\nprint(\"Saved to analysis_dataset.csv\")\n</code></pre>"},{"location":"python/data/cdisc/#adam-import","title":"ADaM Import","text":""},{"location":"python/data/cdisc/#adpc-dataset","title":"ADPC Dataset","text":"<pre><code>from openpkpd.data import import_adam_adpc\n\nadpc = import_adam_adpc(\"adpc.csv\")\n\n# ADaM-specific variables:\n# AVAL - Analysis value\n# ATPT - Analysis timepoint\n# ATPTN - Numeric timepoint\n# TRTP - Planned treatment\n# TRTA - Actual treatment\n</code></pre>"},{"location":"python/data/cdisc/#adsl-dataset","title":"ADSL Dataset","text":"<pre><code>from openpkpd.data import import_adam_adsl\n\nadsl = import_adam_adsl(\"adsl.csv\")\n</code></pre>"},{"location":"python/data/cdisc/#combined-import","title":"Combined Import","text":"<pre><code>from openpkpd.data import import_adam\n\ndata = import_adam(\n    adpc_path=\"adpc.csv\",\n    adsl_path=\"adsl.csv\"\n)\n</code></pre>"},{"location":"python/data/cdisc/#pp-domain-pk-parameters","title":"PP Domain (PK Parameters)","text":"<p>Import pre-calculated PK parameters:</p> <pre><code>from openpkpd.data import read_cdisc_pp\n\npp = read_cdisc_pp(\"pp.csv\")\n\n# Common parameter codes:\n# CMAX - Maximum concentration\n# TMAX - Time to max\n# AUCLST - AUC to last\n# AUCIFO - AUC extrapolated\n# LAMZHL - Half-life\n</code></pre>"},{"location":"python/data/cdisc/#see-also","title":"See Also","text":"<ul> <li>Data Import Overview - All import options</li> <li>Population NCA - NCA analysis</li> <li>Estimation - Population modeling</li> </ul>"},{"location":"python/data/monolix/","title":"Monolix Model Import","text":"<p>Import Monolix project files (.mlxtran) into OpenPKPD Python.</p>"},{"location":"python/data/monolix/#overview","title":"Overview","text":"<pre><code>from openpkpd.import_ import import_monolix\n\nmodel = import_monolix(\"project.mlxtran\")\nprint(f\"Model: {model.model_kind}\")\nprint(f\"Parameters: {model.params}\")\n</code></pre>"},{"location":"python/data/monolix/#quick-start","title":"Quick Start","text":""},{"location":"python/data/monolix/#basic-import","title":"Basic Import","text":"<pre><code>from openpkpd.import_ import import_monolix\n\n# Import Monolix project\nmodel = import_monolix(\"project.mlxtran\")\n\n# Access model information\nprint(f\"Model type: {model.model_kind}\")\nprint(f\"Source: {model.source_format}\")\n\n# Access parameters\nfor name, value in model.params.items():\n    print(f\"  {name} = {value}\")\n</code></pre>"},{"location":"python/data/monolix/#with-dose-events","title":"With Dose Events","text":"<pre><code># Specify doses if needed\ndoses = [\n    {\"time\": 0.0, \"amount\": 100.0, \"route\": \"oral\"}\n]\n\nmodel = import_monolix(\"project.mlxtran\", doses=doses)\n</code></pre>"},{"location":"python/data/monolix/#supported-model-types","title":"Supported Model Types","text":""},{"location":"python/data/monolix/#one-compartment-models","title":"One-Compartment Models","text":"Monolix Library Model OpenPKPD Model <code>pk_bolus1cpt_Vk_PLASMA</code> <code>OneCompIVBolus</code> <code>pk_bolus1cpt_VCl_PLASMA</code> <code>OneCompIVBolus</code> <code>pk_oral1cpt_kaVk_PLASMA</code> <code>OneCompOralFirstOrder</code> <code>pk_oral1cpt_kaVCl_PLASMA</code> <code>OneCompOralFirstOrder</code> <code>pk_infusion1cpt_VCl_PLASMA</code> <code>OneCompIVInfusion</code>"},{"location":"python/data/monolix/#two-compartment-models","title":"Two-Compartment Models","text":"Monolix Library Model OpenPKPD Model <code>pk_bolus2cpt_V1k12k21k_PLASMA</code> <code>TwoCompIVBolus</code> <code>pk_bolus2cpt_V1ClQ2V2_PLASMA</code> <code>TwoCompIVBolus</code> <code>pk_oral2cpt_kaV1k12k21k_PLASMA</code> <code>TwoCompOral</code> <code>pk_oral2cpt_kaV1ClQ2V2_PLASMA</code> <code>TwoCompOral</code>"},{"location":"python/data/monolix/#three-compartment-models","title":"Three-Compartment Models","text":"Monolix Library Model OpenPKPD Model <code>pk_bolus3cpt_V1ClQ2V2Q3V3_PLASMA</code> <code>ThreeCompIVBolus</code>"},{"location":"python/data/monolix/#special-models","title":"Special Models","text":"Monolix Library Model OpenPKPD Model <code>pk_bolus1cpt_VVmKm_PLASMA</code> <code>MichaelisMentenElimination</code>"},{"location":"python/data/monolix/#importedmodel-class","title":"ImportedModel Class","text":"<pre><code>@dataclass\nclass ImportedModel:\n    \"\"\"Result of importing a Monolix model.\"\"\"\n\n    source_format: str          # \"monolix\"\n    source_file: str            # Path to mlxtran file\n    model_kind: str             # OpenPKPD model name\n\n    # Fixed effects\n    params: dict[str, float]    # Parameter values\n    theta_init: list[float]     # Initial values\n    theta_names: list[str]      # Parameter names\n\n    # Random effects\n    omega_init: list[list[float]]  # Omega matrix\n    omega_names: list[str]         # IIV parameter names\n\n    # Residual error\n    sigma_type: str             # Error model type\n    sigma_init: float           # Error parameter\n\n    # Quality\n    warnings: list[str]         # Import warnings\n\n    # Metadata\n    metadata: dict[str, Any]    # Additional info\n</code></pre>"},{"location":"python/data/monolix/#parameter-extraction","title":"Parameter Extraction","text":""},{"location":"python/data/monolix/#population-parameters","title":"Population Parameters","text":"<pre><code>model = import_monolix(\"project.mlxtran\")\n\n# Access population parameters\nprint(\"Population Parameters:\")\nfor name, value in model.params.items():\n    print(f\"  {name} = {value}\")\n\n# Example output:\n# Ka = 1.5\n# V = 50.0\n# CL = 5.0\n</code></pre>"},{"location":"python/data/monolix/#random-effects","title":"Random Effects","text":"<pre><code>import math\n\nmodel = import_monolix(\"project.mlxtran\")\n\nprint(\"Random Effects:\")\nfor i, name in enumerate(model.omega_names):\n    omega_sq = model.omega_init[i][i]\n    # For lognormal IIV, convert to CV%\n    cv = (math.exp(omega_sq) - 1) ** 0.5 * 100\n    print(f\"  {name}: \u03c9\u00b2 = {omega_sq:.4f} (CV \u2248 {cv:.1f}%)\")\n</code></pre>"},{"location":"python/data/monolix/#variability-transformations","title":"Variability Transformations","text":"Monolix Variability OpenPKPD Transform Formula <code>lognormal</code> <code>exponential</code> \u03b8\u1d62 = \u03b8_pop \u00b7 e^\u03b7\u1d62 <code>normal</code> <code>additive</code> \u03b8\u1d62 = \u03b8_pop + \u03b7\u1d62 <code>logitnormal</code> <code>logit</code> Logit transform <code>none</code> No IIV Fixed to pop value"},{"location":"python/data/monolix/#error-model-import","title":"Error Model Import","text":""},{"location":"python/data/monolix/#supported-error-models","title":"Supported Error Models","text":"<pre><code>model = import_monolix(\"project.mlxtran\")\n\nprint(f\"Error type: {model.sigma_type}\")\nprint(f\"Sigma value: {model.sigma_init}\")\n\n# Supported types:\n# - \"proportional\": Y = F * (1 + b*\u03b5)\n# - \"additive\": Y = F + a*\u03b5\n# - \"combined\": Y = F * (1 + b*\u03b5\u2081) + a*\u03b5\u2082\n</code></pre>"},{"location":"python/data/monolix/#error-model-mapping","title":"Error Model Mapping","text":"Monolix Error OpenPKPD Type <code>proportional</code> <code>proportional</code> <code>constant</code> <code>additive</code> <code>combined1</code> <code>combined</code> <code>combined2</code> <code>combined</code>"},{"location":"python/data/monolix/#covariate-models","title":"Covariate Models","text":""},{"location":"python/data/monolix/#extraction","title":"Extraction","text":"<pre><code>model = import_monolix(\"project.mlxtran\")\n\n# Covariate effects in metadata\neffects = model.metadata.get(\"covariate_effects\", [])\n\nfor effect in effects:\n    print(f\"{effect['covariate']} on {effect['parameter']}:\")\n    print(f\"  Type: {effect['type']}\")\n    print(f\"  Coefficient: {effect['coefficient']}\")\n    print(f\"  Reference: {effect['reference_value']}\")\n</code></pre>"},{"location":"python/data/monolix/#supported-covariate-types","title":"Supported Covariate Types","text":"Type Description Formula <code>power</code> Power model \u03b8 \u00b7 (COV/REF)^\u03b2 <code>linear</code> Linear model \u03b8 \u00b7 (1 + \u03b2\u00b7(COV-REF)) <code>exponential</code> Exponential \u03b8 \u00b7 exp(\u03b2\u00b7(COV-REF)) <code>categorical</code> Category effect \u03b8 \u00b7 exp(\u03b2\u00b7I)"},{"location":"python/data/monolix/#using-imported-models","title":"Using Imported Models","text":""},{"location":"python/data/monolix/#simulation","title":"Simulation","text":"<pre><code>from openpkpd.import_ import import_monolix\nfrom openpkpd import simulate\n\n# Import model\nmodel = import_monolix(\"project.mlxtran\")\n\n# Simulate\ntimes = list(range(0, 49))\ndoses = [{\"time\": 0.0, \"amount\": 500.0, \"route\": \"oral\"}]\n\nresult = simulate(\n    model_kind=model.model_kind,\n    params=model.params,\n    times=times,\n    doses=doses\n)\n\nprint(f\"Cmax: {max(result.concentrations):.2f}\")\n</code></pre>"},{"location":"python/data/monolix/#population-simulation","title":"Population Simulation","text":"<pre><code>from openpkpd import simulate_population\n\npop_result = simulate_population(\n    model_kind=model.model_kind,\n    params=model.params,\n    omega=model.omega_init,\n    sigma=model.sigma_init,\n    sigma_type=model.sigma_type,\n    n_subjects=100,\n    times=list(range(0, 49)),\n    doses=[{\"time\": 0.0, \"amount\": 500.0}]\n)\n</code></pre>"},{"location":"python/data/monolix/#unsupported-features","title":"Unsupported Features","text":""},{"location":"python/data/monolix/#models-not-supported","title":"Models Not Supported","text":"Model Type Description PD models Pharmacodynamic Turnover models Indirect response Transit compartment Absorption chain Mixture models Subpopulations Markov models State transitions Time-to-event Survival Count data Poisson/NegBin Categorical Ordered response"},{"location":"python/data/monolix/#features-with-warnings","title":"Features with Warnings","text":"Feature Handling Lag time (Tlag) Ignored, assumes Tlag=0 Bioavailability (F) Ignored, assumes F=1 Complex covariates May be simplified"},{"location":"python/data/monolix/#validation","title":"Validation","text":""},{"location":"python/data/monolix/#check-import-quality","title":"Check Import Quality","text":"<pre><code>model = import_monolix(\"project.mlxtran\")\n\n# Check warnings\nif model.warnings:\n    print(\"Import warnings:\")\n    for w in model.warnings:\n        print(f\"  \u26a0\ufe0f {w}\")\nelse:\n    print(\"\u2713 No warnings\")\n\n# Verify model type\nif model.model_kind == \"Unknown\":\n    print(\"\u274c Model type not recognized\")\nelse:\n    print(f\"\u2713 Model type: {model.model_kind}\")\n\n# Check parameters\nexpected = [\"Ka\", \"CL\", \"V\"]  # For 1-comp oral\nfor param in expected:\n    if param in model.params:\n        print(f\"\u2713 {param} = {model.params[param]}\")\n    else:\n        print(f\"\u274c Missing: {param}\")\n</code></pre>"},{"location":"python/data/monolix/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd.import_ import import_monolix\nfrom openpkpd import simulate\nimport math\n\n# Import Monolix project\nprint(\"Importing Monolix project...\")\nmodel = import_monolix(\"project.mlxtran\")\n\n# Display results\nprint(\"=\" * 50)\nprint(\"Monolix Import Results\")\nprint(\"=\" * 50)\n\nprint(f\"\\nSource: {model.source_file}\")\nprint(f\"Model type: {model.model_kind}\")\n\nprint(\"\\n--- Population Parameters ---\")\nfor name, value in model.params.items():\n    print(f\"  {name} = {value}\")\n\nprint(\"\\n--- Inter-Individual Variability ---\")\nif model.omega_names:\n    for i, name in enumerate(model.omega_names):\n        omega_sq = model.omega_init[i][i]\n        cv = (math.exp(omega_sq) - 1) ** 0.5 * 100\n        print(f\"  {name}: \u03c9\u00b2 = {omega_sq:.4f} (CV \u2248 {cv:.1f}%)\")\nelse:\n    print(\"  None\")\n\nprint(f\"\\n--- Residual Error ---\")\nprint(f\"  Type: {model.sigma_type}\")\nprint(f\"  Value: {model.sigma_init}\")\n\n# Covariate effects\neffects = model.metadata.get(\"covariate_effects\", [])\nif effects:\n    print(\"\\n--- Covariate Effects ---\")\n    for eff in effects:\n        print(f\"  {eff['covariate']} on {eff['parameter']}: {eff['type']}\")\n\nprint(\"\\n--- Warnings ---\")\nif model.warnings:\n    for w in model.warnings:\n        print(f\"  \u26a0\ufe0f {w}\")\nelse:\n    print(\"  None\")\n\n# Validation simulation\nprint(\"\\n--- Validation Simulation ---\")\ntimes = list(range(0, 73, 1))\ndoses = [{\"time\": 0.0, \"amount\": 500.0, \"route\": \"oral\"}]\n\nresult = simulate(\n    model_kind=model.model_kind,\n    params=model.params,\n    times=times,\n    doses=doses\n)\n\ncmax = max(result.concentrations)\ntmax = times[result.concentrations.index(cmax)]\nprint(f\"Cmax: {cmax:.2f}\")\nprint(f\"Tmax: {tmax} h\")\nprint(\"\u2713 Simulation successful\")\n</code></pre>"},{"location":"python/data/monolix/#model-library-reference","title":"Model Library Reference","text":""},{"location":"python/data/monolix/#standard-naming-convention","title":"Standard Naming Convention","text":"<pre><code>pk_{route}{n}cpt_{parameters}_{observation}\n</code></pre> <ul> <li>Route: <code>bolus</code>, <code>oral</code>, <code>infusion</code></li> <li>n: Number of compartments (1, 2, 3)</li> <li>Parameters: <code>V</code>, <code>Cl</code>, <code>k</code>, <code>ka</code>, <code>Q</code>, <code>Vm</code>, <code>Km</code></li> <li>Observation: <code>PLASMA</code>, <code>EFFECT</code></li> </ul>"},{"location":"python/data/monolix/#examples","title":"Examples","text":"<pre><code>pk_oral1cpt_kaVCl_PLASMA     \u2192 1-comp oral, ka/V/Cl parameterization\npk_bolus2cpt_V1ClQ2V2_PLASMA \u2192 2-comp IV, CL/V1/Q/V2 parameterization\npk_bolus1cpt_VVmKm_PLASMA    \u2192 Michaelis-Menten elimination\n</code></pre>"},{"location":"python/data/monolix/#auto-detection","title":"Auto-Detection","text":""},{"location":"python/data/monolix/#using-import_model","title":"Using import_model()","text":"<pre><code>from openpkpd.import_ import import_model\n\n# Auto-detect format from extension\nmodel = import_model(\"run001.ctl\")      # \u2192 NONMEM\nmodel = import_model(\"project.mlxtran\") # \u2192 Monolix\n\n# Or specify format explicitly\nmodel = import_model(\"model.txt\", format=\"nonmem\")\nmodel = import_model(\"project.xml\", format=\"monolix\")\n</code></pre>"},{"location":"python/data/monolix/#see-also","title":"See Also","text":"<ul> <li>NONMEM Import - Import NONMEM models</li> <li>CDISC Import - Import CDISC data</li> <li>Simulation - Model simulation</li> </ul>"},{"location":"python/data/nonmem/","title":"NONMEM Model Import","text":"<p>Import NONMEM control stream files (.ctl, .mod) into OpenPKPD Python.</p>"},{"location":"python/data/nonmem/#overview","title":"Overview","text":"<pre><code>from openpkpd.import_ import import_nonmem\n\nmodel = import_nonmem(\"run001.ctl\")\nprint(f\"Model: {model.model_kind}\")\nprint(f\"Parameters: {model.params}\")\n</code></pre>"},{"location":"python/data/nonmem/#quick-start","title":"Quick Start","text":""},{"location":"python/data/nonmem/#basic-import","title":"Basic Import","text":"<pre><code>from openpkpd.import_ import import_nonmem\n\n# Import NONMEM control file\nmodel = import_nonmem(\"run001.ctl\")\n\n# Access model information\nprint(f\"Model type: {model.model_kind}\")\nprint(f\"Source: {model.source_format}\")\n\n# Access parameters\nfor name, value in model.params.items():\n    print(f\"  {name} = {value}\")\n</code></pre>"},{"location":"python/data/nonmem/#with-dose-events","title":"With Dose Events","text":"<pre><code># Specify doses if not in control file\ndoses = [\n    {\"time\": 0.0, \"amount\": 100.0},\n    {\"time\": 12.0, \"amount\": 100.0}\n]\n\nmodel = import_nonmem(\"run001.ctl\", doses=doses)\n</code></pre>"},{"location":"python/data/nonmem/#importedmodel-class","title":"ImportedModel Class","text":"<pre><code>@dataclass\nclass ImportedModel:\n    \"\"\"Result of importing a model from external format.\"\"\"\n\n    # Source information\n    source_format: str          # \"nonmem\" or \"monolix\"\n    source_file: str            # Path to source file\n\n    # Model type\n    model_kind: str             # OpenPKPD model name\n\n    # Fixed effects\n    params: dict[str, float]    # Parameter name \u2192 value\n    theta_init: list[float]     # Initial THETA values\n    theta_names: list[str]      # Parameter names\n\n    # Random effects\n    omega_init: list[list[float]]  # Omega matrix\n    omega_names: list[str]         # Random effect names\n\n    # Residual error\n    sigma_type: str             # \"proportional\", \"additive\", etc.\n    sigma_init: float           # Error parameter value\n\n    # Quality\n    warnings: list[str]         # Import warnings\n\n    # Metadata\n    metadata: dict[str, Any]    # Additional information\n</code></pre>"},{"location":"python/data/nonmem/#accessing-model-details","title":"Accessing Model Details","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\n\n# Fixed effects\nprint(\"Fixed Effects:\")\nfor name, value in model.params.items():\n    print(f\"  {name} = {value}\")\n\n# Random effects\nprint(\"\\nRandom Effects:\")\nfor i, name in enumerate(model.omega_names):\n    omega = model.omega_init[i][i]\n    cv = (math.exp(omega) - 1) ** 0.5 * 100  # CV for lognormal\n    print(f\"  {name}: \u03c9\u00b2 = {omega:.4f} (CV \u2248 {cv:.1f}%)\")\n\n# Residual error\nprint(f\"\\nError Model: {model.sigma_type}\")\nprint(f\"Sigma: {model.sigma_init}\")\n\n# Warnings\nif model.warnings:\n    print(\"\\nWarnings:\")\n    for w in model.warnings:\n        print(f\"  \u26a0\ufe0f {w}\")\n</code></pre>"},{"location":"python/data/nonmem/#supported-advantrans","title":"Supported ADVAN/TRANS","text":""},{"location":"python/data/nonmem/#one-compartment-models","title":"One-Compartment Models","text":"ADVAN TRANS Parameters Model ADVAN1 TRANS1 K, V <code>OneCompIVBolus</code> ADVAN1 TRANS2 CL, V <code>OneCompIVBolus</code> ADVAN2 TRANS1 KA, K, V <code>OneCompOralFirstOrder</code> ADVAN2 TRANS2 KA, CL, V <code>OneCompOralFirstOrder</code>"},{"location":"python/data/nonmem/#two-compartment-models","title":"Two-Compartment Models","text":"ADVAN TRANS Parameters Model ADVAN3 TRANS1 K, K12, K21, V <code>TwoCompIVBolus</code> ADVAN3 TRANS4 CL, V1, Q, V2 <code>TwoCompIVBolus</code> ADVAN4 TRANS1 KA, K, K23, K32, V <code>TwoCompOral</code> ADVAN4 TRANS4 KA, CL, V1, Q, V2 <code>TwoCompOral</code>"},{"location":"python/data/nonmem/#three-compartment-models","title":"Three-Compartment Models","text":"ADVAN TRANS Parameters Model ADVAN11 TRANS4 CL, V1, Q2, V2, Q3, V3 <code>ThreeCompIVBolus</code>"},{"location":"python/data/nonmem/#special-models","title":"Special Models","text":"ADVAN Parameters Model ADVAN10 VM, KM, V <code>MichaelisMentenElimination</code>"},{"location":"python/data/nonmem/#parsed-control-file","title":"Parsed Control File","text":""},{"location":"python/data/nonmem/#accessing-raw-parsed-data","title":"Accessing Raw Parsed Data","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\n\n# Access parsed control file structure\nparsed = model.metadata.get(\"parsed_control_file\")\n\nif parsed:\n    # Problem statement\n    print(f\"Problem: {parsed.problem}\")\n\n    # Subroutines\n    print(f\"ADVAN: {parsed.subroutines.advan}\")\n    print(f\"TRANS: {parsed.subroutines.trans}\")\n\n    # THETA specifications\n    for i, theta in enumerate(parsed.thetas):\n        print(f\"THETA({i+1}): init={theta.init}, bounds=({theta.lower}, {theta.upper})\")\n</code></pre>"},{"location":"python/data/nonmem/#thetaspec","title":"THETASpec","text":"<pre><code>@dataclass\nclass THETASpec:\n    init: float           # Initial estimate\n    lower: float          # Lower bound\n    upper: float          # Upper bound\n    fixed: bool           # Fixed parameter\n    name: str             # Optional name\n</code></pre>"},{"location":"python/data/nonmem/#omegablock","title":"OMEGABlock","text":"<pre><code>@dataclass\nclass OMEGABlock:\n    values: list[float]          # Variance/covariance values\n    structure: OmegaStructure    # DIAGONAL or BLOCK\n    dimension: int               # Block dimension\n    fixed: bool                  # Fixed block\n</code></pre>"},{"location":"python/data/nonmem/#pk-block-parsing","title":"$PK Block Parsing","text":""},{"location":"python/data/nonmem/#supported-patterns","title":"Supported Patterns","text":"<pre><code># Typical value definitions\n# TVCL = THETA(1)\n\n# Parameter assignments with ETA\n# CL = TVCL * EXP(ETA(1))     \u2192 exponential\n# CL = TVCL + ETA(1)          \u2192 additive\n# CL = TVCL * (1 + ETA(1))    \u2192 proportional\n\n# Covariate effects\n# TVCL = THETA(1) * (WT/70)**THETA(4)      \u2192 power\n# TVCL = THETA(1) * (1 + THETA(5)*(AGE-40)) \u2192 linear\n</code></pre>"},{"location":"python/data/nonmem/#accessing-pk-block","title":"Accessing PK Block","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\nparsed = model.metadata.get(\"parsed_control_file\")\n\nif parsed and parsed.pk_block:\n    pk = parsed.pk_block\n\n    # TV definitions\n    for tv, theta_idx in pk.tv_definitions.items():\n        print(f\"{tv} = THETA({theta_idx})\")\n\n    # Parameter assignments\n    for assign in pk.assignments:\n        print(f\"{assign.parameter}: TV={assign.tv_symbol}, ETA={assign.eta_index}\")\n\n    # Unsupported lines\n    if pk.unsupported_lines:\n        print(\"Unsupported $PK lines:\")\n        for line in pk.unsupported_lines:\n            print(f\"  {line}\")\n</code></pre>"},{"location":"python/data/nonmem/#error-block-parsing","title":"$ERROR Block Parsing","text":""},{"location":"python/data/nonmem/#supported-error-models","title":"Supported Error Models","text":"Type Pattern Formula <code>proportional</code> <code>W = IPRED * THETA(n)</code> Y = F \u00b7 (1 + \u03b5) <code>additive</code> <code>W = THETA(n)</code> Y = F + \u03b5 <code>combined</code> <code>W = SQRT(...)</code> Y = F \u00b7 (1 + \u03b5\u2081) + \u03b5\u2082 <code>exponential</code> <code>Y = F * EXP(ERR(1))</code> Y = F \u00b7 e^\u03b5"},{"location":"python/data/nonmem/#accessing-error-model","title":"Accessing Error Model","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\n\nprint(f\"Error type: {model.sigma_type}\")\nprint(f\"Sigma value: {model.sigma_init}\")\n\n# Detailed error block\nparsed = model.metadata.get(\"parsed_control_file\")\nif parsed and parsed.error_block:\n    error = parsed.error_block\n    print(f\"THETA indices in error: {error.theta_indices}\")\n    print(f\"SIGMA fixed to 1: {error.sigma_fixed_to_1}\")\n</code></pre>"},{"location":"python/data/nonmem/#covariate-effects","title":"Covariate Effects","text":""},{"location":"python/data/nonmem/#extraction","title":"Extraction","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\n\n# Covariate effects extracted from $PK\neffects = model.metadata.get(\"covariate_effects\", [])\n\nfor effect in effects:\n    print(f\"{effect['covariate']} on {effect['parameter']}:\")\n    print(f\"  Type: {effect['type']}\")\n    print(f\"  THETA: {effect['theta_index']}\")\n    print(f\"  Reference: {effect['reference_value']}\")\n</code></pre>"},{"location":"python/data/nonmem/#supported-effect-types","title":"Supported Effect Types","text":"Type NONMEM Pattern Example <code>power</code> <code>(COV/REF)**THETA(n)</code> <code>(WT/70)**0.75</code> <code>linear</code> <code>(1 + THETA(n)*(COV-REF))</code> <code>(1 + 0.01*(AGE-40))</code> <code>exponential</code> <code>EXP(THETA(n)*(COV-REF))</code> <code>EXP(0.005*(CRCL-100))</code>"},{"location":"python/data/nonmem/#using-imported-models","title":"Using Imported Models","text":""},{"location":"python/data/nonmem/#simulation","title":"Simulation","text":"<pre><code>from openpkpd.import_ import import_nonmem\nfrom openpkpd import simulate\n\n# Import model\nmodel = import_nonmem(\"run001.ctl\")\n\n# Create model spec for simulation\n# (Automatic conversion)\ntimes = list(range(0, 49))  # 0-48 hours\ndoses = [{\"time\": 0.0, \"amount\": 500.0, \"route\": \"oral\"}]\n\nresult = simulate(\n    model_kind=model.model_kind,\n    params=model.params,\n    times=times,\n    doses=doses\n)\n\nprint(f\"Cmax: {max(result.concentrations):.2f}\")\n</code></pre>"},{"location":"python/data/nonmem/#population-simulation","title":"Population Simulation","text":"<pre><code>from openpkpd.import_ import import_nonmem\nfrom openpkpd import simulate_population\n\nmodel = import_nonmem(\"run001.ctl\")\n\n# Simulate population with imported IIV\npop_result = simulate_population(\n    model_kind=model.model_kind,\n    params=model.params,\n    omega=model.omega_init,\n    sigma=model.sigma_init,\n    sigma_type=model.sigma_type,\n    n_subjects=100,\n    times=list(range(0, 49)),\n    doses=[{\"time\": 0.0, \"amount\": 500.0}]\n)\n</code></pre>"},{"location":"python/data/nonmem/#validation","title":"Validation","text":""},{"location":"python/data/nonmem/#check-import-quality","title":"Check Import Quality","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\n\n# Check for warnings\nif model.warnings:\n    print(\"Import warnings:\")\n    for w in model.warnings:\n        print(f\"  \u26a0\ufe0f {w}\")\nelse:\n    print(\"\u2713 No warnings\")\n\n# Verify model type\nif model.model_kind == \"Unknown\":\n    print(\"\u274c Model type not recognized\")\nelse:\n    print(f\"\u2713 Model type: {model.model_kind}\")\n\n# Check parameters\nprint(f\"\u2713 {len(model.params)} parameters imported\")\nprint(f\"\u2713 {len(model.omega_names)} random effects imported\")\n</code></pre>"},{"location":"python/data/nonmem/#unsupported-features","title":"Unsupported Features","text":""},{"location":"python/data/nonmem/#not-supported","title":"Not Supported","text":"Feature Workaround Custom $DES Manual model definition Complex IF statements Simplify before import ALAG (lag time) Manual specification F1, F2 (bioavailability) Assumes F=1 R1, D1 (infusion params) Specify in dose events MTIME Not supported $MIX (mixture models) Not supported $MODEL (custom compartments) Use predefined models"},{"location":"python/data/nonmem/#detection","title":"Detection","text":"<pre><code>model = import_nonmem(\"run001.ctl\")\n\n# Warnings include unsupported features\nfor w in model.warnings:\n    if \"unsupported\" in w.lower():\n        print(f\"Unsupported: {w}\")\n</code></pre>"},{"location":"python/data/nonmem/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd.import_ import import_nonmem\nfrom openpkpd import simulate\nimport math\n\n# Import NONMEM control file\nprint(\"Importing NONMEM control file...\")\nmodel = import_nonmem(\"run001.ctl\")\n\n# Display results\nprint(\"=\" * 50)\nprint(\"NONMEM Import Results\")\nprint(\"=\" * 50)\n\nprint(f\"\\nSource: {model.source_file}\")\nprint(f\"Model type: {model.model_kind}\")\n\nprint(\"\\n--- Fixed Effects ---\")\nfor name, value in model.params.items():\n    print(f\"  {name} = {value}\")\n\nprint(\"\\n--- Random Effects ---\")\nfor i, name in enumerate(model.omega_names):\n    omega_sq = model.omega_init[i][i]\n    cv = (math.exp(omega_sq) - 1) ** 0.5 * 100\n    print(f\"  {name}: \u03c9\u00b2 = {omega_sq:.4f} (CV \u2248 {cv:.1f}%)\")\n\nprint(f\"\\n--- Residual Error ---\")\nprint(f\"  Type: {model.sigma_type}\")\nprint(f\"  Value: {model.sigma_init}\")\n\nprint(\"\\n--- Warnings ---\")\nif model.warnings:\n    for w in model.warnings:\n        print(f\"  \u26a0\ufe0f {w}\")\nelse:\n    print(\"  None\")\n\n# Validate with simulation\nprint(\"\\n--- Validation Simulation ---\")\ntimes = list(range(0, 49, 1))\ndoses = [{\"time\": 0.0, \"amount\": 500.0, \"route\": \"oral\"}]\n\nresult = simulate(\n    model_kind=model.model_kind,\n    params=model.params,\n    times=times,\n    doses=doses\n)\n\ncmax = max(result.concentrations)\ntmax = times[result.concentrations.index(cmax)]\nprint(f\"Cmax: {cmax:.2f}\")\nprint(f\"Tmax: {tmax} h\")\nprint(\"\u2713 Simulation successful\")\n</code></pre>"},{"location":"python/data/nonmem/#see-also","title":"See Also","text":"<ul> <li>Monolix Import - Import Monolix projects</li> <li>CDISC Import - Import CDISC data</li> <li>Simulation - Model simulation</li> </ul>"},{"location":"python/estimation/","title":"Parameter Estimation","text":"<p>OpenPKPD Python provides comprehensive parameter estimation capabilities for population PK/PD modeling through seamless integration with the Julia estimation engine.</p>"},{"location":"python/estimation/#overview","title":"Overview","text":"<p>Estimate population parameters from observed data using industry-standard methods:</p> <pre><code>from openpkpd.estimation import estimate, EstimationConfig, FOCEIMethod\n\n# Configure and run estimation\nconfig = EstimationConfig(\n    method=FOCEIMethod(),\n    theta_init=[10.0, 50.0],\n    omega_init=[[0.09, 0], [0, 0.04]],\n    sigma_init=0.1,\n    compute_se=True\n)\n\nresult = estimate(data, model, config)\n\nprint(f\"Theta: {result.theta}\")\nprint(f\"SE: {result.theta_se}\")\nprint(f\"OFV: {result.ofv}\")\n</code></pre>"},{"location":"python/estimation/#estimation-methods","title":"Estimation Methods","text":"Method Description Best For FOCE-I First-Order Conditional Estimation with Interaction Standard analyses SAEM Stochastic Approximation EM Complex models, high IIV Laplacian Laplace approximation Sparse data"},{"location":"python/estimation/#quick-start","title":"Quick Start","text":""},{"location":"python/estimation/#installation","title":"Installation","text":"<pre><code>pip install openpkpd\n</code></pre>"},{"location":"python/estimation/#basic-foce-i-estimation","title":"Basic FOCE-I Estimation","text":"<pre><code>from openpkpd.estimation import (\n    estimate,\n    EstimationConfig,\n    FOCEIMethod,\n    BLQConfig,\n    BLQMethod,\n    EstimationData\n)\n\n# Prepare data\ndata = EstimationData(\n    subject_ids=[\"1\", \"1\", \"1\", \"2\", \"2\", \"2\"],\n    times=[0.5, 2.0, 8.0, 0.5, 2.0, 8.0],\n    observations=[1.8, 1.2, 0.4, 2.1, 1.4, 0.5],\n    doses=[\n        {\"time\": 0.0, \"amount\": 100.0, \"subject_id\": \"1\"},\n        {\"time\": 0.0, \"amount\": 100.0, \"subject_id\": \"2\"}\n    ],\n    observation_name=\"conc\"\n)\n\n# Configure estimation\nconfig = EstimationConfig(\n    method=FOCEIMethod(),\n    theta_init=[5.0, 50.0],           # Initial CL, V\n    omega_init=[[0.09, 0], [0, 0.04]], # 30% CV CL, 20% CV V\n    sigma_init=0.1,                    # 10% proportional error\n    max_iter=1000,\n    tol=1e-6,\n    compute_se=True,\n    compute_ci=True,\n    verbose=True\n)\n\n# Run estimation\nresult = estimate(data, \"OneCompIVBolus\", config)\n\n# Access results\nprint(\"=== Estimation Results ===\")\nprint(f\"CL = {result.theta[0]:.3f} (SE: {result.theta_se[0]:.3f})\")\nprint(f\"V  = {result.theta[1]:.3f} (SE: {result.theta_se[1]:.3f})\")\nprint(f\"OFV = {result.ofv:.2f}\")\nprint(f\"AIC = {result.aic:.2f}\")\n</code></pre>"},{"location":"python/estimation/#configuration-classes","title":"Configuration Classes","text":""},{"location":"python/estimation/#estimationconfig","title":"EstimationConfig","text":"<pre><code>from openpkpd.estimation import EstimationConfig, FOCEIMethod\n\nconfig = EstimationConfig(\n    # Method\n    method=FOCEIMethod(),          # or SAEMMethod(), LaplacianMethod()\n\n    # Initial estimates\n    theta_init=[10.0, 50.0],       # Fixed effects\n    omega_init=[[0.09, 0],         # Random effects variance\n                [0, 0.04]],\n    sigma_init=0.1,                # Residual error\n\n    # Convergence\n    max_iter=1000,                 # Maximum iterations\n    tol=1e-6,                      # Convergence tolerance\n\n    # Standard errors\n    compute_se=True,               # Compute SEs\n    compute_ci=True,               # Compute CIs\n    ci_level=0.95,                 # 95% CI\n\n    # Omega structure\n    omega_structure=\"diagonal\",    # \"diagonal\", \"block\", or \"full\"\n\n    # BLQ handling\n    blq_config=BLQConfig(\n        method=BLQMethod.M3,\n        lloq=0.1\n    ),\n\n    # Output\n    verbose=True,\n    seed=12345\n)\n</code></pre>"},{"location":"python/estimation/#method-specific-configuration","title":"Method-Specific Configuration","text":"<pre><code># FOCE-I\nfrom openpkpd.estimation import FOCEIMethod\nmethod = FOCEIMethod(\n    centered=False,        # FOCE-I (not FOCE)\n    compute_cwres=True,    # Compute CWRES\n    laplacian=True         # Include Laplacian correction\n)\n\n# SAEM\nfrom openpkpd.estimation import SAEMMethod\nmethod = SAEMMethod(\n    n_burn=200,            # Burn-in iterations\n    n_iter=300,            # Main iterations\n    n_chains=3,            # MCMC chains per subject\n    n_mcmc_steps=50,       # MCMC steps per E-step\n    target_acceptance=0.3  # Target acceptance rate\n)\n\n# Laplacian\nfrom openpkpd.estimation import LaplacianMethod\nmethod = LaplacianMethod(\n    max_inner_iter=50,     # Inner optimization iterations\n    inner_tol=1e-6         # Inner tolerance\n)\n</code></pre>"},{"location":"python/estimation/#blq-handling","title":"BLQ Handling","text":"<p>Handle Below Limit of Quantification observations:</p> <pre><code>from openpkpd.estimation import BLQConfig, BLQMethod\n\n# M1: Discard BLQ observations\nblq_config = BLQConfig(method=BLQMethod.M1, lloq=0.1)\n\n# M2: Impute at LLOQ/2\nblq_config = BLQConfig(method=BLQMethod.M2, lloq=0.1, impute_value=\"half\")\n\n# M3: Censored likelihood (recommended)\nblq_config = BLQConfig(method=BLQMethod.M3, lloq=0.1)\n\nconfig = EstimationConfig(\n    # ... other options\n    blq_config=blq_config\n)\n</code></pre>"},{"location":"python/estimation/#estimation-result","title":"Estimation Result","text":"<pre><code>result = estimate(data, model, config)\n\n# Fixed effects\nresult.theta              # Parameter estimates\nresult.theta_se           # Standard errors\nresult.theta_rse          # Relative SE (%)\nresult.theta_ci_lower     # Lower CI\nresult.theta_ci_upper     # Upper CI\n\n# Random effects\nresult.omega              # Omega matrix\nresult.omega_se           # Omega SEs\nresult.omega_corr         # Correlation matrix\n\n# Residual error\nresult.sigma              # Sigma estimate\nresult.sigma_se           # Sigma SE\n\n# Individual estimates\nresult.individual_estimates  # List of IndividualEstimate objects\n\n# Diagnostics\nresult.eta_shrinkage      # Eta shrinkage per parameter\nresult.epsilon_shrinkage  # Epsilon shrinkage\nresult.condition_number   # Covariance matrix condition\n\n# Model fit\nresult.ofv                # Objective function value\nresult.aic                # Akaike Information Criterion\nresult.bic                # Bayesian Information Criterion\n\n# Convergence\nresult.converged          # Did it converge?\nresult.n_iterations       # Number of iterations\nresult.runtime            # Execution time\n</code></pre>"},{"location":"python/estimation/#diagnostics","title":"Diagnostics","text":""},{"location":"python/estimation/#accessing-residuals","title":"Accessing Residuals","text":"<pre><code>from openpkpd.estimation import compute_diagnostics\n\n# Get diagnostics\ndiagnostics = compute_diagnostics(result)\n\n# Per-subject residuals\nfor ind in result.individual_estimates:\n    print(f\"Subject {ind.subject_id}:\")\n    print(f\"  CWRES: {ind.cwres}\")\n    print(f\"  IWRES: {ind.iwres}\")\n    print(f\"  IPRED: {ind.ipred}\")\n</code></pre>"},{"location":"python/estimation/#shrinkage","title":"Shrinkage","text":"<pre><code># Eta shrinkage (should be &lt; 30%)\nprint(f\"CL shrinkage: {result.eta_shrinkage[0]*100:.1f}%\")\nprint(f\"V shrinkage: {result.eta_shrinkage[1]*100:.1f}%\")\n\n# Epsilon shrinkage\nprint(f\"Epsilon shrinkage: {result.epsilon_shrinkage*100:.1f}%\")\n</code></pre>"},{"location":"python/estimation/#model-comparison","title":"Model Comparison","text":""},{"location":"python/estimation/#likelihood-ratio-test","title":"Likelihood Ratio Test","text":"<pre><code>from openpkpd.estimation import likelihood_ratio_test\n\n# Compare nested models\nchi_sq, p_value = likelihood_ratio_test(\n    ofv_full=result_full.ofv,\n    ofv_reduced=result_reduced.ofv,\n    df=1  # Difference in parameters\n)\n\nprint(f\"Chi-squared: {chi_sq:.2f}\")\nprint(f\"p-value: {p_value:.4f}\")\n</code></pre>"},{"location":"python/estimation/#information-criteria","title":"Information Criteria","text":"<pre><code># Compare models using AIC/BIC\nprint(f\"Model 1: AIC={result1.aic:.2f}, BIC={result1.bic:.2f}\")\nprint(f\"Model 2: AIC={result2.aic:.2f}, BIC={result2.bic:.2f}\")\n\n# Lower is better\ndelta_aic = result1.aic - result2.aic\nprint(f\"\u0394AIC = {delta_aic:.2f}\")\n</code></pre>"},{"location":"python/estimation/#bootstrap-analysis","title":"Bootstrap Analysis","text":"<pre><code>from openpkpd.estimation import run_bootstrap, BootstrapConfig\n\n# Configure bootstrap\nbootstrap_config = BootstrapConfig(\n    n_bootstrap=1000,\n    bootstrap_type=\"case\",      # \"case\", \"parametric\", or \"residual\"\n    stratify_by=[\"study\"],      # Stratification variables\n    ci_level=0.95,\n    ci_method=\"percentile\",     # \"percentile\", \"bca\", or \"basic\"\n    parallel=True,\n    seed=12345\n)\n\n# Run bootstrap\nbootstrap_result = run_bootstrap(\n    data=data,\n    model=model,\n    config=config,\n    initial_result=result,\n    bootstrap_config=bootstrap_config\n)\n\n# Access results\nprint(f\"Bootstrap SE: {bootstrap_result.theta_se}\")\nprint(f\"95% CI: [{bootstrap_result.theta_ci_lower}, {bootstrap_result.theta_ci_upper}]\")\nprint(f\"Success rate: {bootstrap_result.success_rate*100:.1f}%\")\n</code></pre>"},{"location":"python/estimation/#example-complete-analysis","title":"Example: Complete Analysis","text":"<pre><code>from openpkpd.estimation import (\n    estimate, run_bootstrap,\n    EstimationConfig, BootstrapConfig,\n    FOCEIMethod, BLQConfig, BLQMethod\n)\nimport pandas as pd\n\n# Load data\ndf = pd.read_csv(\"pk_data.csv\")\n\n# Prepare estimation data\ndata = EstimationData.from_dataframe(\n    df,\n    id_col=\"ID\",\n    time_col=\"TIME\",\n    dv_col=\"DV\",\n    amt_col=\"AMT\",\n    mdv_col=\"MDV\"\n)\n\n# Configure FOCE-I estimation\nconfig = EstimationConfig(\n    method=FOCEIMethod(compute_cwres=True),\n    theta_init=[10.0, 30.0, 5.0, 100.0],  # CL, V1, Q, V2\n    omega_init=[\n        [0.09, 0, 0, 0],\n        [0, 0.04, 0, 0],\n        [0, 0, 0.16, 0],\n        [0, 0, 0, 0.04]\n    ],\n    sigma_init={\"additive\": 0.1, \"proportional\": 0.1},\n    blq_config=BLQConfig(method=BLQMethod.M3, lloq=0.01),\n    compute_se=True,\n    verbose=True\n)\n\n# Run estimation\nresult = estimate(data, \"TwoCompIVBolus\", config)\n\n# Print results\nprint(\"=== FOCE-I Results ===\")\nparam_names = [\"CL\", \"V1\", \"Q\", \"V2\"]\nfor i, name in enumerate(param_names):\n    print(f\"{name}: {result.theta[i]:.3f} (RSE: {result.theta_rse[i]:.1f}%)\")\n\nprint(f\"\\nOFV: {result.ofv:.2f}\")\nprint(f\"Converged: {result.converged}\")\n\n# Run bootstrap for uncertainty\nbootstrap_config = BootstrapConfig(\n    n_bootstrap=500,\n    parallel=True,\n    seed=42\n)\n\nboot_result = run_bootstrap(data, \"TwoCompIVBolus\", config, result, bootstrap_config)\n\nprint(\"\\n=== Bootstrap Results ===\")\nfor i, name in enumerate(param_names):\n    ci_lo = boot_result.theta_ci_lower[i]\n    ci_hi = boot_result.theta_ci_upper[i]\n    print(f\"{name}: 95% CI [{ci_lo:.3f}, {ci_hi:.3f}]\")\n</code></pre>"},{"location":"python/estimation/#api-reference","title":"API Reference","text":""},{"location":"python/estimation/#main-functions","title":"Main Functions","text":"Function Description <code>estimate(data, model, config)</code> Run parameter estimation <code>run_bootstrap(data, model, config, result, boot_config)</code> Run bootstrap analysis <code>likelihood_ratio_test(ofv1, ofv2, df)</code> Compare nested models <code>compare_models(results, names)</code> Compare multiple models <code>compute_diagnostics(result)</code> Compute model diagnostics"},{"location":"python/estimation/#configuration-classes_1","title":"Configuration Classes","text":"Class Description <code>EstimationConfig</code> Main estimation configuration <code>FOCEIMethod</code> FOCE-I method settings <code>SAEMMethod</code> SAEM method settings <code>LaplacianMethod</code> Laplacian method settings <code>BLQConfig</code> BLQ handling configuration <code>BootstrapConfig</code> Bootstrap configuration"},{"location":"python/estimation/#result-classes","title":"Result Classes","text":"Class Description <code>EstimationResult</code> Full estimation results <code>IndividualEstimate</code> Per-subject estimates <code>BootstrapResult</code> Bootstrap analysis results <code>ModelComparisonResult</code> Model comparison results"},{"location":"python/estimation/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Detailed FOCE-I documentation</li> <li>SAEM Algorithm - SAEM details</li> <li>Laplacian Method - Laplacian details</li> <li>Diagnostics - Model diagnostics</li> <li>Bootstrap - Bootstrap analysis</li> <li>Model Comparison - Comparing models</li> </ul>"},{"location":"python/estimation/bootstrap/","title":"Bootstrap Analysis","text":"<p>Industry-standard bootstrap methods for parameter uncertainty estimation.</p>"},{"location":"python/estimation/bootstrap/#overview","title":"Overview","text":"<pre><code>from openpkpd.estimation import run_bootstrap, BootstrapConfig\n\nbootstrap_config = BootstrapConfig(\n    n_bootstrap=1000,\n    parallel=True,\n    seed=12345\n)\n\nbootstrap_result = run_bootstrap(\n    data, model, config, result, bootstrap_config\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#bootstrap-types","title":"Bootstrap Types","text":""},{"location":"python/estimation/bootstrap/#case-bootstrap-default","title":"Case Bootstrap (Default)","text":"<p>Resample subjects with replacement - FDA/EMA recommended:</p> <pre><code>bootstrap_config = BootstrapConfig(\n    n_bootstrap=1000,\n    bootstrap_type=\"case\",\n    seed=12345\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#parametric-bootstrap","title":"Parametric Bootstrap","text":"<p>Simulate new data from fitted model:</p> <pre><code>bootstrap_config = BootstrapConfig(\n    n_bootstrap=500,\n    bootstrap_type=\"parametric\"\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#residual-bootstrap","title":"Residual Bootstrap","text":"<p>Resample residuals:</p> <pre><code>bootstrap_config = BootstrapConfig(\n    n_bootstrap=500,\n    bootstrap_type=\"residual\",\n    standardize_residuals=True\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#configuration","title":"Configuration","text":""},{"location":"python/estimation/bootstrap/#bootstrapconfig-parameters","title":"BootstrapConfig Parameters","text":"<pre><code>from openpkpd.estimation import BootstrapConfig\n\nbootstrap_config = BootstrapConfig(\n    # Number of replicates\n    n_bootstrap=1000,           # FDA recommends \u2265500\n\n    # Bootstrap type\n    bootstrap_type=\"case\",      # \"case\", \"parametric\", \"residual\"\n\n    # Stratification\n    stratify_by=[\"study\"],      # Stratification variables\n\n    # Confidence intervals\n    ci_level=0.95,              # 95% CI\n    ci_method=\"percentile\",     # \"percentile\", \"bca\", \"basic\"\n\n    # Execution\n    parallel=True,              # Use multiple cores\n    n_jobs=-1,                  # -1 = all cores\n\n    # Quality control\n    min_success_rate=0.8,       # Minimum 80% success\n\n    # Reproducibility\n    seed=12345\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#stratified-resampling","title":"Stratified Resampling","text":"<pre><code># For pooled analyses, stratify by study\nbootstrap_config = BootstrapConfig(\n    n_bootstrap=1000,\n    stratify_by=[\"study\", \"formulation\"],\n    seed=12345\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#ci-methods","title":"CI Methods","text":""},{"location":"python/estimation/bootstrap/#percentile-ci-default","title":"Percentile CI (Default)","text":"<pre><code>bootstrap_config = BootstrapConfig(\n    ci_method=\"percentile\",\n    ci_level=0.95\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#bca-bias-corrected-and-accelerated","title":"BCa (Bias-Corrected and Accelerated)","text":"<p>Better for skewed distributions:</p> <pre><code>bootstrap_config = BootstrapConfig(\n    ci_method=\"bca\",\n    ci_level=0.95\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#basic-bootstrap-ci","title":"Basic Bootstrap CI","text":"<pre><code>bootstrap_config = BootstrapConfig(\n    ci_method=\"basic\",\n    ci_level=0.95\n)\n</code></pre>"},{"location":"python/estimation/bootstrap/#accessing-results","title":"Accessing Results","text":"<pre><code>result = run_bootstrap(data, model, config, initial_result, bootstrap_config)\n\n# Fixed effects\nprint(f\"Theta mean: {result.theta_mean}\")\nprint(f\"Theta SE: {result.theta_se}\")\nprint(f\"Theta RSE%: {result.theta_rse}\")\nprint(f\"95% CI lower: {result.theta_ci_lower}\")\nprint(f\"95% CI upper: {result.theta_ci_upper}\")\n\n# Bias\nprint(f\"Bias: {result.bias}\")\nprint(f\"Bias-corrected: {result.bias_corrected}\")\n\n# Diagnostics\nprint(f\"Success rate: {result.success_rate:.1%}\")\nprint(f\"N successful: {result.n_successful}\")\nprint(f\"N failed: {result.n_failed}\")\n\n# All estimates (for custom analysis)\nall_estimates = result.theta_estimates  # (n_bootstrap, n_params)\n</code></pre>"},{"location":"python/estimation/bootstrap/#quality-checks","title":"Quality Checks","text":"<pre><code># Check success rate (FDA requires \u226580%)\nif result.success_rate &lt; 0.8:\n    print(f\"WARNING: Success rate {result.success_rate:.1%} below 80%\")\n\n# Check for outliers\nif result.outlier_indices:\n    print(f\"Outlier estimates at indices: {result.outlier_indices}\")\n\n# Check SE stability\nprint(f\"RSE of SE estimate: {result.rse_stability}\")\n</code></pre>"},{"location":"python/estimation/bootstrap/#visualization","title":"Visualization","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Plot bootstrap distributions\nfig, axes = plt.subplots(1, len(result.theta_mean), figsize=(4*len(result.theta_mean), 4))\n\nparam_names = [\"CL\", \"V\"]\nfor i, (ax, name) in enumerate(zip(axes, param_names)):\n    estimates = result.theta_estimates[:, i]\n\n    ax.hist(estimates, bins=50, density=True, alpha=0.7)\n    ax.axvline(result.theta_mean[i], color='r', linestyle='-', label='Mean')\n    ax.axvline(result.theta_ci_lower[i], color='r', linestyle='--', label='95% CI')\n    ax.axvline(result.theta_ci_upper[i], color='r', linestyle='--')\n    ax.set_xlabel(name)\n    ax.set_ylabel('Density')\n    ax.set_title(f'{name} Bootstrap Distribution')\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"python/estimation/bootstrap/#example-complete-bootstrap-analysis","title":"Example: Complete Bootstrap Analysis","text":"<pre><code>from openpkpd.estimation import (\n    estimate, run_bootstrap,\n    EstimationConfig, BootstrapConfig,\n    FOCEIMethod\n)\n\n# Initial estimation\nconfig = EstimationConfig(\n    method=FOCEIMethod(),\n    theta_init=[10.0, 50.0],\n    omega_init=[[0.09, 0], [0, 0.04]],\n    sigma_init=0.1,\n    compute_se=True\n)\n\ninitial_result = estimate(data, \"OneCompIVBolus\", config)\n\n# Bootstrap analysis\nbootstrap_config = BootstrapConfig(\n    n_bootstrap=1000,\n    bootstrap_type=\"case\",\n    ci_level=0.95,\n    ci_method=\"percentile\",\n    parallel=True,\n    seed=42\n)\n\nboot_result = run_bootstrap(\n    data, \"OneCompIVBolus\", config,\n    initial_result, bootstrap_config\n)\n\n# Report\nprint(\"=== Bootstrap Results ===\")\nprint(f\"Success rate: {boot_result.success_rate:.1%}\")\n\nparam_names = [\"CL (L/h)\", \"V (L)\"]\nprint(\"\\nParameter  Estimate    SE       RSE%     95% CI\")\nprint(\"-\" * 55)\n\nfor i, name in enumerate(param_names):\n    est = initial_result.theta[i]\n    se = boot_result.theta_se[i]\n    rse = boot_result.theta_rse[i]\n    ci_lo = boot_result.theta_ci_lower[i]\n    ci_hi = boot_result.theta_ci_upper[i]\n    print(f\"{name:&lt;10} {est:&lt;10.3f} {se:&lt;8.3f} {rse:&lt;8.1f} [{ci_lo:.3f}, {ci_hi:.3f}]\")\n\n# Compare asymptotic vs bootstrap SE\nprint(\"\\n=== SE Comparison ===\")\nfor i, name in enumerate(param_names):\n    asymp = initial_result.theta_se[i]\n    boot = boot_result.theta_se[i]\n    ratio = boot / asymp\n    print(f\"{name}: Asymptotic={asymp:.3f}, Bootstrap={boot:.3f}, Ratio={ratio:.2f}\")\n</code></pre>"},{"location":"python/estimation/bootstrap/#best-practices","title":"Best Practices","text":"<ol> <li>Sample size: Use n \u2265 500 (FDA) or 1000 for regulatory submissions</li> <li>Success rate: Target \u2265 80%</li> <li>Stratification: Always stratify for pooled analyses</li> <li>CI method: Use BCa for skewed parameters</li> </ol>"},{"location":"python/estimation/bootstrap/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Primary estimation</li> <li>Diagnostics - Model validation</li> <li>Model Comparison - Comparing models</li> </ul>"},{"location":"python/estimation/comparison/","title":"Model Comparison","text":"<p>Tools for comparing nested and non-nested models.</p>"},{"location":"python/estimation/comparison/#overview","title":"Overview","text":"<pre><code>from openpkpd.estimation import likelihood_ratio_test, compare_models\n\n# Compare two models\nchi_sq, p_value = likelihood_ratio_test(\n    ofv_full=result_full.ofv,\n    ofv_reduced=result_reduced.ofv,\n    df=1\n)\n</code></pre>"},{"location":"python/estimation/comparison/#likelihood-ratio-test","title":"Likelihood Ratio Test","text":"<p>For nested models (reduced is special case of full):</p> <pre><code>from openpkpd.estimation import likelihood_ratio_test\n\n# Test if adding IIV on ka improves fit\nchi_sq, p_value = likelihood_ratio_test(\n    ofv_full=result_with_ka_iiv.ofv,\n    ofv_reduced=result_without_ka_iiv.ofv,\n    df=1  # One parameter added\n)\n\nprint(f\"Chi-squared: {chi_sq:.2f}\")\nprint(f\"p-value: {p_value:.4f}\")\n\nif p_value &lt; 0.05:\n    print(\"Full model significantly better\")\nelse:\n    print(\"Prefer simpler model\")\n</code></pre>"},{"location":"python/estimation/comparison/#significance-thresholds","title":"Significance Thresholds","text":"\u0394OFV df p-value 3.84 1 0.05 6.63 1 0.01 5.99 2 0.05 7.81 3 0.05"},{"location":"python/estimation/comparison/#information-criteria","title":"Information Criteria","text":"<p>For both nested and non-nested models:</p> <pre><code># Access from results\nprint(f\"Model 1: OFV={result1.ofv:.2f}, AIC={result1.aic:.2f}, BIC={result1.bic:.2f}\")\nprint(f\"Model 2: OFV={result2.ofv:.2f}, AIC={result2.aic:.2f}, BIC={result2.bic:.2f}\")\n\n# Lower is better\ndelta_aic = result1.aic - result2.aic\nprint(f\"\u0394AIC = {delta_aic:.2f}\")\n</code></pre>"},{"location":"python/estimation/comparison/#aic-vs-bic","title":"AIC vs BIC","text":"\\[AIC = OFV + 2p$$ $$BIC = OFV + p \\cdot \\ln(n)\\] Criterion Penalty Best For AIC 2 per param Prediction BIC ln(n) per param Model selection"},{"location":"python/estimation/comparison/#compare-multiple-models","title":"Compare Multiple Models","text":"<pre><code>from openpkpd.estimation import compare_models\n\n# Compare multiple models at once\ncomparison = compare_models(\n    results=[result_1comp, result_2comp, result_2comp_wt],\n    names=[\"1-comp\", \"2-comp\", \"2-comp + CL~WT\"]\n)\n\nprint(comparison.summary_table())\n# Output:\n# Model          n_params   OFV      AIC      BIC      \u0394AIC\n# ---------------------------------------------------------\n# 1-comp         5          245.3    255.3    267.1    0.0\n# 2-comp         9          198.7    216.7    240.3    -38.6\n# 2-comp+CL~WT   10         192.1    212.1    238.5    -43.2\n\nprint(f\"Best model by AIC: {comparison.best_by_aic}\")\nprint(f\"Best model by BIC: {comparison.best_by_bic}\")\n</code></pre>"},{"location":"python/estimation/comparison/#covariate-model-selection","title":"Covariate Model Selection","text":""},{"location":"python/estimation/comparison/#forward-selection","title":"Forward Selection","text":"<pre><code>def forward_selection(base_result, data, model, covariates, threshold=3.84):\n    \"\"\"Forward covariate selection.\"\"\"\n    selected = []\n    current_ofv = base_result.ofv\n\n    for cov in covariates:\n        # Fit model with this covariate\n        result_with_cov = estimate_with_covariate(data, model, cov)\n        delta_ofv = current_ofv - result_with_cov.ofv\n\n        if delta_ofv &gt; threshold:  # p &lt; 0.05\n            print(f\"{cov}: \u0394OFV = {delta_ofv:.2f}, INCLUDE\")\n            selected.append(cov)\n            current_ofv = result_with_cov.ofv\n        else:\n            print(f\"{cov}: \u0394OFV = {delta_ofv:.2f}, EXCLUDE\")\n\n    return selected\n\ncovariates = [\"WT\", \"AGE\", \"SEX\", \"CRCL\"]\nselected = forward_selection(base_result, data, model, covariates)\nprint(f\"Selected covariates: {selected}\")\n</code></pre>"},{"location":"python/estimation/comparison/#backward-elimination","title":"Backward Elimination","text":"<pre><code>def backward_elimination(full_result, data, model, covariates, threshold=6.63):\n    \"\"\"Backward covariate elimination.\"\"\"\n    remaining = list(covariates)\n    current_ofv = full_result.ofv\n\n    for cov in covariates:\n        # Fit model without this covariate\n        result_without = estimate_without_covariate(data, model, cov)\n        delta_ofv = result_without.ofv - current_ofv\n\n        if delta_ofv &lt; threshold:  # p &gt; 0.01\n            print(f\"{cov}: \u0394OFV = {delta_ofv:.2f}, DROP\")\n            remaining.remove(cov)\n        else:\n            print(f\"{cov}: \u0394OFV = {delta_ofv:.2f}, KEEP\")\n\n    return remaining\n</code></pre>"},{"location":"python/estimation/comparison/#random-effects-selection","title":"Random Effects Selection","text":""},{"location":"python/estimation/comparison/#test-iiv","title":"Test IIV","text":"<pre><code># Test if IIV on ka is needed\nresult_with_ka = estimate(data, model, config_with_ka_iiv)\nresult_without_ka = estimate(data, model, config_without_ka_iiv)\n\nchi_sq, p = likelihood_ratio_test(\n    result_with_ka.ofv,\n    result_without_ka.ofv,\n    df=1\n)\n\nprint(f\"IIV on ka: p = {p:.4f}\")\nif p &lt; 0.05:\n    print(\"Include IIV on ka\")\n</code></pre>"},{"location":"python/estimation/comparison/#test-correlation","title":"Test Correlation","text":"<pre><code># Test CL-V correlation\nresult_block = estimate(data, model, config_block_omega)\nresult_diag = estimate(data, model, config_diagonal_omega)\n\nchi_sq, p = likelihood_ratio_test(result_block.ofv, result_diag.ofv, df=1)\n\nif p &lt; 0.05:\n    corr = result_block.omega_corr[0, 1]\n    print(f\"CL-V correlation significant: r = {corr:.3f}\")\n</code></pre>"},{"location":"python/estimation/comparison/#example-complete-model-selection","title":"Example: Complete Model Selection","text":"<pre><code>from openpkpd.estimation import (\n    estimate, likelihood_ratio_test, compare_models,\n    EstimationConfig, FOCEIMethod\n)\n\n# Step 1: Structural model selection\nprint(\"=== Structural Model Selection ===\")\n\nresult_1c = estimate(data, \"OneCompIVBolus\", config_1c)\nresult_2c = estimate(data, \"TwoCompIVBolus\", config_2c)\n\nprint(f\"1-comp: AIC = {result_1c.aic:.2f}\")\nprint(f\"2-comp: AIC = {result_2c.aic:.2f}\")\n\nbest_struct = \"2-comp\" if result_2c.aic &lt; result_1c.aic - 4 else \"1-comp\"\nprint(f\"Selected: {best_struct}\")\n\n# Step 2: Random effects\nprint(\"\\n=== Random Effects Selection ===\")\n\nresult_diag = estimate(data, model, config_diag)\nresult_block = estimate(data, model, config_block)\n\nchi_sq, p = likelihood_ratio_test(result_block.ofv, result_diag.ofv, df=1)\nprint(f\"CL-V correlation: p = {p:.4f}\")\n\n# Step 3: Covariates\nprint(\"\\n=== Covariate Selection ===\")\n\ncovariates = [\"WT\", \"AGE\", \"SEX\"]\nfor cov in covariates:\n    result_cov = estimate_with_covariate(data, model, cov)\n    delta = base_ofv - result_cov.ofv\n    status = \"INCLUDE\" if delta &gt; 3.84 else \"EXCLUDE\"\n    print(f\"{cov}: \u0394OFV = {delta:.2f}, {status}\")\n\n# Step 4: Final comparison\nprint(\"\\n=== Final Model Comparison ===\")\ncomparison = compare_models(\n    [result_base, result_final],\n    [\"Base\", \"Final\"]\n)\nprint(comparison.summary_table())\n</code></pre>"},{"location":"python/estimation/comparison/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Estimation method</li> <li>Diagnostics - Model validation</li> <li>Bootstrap - Uncertainty quantification</li> </ul>"},{"location":"python/estimation/diagnostics/","title":"Model Diagnostics","text":"<p>Comprehensive diagnostic tools for assessing model fit and validating assumptions.</p>"},{"location":"python/estimation/diagnostics/#overview","title":"Overview","text":"<pre><code>from openpkpd.estimation import compute_diagnostics\n\nresult = estimate(data, model, config)\ndiagnostics = compute_diagnostics(result)\n</code></pre>"},{"location":"python/estimation/diagnostics/#residual-types","title":"Residual Types","text":""},{"location":"python/estimation/diagnostics/#cwres-conditional-weighted-residuals","title":"CWRES - Conditional Weighted Residuals","text":"<pre><code># Access CWRES\nfor ind in result.individual_estimates:\n    print(f\"Subject {ind.subject_id}: CWRES = {ind.cwres}\")\n\n# All CWRES combined\nimport numpy as np\nall_cwres = np.concatenate([ind.cwres for ind in result.individual_estimates])\nprint(f\"CWRES mean: {np.mean(all_cwres):.3f}\")\nprint(f\"CWRES std: {np.std(all_cwres):.3f}\")\n</code></pre>"},{"location":"python/estimation/diagnostics/#iwres-individual-weighted-residuals","title":"IWRES - Individual Weighted Residuals","text":"<pre><code>all_iwres = np.concatenate([ind.iwres for ind in result.individual_estimates])\n</code></pre>"},{"location":"python/estimation/diagnostics/#expected-values","title":"Expected Values","text":"Residual Expected Mean Expected SD CWRES 0 1 IWRES 0 1 NPDE 0 1"},{"location":"python/estimation/diagnostics/#shrinkage","title":"Shrinkage","text":""},{"location":"python/estimation/diagnostics/#eta-shrinkage","title":"Eta Shrinkage","text":"<pre><code># Access eta shrinkage\nprint(f\"Eta shrinkage: {result.eta_shrinkage}\")\n\n# Interpretation\nfor i, shrink in enumerate(result.eta_shrinkage):\n    pct = shrink * 100\n    status = \"Good\" if pct &lt; 20 else (\"Moderate\" if pct &lt; 30 else \"High\")\n    print(f\"  \u03b7{i+1}: {pct:.1f}% ({status})\")\n</code></pre> Shrinkage Interpretation &lt; 20% Good 20-30% Moderate &gt; 30% High - use caution"},{"location":"python/estimation/diagnostics/#epsilon-shrinkage","title":"Epsilon Shrinkage","text":"<pre><code>print(f\"Epsilon shrinkage: {result.epsilon_shrinkage*100:.1f}%\")\n</code></pre>"},{"location":"python/estimation/diagnostics/#goodness-of-fit-plots","title":"Goodness-of-Fit Plots","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Collect data\nobs = np.concatenate([ind.observed for ind in result.individual_estimates])\npred = np.concatenate([ind.pred for ind in result.individual_estimates])\nipred = np.concatenate([ind.ipred for ind in result.individual_estimates])\ncwres = np.concatenate([ind.cwres for ind in result.individual_estimates])\ntime = np.concatenate([ind.times for ind in result.individual_estimates])\n\n# Create 4-panel GOF plot\nfig, axes = plt.subplots(2, 2, figsize=(10, 10))\n\n# DV vs PRED\naxes[0, 0].scatter(pred, obs, alpha=0.5)\naxes[0, 0].plot([pred.min(), pred.max()], [pred.min(), pred.max()], 'r--')\naxes[0, 0].set_xlabel('Population Prediction')\naxes[0, 0].set_ylabel('Observed')\naxes[0, 0].set_title('DV vs PRED')\n\n# DV vs IPRED\naxes[0, 1].scatter(ipred, obs, alpha=0.5)\naxes[0, 1].plot([ipred.min(), ipred.max()], [ipred.min(), ipred.max()], 'r--')\naxes[0, 1].set_xlabel('Individual Prediction')\naxes[0, 1].set_ylabel('Observed')\naxes[0, 1].set_title('DV vs IPRED')\n\n# CWRES vs Time\naxes[1, 0].scatter(time, cwres, alpha=0.5)\naxes[1, 0].axhline(y=0, color='r', linestyle='--')\naxes[1, 0].axhline(y=-2, color='gray', linestyle=':')\naxes[1, 0].axhline(y=2, color='gray', linestyle=':')\naxes[1, 0].set_xlabel('Time')\naxes[1, 0].set_ylabel('CWRES')\naxes[1, 0].set_title('CWRES vs Time')\n\n# CWRES vs PRED\naxes[1, 1].scatter(pred, cwres, alpha=0.5)\naxes[1, 1].axhline(y=0, color='r', linestyle='--')\naxes[1, 1].axhline(y=-2, color='gray', linestyle=':')\naxes[1, 1].axhline(y=2, color='gray', linestyle=':')\naxes[1, 1].set_xlabel('Population Prediction')\naxes[1, 1].set_ylabel('CWRES')\naxes[1, 1].set_title('CWRES vs PRED')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"python/estimation/diagnostics/#qq-plot","title":"QQ Plot","text":"<pre><code>import scipy.stats as stats\n\nfig, ax = plt.subplots(figsize=(6, 6))\nstats.probplot(cwres, dist=\"norm\", plot=ax)\nax.set_title(\"QQ Plot of CWRES\")\nplt.show()\n</code></pre>"},{"location":"python/estimation/diagnostics/#individual-fits","title":"Individual Fits","text":"<pre><code># Plot first 9 subjects\nfig, axes = plt.subplots(3, 3, figsize=(12, 12))\naxes = axes.flatten()\n\nfor i, ind in enumerate(result.individual_estimates[:9]):\n    ax = axes[i]\n    ax.scatter(ind.times, ind.observed, label='Observed', s=50)\n    ax.plot(ind.times, ind.ipred, 'b-', label='IPRED', linewidth=2)\n    ax.plot(ind.times, ind.pred, 'r--', label='PRED', alpha=0.7)\n    ax.set_title(f\"Subject {ind.subject_id}\")\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Concentration')\n    if i == 0:\n        ax.legend()\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"python/estimation/diagnostics/#covariance-diagnostics","title":"Covariance Diagnostics","text":"<pre><code># Condition number\nprint(f\"Condition number: {result.condition_number:.1f}\")\n\nif result.condition_number &gt; 1000:\n    print(\"WARNING: High condition number - potential identifiability issues\")\n\n# Eigenvalue ratio\nprint(f\"Eigenvalue ratio: {result.eigenvalue_ratio:.1f}\")\n\n# Correlation matrix\nif result.covariance_matrix is not None:\n    corr = result.correlation_matrix\n    print(\"\\nParameter correlation matrix:\")\n    print(corr)\n</code></pre>"},{"location":"python/estimation/diagnostics/#diagnostic-checklist","title":"Diagnostic Checklist","text":"<pre><code>def check_diagnostics(result):\n    issues = []\n\n    # Convergence\n    if not result.converged:\n        issues.append(\"Model did not converge\")\n\n    # Condition number\n    if result.condition_number &gt; 1000:\n        issues.append(f\"High condition number: {result.condition_number:.0f}\")\n\n    # RSE\n    for i, rse in enumerate(result.theta_rse):\n        if rse &gt; 50:\n            issues.append(f\"High RSE for \u03b8{i+1}: {rse:.1f}%\")\n\n    # Shrinkage\n    for i, shrink in enumerate(result.eta_shrinkage):\n        if shrink &gt; 0.3:\n            issues.append(f\"High \u03b7{i+1} shrinkage: {shrink*100:.1f}%\")\n\n    # CWRES\n    all_cwres = np.concatenate([ind.cwres for ind in result.individual_estimates])\n    cwres_mean = np.mean(all_cwres)\n    cwres_std = np.std(all_cwres)\n\n    if abs(cwres_mean) &gt; 0.2:\n        issues.append(f\"CWRES mean bias: {cwres_mean:.3f}\")\n    if abs(cwres_std - 1) &gt; 0.2:\n        issues.append(f\"CWRES SD deviation: {cwres_std:.3f}\")\n\n    return issues\n\n# Run checks\nissues = check_diagnostics(result)\nif issues:\n    print(\"Diagnostic issues found:\")\n    for issue in issues:\n        print(f\"  - {issue}\")\nelse:\n    print(\"All diagnostics passed!\")\n</code></pre>"},{"location":"python/estimation/diagnostics/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Estimation method</li> <li>Bootstrap - Uncertainty quantification</li> <li>Model Comparison - Comparing models</li> </ul>"},{"location":"python/estimation/foce/","title":"FOCE-I Method","text":"<p>First-Order Conditional Estimation with Interaction (FOCE-I) is the industry-standard method for nonlinear mixed-effects modeling.</p>"},{"location":"python/estimation/foce/#overview","title":"Overview","text":"<p>FOCE-I linearizes the model around individual eta estimates, providing accurate parameter estimates for most PK/PD models.</p> <pre><code>from openpkpd.estimation import estimate, EstimationConfig, FOCEIMethod\n\nconfig = EstimationConfig(\n    method=FOCEIMethod(),\n    theta_init=[10.0, 50.0],\n    omega_init=[[0.09, 0], [0, 0.04]],\n    sigma_init=0.1\n)\n\nresult = estimate(data, \"OneCompIVBolus\", config)\n</code></pre>"},{"location":"python/estimation/foce/#configuration","title":"Configuration","text":""},{"location":"python/estimation/foce/#foceimethod-parameters","title":"FOCEIMethod Parameters","text":"<pre><code>from openpkpd.estimation import FOCEIMethod\n\nmethod = FOCEIMethod(\n    centered=False,        # False=FOCE-I, True=FOCE (no interaction)\n    compute_cwres=True,    # Compute conditional weighted residuals\n    laplacian=True,        # Include Laplacian correction\n    eta_tol=1e-8,          # Inner optimization tolerance\n    max_eta_iter=100       # Max iterations for eta optimization\n)\n</code></pre>"},{"location":"python/estimation/foce/#full-configuration-example","title":"Full Configuration Example","text":"<pre><code>from openpkpd.estimation import (\n    EstimationConfig, FOCEIMethod, BLQConfig, BLQMethod,\n    OmegaStructure, ResidualErrorModel\n)\n\nconfig = EstimationConfig(\n    # Method specification\n    method=FOCEIMethod(\n        centered=False,\n        compute_cwres=True\n    ),\n\n    # Initial estimates\n    theta_init=[10.0, 50.0],           # CL, V\n    omega_init=[[0.09, 0], [0, 0.04]], # IIV variances\n\n    # Residual error\n    sigma_init=0.1,                    # Proportional error\n    residual_error_model=ResidualErrorModel.PROPORTIONAL,\n\n    # Omega structure\n    omega_structure=OmegaStructure.DIAGONAL,\n\n    # BLQ handling\n    blq_config=BLQConfig(\n        method=BLQMethod.M3,\n        lloq=0.1\n    ),\n\n    # Convergence settings\n    max_iter=1000,\n    tol=1e-6,\n\n    # Output options\n    compute_se=True,\n    compute_ci=True,\n    ci_level=0.95,\n    verbose=True,\n    seed=12345\n)\n</code></pre>"},{"location":"python/estimation/foce/#residual-error-models","title":"Residual Error Models","text":""},{"location":"python/estimation/foce/#additive-error","title":"Additive Error","text":"\\[Y = F + \\epsilon, \\quad \\epsilon \\sim N(0, \\sigma^2)\\] <pre><code>config = EstimationConfig(\n    sigma_init=0.5,\n    residual_error_model=ResidualErrorModel.ADDITIVE\n)\n</code></pre>"},{"location":"python/estimation/foce/#proportional-error","title":"Proportional Error","text":"\\[Y = F \\cdot (1 + \\epsilon), \\quad \\epsilon \\sim N(0, \\sigma^2)\\] <pre><code>config = EstimationConfig(\n    sigma_init=0.1,  # 10% CV\n    residual_error_model=ResidualErrorModel.PROPORTIONAL\n)\n</code></pre>"},{"location":"python/estimation/foce/#combined-error","title":"Combined Error","text":"\\[Y = F + F \\cdot \\epsilon_{prop} + \\epsilon_{add}\\] <pre><code>config = EstimationConfig(\n    sigma_init={\"additive\": 0.5, \"proportional\": 0.1},\n    residual_error_model=ResidualErrorModel.COMBINED\n)\n</code></pre>"},{"location":"python/estimation/foce/#exponential-error","title":"Exponential Error","text":"\\[\\log(Y) = \\log(F) + \\epsilon\\] <pre><code>config = EstimationConfig(\n    sigma_init=0.15,\n    residual_error_model=ResidualErrorModel.EXPONENTIAL\n)\n</code></pre>"},{"location":"python/estimation/foce/#omega-structures","title":"Omega Structures","text":""},{"location":"python/estimation/foce/#diagonal-omega","title":"Diagonal Omega","text":"<p>Independent random effects:</p> <pre><code>config = EstimationConfig(\n    omega_init=[\n        [0.09, 0],\n        [0, 0.04]\n    ],\n    omega_structure=OmegaStructure.DIAGONAL\n)\n</code></pre>"},{"location":"python/estimation/foce/#block-omega","title":"Block Omega","text":"<p>Correlated random effects:</p> <pre><code>config = EstimationConfig(\n    omega_init=[\n        [0.09, 0.02],\n        [0.02, 0.04]\n    ],\n    omega_structure=OmegaStructure.BLOCK\n)\n</code></pre>"},{"location":"python/estimation/foce/#full-omega","title":"Full Omega","text":"<p>All parameters correlated:</p> <pre><code>config = EstimationConfig(\n    omega_init=[\n        [0.09, 0.02, 0.01],\n        [0.02, 0.04, 0.005],\n        [0.01, 0.005, 0.16]\n    ],\n    omega_structure=OmegaStructure.FULL\n)\n</code></pre>"},{"location":"python/estimation/foce/#blq-handling","title":"BLQ Handling","text":"<pre><code>from openpkpd.estimation import BLQConfig, BLQMethod\n\n# M1: Discard BLQ\nblq_config = BLQConfig(method=BLQMethod.M1, lloq=0.1)\n\n# M2: Impute at LLOQ/2\nblq_config = BLQConfig(method=BLQMethod.M2, lloq=0.1, impute_value=\"half\")\n\n# M3: Censored likelihood (recommended)\nblq_config = BLQConfig(method=BLQMethod.M3, lloq=0.1)\n\nconfig = EstimationConfig(\n    blq_config=blq_config,\n    # ... other options\n)\n</code></pre>"},{"location":"python/estimation/foce/#inter-occasion-variability-iov","title":"Inter-Occasion Variability (IOV)","text":"<pre><code>from openpkpd.estimation import IOVSpec\n\niov_specs = [\n    IOVSpec(\n        eta_name=\"eta_CL\",\n        occasion_names=[\"OCC1\", \"OCC2\", \"OCC3\"],\n        omega_iov=0.04  # 20% IOV on CL\n    )\n]\n\nconfig = EstimationConfig(\n    iov_specs=iov_specs,\n    # ... other options\n)\n</code></pre>"},{"location":"python/estimation/foce/#covariate-effects-on-iiv","title":"Covariate Effects on IIV","text":"<pre><code>from openpkpd.estimation import CovariateOnIIV\n\ncovariate_effects = [\n    CovariateOnIIV(\n        eta_name=\"eta_CL\",\n        covariate_name=\"WT\",\n        effect_type=\"exponential\",\n        reference_value=70.0\n    ),\n    CovariateOnIIV(\n        eta_name=\"eta_V\",\n        covariate_name=\"AGE\",\n        effect_type=\"linear\",\n        reference_value=40.0\n    )\n]\n\nconfig = EstimationConfig(\n    covariate_effects=covariate_effects,\n    # ... other options\n)\n</code></pre>"},{"location":"python/estimation/foce/#accessing-results","title":"Accessing Results","text":"<pre><code>result = estimate(data, model, config)\n\n# Fixed effects\nprint(f\"Theta: {result.theta}\")\nprint(f\"SE: {result.theta_se}\")\nprint(f\"RSE%: {result.theta_rse}\")\nprint(f\"95% CI: [{result.theta_ci_lower}, {result.theta_ci_upper}]\")\n\n# Random effects\nprint(f\"Omega:\\n{result.omega}\")\nprint(f\"Omega correlation:\\n{result.omega_corr}\")\n\n# Residual error\nprint(f\"Sigma: {result.sigma}\")\n\n# Model fit\nprint(f\"OFV: {result.ofv}\")\nprint(f\"AIC: {result.aic}\")\nprint(f\"BIC: {result.bic}\")\n\n# Convergence\nprint(f\"Converged: {result.converged}\")\nprint(f\"Iterations: {result.n_iterations}\")\nprint(f\"Runtime: {result.runtime:.2f}s\")\n\n# Diagnostics\nprint(f\"Eta shrinkage: {result.eta_shrinkage}\")\nprint(f\"Epsilon shrinkage: {result.epsilon_shrinkage}\")\nprint(f\"Condition number: {result.condition_number}\")\n</code></pre>"},{"location":"python/estimation/foce/#individual-estimates","title":"Individual Estimates","text":"<pre><code>for ind in result.individual_estimates:\n    print(f\"\\nSubject {ind.subject_id}:\")\n    print(f\"  Eta: {ind.eta}\")\n    print(f\"  Individual CL: {result.theta[0] * np.exp(ind.eta[0]):.3f}\")\n    print(f\"  IPRED: {ind.ipred[:3]}...\")\n    print(f\"  CWRES: {ind.cwres[:3]}...\")\n</code></pre>"},{"location":"python/estimation/foce/#standard-errors","title":"Standard Errors","text":""},{"location":"python/estimation/foce/#asymptotic-ses","title":"Asymptotic SEs","text":"<pre><code>config = EstimationConfig(\n    compute_se=True,\n    se_method=\"hessian\"  # Default\n)\n</code></pre>"},{"location":"python/estimation/foce/#sandwich-robust-ses","title":"Sandwich (Robust) SEs","text":"<pre><code>config = EstimationConfig(\n    compute_se=True,\n    se_method=\"sandwich\"  # More robust to misspecification\n)\n</code></pre>"},{"location":"python/estimation/foce/#example-two-compartment-model","title":"Example: Two-Compartment Model","text":"<pre><code>from openpkpd.estimation import (\n    estimate, EstimationConfig, FOCEIMethod,\n    BLQConfig, BLQMethod, EstimationData\n)\nimport pandas as pd\n\n# Load data\ndf = pd.read_csv(\"two_comp_data.csv\")\n\ndata = EstimationData.from_dataframe(\n    df, id_col=\"ID\", time_col=\"TIME\",\n    dv_col=\"DV\", amt_col=\"AMT\"\n)\n\n# Configure estimation\nconfig = EstimationConfig(\n    method=FOCEIMethod(compute_cwres=True),\n    theta_init=[10.0, 30.0, 5.0, 100.0],  # CL, V1, Q, V2\n    omega_init=[\n        [0.09, 0, 0, 0],\n        [0, 0.04, 0, 0],\n        [0, 0, 0.16, 0],\n        [0, 0, 0, 0.04]\n    ],\n    sigma_init={\"additive\": 0.1, \"proportional\": 0.1},\n    blq_config=BLQConfig(method=BLQMethod.M3, lloq=0.01),\n    max_iter=2000,\n    compute_se=True,\n    verbose=True\n)\n\n# Run estimation\nresult = estimate(data, \"TwoCompIVBolus\", config)\n\n# Print summary\nparam_names = [\"CL (L/h)\", \"V1 (L)\", \"Q (L/h)\", \"V2 (L)\"]\nprint(\"=== Parameter Estimates ===\")\nprint(f\"{'Parameter':&lt;12} {'Estimate':&lt;10} {'SE':&lt;10} {'RSE%':&lt;8} {'95% CI'}\")\nprint(\"-\" * 60)\n\nfor i, name in enumerate(param_names):\n    est = result.theta[i]\n    se = result.theta_se[i]\n    rse = result.theta_rse[i]\n    ci = f\"[{result.theta_ci_lower[i]:.2f}, {result.theta_ci_upper[i]:.2f}]\"\n    print(f\"{name:&lt;12} {est:&lt;10.3f} {se:&lt;10.3f} {rse:&lt;8.1f} {ci}\")\n\nprint(f\"\\nOFV: {result.ofv:.2f}\")\nprint(f\"AIC: {result.aic:.2f}\")\n</code></pre>"},{"location":"python/estimation/foce/#mathematical-details","title":"Mathematical Details","text":""},{"location":"python/estimation/foce/#foce-i-objective-function","title":"FOCE-I Objective Function","text":"\\[OFV = \\sum_i \\left[ \\ln|C_i(\\hat{\\eta}_i)| + (y_i - f_i(\\hat{\\eta}_i))^T C_i^{-1}(\\hat{\\eta}_i) (y_i - f_i(\\hat{\\eta}_i)) + \\hat{\\eta}_i^T \\Omega^{-1} \\hat{\\eta}_i + \\ln|H_{\\eta,i}| \\right]\\]"},{"location":"python/estimation/foce/#foce-vs-foce-i","title":"FOCE vs FOCE-I","text":"Aspect FOCE FOCE-I Interaction No Yes C evaluation At \u03b7=0 At \u03b7=\u03b7\u0302 Accuracy Lower Higher"},{"location":"python/estimation/foce/#see-also","title":"See Also","text":"<ul> <li>SAEM Algorithm - Alternative for complex models</li> <li>Laplacian Method - For sparse data</li> <li>Diagnostics - Model validation</li> <li>Bootstrap - Uncertainty quantification</li> </ul>"},{"location":"python/estimation/laplacian/","title":"Laplacian Method","text":"<p>The Laplacian approximation provides fast, efficient parameter estimation particularly suited for sparse data.</p>"},{"location":"python/estimation/laplacian/#overview","title":"Overview","text":"<pre><code>from openpkpd.estimation import estimate, EstimationConfig, LaplacianMethod\n\nconfig = EstimationConfig(\n    method=LaplacianMethod(),\n    theta_init=[10.0, 50.0],\n    omega_init=[[0.09, 0], [0, 0.04]],\n    sigma_init=0.1\n)\n\nresult = estimate(data, \"OneCompIVBolus\", config)\n</code></pre>"},{"location":"python/estimation/laplacian/#when-to-use-laplacian","title":"When to Use Laplacian","text":"Situation Why Laplacian Helps Sparse sampling Few observations per subject (1-3) Large populations Fast computation scales well Initial estimates Quick screening before FOCE/SAEM Simple models One-compartment, few parameters"},{"location":"python/estimation/laplacian/#configuration","title":"Configuration","text":""},{"location":"python/estimation/laplacian/#laplacianmethod-parameters","title":"LaplacianMethod Parameters","text":"<pre><code>from openpkpd.estimation import LaplacianMethod\n\nmethod = LaplacianMethod(\n    max_inner_iter=50,     # Max iterations for eta mode\n    inner_tol=1e-6,        # Inner optimization tolerance\n    use_prior=True,        # Include prior on eta\n    hessian_method=\"exact\" # or \"finite_diff\"\n)\n</code></pre>"},{"location":"python/estimation/laplacian/#full-configuration","title":"Full Configuration","text":"<pre><code>from openpkpd.estimation import (\n    EstimationConfig, LaplacianMethod, BLQConfig, BLQMethod\n)\n\nconfig = EstimationConfig(\n    method=LaplacianMethod(\n        max_inner_iter=50,\n        inner_tol=1e-6\n    ),\n    theta_init=[10.0, 50.0],\n    omega_init=[[0.25, 0], [0, 0.16]],  # Wide initial IIV\n    sigma_init={\"additive\": 0.5, \"proportional\": 0.2},\n    blq_config=BLQConfig(method=BLQMethod.M3, lloq=0.1),\n    max_iter=500,\n    compute_se=True,\n    verbose=True\n)\n</code></pre>"},{"location":"python/estimation/laplacian/#sparse-data-example","title":"Sparse Data Example","text":"<pre><code>from openpkpd.estimation import (\n    estimate, EstimationConfig, LaplacianMethod, EstimationData\n)\n\n# Very sparse data: 1-2 observations per subject\ndata = EstimationData(\n    subject_ids=[\"1\", \"1\", \"2\", \"3\", \"3\"],\n    times=[1.0, 4.0, 2.0, 0.5, 8.0],\n    observations=[8.5, 3.2, 6.1, 9.2, 1.1],\n    doses=[\n        {\"time\": 0.0, \"amount\": 500.0, \"subject_id\": \"1\"},\n        {\"time\": 0.0, \"amount\": 500.0, \"subject_id\": \"2\"},\n        {\"time\": 0.0, \"amount\": 500.0, \"subject_id\": \"3\"}\n    ]\n)\n\nconfig = EstimationConfig(\n    method=LaplacianMethod(),\n    theta_init=[5.0, 30.0],\n    omega_init=[[0.25, 0], [0, 0.16]],\n    sigma_init=0.15,\n    compute_se=True\n)\n\nresult = estimate(data, \"OneCompIVBolus\", config)\n\nprint(f\"CL = {result.theta[0]:.3f} \u00b1 {result.theta_se[0]:.3f}\")\nprint(f\"V  = {result.theta[1]:.3f} \u00b1 {result.theta_se[1]:.3f}\")\nprint(f\"OFV = {result.ofv:.2f}\")\n</code></pre>"},{"location":"python/estimation/laplacian/#comparison-with-foce-i","title":"Comparison with FOCE-I","text":"Aspect Laplacian FOCE-I Interaction term No Yes Computational cost Lower Higher Accuracy (dense) Lower Higher Accuracy (sparse) Good Good"},{"location":"python/estimation/laplacian/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - More accurate for dense data</li> <li>SAEM Algorithm - More robust for complex models</li> <li>Diagnostics - Model validation</li> </ul>"},{"location":"python/estimation/saem/","title":"SAEM Algorithm","text":"<p>Stochastic Approximation Expectation Maximization (SAEM) is a robust estimation method using MCMC sampling for complex models.</p>"},{"location":"python/estimation/saem/#overview","title":"Overview","text":"<p>SAEM alternates between MCMC sampling of random effects and stochastic parameter updates, making it more robust for challenging datasets.</p> <pre><code>from openpkpd.estimation import estimate, EstimationConfig, SAEMMethod\n\nconfig = EstimationConfig(\n    method=SAEMMethod(\n        n_burn=200,\n        n_iter=300,\n        n_chains=3\n    ),\n    theta_init=[10.0, 50.0],\n    omega_init=[[0.09, 0], [0, 0.04]],\n    sigma_init=0.1\n)\n\nresult = estimate(data, \"OneCompIVBolus\", config)\n</code></pre>"},{"location":"python/estimation/saem/#when-to-use-saem","title":"When to Use SAEM","text":"Situation Why SAEM Helps Large IIV (&gt;50% CV) Better handles extreme random effects Complex nonlinear models More robust to model nonlinearity FOCE convergence issues SAEM often converges where FOCE fails Multimodal likelihood Multiple chains explore the space"},{"location":"python/estimation/saem/#configuration","title":"Configuration","text":""},{"location":"python/estimation/saem/#saemmethod-parameters","title":"SAEMMethod Parameters","text":"<pre><code>from openpkpd.estimation import SAEMMethod\n\nmethod = SAEMMethod(\n    # Iteration control\n    n_burn=200,              # Burn-in iterations\n    n_iter=300,              # Main iterations\n\n    # MCMC settings\n    n_chains=3,              # Chains per subject\n    n_mcmc_steps=50,         # MCMC steps per E-step\n\n    # Proposal adaptation\n    adapt_proposal=True,     # Adaptive Metropolis-Hastings\n    target_acceptance=0.3,   # Target acceptance rate\n    adaptation_interval=20,  # Adapt every N iterations\n\n    # Step size\n    step_size_schedule=\"standard\",  # \"standard\", \"fast\", or \"slow\"\n\n    # Diagnostics\n    track_diagnostics=True,  # Track MCMC convergence\n    use_all_chains=True,     # Average across all chains\n    parallel_chains=False    # Parallel chain execution\n)\n</code></pre>"},{"location":"python/estimation/saem/#full-configuration","title":"Full Configuration","text":"<pre><code>from openpkpd.estimation import (\n    EstimationConfig, SAEMMethod, BLQConfig, BLQMethod\n)\n\nconfig = EstimationConfig(\n    method=SAEMMethod(\n        n_burn=300,\n        n_iter=500,\n        n_chains=4,\n        n_mcmc_steps=100,\n        target_acceptance=0.25,\n        track_diagnostics=True\n    ),\n    theta_init=[15.0, 30.0, 5.0, 100.0, 1.5],\n    omega_init=[\n        [0.09, 0, 0, 0, 0],\n        [0, 0.04, 0, 0, 0],\n        [0, 0, 0.16, 0, 0],\n        [0, 0, 0, 0.04, 0],\n        [0, 0, 0, 0, 0.25]\n    ],\n    sigma_init=0.15,\n    blq_config=BLQConfig(method=BLQMethod.M3, lloq=0.05),\n    compute_se=True,\n    verbose=True,\n    seed=12345\n)\n</code></pre>"},{"location":"python/estimation/saem/#mcmc-diagnostics","title":"MCMC Diagnostics","text":""},{"location":"python/estimation/saem/#accessing-diagnostics","title":"Accessing Diagnostics","text":"<pre><code>result = estimate(data, model, config)\n\n# SAEM-specific diagnostics\ndiag = result.saem_diagnostics\n\nprint(f\"Mean acceptance rate: {diag.mean_acceptance_rate:.2%}\")\nprint(f\"Gelman-Rubin R-hat: {diag.gelman_rubin}\")\nprint(f\"Effective sample size: {diag.effective_sample_size}\")\nprint(f\"Converged: {diag.converged}\")\n</code></pre>"},{"location":"python/estimation/saem/#convergence-checks","title":"Convergence Checks","text":"<pre><code># Check R-hat (should be &lt; 1.1)\nmax_rhat = max(diag.gelman_rubin)\nif max_rhat &gt; 1.1:\n    print(f\"WARNING: R-hat = {max_rhat:.3f} &gt; 1.1\")\n\n# Check ESS (should be &gt; 100)\nmin_ess = min(diag.effective_sample_size)\nif min_ess &lt; 100:\n    print(f\"WARNING: ESS = {min_ess:.0f} &lt; 100\")\n</code></pre>"},{"location":"python/estimation/saem/#trace-plots","title":"Trace Plots","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Plot parameter traces\nfig, axes = plt.subplots(2, 1, figsize=(10, 6))\n\n# Theta trace\ntheta_trace = np.array(diag.theta_trace)\nfor i in range(theta_trace.shape[1]):\n    axes[0].plot(theta_trace[:, i], label=f'\u03b8{i+1}')\naxes[0].set_xlabel('Iteration')\naxes[0].set_ylabel('Theta')\naxes[0].legend()\naxes[0].axvline(config.method.n_burn, color='r', linestyle='--', label='End burn-in')\n\n# OFV trace\naxes[1].plot(diag.ofv_trace)\naxes[1].set_xlabel('Iteration')\naxes[1].set_ylabel('OFV')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"python/estimation/saem/#standard-errors-for-saem","title":"Standard Errors for SAEM","text":"<p>SAEM doesn't directly produce analytical SEs. Use bootstrap:</p> <pre><code>from openpkpd.estimation import run_bootstrap, BootstrapConfig\n\n# Run bootstrap after SAEM\nbootstrap_config = BootstrapConfig(\n    n_bootstrap=500,\n    parallel=True,\n    seed=12345\n)\n\nbootstrap_result = run_bootstrap(\n    data, model, config, result, bootstrap_config\n)\n\nprint(f\"Bootstrap SE: {bootstrap_result.theta_se}\")\nprint(f\"95% CI: [{bootstrap_result.theta_ci_lower}, {bootstrap_result.theta_ci_upper}]\")\n</code></pre>"},{"location":"python/estimation/saem/#parallel-execution","title":"Parallel Execution","text":""},{"location":"python/estimation/saem/#parallel-subjects","title":"Parallel Subjects","text":"<pre><code>config = EstimationConfig(\n    method=SAEMMethod(n_chains=3),\n    parallel=True,     # Parallel subject processing\n    n_threads=8,       # Number of threads\n    # ... other options\n)\n</code></pre>"},{"location":"python/estimation/saem/#parallel-chains","title":"Parallel Chains","text":"<pre><code>method = SAEMMethod(\n    n_chains=4,\n    parallel_chains=True  # Run chains in parallel\n)\n</code></pre>"},{"location":"python/estimation/saem/#example-complex-model-with-high-iiv","title":"Example: Complex Model with High IIV","text":"<pre><code>from openpkpd.estimation import (\n    estimate, EstimationConfig, SAEMMethod,\n    BLQConfig, BLQMethod\n)\n\n# Complex model scenario\nconfig = EstimationConfig(\n    method=SAEMMethod(\n        n_burn=400,          # More burn-in for complex models\n        n_iter=600,          # More iterations\n        n_chains=5,          # More chains for better mixing\n        n_mcmc_steps=100,    # More MCMC steps\n        target_acceptance=0.25,\n        track_diagnostics=True\n    ),\n    theta_init=[5.0, 50.0, 0.5],    # CL, V, ktr\n    omega_init=[\n        [0.36, 0, 0],    # 60% CV on CL\n        [0, 0.16, 0],    # 40% CV on V\n        [0, 0, 0.49]     # 70% CV on ktr\n    ],\n    sigma_init={\"additive\": 0.1, \"proportional\": 0.15},\n    blq_config=BLQConfig(method=BLQMethod.M3, lloq=0.01),\n    compute_se=True,\n    verbose=True,\n    seed=42\n)\n\nresult = estimate(data, \"TransitAbsorption\", config)\n\n# Check convergence\ndiag = result.saem_diagnostics\nprint(\"=== SAEM Convergence ===\")\nprint(f\"Converged: {result.converged}\")\nprint(f\"Mean acceptance: {diag.mean_acceptance_rate:.2%}\")\nprint(f\"Max R-hat: {max(diag.gelman_rubin):.3f}\")\nprint(f\"Min ESS: {min(diag.effective_sample_size):.0f}\")\n\n# Parameter estimates\nprint(\"\\n=== Parameter Estimates ===\")\nparam_names = [\"CL\", \"V\", \"ktr\"]\nfor i, name in enumerate(param_names):\n    cv = np.sqrt(result.omega[i, i]) * 100\n    print(f\"{name} = {result.theta[i]:.3f} (IIV: {cv:.1f}%)\")\n</code></pre>"},{"location":"python/estimation/saem/#comparison-with-foce-i","title":"Comparison with FOCE-I","text":"Aspect FOCE-I SAEM Eta estimation Mode (optimization) Posterior samples (MCMC) Local minima Susceptible More robust Computation Faster Slower Standard errors Analytical Bootstrap/Louis High IIV Can struggle Handles well"},{"location":"python/estimation/saem/#see-also","title":"See Also","text":"<ul> <li>FOCE-I Method - Faster alternative</li> <li>Laplacian Method - For sparse data</li> <li>Bootstrap - Uncertainty for SAEM</li> <li>Diagnostics - Model validation</li> </ul>"},{"location":"python/models/","title":"Models Reference","text":"<p>Python simulation functions for all PK and PD models supported by OpenPKPD.</p>"},{"location":"python/models/#model-categories","title":"Model Categories","text":"<ul> <li> <p> Pharmacokinetic Models</p> <p>Compartmental PK simulation functions</p> <p> PK Functions</p> </li> <li> <p> Pharmacodynamic Models</p> <p>Effect model simulation functions</p> <p> PD Functions</p> </li> </ul>"},{"location":"python/models/#pharmacokinetic-functions","title":"Pharmacokinetic Functions","text":"Function Model Parameters <code>simulate_pk_iv_bolus</code> One-comp IV cl, v <code>simulate_pk_oral_first_order</code> One-comp oral ka, cl, v <code>simulate_pk_twocomp_iv_bolus</code> Two-comp IV cl, v1, q, v2 <code>simulate_pk_twocomp_oral</code> Two-comp oral ka, cl, v1, q, v2 <code>simulate_pk_threecomp_iv_bolus</code> Three-comp IV cl, v1, q2, v2, q3, v3 <code>simulate_pk_transit_absorption</code> Transit n_transit, ktr, ka, cl, v <code>simulate_pk_michaelis_menten</code> MM elimination vmax, km, v"},{"location":"python/models/#pharmacodynamic-functions","title":"Pharmacodynamic Functions","text":"Function Model PD Parameters <code>simulate_pkpd_direct_emax</code> Direct Emax e0, emax, ec50 <code>simulate_pkpd_sigmoid_emax</code> Sigmoid Emax e0, emax, ec50, gamma <code>simulate_pkpd_biophase_equilibration</code> Effect compartment ke0, e0, emax, ec50 <code>simulate_pkpd_indirect_response</code> Indirect response kin, kout, ic50, imax"},{"location":"python/models/#common-parameters","title":"Common Parameters","text":"<p>All simulation functions share these parameters:</p> Parameter Type Required Description <code>doses</code> <code>list[dict]</code> Yes List of dose events <code>t0</code> <code>float</code> Yes Simulation start time <code>t1</code> <code>float</code> Yes Simulation end time <code>saveat</code> <code>list[float]</code> Yes Output time points"},{"location":"python/models/#dose-event-format","title":"Dose Event Format","text":"<pre><code>doses = [\n    {\"time\": 0.0, \"amount\": 100.0},              # Bolus\n    {\"time\": 12.0, \"amount\": 100.0},             # Bolus\n    {\"time\": 0.0, \"amount\": 100.0, \"duration\": 1.0}  # Infusion\n]\n</code></pre>"},{"location":"python/models/#quick-examples","title":"Quick Examples","text":""},{"location":"python/models/#one-compartment-iv-bolus","title":"One-Compartment IV Bolus","text":"<pre><code>import openpkpd\n\nopenpkpd.init_julia()\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[float(t) for t in range(25)]\n)\n\nprint(\"Concentrations:\", result[\"observations\"][\"conc\"][:5])\n</code></pre>"},{"location":"python/models/#two-compartment-with-distribution","title":"Two-Compartment with Distribution","text":"<pre><code>result = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0,\n    v1=20.0,\n    q=15.0,\n    v2=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[t * 0.5 for t in range(97)]\n)\n</code></pre>"},{"location":"python/models/#direct-emax-pd","title":"Direct Emax PD","text":"<pre><code>result = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    e0=0.0,\n    emax=100.0,\n    ec50=2.0,\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)]\n)\n\nprint(\"Effect:\", result[\"observations\"][\"effect\"][:5])\n</code></pre>"},{"location":"python/models/#return-structure","title":"Return Structure","text":"<p>All functions return a dictionary:</p> <pre><code>{\n    \"t\": [0.0, 1.0, ...],              # Time points\n    \"states\": {\n        \"A_central\": [100.0, 90.5, ...]  # State variables\n    },\n    \"observations\": {\n        \"conc\": [2.0, 1.81, ...],        # Concentrations\n        \"effect\": [...]                   # Effects (PKPD only)\n    },\n    \"metadata\": {\n        \"model\": \"OneCompIVBolus\",\n        \"version\": \"0.1.0\"\n    }\n}\n</code></pre>"},{"location":"python/models/#next-steps","title":"Next Steps","text":"<ul> <li>IV Bolus Details</li> <li>Population Simulation</li> <li>Visualization</li> </ul>"},{"location":"python/models/pd/direct-emax/","title":"Direct Emax Model","text":"<p>Simple hyperbolic concentration-effect relationship where effect is directly proportional to receptor occupancy.</p>"},{"location":"python/models/pd/direct-emax/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_direct_emax(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    e0: float,\n    emax: float,\n    ec50: float,\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/direct-emax/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events <code>e0</code> float Baseline effect <code>emax</code> float Maximum effect change <code>ec50</code> float Concentration at 50% Emax (mg/L) <code>pk_kind</code> str PK model type <code>ka</code> float Absorption rate (for oral models)"},{"location":"python/models/pd/direct-emax/#supported-pk-models","title":"Supported PK Models","text":"<ul> <li><code>\"OneCompIVBolus\"</code> - One-compartment IV</li> <li><code>\"OneCompOralFirstOrder\"</code> - One-compartment oral (requires <code>ka</code>)</li> </ul>"},{"location":"python/models/pd/direct-emax/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {...},\n    \"observations\": {\n        \"conc\": [...],       # Plasma concentration\n        \"effect\": [...]      # Pharmacodynamic effect\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pd/direct-emax/#model-equation","title":"Model Equation","text":"\\[E(C) = E_0 + \\frac{E_{max} \\cdot C}{EC_{50} + C}\\]"},{"location":"python/models/pd/direct-emax/#basic-examples","title":"Basic Examples","text":""},{"location":"python/models/pd/direct-emax/#iv-bolus-with-direct-effect","title":"IV Bolus with Direct Effect","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=80.0,      # Baseline (e.g., heart rate)\n    emax=-30.0,   # Maximum reduction\n    ec50=2.0,     # mg/L\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Effect tracks concentration directly\nconc = result['observations']['conc']\neffect = result['observations']['effect']\nt = result['t']\n\nprint(f\"Baseline effect (E0): {effect[0]:.1f}\")  # Effect at C=Cmax\nprint(f\"Effect at 24h: {effect[-1]:.1f}\")         # Near baseline\n</code></pre>"},{"location":"python/models/pd/direct-emax/#oral-administration","title":"Oral Administration","text":"<pre><code>result = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=0.0,       # Baseline\n    emax=100.0,   # Maximum stimulation\n    ec50=5.0,\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)],\n    pk_kind=\"OneCompOralFirstOrder\",\n    ka=1.5\n)\n\n# Find maximum effect and when it occurs\neffect = result['observations']['effect']\nt = result['t']\nmax_effect_idx = max(range(len(effect)), key=lambda i: effect[i])\n\nprint(f\"Maximum effect: {effect[max_effect_idx]:.1f}\")\nprint(f\"Time of max effect: {t[max_effect_idx]:.2f} h\")\n</code></pre>"},{"location":"python/models/pd/direct-emax/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code>import openpkpd\n\n# 500 mg every 8 hours\ndoses = [{\"time\": i * 8.0, \"amount\": 500.0} for i in range(6)]\n\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=doses,\n    e0=100.0,      # Baseline blood pressure\n    emax=-40.0,    # Maximum reduction\n    ec50=3.0,\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\neffect = result['observations']['effect']\n\n# Effect oscillates with concentration\nprint(f\"Max effect: {min(effect):.1f}\")   # Note: negative Emax means min is max effect\nprint(f\"Min effect: {max(effect):.1f}\")   # Trough effect\n</code></pre>"},{"location":"python/models/pd/direct-emax/#inhibitory-vs-stimulatory-effects","title":"Inhibitory vs Stimulatory Effects","text":""},{"location":"python/models/pd/direct-emax/#inhibitory-emax-0","title":"Inhibitory (Emax &lt; 0)","text":"<pre><code># Drug reduces blood pressure\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=140.0,      # Baseline BP\n    emax=-40.0,    # Maximum reduction\n    ec50=2.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Effect range: 140 \u2192 100 mmHg\n</code></pre>"},{"location":"python/models/pd/direct-emax/#stimulatory-emax-0","title":"Stimulatory (Emax &gt; 0)","text":"<pre><code># Drug increases enzyme activity\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=100.0,      # Baseline activity\n    emax=200.0,    # Maximum increase\n    ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Effect range: 100 \u2192 300 units\n</code></pre>"},{"location":"python/models/pd/direct-emax/#potency-vs-efficacy","title":"Potency vs Efficacy","text":"<pre><code>import openpkpd\n\n# Drug A: High potency, moderate efficacy\nresult_a = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    e0=0.0, emax=80.0, ec50=0.5,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Drug B: Low potency, high efficacy\nresult_b = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Compare effects\nprint(\"Drug A (high potency): EC50 = 0.5, Emax = 80\")\nprint(\"Drug B (low potency): EC50 = 5.0, Emax = 100\")\nprint(f\"Drug A max effect: {max(result_a['observations']['effect']):.1f}\")\nprint(f\"Drug B max effect: {max(result_b['observations']['effect']):.1f}\")\n</code></pre>"},{"location":"python/models/pd/direct-emax/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pkpd_profile\n\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=80.0, emax=-30.0, ec50=2.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nfig = plot_pkpd_profile(\n    result['t'],\n    result['observations']['conc'],\n    result['observations']['effect'],\n    title=\"Direct Emax PKPD\",\n    conc_label=\"Concentration (mg/L)\",\n    effect_label=\"Heart Rate (bpm)\"\n)\n</code></pre>"},{"location":"python/models/pd/direct-emax/#concentration-effect-relationship","title":"Concentration-Effect Relationship","text":"<pre><code>import openpkpd\nimport numpy as np\n\nresult = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\nconc = np.array(result['observations']['conc'])\neffect = np.array(result['observations']['effect'])\n\n# Verify Emax equation\n# At C = EC50, Effect should be E0 + Emax/2 = 50\nidx_ec50 = np.argmin(np.abs(conc - 5.0))\nprint(f\"Effect at C=EC50: {effect[idx_ec50]:.1f} (expected: 50.0)\")\n</code></pre>"},{"location":"python/models/pd/direct-emax/#equations-summary","title":"Equations Summary","text":"Quantity Formula Effect \\(E_0 + E_{max} \\cdot C / (EC_{50} + C)\\) Fraction of Emax \\(C / (EC_{50} + C)\\) C for target effect \\(EC_{50} \\cdot (E - E_0) / (E_{max} - (E - E_0))\\) Sensitivity \\(E_{max} / EC_{50}\\)"},{"location":"python/models/pd/direct-emax/#see-also","title":"See Also","text":"<ul> <li>Sigmoid Emax - Variable steepness</li> <li>Effect Compartment - With temporal delay</li> <li>Indirect Response - Mechanism-based</li> <li>PKPD Visualization</li> </ul>"},{"location":"python/models/pd/disease-progression/","title":"Disease Progression Model","text":"<p>PD model for tumor growth dynamics with drug-induced cell kill, supporting multiple growth models.</p>"},{"location":"python/models/pd/disease-progression/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_disease_progression(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    growth_model: str,\n    s0: float,\n    kgrow: float,\n    smax: float,\n    alpha: float,\n    kdrug: float,\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    q: float | None = None,\n    v2: float | None = None,\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/disease-progression/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events <code>growth_model</code> str Growth model type (see below) <code>s0</code> float Initial tumor size <code>kgrow</code> float Growth rate constant <code>smax</code> float Maximum size (carrying capacity) <code>alpha</code> float Linear growth rate (for linear model) <code>kdrug</code> float Drug-induced cell kill rate constant"},{"location":"python/models/pd/disease-progression/#growth-models","title":"Growth Models","text":"Model Equation <code>\"exponential\"</code> \\(dS/dt = k_{grow} \\cdot S - k_{drug} \\cdot C \\cdot S\\) <code>\"linear\"</code> \\(dS/dt = \\alpha - k_{drug} \\cdot C \\cdot S\\) <code>\"logistic\"</code> \\(dS/dt = k_{grow} \\cdot S \\cdot (1 - S/S_{max}) - k_{drug} \\cdot C \\cdot S\\) <code>\"gompertz\"</code> \\(dS/dt = k_{grow} \\cdot S \\cdot \\ln(S_{max}/S) - k_{drug} \\cdot C \\cdot S\\) <code>\"asymptotic\"</code> \\(dS/dt = k_{grow} \\cdot (S_{max} - S) - k_{drug} \\cdot C \\cdot S\\)"},{"location":"python/models/pd/disease-progression/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_central\": [...],   # Drug amount\n        \"S\": [...]            # Tumor size\n    },\n    \"observations\": {\n        \"conc\": [...],        # Drug concentration\n        \"tumor_size\": [...]   # Tumor size\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pd/disease-progression/#basic-example-exponential-growth","title":"Basic Example: Exponential Growth","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    growth_model=\"exponential\",\n    s0=100.0,         # Initial tumor size\n    kgrow=0.02,       # Growth rate (1/h) = doubling ~35h\n    smax=1000.0,      # Not used for exponential\n    alpha=0.0,        # Not used for exponential\n    kdrug=0.005,      # Drug kill rate\n    t0=0.0,\n    t1=336.0,         # 2 weeks\n    saveat=[i * 2.0 for i in range(169)]\n)\n\ntumor = result['observations']['tumor_size']\nt = result['t']\n\nprint(\"Exponential Growth Model:\")\nprint(f\"  Initial size: {s0:.0f}\")\nprint(f\"  Size at 7 days: {tumor[84]:.1f}\")\nprint(f\"  Size at 14 days: {tumor[-1]:.1f}\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#comparing-growth-models","title":"Comparing Growth Models","text":"<pre><code>import openpkpd\n\nmodels = [\"exponential\", \"logistic\", \"gompertz\", \"asymptotic\"]\ns0 = 100.0\n\nprint(\"Growth Model | Day 7 Size | Day 14 Size | Max Size\")\nprint(\"-\" * 55)\n\nfor model in models:\n    result = openpkpd.simulate_pkpd_disease_progression(\n        cl=5.0, v=50.0,\n        doses=[],  # No treatment\n        growth_model=model,\n        s0=s0, kgrow=0.02, smax=1000.0, alpha=1.0, kdrug=0.0,\n        t0=0.0, t1=672.0,  # 4 weeks\n        saveat=[i * 4.0 for i in range(169)]\n    )\n\n    tumor = result['observations']['tumor_size']\n    max_size = max(tumor)\n\n    print(f\"{model:12s} | {tumor[42]:.1f} | {tumor[84]:.1f} | {max_size:.1f}\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#treatment-effect","title":"Treatment Effect","text":"<pre><code>import openpkpd\n\n# Weekly dosing\ndoses = [{\"time\": i * 168, \"amount\": 200.0} for i in range(4)]\n\n# No treatment baseline\nresult_no_tx = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0, doses=[],\n    growth_model=\"gompertz\",\n    s0=100.0, kgrow=0.02, smax=1000.0, alpha=0.0, kdrug=0.0,\n    t0=0.0, t1=672.0,\n    saveat=[i * 4.0 for i in range(169)]\n)\n\n# With treatment\nresult_tx = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0, doses=doses,\n    growth_model=\"gompertz\",\n    s0=100.0, kgrow=0.02, smax=1000.0, alpha=0.0, kdrug=0.01,\n    t0=0.0, t1=672.0,\n    saveat=[i * 4.0 for i in range(169)]\n)\n\nno_tx = result_no_tx['observations']['tumor_size']\ntx = result_tx['observations']['tumor_size']\nt = result_no_tx['t']\n\nprint(\"Treatment Effect (Gompertz Model):\")\nprint(f\"  Day 0: {no_tx[0]:.1f}\")\nprint(f\"  Day 28 no treatment: {no_tx[-1]:.1f}\")\nprint(f\"  Day 28 with treatment: {tx[-1]:.1f}\")\nprint(f\"  Tumor growth inhibition: {(1 - tx[-1]/no_tx[-1]) * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#dose-response-relationship","title":"Dose-Response Relationship","text":"<pre><code>import openpkpd\n\ndoses_list = [50, 100, 200, 400, 800]\n\nprint(\"Dose (mg) | Final Size | TGI (%)\")\nprint(\"-\" * 40)\n\n# No treatment reference\nresult_ref = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0, doses=[],\n    growth_model=\"logistic\",\n    s0=100.0, kgrow=0.02, smax=1000.0, alpha=0.0, kdrug=0.0,\n    t0=0.0, t1=336.0,\n    saveat=[i * 4.0 for i in range(85)]\n)\nref_final = result_ref['observations']['tumor_size'][-1]\n\nfor dose in doses_list:\n    weekly_doses = [{\"time\": i * 168, \"amount\": float(dose)} for i in range(2)]\n\n    result = openpkpd.simulate_pkpd_disease_progression(\n        cl=5.0, v=50.0, doses=weekly_doses,\n        growth_model=\"logistic\",\n        s0=100.0, kgrow=0.02, smax=1000.0, alpha=0.0, kdrug=0.01,\n        t0=0.0, t1=336.0,\n        saveat=[i * 4.0 for i in range(85)]\n    )\n\n    final = result['observations']['tumor_size'][-1]\n    tgi = (1 - final / ref_final) * 100\n\n    print(f\"{dose:9d} | {final:10.1f} | {tgi:7.1f}\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#complete-response-detection","title":"Complete Response Detection","text":"<pre><code>import openpkpd\n\n# Intensive treatment\ndoses = [{\"time\": i * 24, \"amount\": 300.0} for i in range(14)]\n\nresult = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0, doses=doses,\n    growth_model=\"exponential\",\n    s0=100.0, kgrow=0.02, smax=1000.0, alpha=0.0, kdrug=0.02,\n    t0=0.0, t1=672.0,\n    saveat=[i * 2.0 for i in range(337)]\n)\n\ntumor = result['observations']['tumor_size']\nt = result['t']\n\n# Find if tumor shrinks below detection threshold\ndetection_threshold = 10.0\nmin_size = min(tumor)\nt_min = t[tumor.index(min_size)]\n\nprint(\"Tumor Response:\")\nprint(f\"  Initial: {tumor[0]:.1f}\")\nprint(f\"  Minimum: {min_size:.2f} at day {t_min/24:.1f}\")\n\nif min_size &lt; detection_threshold:\n    print(\"  Response: Complete Response (CR)\")\nelif min_size &lt; tumor[0] * 0.5:\n    print(\"  Response: Partial Response (PR)\")\nelif min_size &lt; tumor[0] * 1.25:\n    print(\"  Response: Stable Disease (SD)\")\nelse:\n    print(\"  Response: Progressive Disease (PD)\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#regrowth-after-treatment","title":"Regrowth After Treatment","text":"<pre><code>import openpkpd\n\n# Treatment for 2 weeks, then observe\ndoses = [{\"time\": i * 24, \"amount\": 200.0} for i in range(14)]\n\nresult = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0, doses=doses,\n    growth_model=\"gompertz\",\n    s0=100.0, kgrow=0.03, smax=1000.0, alpha=0.0, kdrug=0.015,\n    t0=0.0, t1=1008.0,  # 6 weeks total\n    saveat=[i * 4.0 for i in range(253)]\n)\n\ntumor = result['observations']['tumor_size']\nt = result['t']\n\nprint(\"Tumor Dynamics:\")\nprint(f\"  Day 0: {tumor[0]:.1f}\")\nprint(f\"  Day 14 (end of treatment): {tumor[84]:.1f}\")\nprint(f\"  Day 28: {tumor[168]:.1f}\")\nprint(f\"  Day 42: {tumor[-1]:.1f}\")\n\n# Time to regrow to initial size\nfor i, s in enumerate(tumor):\n    if i &gt; 84 and s &gt; tumor[0]:\n        print(f\"  Regrowth to initial size: day {t[i]/24:.0f}\")\n        break\n</code></pre>"},{"location":"python/models/pd/disease-progression/#combination-treatment","title":"Combination Treatment","text":"<pre><code>import openpkpd\n\n# Single agent\nresult_single = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": i * 168, \"amount\": 200.0} for i in range(4)],\n    growth_model=\"logistic\",\n    s0=100.0, kgrow=0.025, smax=800.0, alpha=0.0, kdrug=0.008,\n    t0=0.0, t1=672.0,\n    saveat=[i * 4.0 for i in range(169)]\n)\n\n# Combination (simulate as higher effective kdrug)\nresult_combo = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": i * 168, \"amount\": 200.0} for i in range(4)],\n    growth_model=\"logistic\",\n    s0=100.0, kgrow=0.025, smax=800.0, alpha=0.0, kdrug=0.015,\n    t0=0.0, t1=672.0,\n    saveat=[i * 4.0 for i in range(169)]\n)\n\nsingle = result_single['observations']['tumor_size']\ncombo = result_combo['observations']['tumor_size']\n\nprint(\"Single Agent vs Combination:\")\nprint(f\"  Single agent day 28: {single[-1]:.1f}\")\nprint(f\"  Combination day 28: {combo[-1]:.1f}\")\nprint(f\"  Additional benefit: {(single[-1] - combo[-1])/single[-1] * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#survival-surrogate","title":"Survival Surrogate","text":"<pre><code>import openpkpd\n\n# Tumor doubling time as survival surrogate\ndoses = [{\"time\": i * 168, \"amount\": 200.0} for i in range(4)]\n\nresult = openpkpd.simulate_pkpd_disease_progression(\n    cl=5.0, v=50.0, doses=doses,\n    growth_model=\"exponential\",\n    s0=100.0, kgrow=0.025, smax=1000.0, alpha=0.0, kdrug=0.01,\n    t0=0.0, t1=2016.0,  # 12 weeks\n    saveat=[i * 8.0 for i in range(253)]\n)\n\ntumor = result['observations']['tumor_size']\nt = result['t']\n\n# Time to reach lethal tumor burden\nlethal_burden = 1000.0\nfor i, s in enumerate(tumor):\n    if s &gt; lethal_burden:\n        print(f\"Time to lethal burden: {t[i]/24:.0f} days ({t[i]/168:.1f} weeks)\")\n        break\nelse:\n    print(f\"Tumor below lethal burden at end of simulation\")\n    print(f\"Final tumor size: {tumor[-1]:.1f}\")\n</code></pre>"},{"location":"python/models/pd/disease-progression/#equations-summary","title":"Equations Summary","text":"Model dS/dt (without drug) Steady State Exponential \\(k_{grow} \\cdot S\\) Infinite Linear \\(\\alpha\\) Infinite Logistic \\(k_{grow} \\cdot S \\cdot (1 - S/S_{max})\\) \\(S_{max}\\) Gompertz \\(k_{grow} \\cdot S \\cdot \\ln(S_{max}/S)\\) \\(S_{max}\\) Asymptotic \\(k_{grow} \\cdot (S_{max} - S)\\) \\(S_{max}\\) <p>Drug effect: \\(-k_{drug} \\cdot C \\cdot S\\) (concentration-dependent cell kill)</p>"},{"location":"python/models/pd/disease-progression/#see-also","title":"See Also","text":"<ul> <li>Transit Compartment PD - Delayed effects</li> <li>Indirect Response - Turnover models</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pd/effect-compartment/","title":"Effect Compartment (Biophase) Model","text":"<p>Hypothetical effect site compartment to model temporal delays between plasma concentration and pharmacodynamic effect.</p>"},{"location":"python/models/pd/effect-compartment/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_biophase_equilibration(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    ke0: float,\n    e0: float,\n    emax: float,\n    ec50: float,\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events <code>ke0</code> float Effect site equilibration rate (1/h) <code>e0</code> float Baseline effect <code>emax</code> float Maximum effect change <code>ec50</code> float Effect site concentration at 50% Emax <code>pk_kind</code> str PK model type <code>ka</code> float Absorption rate (for oral)"},{"location":"python/models/pd/effect-compartment/#key-derived-parameter","title":"Key Derived Parameter","text":"<p>Equilibration half-life: \\(t_{1/2,ke0} = \\ln(2) / ke0\\)</p>"},{"location":"python/models/pd/effect-compartment/#model-equations","title":"Model Equations","text":"<p>Effect site equilibration: $\\(\\frac{dC_e}{dt} = k_{e0} \\cdot (C_p - C_e)\\)$</p> <p>Effect from effect site concentration: $\\(E(C_e) = E_0 + \\frac{E_{max} \\cdot C_e}{EC_{50} + C_e}\\)$</p>"},{"location":"python/models/pd/effect-compartment/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pkpd_biophase_equilibration(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    ke0=0.5,       # Equilibration rate (1/h)\n    e0=0.0,\n    emax=100.0,\n    ec50=5.0,\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nconc = result['observations']['conc']\neffect = result['observations']['effect']\nt = result['t']\n\n# Effect lags behind concentration\nconc_max_idx = max(range(len(conc)), key=lambda i: conc[i])\neffect_max_idx = max(range(len(effect)), key=lambda i: effect[i])\n\nprint(f\"Cmax at t = {t[conc_max_idx]:.1f} h\")\nprint(f\"Emax at t = {t[effect_max_idx]:.1f} h\")\nprint(f\"Effect delay: {t[effect_max_idx] - t[conc_max_idx]:.1f} h\")\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#effect-of-ke0-on-response","title":"Effect of ke0 on Response","text":"<pre><code>import openpkpd\n\nke0_values = [0.2, 0.5, 1.0, 2.0, 5.0]\n\nprint(\"ke0 (1/h) | t1/2,ke0 (h) | Tmax effect (h)\")\nprint(\"-\" * 50)\n\nfor ke0 in ke0_values:\n    result = openpkpd.simulate_pkpd_biophase_equilibration(\n        cl=5.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        ke0=ke0, e0=0.0, emax=100.0, ec50=5.0,\n        t0=0.0, t1=24.0,\n        saveat=[i * 0.1 for i in range(241)]\n    )\n\n    effect = result['observations']['effect']\n    t = result['t']\n    tmax_effect = t[max(range(len(effect)), key=lambda i: effect[i])]\n    t_half_ke0 = 0.693 / ke0\n\n    print(f\"{ke0:9.1f} | {t_half_ke0:12.2f} | {tmax_effect:15.2f}\")\n</code></pre> <p>Expected Pattern: - Higher ke0 \u2192 Faster equilibration \u2192 Earlier Tmax,effect - Lower ke0 \u2192 Slower equilibration \u2192 More delayed Tmax,effect</p>"},{"location":"python/models/pd/effect-compartment/#counter-clockwise-hysteresis","title":"Counter-Clockwise Hysteresis","text":"<pre><code>import openpkpd\nimport numpy as np\n\nresult = openpkpd.simulate_pkpd_biophase_equilibration(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    ke0=0.3, e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\nconc = result['observations']['conc']\neffect = result['observations']['effect']\n\n# Plot Effect vs Concentration would show counter-clockwise loop\n# - Rising limb: Effect lags behind rising concentration\n# - Falling limb: Effect persists as concentration falls\nprint(\"Hysteresis visible when plotting Effect vs Concentration\")\nprint(\"Counter-clockwise loop indicates effect site delay\")\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#clinical-example-propofol-anesthesia","title":"Clinical Example: Propofol Anesthesia","text":"<pre><code>import openpkpd\n\n# Propofol effect compartment\nresult = openpkpd.simulate_pkpd_biophase_equilibration(\n    cl=100.0,      # Fast clearance (L/h)\n    v=20.0,        # Small central volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 200.0}],\n    ke0=2.0,       # Fast equilibration (~20 sec t1/2)\n    e0=0.0,        # Awake = 0\n    emax=100.0,    # Deep anesthesia = 100\n    ec50=3.0,      # mcg/mL\n    t0=0.0,\n    t1=0.5,        # 30 minutes\n    saveat=[i * 0.01 for i in range(51)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\n# Time to loss of consciousness (effect &gt; 50)\nloc_idx = next((i for i, e in enumerate(effect) if e &gt; 50), None)\nif loc_idx:\n    print(f\"Time to LOC: {t[loc_idx] * 60:.1f} seconds\")\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#oral-administration-with-effect-delay","title":"Oral Administration with Effect Delay","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pkpd_biophase_equilibration(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    ke0=0.5, e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)],\n    pk_kind=\"OneCompOralFirstOrder\",\n    ka=1.5\n)\n\nconc = result['observations']['conc']\neffect = result['observations']['effect']\nt = result['t']\n\n# Two sources of delay: absorption + effect compartment\ncmax_t = t[max(range(len(conc)), key=lambda i: conc[i])]\nemax_t = t[max(range(len(effect)), key=lambda i: effect[i])]\n\nprint(f\"Tmax (concentration): {cmax_t:.2f} h\")\nprint(f\"Tmax (effect): {emax_t:.2f} h\")\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#comparing-direct-vs-effect-compartment","title":"Comparing Direct vs Effect Compartment","text":"<pre><code>import openpkpd\n\n# Direct Emax (no delay)\nresult_direct = openpkpd.simulate_pkpd_direct_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Effect compartment (with delay)\nresult_biophase = openpkpd.simulate_pkpd_biophase_equilibration(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    ke0=0.3, e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Compare Tmax\nt = result_direct['t']\ntmax_direct = t[max(range(len(result_direct['observations']['effect'])),\n                    key=lambda i: result_direct['observations']['effect'][i])]\ntmax_biophase = t[max(range(len(result_biophase['observations']['effect'])),\n                      key=lambda i: result_biophase['observations']['effect'][i])]\n\nprint(f\"Direct Emax Tmax: {tmax_direct:.2f} h\")\nprint(f\"Effect Compartment Tmax: {tmax_biophase:.2f} h\")\nprint(f\"Delay: {tmax_biophase - tmax_direct:.2f} h\")\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#model-selection-guide","title":"Model Selection Guide","text":"<pre><code># Rule of thumb:\n# If t1/2,ke0 &lt; elimination t1/2 / 10, use Direct Emax\n# Otherwise, use Effect Compartment\n\ndef recommend_model(ke0, cl, v):\n    t_half_ke0 = 0.693 / ke0\n    kel = cl / v\n    t_half_kel = 0.693 / kel\n\n    print(f\"t1/2,ke0 = {t_half_ke0:.2f} h\")\n    print(f\"t1/2,kel = {t_half_kel:.2f} h\")\n\n    if t_half_ke0 &lt; t_half_kel / 10:\n        print(\"Recommend: Direct Emax (fast equilibration)\")\n    else:\n        print(\"Recommend: Effect Compartment (significant delay)\")\n\n# Examples\nrecommend_model(ke0=5.0, cl=5.0, v=50.0)   # Fast ke0\nprint()\nrecommend_model(ke0=0.2, cl=5.0, v=50.0)   # Slow ke0\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pkpd_profile\n\nresult = openpkpd.simulate_pkpd_biophase_equilibration(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    ke0=0.5, e0=0.0, emax=100.0, ec50=5.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nfig = plot_pkpd_profile(\n    result['t'],\n    result['observations']['conc'],\n    result['observations']['effect'],\n    title=\"Effect Compartment PKPD\",\n    effect_label=\"Effect (%)\"\n)\n</code></pre>"},{"location":"python/models/pd/effect-compartment/#equations-summary","title":"Equations Summary","text":"Quantity Formula dCe/dt \\(k_{e0} \\cdot (C_p - C_e)\\) Effect \\(E_0 + E_{max} \\cdot C_e / (EC_{50} + C_e)\\) t1/2,ke0 \\(\\ln(2) / k_{e0}\\) t90% equilibration \\(\\ln(10) / k_{e0}\\) Steady state \\(C_e = C_p\\)"},{"location":"python/models/pd/effect-compartment/#see-also","title":"See Also","text":"<ul> <li>Direct Emax - Without delay</li> <li>Sigmoid Emax - Variable steepness</li> <li>Indirect Response - Mechanism-based</li> </ul>"},{"location":"python/models/pd/indirect-response/","title":"Indirect Response Models (IRM)","text":"<p>Mechanism-based PD models where drug affects the production (Kin) or elimination (Kout) of a response variable.</p>"},{"location":"python/models/pd/indirect-response/#available-functions","title":"Available Functions","text":"Function Model Type Mechanism <code>simulate_pkpd_indirect_response</code> IRM-III Inhibition of Kout <code>simulate_pkpd_irm1</code> IRM-I Inhibition of Kin <code>simulate_pkpd_irm2</code> IRM-II Stimulation of Kin <code>simulate_pkpd_irm4</code> IRM-IV Stimulation of Kout"},{"location":"python/models/pd/indirect-response/#the-four-irm-types","title":"The Four IRM Types","text":"Model Target Direction Effect on R IRM-I Kin (production) Inhibition Decreases R IRM-II Kin (production) Stimulation Increases R IRM-III Kout (elimination) Inhibition Increases R IRM-IV Kout (elimination) Stimulation Decreases R"},{"location":"python/models/pd/indirect-response/#irm-i-inhibition-of-production","title":"IRM-I: Inhibition of Production","text":""},{"location":"python/models/pd/indirect-response/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_irm1(\n    cl: float, v: float, doses: list[dict],\n    kin: float, kout: float, r0: float,\n    imax: float, ic50: float,\n    t0: float, t1: float, saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    q: float | None = None,\n    v2: float | None = None,\n    ...\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/indirect-response/#equation","title":"Equation","text":"\\[\\frac{dR}{dt} = K_{in} \\cdot (1 - I(C)) - K_{out} \\cdot R\\] <p>Where: \\(I(C) = \\frac{I_{max} \\cdot C}{IC_{50} + C}\\)</p>"},{"location":"python/models/pd/indirect-response/#example-corticosteroid-effect-on-cortisol","title":"Example: Corticosteroid Effect on Cortisol","text":"<pre><code>import openpkpd\n\n# Cortisol dynamics: baseline 15 mcg/dL, t1/2 ~1.5 h\nkout = 0.693 / 1.5  # 0.46/h\nr0 = 15.0\nkin = kout * r0\n\nresult = openpkpd.simulate_pkpd_irm1(\n    cl=2.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 10.0}],\n    kin=kin, kout=kout, r0=r0,\n    imax=0.9, ic50=0.01,  # Very potent\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\nresponse = result['observations']['response']\nprint(f\"Baseline cortisol: {r0} mcg/dL\")\nprint(f\"Minimum cortisol: {min(response):.1f} mcg/dL\")\n</code></pre>"},{"location":"python/models/pd/indirect-response/#irm-ii-stimulation-of-production","title":"IRM-II: Stimulation of Production","text":""},{"location":"python/models/pd/indirect-response/#equation_1","title":"Equation","text":"\\[\\frac{dR}{dt} = K_{in} \\cdot (1 + S(C)) - K_{out} \\cdot R\\] <p>Where: \\(S(C) = \\frac{S_{max} \\cdot C}{SC_{50} + C}\\)</p>"},{"location":"python/models/pd/indirect-response/#example-epo-effect-on-red-blood-cells","title":"Example: EPO Effect on Red Blood Cells","text":"<pre><code>import openpkpd\n\n# RBC dynamics: long turnover\nkout = 0.693 / (30 * 24)  # 30-day half-life\nr0 = 5.0  # million/mcL\nkin = kout * r0\n\nresult = openpkpd.simulate_pkpd_irm2(\n    cl=0.5, v=10.0,\n    doses=[{\"time\": i * 168, \"amount\": 100.0} for i in range(4)],  # Weekly\n    kin=kin, kout=kout, r0=r0,\n    smax=3.0, sc50=0.1,\n    t0=0.0, t1=672.0,  # 4 weeks\n    saveat=[i * 12 for i in range(57)]\n)\n\nresponse = result['observations']['response']\nprint(f\"Baseline RBC: {r0} million/mcL\")\nprint(f\"Maximum RBC: {max(response):.2f} million/mcL\")\n</code></pre>"},{"location":"python/models/pd/indirect-response/#irm-iii-inhibition-of-elimination","title":"IRM-III: Inhibition of Elimination","text":""},{"location":"python/models/pd/indirect-response/#function-simpler-signature","title":"Function (simpler signature)","text":"<pre><code>openpkpd.simulate_pkpd_indirect_response(\n    cl: float, v: float, doses: list[dict],\n    kin: float, kout: float, r0: float,\n    imax: float, ic50: float,\n    t0: float, t1: float, saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    ...\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/indirect-response/#equation_2","title":"Equation","text":"\\[\\frac{dR}{dt} = K_{in} - K_{out} \\cdot (1 - I(C)) \\cdot R\\]"},{"location":"python/models/pd/indirect-response/#example-warfarin-effect","title":"Example: Warfarin Effect","text":"<pre><code>import openpkpd\n\n# Clotting factor dynamics\nkout = 0.693 / 36.0  # 36-hour half-life\nr0 = 100.0  # % of normal\nkin = kout * r0\n\nresult = openpkpd.simulate_pkpd_indirect_response(\n    cl=0.1, v=10.0,\n    doses=[{\"time\": 0.0, \"amount\": 5.0}],\n    kin=kin, kout=kout, r0=r0,\n    imax=0.95, ic50=1.5,\n    t0=0.0, t1=120.0,\n    saveat=[i * 1.0 for i in range(121)]\n)\n\nresponse = result['observations']['response']\nprint(f\"Baseline: {r0}%\")\nprint(f\"Maximum response: {max(response):.1f}%\")\nprint(f\"Time to max: {response.index(max(response))} h\")\n</code></pre>"},{"location":"python/models/pd/indirect-response/#irm-iv-stimulation-of-elimination","title":"IRM-IV: Stimulation of Elimination","text":""},{"location":"python/models/pd/indirect-response/#equation_3","title":"Equation","text":"\\[\\frac{dR}{dt} = K_{in} - K_{out} \\cdot (1 + S(C)) \\cdot R\\]"},{"location":"python/models/pd/indirect-response/#example-laxative-effect","title":"Example: Laxative Effect","text":"<pre><code>import openpkpd\n\nkout = 0.693 / 12.0  # 12-hour transit\nr0 = 100.0\nkin = kout * r0\n\nresult = openpkpd.simulate_pkpd_irm4(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 200.0}],\n    kin=kin, kout=kout, r0=r0,\n    smax=5.0, sc50=0.5,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nresponse = result['observations']['response']\nprint(f\"Minimum response: {min(response):.1f}\")\nprint(f\"Theoretical minimum: {r0 / (1 + 5.0):.1f}\")\n</code></pre>"},{"location":"python/models/pd/indirect-response/#comparing-irm-types","title":"Comparing IRM Types","text":"<pre><code>import openpkpd\n\n# Same baseline and turnover\nkout = 0.1  # 1/h\nr0 = 100.0\nkin = kout * r0\n\n# Same PK\ndoses = [{\"time\": 0.0, \"amount\": 100.0}]\n\n# IRM-I: Inhibit production \u2192 Decrease\nresult_irm1 = openpkpd.simulate_pkpd_irm1(\n    cl=2.0, v=20.0, doses=doses,\n    kin=kin, kout=kout, r0=r0,\n    imax=0.8, ic50=2.0,\n    t0=0.0, t1=48.0, saveat=[i for i in range(49)]\n)\n\n# IRM-II: Stimulate production \u2192 Increase\nresult_irm2 = openpkpd.simulate_pkpd_irm2(\n    cl=2.0, v=20.0, doses=doses,\n    kin=kin, kout=kout, r0=r0,\n    smax=3.0, sc50=2.0,\n    t0=0.0, t1=48.0, saveat=[i for i in range(49)]\n)\n\n# IRM-IV: Stimulate elimination \u2192 Decrease\nresult_irm4 = openpkpd.simulate_pkpd_irm4(\n    cl=2.0, v=20.0, doses=doses,\n    kin=kin, kout=kout, r0=r0,\n    smax=4.0, sc50=2.0,\n    t0=0.0, t1=48.0, saveat=[i for i in range(49)]\n)\n\nprint(\"Model    | Min/Max Response\")\nprint(\"-\" * 30)\nprint(f\"IRM-I    | {min(result_irm1['observations']['response']):.1f} (decrease)\")\nprint(f\"IRM-II   | {max(result_irm2['observations']['response']):.1f} (increase)\")\nprint(f\"IRM-IV   | {min(result_irm4['observations']['response']):.1f} (decrease)\")\n</code></pre>"},{"location":"python/models/pd/indirect-response/#steady-state-predictions","title":"Steady State Predictions","text":"<pre><code># At high drug concentration (complete effect):\n\n# IRM-I: R_min = R0 \u00d7 (1 - Imax)\nr0, imax = 100.0, 0.8\nprint(f\"IRM-I steady state: {r0 * (1 - imax):.1f}\")\n\n# IRM-II: R_max = R0 \u00d7 (1 + Smax)\nr0, smax = 100.0, 3.0\nprint(f\"IRM-II steady state: {r0 * (1 + smax):.1f}\")\n\n# IRM-III: R_max = R0 / (1 - Imax)  [limited by Imax &lt; 1]\nr0, imax = 100.0, 0.8\nprint(f\"IRM-III steady state: {r0 / (1 - imax):.1f}\")\n\n# IRM-IV: R_min = R0 / (1 + Smax)\nr0, smax = 100.0, 4.0\nprint(f\"IRM-IV steady state: {r0 / (1 + smax):.1f}\")\n</code></pre>"},{"location":"python/models/pd/indirect-response/#model-selection-guide","title":"Model Selection Guide","text":"Observation Suggested Model Drug decreases biomarker IRM-I or IRM-IV Drug increases biomarker IRM-II or IRM-III Effect persists after drug washout Any IRM Known to inhibit synthesis IRM-I Known to stimulate synthesis IRM-II Known to inhibit degradation IRM-III Known to stimulate elimination IRM-IV"},{"location":"python/models/pd/indirect-response/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pkpd_profile\n\nresult = openpkpd.simulate_pkpd_irm1(\n    cl=2.0, v=20.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    kin=10.0, kout=0.1, r0=100.0,\n    imax=0.8, ic50=2.0,\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\nfig = plot_pkpd_profile(\n    result['t'],\n    result['observations']['conc'],\n    result['observations']['response'],\n    title=\"IRM-I: Inhibition of Production\",\n    effect_label=\"Response\"\n)\n</code></pre>"},{"location":"python/models/pd/indirect-response/#equations-summary","title":"Equations Summary","text":"Model dR/dt Steady State IRM-I \\(K_{in}(1-I(C)) - K_{out}R\\) \\(R_0(1-I_{max})\\) IRM-II \\(K_{in}(1+S(C)) - K_{out}R\\) \\(R_0(1+S_{max})\\) IRM-III \\(K_{in} - K_{out}(1-I(C))R\\) \\(R_0/(1-I_{max})\\) IRM-IV \\(K_{in} - K_{out}(1+S(C))R\\) \\(R_0/(1+S_{max})\\) <p>Common: \\(R_0 = K_{in}/K_{out}\\), Recovery \\(t_{1/2} = \\ln(2)/K_{out}\\)</p>"},{"location":"python/models/pd/indirect-response/#see-also","title":"See Also","text":"<ul> <li>Direct Emax - Simpler model</li> <li>Sigmoid Emax - Variable steepness</li> <li>Effect Compartment - Temporal delay</li> </ul>"},{"location":"python/models/pd/sigmoid-emax/","title":"Sigmoid Emax (Hill) Model","text":"<p>Extended Emax model with Hill coefficient (gamma) controlling the steepness of the concentration-response curve.</p>"},{"location":"python/models/pd/sigmoid-emax/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_sigmoid_emax(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    e0: float,\n    emax: float,\n    ec50: float,\n    gamma: float,\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events <code>e0</code> float Baseline effect <code>emax</code> float Maximum effect change <code>ec50</code> float Concentration at 50% Emax <code>gamma</code> float Hill coefficient (steepness) <code>pk_kind</code> str PK model type <code>ka</code> float Absorption rate (for oral)"},{"location":"python/models/pd/sigmoid-emax/#hill-equation","title":"Hill Equation","text":"\\[E(C) = E_0 + \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\]"},{"location":"python/models/pd/sigmoid-emax/#effect-of-gamma","title":"Effect of Gamma","text":"Gamma Curve Shape &lt; 1 Shallow, gradual = 1 Standard Emax (hyperbolic) &gt; 1 Steep, sigmoidal &gt;&gt; 3 Near-threshold"},{"location":"python/models/pd/sigmoid-emax/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pkpd_sigmoid_emax(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=0.0,\n    emax=100.0,\n    ec50=2.0,\n    gamma=3.0,    # Steep response\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\nprint(f\"Max effect: {max(effect):.1f}\")\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#comparing-gamma-values","title":"Comparing Gamma Values","text":"<pre><code>import openpkpd\n\ngamma_values = [0.5, 1.0, 2.0, 3.0, 5.0]\n\nprint(\"Gamma | Max Effect | Time &gt; 50% effect\")\nprint(\"-\" * 45)\n\nfor gamma in gamma_values:\n    result = openpkpd.simulate_pkpd_sigmoid_emax(\n        cl=5.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        e0=0.0, emax=100.0, ec50=2.0, gamma=gamma,\n        t0=0.0, t1=24.0,\n        saveat=[i * 0.1 for i in range(241)]\n    )\n\n    effect = result['observations']['effect']\n    t = result['t']\n\n    max_effect = max(effect)\n\n    # Time above 50% of Emax\n    above_50 = [i for i, e in enumerate(effect) if e &gt; 50]\n    if above_50:\n        duration = (t[above_50[-1]] - t[above_50[0]])\n    else:\n        duration = 0\n\n    print(f\"{gamma:5.1f} | {max_effect:10.1f} | {duration:6.1f} h\")\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#steepness-at-ec50","title":"Steepness at EC50","text":"<p>Higher gamma = narrower therapeutic window:</p> <pre><code>import openpkpd\n\n# Calculate concentration at EC10 and EC90 for different gamma\nec50 = 2.0\n\nprint(\"Gamma | EC10 (mg/L) | EC90 (mg/L) | EC90/EC10\")\nprint(\"-\" * 50)\n\nfor gamma in [1.0, 2.0, 3.0, 5.0]:\n    ec10 = ec50 * (0.1 / 0.9) ** (1/gamma)\n    ec90 = ec50 * (0.9 / 0.1) ** (1/gamma)\n\n    print(f\"{gamma:5.1f} | {ec10:11.3f} | {ec90:11.2f} | {ec90/ec10:9.1f}\")\n</code></pre> <p>Key insight: Higher gamma compresses the concentration range between EC10 and EC90.</p>"},{"location":"python/models/pd/sigmoid-emax/#clinical-example-neuromuscular-blockade","title":"Clinical Example: Neuromuscular Blockade","text":"<pre><code>import openpkpd\n\n# Rocuronium: steep response (gamma = 3-4)\nresult = openpkpd.simulate_pkpd_sigmoid_emax(\n    cl=3.0, v=15.0,\n    doses=[{\"time\": 0.0, \"amount\": 50.0}],\n    e0=100.0,      # 100% baseline twitch\n    emax=-100.0,   # Complete block possible\n    ec50=1.0,      # mcg/mL\n    gamma=3.5,     # Steep response\n    t0=0.0, t1=2.0,  # 2 hours\n    saveat=[i * 0.02 for i in range(101)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\n# Time to onset (twitch &lt; 10%)\nonset_idx = next((i for i, e in enumerate(effect) if e &lt; 10), None)\nif onset_idx:\n    print(f\"Onset time (to &lt;10% twitch): {t[onset_idx]*60:.1f} seconds\")\n\n# Duration of action (until twitch recovers to 25%)\nrecovery_idx = next((i for i, e in enumerate(effect[onset_idx:]) if e &gt; 25), None)\nif recovery_idx:\n    duration = t[onset_idx + recovery_idx] - t[onset_idx]\n    print(f\"Duration of action: {duration*60:.1f} minutes\")\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#therapeutic-index","title":"Therapeutic Index","text":"<pre><code>import openpkpd\n\n# Drug with narrow therapeutic index (high gamma)\nec50_efficacy = 2.0\nec50_toxicity = 8.0  # 4\u00d7 separation\ngamma = 3.0\n\n# Find therapeutic window (&gt;80% efficacy with &lt;20% toxicity)\ndef effect_at_conc(c, e0, emax, ec50, gamma):\n    return e0 + emax * c**gamma / (ec50**gamma + c**gamma)\n\nprint(\"Concentration | Efficacy | Toxicity | Therapeutic?\")\nprint(\"-\" * 55)\n\nfor c in [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]:\n    eff = effect_at_conc(c, 0, 100, ec50_efficacy, gamma)\n    tox = effect_at_conc(c, 0, 100, ec50_toxicity, gamma)\n\n    therapeutic = \"Yes\" if eff &gt; 80 and tox &lt; 20 else \"No\"\n    print(f\"{c:13.1f} | {eff:8.1f}% | {tox:8.1f}% | {therapeutic}\")\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#multiple-dosing-with-steep-response","title":"Multiple Dosing with Steep Response","text":"<pre><code>import openpkpd\n\n# With steep gamma, small concentration changes cause large effect changes\ndoses = [{\"time\": i * 8.0, \"amount\": 200.0} for i in range(6)]\n\nresult = openpkpd.simulate_pkpd_sigmoid_emax(\n    cl=5.0, v=50.0,\n    doses=doses,\n    e0=0.0, emax=100.0, ec50=2.0, gamma=4.0,\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\neffect = result['observations']['effect']\n\n# With high gamma, effect has \"all-or-none\" appearance\nprint(f\"Peak effect: {max(effect):.1f}\")\nprint(f\"Trough effect: {min(effect):.1f}\")\nprint(f\"Fluctuation: {max(effect) - min(effect):.1f}\")\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pkpd_profile\n\nresult = openpkpd.simulate_pkpd_sigmoid_emax(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    e0=0.0, emax=100.0, ec50=2.0, gamma=3.0,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nfig = plot_pkpd_profile(\n    result['t'],\n    result['observations']['conc'],\n    result['observations']['effect'],\n    title=\"Sigmoid Emax PKPD (gamma=3)\",\n    effect_label=\"Effect (%)\"\n)\n</code></pre>"},{"location":"python/models/pd/sigmoid-emax/#equations-summary","title":"Equations Summary","text":"Quantity Formula Effect \\(E_0 + \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\) C at fraction f \\(EC_{50} \\cdot (f/(1-f))^{1/\\gamma}\\) Slope at EC50 \\(\\gamma \\cdot E_{max} / (4 \\cdot EC_{50})\\) EC90/EC10 ratio \\(81^{1/\\gamma}\\)"},{"location":"python/models/pd/sigmoid-emax/#see-also","title":"See Also","text":"<ul> <li>Direct Emax - gamma = 1 case</li> <li>Effect Compartment - With delay</li> <li>Indirect Response - Mechanism-based</li> </ul>"},{"location":"python/models/pd/tolerance/","title":"Tolerance Models","text":"<p>PD models for tolerance development through counter-regulation or receptor regulation mechanisms.</p>"},{"location":"python/models/pd/tolerance/#counter-regulation-tolerance","title":"Counter-Regulation Tolerance","text":""},{"location":"python/models/pd/tolerance/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_tolerance_counter_regulation(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    e0: float,\n    emax: float,\n    ec50: float,\n    gamma: float,\n    kin_mod: float,\n    kout_mod: float,\n    alpha_feedback: float,\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    q: float | None = None,\n    v2: float | None = None,\n    ...\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/tolerance/#parameters","title":"Parameters","text":"Parameter Type Description <code>e0</code> float Baseline effect <code>emax</code> float Maximum drug effect <code>ec50</code> float EC50 for drug effect <code>gamma</code> float Hill coefficient <code>kin_mod</code> float Moderator production rate constant <code>kout_mod</code> float Moderator elimination rate constant <code>alpha_feedback</code> float Feedback strength coefficient"},{"location":"python/models/pd/tolerance/#model-equations","title":"Model Equations","text":"<p>Drug effect: $\\(E_{drug} = \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\)$</p> <p>Moderator dynamics (builds up with drug effect): $\\(\\frac{dM}{dt} = k_{in,mod} \\cdot E_{drug} - k_{out,mod} \\cdot M\\)$</p> <p>Net effect with tolerance: $\\(E_{net} = E_0 + E_{drug} - \\alpha \\cdot M\\)$</p>"},{"location":"python/models/pd/tolerance/#basic-counter-regulation-example","title":"Basic Counter-Regulation Example","text":"<pre><code>import openpkpd\n\n# Chronic dosing with tolerance development\ndoses = [{\"time\": i * 8.0, \"amount\": 50.0} for i in range(21)]  # TID for 7 days\n\nresult = openpkpd.simulate_pkpd_tolerance_counter_regulation(\n    cl=5.0,\n    v=50.0,\n    doses=doses,\n    e0=0.0,\n    emax=100.0,\n    ec50=5.0,\n    gamma=1.0,\n    kin_mod=0.1,       # Moderator production\n    kout_mod=0.05,     # Moderator elimination (t1/2 ~14h)\n    alpha_feedback=1.0, # Full feedback\n    t0=0.0,\n    t1=168.0,          # 1 week\n    saveat=[i * 0.5 for i in range(337)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\n# Compare first dose vs last dose effect\nfirst_dose_peak = max(effect[:16])  # First 8 hours\nlast_dose_peak = max(effect[-16:])  # Last 8 hours\n\nprint(\"Counter-Regulation Tolerance:\")\nprint(f\"  First dose peak effect: {first_dose_peak:.1f}\")\nprint(f\"  Last dose peak effect: {last_dose_peak:.1f}\")\nprint(f\"  Tolerance: {(1 - last_dose_peak/first_dose_peak) * 100:.1f}% reduction\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#clinical-example-opioid-tolerance","title":"Clinical Example: Opioid Tolerance","text":"<pre><code>import openpkpd\n\n# Morphine-like tolerance\n# Daily dosing for 2 weeks\n\ndoses = [{\"time\": i * 6.0, \"amount\": 10.0} for i in range(56)]  # Q6H for 2 weeks\n\nresult = openpkpd.simulate_pkpd_tolerance_counter_regulation(\n    cl=60.0, v=200.0,    # Morphine-like PK\n    doses=doses,\n    e0=0.0,              # Baseline pain score\n    emax=100.0,          # Max analgesia\n    ec50=0.05,           # EC50 (mg/L)\n    gamma=2.0,\n    kin_mod=0.2,\n    kout_mod=0.01,       # Slow moderator turnover (~3 day t1/2)\n    alpha_feedback=0.8,\n    t0=0.0, t1=336.0,\n    saveat=[i * 1.0 for i in range(337)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\n# Daily peak effect\nprint(\"Daily Peak Analgesia:\")\nfor day in [1, 3, 7, 14]:\n    start = (day - 1) * 24\n    end = day * 24\n    peak = max(effect[start:end])\n    print(f\"  Day {day:2d}: {peak:.1f}\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#effect-of-feedback-strength","title":"Effect of Feedback Strength","text":"<pre><code>import openpkpd\n\nalpha_values = [0.0, 0.25, 0.5, 1.0, 1.5]\n\ndoses = [{\"time\": i * 12.0, \"amount\": 50.0} for i in range(14)]\n\nprint(\"Alpha | Day 1 Peak | Day 7 Peak | Tolerance %\")\nprint(\"-\" * 50)\n\nfor alpha in alpha_values:\n    result = openpkpd.simulate_pkpd_tolerance_counter_regulation(\n        cl=5.0, v=50.0, doses=doses,\n        e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n        kin_mod=0.1, kout_mod=0.05, alpha_feedback=alpha,\n        t0=0.0, t1=168.0,\n        saveat=[i * 0.5 for i in range(337)]\n    )\n\n    effect = result['observations']['effect']\n    day1_peak = max(effect[:24])\n    day7_peak = max(effect[-24:])\n    tolerance = (1 - day7_peak/day1_peak) * 100 if day1_peak &gt; 0 else 0\n\n    print(f\"{alpha:5.2f} | {day1_peak:10.1f} | {day7_peak:10.1f} | {tolerance:10.1f}\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#receptor-regulation-model","title":"Receptor Regulation Model","text":""},{"location":"python/models/pd/tolerance/#function-signature_1","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_receptor_regulation(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    e0: float,\n    emax: float,\n    ec50: float,\n    gamma: float,\n    r_baseline: float,\n    kreg: float,\n    rmax: float,\n    kchange: float,\n    direction: str,  # \"down\" or \"up\"\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    ...\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/tolerance/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>r_baseline</code> float Baseline receptor density (normalized, typically 1.0) <code>kreg</code> float Receptor return-to-baseline rate constant <code>rmax</code> float Maximum receptor density (for up-regulation) <code>kchange</code> float Rate of receptor change <code>direction</code> str \"down\" or \"up\" regulation"},{"location":"python/models/pd/tolerance/#model-equations_1","title":"Model Equations","text":"<p>Receptor dynamics: $\\(\\frac{dR}{dt} = k_{reg} \\cdot (R_{baseline} - R) + regulation\\_effect\\)$</p> <p>Down-regulation: $\\(regulation\\_effect = -k_{change} \\cdot E_{drug} \\cdot R\\)$</p> <p>Up-regulation: $\\(regulation\\_effect = +k_{change} \\cdot E_{drug} \\cdot (R_{max} - R)\\)$</p> <p>Net effect: $\\(E_{net} = E_0 + R \\cdot E_{drug}\\)$</p>"},{"location":"python/models/pd/tolerance/#receptor-down-regulation-example","title":"Receptor Down-Regulation Example","text":"<pre><code>import openpkpd\n\n# Beta-receptor down-regulation with chronic agonist\ndoses = [{\"time\": i * 8.0, \"amount\": 50.0} for i in range(21)]\n\nresult = openpkpd.simulate_pkpd_receptor_regulation(\n    cl=5.0, v=50.0, doses=doses,\n    e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n    r_baseline=1.0,    # Normalized baseline\n    kreg=0.05,         # Receptor recovery rate\n    rmax=2.0,          # Not used for down-regulation\n    kchange=0.02,      # Down-regulation rate\n    direction=\"down\",\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\neffect = result['observations']['effect']\nreceptor = result['states']['R']\nt = result['t']\n\nprint(\"Beta-Receptor Down-Regulation:\")\nprint(f\"  Initial receptor: {receptor[0]:.2f}\")\nprint(f\"  Day 7 receptor: {receptor[-1]:.2f}\")\nprint(f\"  First dose peak: {max(effect[:16]):.1f}\")\nprint(f\"  Day 7 dose peak: {max(effect[-16:]):.1f}\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#receptor-up-regulation-example","title":"Receptor Up-Regulation Example","text":"<pre><code>import openpkpd\n\n# Receptor up-regulation (e.g., chronic antagonist exposure)\ndoses = [{\"time\": i * 12.0, \"amount\": 30.0} for i in range(14)]\n\nresult = openpkpd.simulate_pkpd_receptor_regulation(\n    cl=5.0, v=50.0, doses=doses,\n    e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n    r_baseline=1.0,\n    kreg=0.03,\n    rmax=3.0,          # Max 3x receptor density\n    kchange=0.01,\n    direction=\"up\",\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\neffect = result['observations']['effect']\nreceptor = result['states']['R']\nt = result['t']\n\nprint(\"Receptor Up-Regulation:\")\nprint(f\"  Initial receptor: {receptor[0]:.2f}\")\nprint(f\"  Day 7 receptor: {receptor[-1]:.2f}\")\nprint(f\"  Receptor increase: {(receptor[-1]/receptor[0] - 1) * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#recovery-after-drug-discontinuation","title":"Recovery After Drug Discontinuation","text":"<pre><code>import openpkpd\n\n# 1 week dosing, then 2 weeks recovery\ndoses = [{\"time\": i * 8.0, \"amount\": 50.0} for i in range(21)]  # 7 days only\n\nresult = openpkpd.simulate_pkpd_tolerance_counter_regulation(\n    cl=5.0, v=50.0, doses=doses,\n    e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n    kin_mod=0.1, kout_mod=0.02, alpha_feedback=1.0,\n    t0=0.0, t1=504.0,  # 3 weeks total\n    saveat=[i * 1.0 for i in range(505)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\nprint(\"Tolerance Recovery:\")\nprint(f\"  Day 7 (end of dosing): Moderator at maximum\")\nprint(f\"  Day 14: Partial recovery\")\nprint(f\"  Day 21: Near baseline\")\n\n# Simulate re-exposure after 2-week break\n# (Would need new simulation with rechallenge dose)\n</code></pre>"},{"location":"python/models/pd/tolerance/#comparing-tolerance-mechanisms","title":"Comparing Tolerance Mechanisms","text":"<pre><code>import openpkpd\n\ndoses = [{\"time\": i * 8.0, \"amount\": 50.0} for i in range(21)]\n\n# Counter-regulation\nresult_counter = openpkpd.simulate_pkpd_tolerance_counter_regulation(\n    cl=5.0, v=50.0, doses=doses,\n    e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n    kin_mod=0.1, kout_mod=0.05, alpha_feedback=1.0,\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\n# Receptor down-regulation\nresult_receptor = openpkpd.simulate_pkpd_receptor_regulation(\n    cl=5.0, v=50.0, doses=doses,\n    e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n    r_baseline=1.0, kreg=0.05, rmax=2.0, kchange=0.02,\n    direction=\"down\",\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\ncounter_effect = result_counter['observations']['effect']\nreceptor_effect = result_receptor['observations']['effect']\n\nprint(\"Tolerance Mechanism Comparison:\")\nprint(\"                  | Counter-Reg | Receptor\")\nprint(\"-\" * 50)\nprint(f\"Day 1 peak effect | {max(counter_effect[:48]):11.1f} | {max(receptor_effect[:48]):.1f}\")\nprint(f\"Day 7 peak effect | {max(counter_effect[-48:]):11.1f} | {max(receptor_effect[-48:]):.1f}\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#dose-escalation-to-overcome-tolerance","title":"Dose Escalation to Overcome Tolerance","text":"<pre><code>import openpkpd\n\n# Escalating dose to maintain effect\nbase_dose = 50.0\nescalation = 1.2  # 20% increase each day\n\ndoses = []\nfor day in range(7):\n    daily_dose = base_dose * (escalation ** day)\n    for dose_num in range(3):  # TID\n        doses.append({\"time\": day * 24 + dose_num * 8.0, \"amount\": daily_dose})\n\nresult = openpkpd.simulate_pkpd_tolerance_counter_regulation(\n    cl=5.0, v=50.0, doses=doses,\n    e0=0.0, emax=100.0, ec50=5.0, gamma=1.0,\n    kin_mod=0.1, kout_mod=0.05, alpha_feedback=1.0,\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\neffect = result['observations']['effect']\n\nprint(\"Dose Escalation to Maintain Effect:\")\nfor day in range(7):\n    start = day * 48\n    end = (day + 1) * 48\n    peak = max(effect[start:end])\n    dose = base_dose * (escalation ** day)\n    print(f\"  Day {day+1}: Dose = {dose:.0f} mg, Peak effect = {peak:.1f}\")\n</code></pre>"},{"location":"python/models/pd/tolerance/#equations-summary","title":"Equations Summary","text":""},{"location":"python/models/pd/tolerance/#counter-regulation-model","title":"Counter-Regulation Model","text":"Quantity Formula Drug effect \\(E_{max} \\cdot C^\\gamma / (EC_{50}^\\gamma + C^\\gamma)\\) Moderator rate \\(k_{in,mod} \\cdot E_{drug} - k_{out,mod} \\cdot M\\) Net effect \\(E_0 + E_{drug} - \\alpha \\cdot M\\) Moderator t1/2 \\(\\ln(2) / k_{out,mod}\\)"},{"location":"python/models/pd/tolerance/#receptor-regulation-model_1","title":"Receptor Regulation Model","text":"Quantity Formula Down-regulation \\(k_{reg}(R_0 - R) - k_{change} \\cdot E_{drug} \\cdot R\\) Up-regulation \\(k_{reg}(R_0 - R) + k_{change} \\cdot E_{drug} \\cdot (R_{max} - R)\\) Net effect \\(E_0 + R \\cdot E_{drug}\\)"},{"location":"python/models/pd/tolerance/#see-also","title":"See Also","text":"<ul> <li>Direct Emax - Without tolerance</li> <li>Indirect Response - Turnover-based effects</li> <li>Effect Compartment - Temporal delay</li> </ul>"},{"location":"python/models/pd/transit-pd/","title":"Transit Compartment PD Model","text":"<p>PD model with a chain of transit compartments to model delayed drug effects and signal transduction cascades.</p>"},{"location":"python/models/pd/transit-pd/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pkpd_transit_compartment(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    n_transit: int,\n    ktr: float,\n    e0: float,\n    emax: float,\n    ec50: float,\n    gamma: float,\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    pk_kind: str = \"OneCompIVBolus\",\n    ka: float | None = None,\n    q: float | None = None,\n    v2: float | None = None,\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pd/transit-pd/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events <code>n_transit</code> int Number of transit compartments (1-20 typical) <code>ktr</code> float Transit rate constant (1/h) <code>e0</code> float Baseline effect/signal <code>emax</code> float Maximum effect above baseline <code>ec50</code> float Concentration at 50% of Emax <code>gamma</code> float Hill coefficient (steepness)"},{"location":"python/models/pd/transit-pd/#key-derived-parameter","title":"Key Derived Parameter","text":"<p>Mean Transit Time (MTT): $\\(MTT = \\frac{N + 1}{K_{tr}}\\)$</p>"},{"location":"python/models/pd/transit-pd/#model-equations","title":"Model Equations","text":"<p>Drug-induced signal: $\\(Signal(C) = E_0 + \\frac{E_{max} \\cdot C^\\gamma}{EC_{50}^\\gamma + C^\\gamma}\\)$</p> <p>Transit compartment chain: $\\(\\frac{dA_1}{dt} = K_{tr} \\cdot (Signal(C) - A_1)\\)$</p> \\[\\frac{dA_i}{dt} = K_{tr} \\cdot (A_{i-1} - A_i) \\quad \\text{for } i = 2..N\\] <p>Final effect: $\\(Effect = A_N\\)$</p>"},{"location":"python/models/pd/transit-pd/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_central\": [...],   # Drug amount\n        \"transit_1\": [...],   # Transit compartments\n        ...\n    },\n    \"observations\": {\n        \"conc\": [...],        # Drug concentration\n        \"effect\": [...]       # Final effect\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pd/transit-pd/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pkpd_transit_compartment(\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    n_transit=5,      # 5 transit compartments\n    ktr=0.5,          # Transit rate\n    e0=100.0,         # Baseline effect\n    emax=-50.0,       # Maximum decrease\n    ec50=5.0,\n    gamma=1.0,\n    t0=0.0,\n    t1=168.0,         # 1 week\n    saveat=[i * 1.0 for i in range(169)]\n)\n\neffect = result['observations']['effect']\nconc = result['observations']['conc']\nt = result['t']\n\n# MTT = (5+1) / 0.5 = 12 hours\nprint(f\"Mean Transit Time: {(5+1)/0.5:.1f} h\")\nprint(f\"Max effect: {min(effect):.1f}\")  # Minimum because emax is negative\nprint(f\"Time to max effect: {t[effect.index(min(effect))]} h\")\n</code></pre>"},{"location":"python/models/pd/transit-pd/#effect-of-number-of-transit-compartments","title":"Effect of Number of Transit Compartments","text":"<pre><code>import openpkpd\n\nn_transit_values = [1, 3, 5, 10, 20]\nktr = 0.5  # Fixed ktr\n\nprint(\"N transit | MTT (h) | T_nadir (h) | Nadir effect\")\nprint(\"-\" * 55)\n\nfor n in n_transit_values:\n    result = openpkpd.simulate_pkpd_transit_compartment(\n        cl=5.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        n_transit=n, ktr=ktr, e0=100.0, emax=-60.0, ec50=5.0, gamma=1.0,\n        t0=0.0, t1=168.0,\n        saveat=[i * 0.5 for i in range(337)]\n    )\n\n    effect = result['observations']['effect']\n    t = result['t']\n    mtt = (n + 1) / ktr\n\n    nadir = min(effect)\n    t_nadir = t[effect.index(nadir)]\n\n    print(f\"{n:9d} | {mtt:7.1f} | {t_nadir:11.1f} | {nadir:12.1f}\")\n</code></pre> <p>Expected: More compartments = sharper nadir, closer to MTT.</p>"},{"location":"python/models/pd/transit-pd/#clinical-example-myelosuppression","title":"Clinical Example: Myelosuppression","text":"<pre><code>import openpkpd\n\n# Chemotherapy-induced neutropenia\n# Typical: 5-7 transit compartments, MTT ~5 days for neutrophils\n\nmtt_days = 5.0\nn_transit = 5\nktr = (n_transit + 1) / (mtt_days * 24)  # Convert to 1/h\n\nresult = openpkpd.simulate_pkpd_transit_compartment(\n    cl=3.0, v=30.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],  # Single chemo dose\n    n_transit=n_transit,\n    ktr=ktr,\n    e0=5.0,           # Baseline ANC (10^9/L)\n    emax=-4.5,        # Max 90% reduction\n    ec50=1.0,\n    gamma=1.5,\n    t0=0.0, t1=504.0,  # 3 weeks\n    saveat=[i * 2.0 for i in range(253)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\n# Grade neutropenia thresholds\nprint(\"Neutropenia Profile:\")\nprint(f\"  Baseline ANC: 5.0 x10^9/L\")\nnadir = min(effect)\nt_nadir = t[effect.index(nadir)]\nprint(f\"  Nadir ANC: {nadir:.2f} x10^9/L at day {t_nadir/24:.1f}\")\n\n# Time to recovery\nfor i, e in enumerate(effect):\n    if i &gt; effect.index(nadir) and e &gt; 1.5:\n        print(f\"  Recovery to &gt;1.5 x10^9/L: day {t[i]/24:.1f}\")\n        break\n\n# Grade classification\nif nadir &lt; 0.5:\n    print(\"  Grade 4 (severe)\")\nelif nadir &lt; 1.0:\n    print(\"  Grade 3 (moderate)\")\nelif nadir &lt; 1.5:\n    print(\"  Grade 2 (mild)\")\n</code></pre>"},{"location":"python/models/pd/transit-pd/#multiple-chemotherapy-cycles","title":"Multiple Chemotherapy Cycles","text":"<pre><code>import openpkpd\n\n# Every 3 weeks (21 days)\ncycle_length = 21 * 24  # hours\nn_cycles = 4\n\ndoses = [{\"time\": i * cycle_length, \"amount\": 100.0} for i in range(n_cycles)]\n\nmtt_days = 5.0\nn_transit = 5\nktr = (n_transit + 1) / (mtt_days * 24)\n\nresult = openpkpd.simulate_pkpd_transit_compartment(\n    cl=3.0, v=30.0,\n    doses=doses,\n    n_transit=n_transit, ktr=ktr,\n    e0=5.0, emax=-4.0, ec50=1.0, gamma=1.5,\n    t0=0.0, t1=n_cycles * cycle_length + 168,\n    saveat=[i * 4.0 for i in range(500)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\nprint(\"Cycle-by-Cycle Nadir:\")\nfor cycle in range(n_cycles):\n    start_h = cycle * cycle_length\n    end_h = (cycle + 1) * cycle_length\n    start_idx = int(start_h / 4)\n    end_idx = int(end_h / 4)\n\n    cycle_effect = effect[start_idx:end_idx]\n    nadir = min(cycle_effect)\n    nadir_t = t[start_idx + cycle_effect.index(nadir)]\n\n    print(f\"  Cycle {cycle+1}: Nadir = {nadir:.2f} at day {nadir_t/24:.0f}\")\n</code></pre>"},{"location":"python/models/pd/transit-pd/#thrombocytopenia-model","title":"Thrombocytopenia Model","text":"<pre><code>import openpkpd\n\n# Platelet dynamics: longer MTT than neutrophils (~8-10 days)\nmtt_days = 8.0\nn_transit = 5\nktr = (n_transit + 1) / (mtt_days * 24)\n\nresult = openpkpd.simulate_pkpd_transit_compartment(\n    cl=3.0, v=30.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    n_transit=n_transit, ktr=ktr,\n    e0=250.0,         # Baseline platelets (10^9/L)\n    emax=-200.0,      # Max 80% reduction\n    ec50=1.0,\n    gamma=2.0,\n    t0=0.0, t1=672.0,  # 4 weeks\n    saveat=[i * 2.0 for i in range(337)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\nnadir = min(effect)\nt_nadir = t[effect.index(nadir)]\n\nprint(\"Thrombocytopenia Profile:\")\nprint(f\"  Baseline platelets: 250 x10^9/L\")\nprint(f\"  Nadir: {nadir:.0f} x10^9/L at day {t_nadir/24:.1f}\")\n\n# Recovery\nfor i, e in enumerate(effect):\n    if i &gt; effect.index(nadir) and e &gt; 100:\n        print(f\"  Recovery to &gt;100 x10^9/L: day {t[i]/24:.1f}\")\n        break\n</code></pre>"},{"location":"python/models/pd/transit-pd/#varying-mtt-with-fixed-n","title":"Varying MTT with Fixed N","text":"<pre><code>import openpkpd\n\nmtt_values = [12, 24, 48, 72, 120]  # hours\nn_transit = 5\n\nprint(\"MTT (h) | Ktr (1/h) | T_nadir (h)\")\nprint(\"-\" * 40)\n\nfor mtt in mtt_values:\n    ktr = (n_transit + 1) / mtt\n\n    result = openpkpd.simulate_pkpd_transit_compartment(\n        cl=5.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        n_transit=n_transit, ktr=ktr,\n        e0=100.0, emax=-50.0, ec50=5.0, gamma=1.0,\n        t0=0.0, t1=336.0,\n        saveat=[i * 1.0 for i in range(337)]\n    )\n\n    effect = result['observations']['effect']\n    t = result['t']\n    t_nadir = t[effect.index(min(effect))]\n\n    print(f\"{mtt:7d} | {ktr:9.4f} | {t_nadir:11.1f}\")\n</code></pre>"},{"location":"python/models/pd/transit-pd/#stimulation-model-g-csf-effect","title":"Stimulation Model (G-CSF Effect)","text":"<pre><code>import openpkpd\n\n# G-CSF stimulates neutrophil production\n# Positive Emax = stimulation\n\nresult = openpkpd.simulate_pkpd_transit_compartment(\n    cl=0.5, v=5.0,     # Typical G-CSF PK\n    doses=[{\"time\": i * 24, \"amount\": 5.0} for i in range(7)],  # Daily dosing\n    n_transit=5,\n    ktr=0.05,          # Slow effect\n    e0=3.0,            # Low baseline (neutropenic patient)\n    emax=10.0,         # Stimulation\n    ec50=0.1,\n    gamma=1.0,\n    t0=0.0, t1=336.0,\n    saveat=[i * 2.0 for i in range(169)]\n)\n\neffect = result['observations']['effect']\nt = result['t']\n\nprint(\"G-CSF Effect on ANC:\")\nprint(f\"  Baseline ANC: 3.0 x10^9/L\")\nprint(f\"  Peak ANC: {max(effect):.1f} x10^9/L\")\nprint(f\"  Day 7 ANC: {effect[84]:.1f} x10^9/L\")\n</code></pre>"},{"location":"python/models/pd/transit-pd/#equations-summary","title":"Equations Summary","text":"Quantity Formula MTT \\((N+1) / K_{tr}\\) Signal \\(E_0 + E_{max} \\cdot C^\\gamma / (EC_{50}^\\gamma + C^\\gamma)\\) Transit rate \\(K_{tr} \\cdot (A_{i-1} - A_i)\\) CV of delay \\(1 / \\sqrt{N+1}\\) Peak effect lag \\(\\approx MTT\\) from peak concentration"},{"location":"python/models/pd/transit-pd/#see-also","title":"See Also","text":"<ul> <li>Indirect Response - Simpler delay mechanism</li> <li>Effect Compartment - Single delay compartment</li> <li>Disease Progression - Tumor growth models</li> </ul>"},{"location":"python/models/pk/autoinduction/","title":"Autoinduction","text":"<p>PK model for drugs that induce their own metabolism, leading to time-varying clearance that increases with chronic dosing.</p>"},{"location":"python/models/pk/autoinduction/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_autoinduction(\n    cl0: float,\n    v: float,\n    emax: float,\n    ec50: float,\n    kenz: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/autoinduction/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl0</code> float Baseline clearance (L/h) <code>v</code> float Volume of distribution (L) <code>emax</code> float Maximum enzyme induction (fold increase) <code>ec50</code> float Concentration for 50% of max induction <code>kenz</code> float Enzyme turnover rate constant (1/h) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/autoinduction/#derived-parameters","title":"Derived Parameters","text":"<ul> <li>Enzyme half-life: \\(t_{1/2,enz} = \\ln(2) / k_{enz}\\)</li> <li>Maximum clearance: \\(CL_{max} = CL_0 \\cdot (1 + E_{max})\\)</li> </ul>"},{"location":"python/models/pk/autoinduction/#model-equations","title":"Model Equations","text":"<p>Two-state system (drug and enzyme):</p> <p>Enzyme induction signal: $\\(E_{induced} = 1 + \\frac{E_{max} \\cdot C}{EC_{50} + C}\\)$</p> <p>Enzyme dynamics (indirect response): $\\(\\frac{dE}{dt} = k_{enz} \\cdot (E_{induced} - E)\\)$</p> <p>Drug elimination with induced clearance: $\\(\\frac{dA_c}{dt} = -\\frac{CL_0 \\cdot E}{V} \\cdot A_c\\)$</p> \\[C = \\frac{A_c}{V}\\] <p>Initial condition: \\(E(0) = 1.0\\) (baseline enzyme)</p>"},{"location":"python/models/pk/autoinduction/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_central\": [...],   # Amount in central compartment\n        \"E_enzyme\": [...]     # Enzyme level (relative to baseline)\n    },\n    \"observations\": {\n        \"conc\": [...]         # Plasma concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/autoinduction/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\n# Single dose - minimal induction\nresult = openpkpd.simulate_pk_autoinduction(\n    cl0=10.0,     # Baseline clearance (L/h)\n    v=50.0,       # Volume (L)\n    emax=2.0,     # Max 3-fold increase in enzyme\n    ec50=5.0,     # EC50 for induction\n    kenz=0.1,     # Enzyme turnover (~7 hour half-life)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\nconc = result['observations']['conc']\nenzyme = result['states']['E_enzyme']\nt = result['t']\n\nprint(\"Single Dose Profile:\")\nprint(f\"  Initial enzyme: {enzyme[0]:.2f}\")\nprint(f\"  Peak enzyme: {max(enzyme):.2f}\")\nprint(f\"  Enzyme at 48h: {enzyme[-1]:.2f}\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#chronic-dosing-time-varying-clearance","title":"Chronic Dosing - Time-Varying Clearance","text":"<pre><code>import openpkpd\n\n# Daily dosing for 2 weeks\ndoses = [{\"time\": i * 24.0, \"amount\": 200.0} for i in range(14)]\n\nresult = openpkpd.simulate_pk_autoinduction(\n    cl0=10.0, v=50.0, emax=2.0, ec50=5.0, kenz=0.05,\n    doses=doses,\n    t0=0.0, t1=336.0,  # 14 days\n    saveat=[i * 1.0 for i in range(337)]\n)\n\nconc = result['observations']['conc']\nenzyme = result['states']['E_enzyme']\nt = result['t']\n\n# Compare day 1 vs day 14\nday1_cmax = max(conc[:24])\nday14_cmax = max(conc[312:336])\n\nprint(\"Autoinduction Effect:\")\nprint(f\"  Day 1 Cmax: {day1_cmax:.2f} mg/L\")\nprint(f\"  Day 14 Cmax: {day14_cmax:.2f} mg/L\")\nprint(f\"  Cmax decrease: {(1 - day14_cmax/day1_cmax) * 100:.1f}%\")\nprint(f\"  Enzyme level day 14: {enzyme[312]:.2f}x baseline\")\nprint(f\"  Effective clearance: {10.0 * enzyme[312]:.1f} L/h\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#clinical-example-carbamazepine","title":"Clinical Example: Carbamazepine","text":"<pre><code>import openpkpd\n\n# Carbamazepine-like autoinduction\n# Enzyme t1/2 ~3-5 days, full induction ~2-4 weeks\n\nkenz = 0.693 / (4 * 24)  # ~4 day enzyme half-life\n\n# BID dosing for 4 weeks\ndoses = [{\"time\": i * 12.0, \"amount\": 200.0} for i in range(56)]\n\nresult = openpkpd.simulate_pk_autoinduction(\n    cl0=2.0,      # Initial low clearance\n    v=80.0,       # Volume\n    emax=1.5,     # Can increase enzyme 2.5-fold\n    ec50=4.0,     # EC50 for induction\n    kenz=kenz,\n    doses=doses,\n    t0=0.0, t1=672.0,  # 4 weeks\n    saveat=[i * 2.0 for i in range(337)]\n)\n\nconc = result['observations']['conc']\nenzyme = result['states']['E_enzyme']\nt = result['t']\n\n# Weekly Cmax comparison\nprint(\"Carbamazepine-like Autoinduction:\")\nfor week in range(4):\n    start = week * 168\n    end = start + 168\n    start_idx = int(start / 2)\n    end_idx = int(end / 2)\n    week_cmax = max(conc[start_idx:end_idx])\n    week_enzyme = enzyme[end_idx - 1]\n    print(f\"  Week {week+1}: Cmax = {week_cmax:.2f} mg/L, Enzyme = {week_enzyme:.2f}x\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#dose-adjustment-for-autoinduction","title":"Dose Adjustment for Autoinduction","text":"<pre><code>import openpkpd\n\n# Strategy: Increase dose over time to maintain target concentration\ntarget_conc = 6.0  # Target trough\n\n# Week 1: Start low\n# Week 2: Increase\n# Week 3+: Maintenance\n\nkenz = 0.693 / (5 * 24)  # 5-day enzyme half-life\n\n# Stepped dosing regimen\ndoses = (\n    [{\"time\": i * 24.0, \"amount\": 200.0} for i in range(7)] +      # Week 1\n    [{\"time\": (7 + i) * 24.0, \"amount\": 300.0} for i in range(7)] +  # Week 2\n    [{\"time\": (14 + i) * 24.0, \"amount\": 400.0} for i in range(7)]   # Week 3\n)\n\nresult = openpkpd.simulate_pk_autoinduction(\n    cl0=5.0, v=50.0, emax=1.5, ec50=4.0, kenz=kenz,\n    doses=doses,\n    t0=0.0, t1=504.0,\n    saveat=[i * 2.0 for i in range(253)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Check trough levels at end of each week\nprint(\"Dose Titration Strategy:\")\nfor week, dose in enumerate([200, 300, 400]):\n    trough_time = (week + 1) * 168 - 2  # 2h before next dose\n    trough_idx = int(trough_time / 2)\n    trough = conc[trough_idx]\n    print(f\"  Week {week+1} ({dose} mg QD): Trough = {trough:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#time-to-steady-state","title":"Time to Steady State","text":"<pre><code>import openpkpd\n\n# With autoinduction, steady state takes longer\nkenz = 0.693 / (4 * 24)  # 4-day enzyme half-life\n\ndoses = [{\"time\": i * 24.0, \"amount\": 200.0} for i in range(42)]  # 6 weeks\n\nresult = openpkpd.simulate_pk_autoinduction(\n    cl0=5.0, v=50.0, emax=2.0, ec50=3.0, kenz=kenz,\n    doses=doses,\n    t0=0.0, t1=1008.0,\n    saveat=[i * 6.0 for i in range(169)]\n)\n\nenzyme = result['states']['E_enzyme']\nt = result['t']\n\n# Time to 90% of steady-state enzyme\ne_ss = enzyme[-1]\ne_90 = 1.0 + 0.9 * (e_ss - 1.0)\n\nfor i, e in enumerate(enzyme):\n    if e &gt;= e_90:\n        print(f\"Time to 90% enzyme steady state: {t[i]:.0f} h ({t[i]/24:.1f} days)\")\n        break\n\nprint(f\"Final enzyme level: {e_ss:.2f}x baseline\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#drug-washout-enzyme-recovery","title":"Drug Washout - Enzyme Recovery","text":"<pre><code>import openpkpd\n\nkenz = 0.693 / (5 * 24)\n\n# 2 weeks dosing, then stop\ndoses = [{\"time\": i * 24.0, \"amount\": 200.0} for i in range(14)]\n\nresult = openpkpd.simulate_pk_autoinduction(\n    cl0=5.0, v=50.0, emax=2.0, ec50=3.0, kenz=kenz,\n    doses=doses,\n    t0=0.0, t1=672.0,  # Continue simulation 2 more weeks\n    saveat=[i * 4.0 for i in range(169)]\n)\n\nenzyme = result['states']['E_enzyme']\nt = result['t']\n\nprint(\"Enzyme Recovery After Drug Discontinuation:\")\nprint(f\"  Enzyme at day 14 (stop): {enzyme[84]:.2f}x\")\nprint(f\"  Enzyme at day 21: {enzyme[126]:.2f}x\")\nprint(f\"  Enzyme at day 28: {enzyme[-1]:.2f}x\")\nprint(f\"  Recovery t1/2: ~{0.693/kenz/24:.1f} days\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#comparison-with-vs-without-autoinduction","title":"Comparison: With vs Without Autoinduction","text":"<pre><code>import openpkpd\n\n# Daily dosing for 2 weeks\ndoses = [{\"time\": i * 24.0, \"amount\": 200.0} for i in range(14)]\n\n# With autoinduction\nresult_auto = openpkpd.simulate_pk_autoinduction(\n    cl0=5.0, v=50.0, emax=1.5, ec50=3.0, kenz=0.693/(3*24),\n    doses=doses,\n    t0=0.0, t1=336.0,\n    saveat=[i * 1.0 for i in range(337)]\n)\n\n# Without autoinduction (standard IV)\nresult_linear = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=336.0,\n    saveat=[i * 1.0 for i in range(337)]\n)\n\nauto_conc = result_auto['observations']['conc']\nlinear_conc = result_linear['observations']['conc']\n\nprint(\"Day 14 Comparison:\")\nprint(f\"  Linear PK Cmax: {max(linear_conc[312:336]):.2f} mg/L\")\nprint(f\"  Autoinduction Cmax: {max(auto_conc[312:336]):.2f} mg/L\")\n\n# AUC comparison\nauc_linear = sum(linear_conc[312:336])\nauc_auto = sum(auto_conc[312:336])\nprint(f\"  Linear AUC (day 14): {auc_linear:.1f} mg*h/L\")\nprint(f\"  Autoinduction AUC (day 14): {auc_auto:.1f} mg*h/L\")\nprint(f\"  AUC reduction: {(1 - auc_auto/auc_linear) * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pk/autoinduction/#equations-summary","title":"Equations Summary","text":"Quantity Formula Induction signal \\(E_{induced} = 1 + E_{max} \\cdot C / (EC_{50} + C)\\) Enzyme rate \\(dE/dt = k_{enz} \\cdot (E_{induced} - E)\\) Effective clearance \\(CL_{eff} = CL_0 \\cdot E\\) Max clearance \\(CL_{max} = CL_0 \\cdot (1 + E_{max})\\) Enzyme t1/2 \\(\\ln(2) / k_{enz}\\)"},{"location":"python/models/pk/autoinduction/#see-also","title":"See Also","text":"<ul> <li>IV Bolus - Linear PK model</li> <li>Michaelis-Menten - Saturable elimination</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pk/enterohepatic/","title":"Enterohepatic Recirculation (EHR)","text":"<p>PK model for drugs that undergo biliary excretion and intestinal reabsorption, leading to secondary concentration peaks.</p>"},{"location":"python/models/pk/enterohepatic/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka: float,\n    cl: float,\n    v: float,\n    kbile: float,\n    kreab: float,\n    f_reab: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#parameters","title":"Parameters","text":"Parameter Type Description <code>ka</code> float Absorption rate constant (1/h) <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>kbile</code> float Biliary excretion rate constant (1/h) <code>kreab</code> float Reabsorption rate constant from bile (1/h) <code>f_reab</code> float Fraction reabsorbed (0-1) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/enterohepatic/#model-equations","title":"Model Equations","text":"<p>Three-compartment system (GI tract, central, bile):</p> \\[\\frac{dA_{gut}}{dt} = -K_a \\cdot A_{gut} + F_{reab} \\cdot K_{reab} \\cdot A_{bile}\\] \\[\\frac{dA_c}{dt} = K_a \\cdot A_{gut} - \\frac{CL}{V} \\cdot A_c - K_{bile} \\cdot A_c\\] \\[\\frac{dA_{bile}}{dt} = K_{bile} \\cdot A_c - K_{reab} \\cdot A_{bile}\\] \\[C = \\frac{A_c}{V}\\]"},{"location":"python/models/pk/enterohepatic/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_gut\": [...],       # Amount in GI tract\n        \"A_central\": [...],   # Amount in central compartment\n        \"A_bile\": [...]       # Amount in biliary compartment\n    },\n    \"observations\": {\n        \"conc\": [...]         # Plasma concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka=1.0,       # Absorption rate (1/h)\n    cl=10.0,      # Clearance (L/h)\n    v=50.0,       # Volume (L)\n    kbile=0.5,    # Biliary excretion rate (1/h)\n    kreab=0.3,    # Reabsorption rate (1/h)\n    f_reab=0.7,   # 70% reabsorbed\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Look for secondary peaks\nprint(\"Concentration profile with EHR:\")\nprint(f\"  Initial peak: {max(conc[:20]):.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#secondary-peak-detection","title":"Secondary Peak Detection","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka=1.5, cl=8.0, v=50.0,\n    kbile=0.4, kreab=0.2, f_reab=0.8,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Find local maxima (peaks)\npeaks = []\nfor i in range(2, len(conc)-2):\n    if (conc[i] &gt; conc[i-1] and conc[i] &gt; conc[i-2] and\n        conc[i] &gt; conc[i+1] and conc[i] &gt; conc[i+2]):\n        peaks.append((t[i], conc[i]))\n\nprint(\"Detected peaks:\")\nfor i, (time, c) in enumerate(peaks):\n    print(f\"  Peak {i+1}: t = {time:.1f} h, C = {c:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#effect-of-reabsorption-fraction","title":"Effect of Reabsorption Fraction","text":"<pre><code>import openpkpd\n\nf_reab_values = [0.0, 0.3, 0.6, 0.9]\n\nprint(\"F_reab | AUC (mg*h/L) | Secondary peaks?\")\nprint(\"-\" * 50)\n\nfor f_reab in f_reab_values:\n    result = openpkpd.simulate_pk_enterohepatic_recirculation(\n        ka=1.5, cl=10.0, v=50.0,\n        kbile=0.5, kreab=0.3, f_reab=f_reab,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        t0=0.0, t1=72.0,\n        saveat=[i * 0.1 for i in range(721)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n\n    # Calculate AUC\n    auc = sum(0.5 * (conc[i] + conc[i+1]) * 0.1\n              for i in range(len(conc)-1))\n\n    # Count peaks after initial\n    peaks = 0\n    for i in range(30, len(conc)-2):  # Skip first 3 hours\n        if conc[i] &gt; conc[i-1] and conc[i] &gt; conc[i+1]:\n            if conc[i] &gt; conc[i-1] * 1.05:  # 5% increase threshold\n                peaks += 1\n\n    print(f\"{f_reab:6.1f} | {auc:12.1f} | {'Yes' if peaks &gt; 0 else 'No'}\")\n</code></pre> <p>Expected: Higher F_reab leads to larger AUC and more pronounced secondary peaks.</p>"},{"location":"python/models/pk/enterohepatic/#clinical-example-digoxin","title":"Clinical Example: Digoxin","text":"<pre><code>import openpkpd\n\n# Digoxin-like EHR parameters\nresult = openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka=0.8,       # Absorption rate\n    cl=7.0,       # Clearance (L/h)\n    v=500.0,      # Large Vd (tissue binding)\n    kbile=0.15,   # Biliary excretion\n    kreab=0.1,    # Reabsorption rate\n    f_reab=0.6,   # 60% reabsorbed\n    doses=[{\"time\": 0.0, \"amount\": 0.5}],  # 0.5 mg dose\n    t0=0.0, t1=72.0,\n    saveat=[i * 0.5 for i in range(145)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Convert to ng/mL (typical clinical units)\nconc_ng = [c * 1000 for c in conc]\n\nprint(\"Digoxin-like Profile:\")\nprint(f\"  Cmax: {max(conc_ng):.2f} ng/mL\")\nprint(f\"  C at 24h: {conc_ng[48]:.2f} ng/mL\")\nprint(f\"  C at 48h: {conc_ng[96]:.2f} ng/mL\")\nprint(\"  Therapeutic range: 0.8-2.0 ng/mL\")\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#meal-triggered-gallbladder-emptying","title":"Meal-Triggered Gallbladder Emptying","text":"<pre><code>import openpkpd\n\n# Model gallbladder emptying at mealtimes\n# Note: This is a simplified approach - true meal effect would need\n# time-varying parameters\n\n# Morning dose, evening meal triggers bile release\nresult = openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka=1.2, cl=10.0, v=50.0,\n    kbile=0.3,    # Moderate biliary excretion\n    kreab=0.5,    # Fast reabsorption when released\n    f_reab=0.75,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\nconc = result['observations']['conc']\na_bile = result['states']['A_bile']\nt = result['t']\n\nprint(\"Biliary Compartment Dynamics:\")\nprint(f\"  Max bile accumulation: {max(a_bile):.1f} mg at t={t[a_bile.index(max(a_bile))]:.1f} h\")\nprint(f\"  This bile would be released with next meal\")\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#comparison-with-vs-without-ehr","title":"Comparison: With vs Without EHR","text":"<pre><code>import openpkpd\n\n# With EHR\nresult_ehr = openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka=1.5, cl=10.0, v=50.0,\n    kbile=0.4, kreab=0.3, f_reab=0.7,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\n# Without EHR (standard oral model)\nresult_no_ehr = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\nehr_conc = result_ehr['observations']['conc']\nno_ehr_conc = result_no_ehr['observations']['conc']\nt = result_ehr['t']\n\n# Calculate AUCs\nauc_ehr = sum(0.5 * (ehr_conc[i] + ehr_conc[i+1]) * 0.1\n              for i in range(len(ehr_conc)-1))\nauc_no_ehr = sum(0.5 * (no_ehr_conc[i] + no_ehr_conc[i+1]) * 0.1\n                 for i in range(len(no_ehr_conc)-1))\n\nprint(\"Effect of Enterohepatic Recirculation:\")\nprint(f\"  AUC without EHR: {auc_no_ehr:.1f} mg*h/L\")\nprint(f\"  AUC with EHR: {auc_ehr:.1f} mg*h/L\")\nprint(f\"  AUC increase: {(auc_ehr/auc_no_ehr - 1) * 100:.1f}%\")\n\n# Terminal half-life\n# Find time to reach 10% of Cmax\ncmax_ehr = max(ehr_conc)\ncmax_no_ehr = max(no_ehr_conc)\nprint(f\"  Cmax without EHR: {cmax_no_ehr:.2f} mg/L\")\nprint(f\"  Cmax with EHR: {cmax_ehr:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#multiple-dosing-with-ehr","title":"Multiple Dosing with EHR","text":"<pre><code>import openpkpd\n\n# Once daily dosing\ndoses = [{\"time\": i * 24.0, \"amount\": 200.0} for i in range(5)]\n\nresult = openpkpd.simulate_pk_enterohepatic_recirculation(\n    ka=1.0, cl=8.0, v=50.0,\n    kbile=0.3, kreab=0.2, f_reab=0.65,\n    doses=doses,\n    t0=0.0, t1=120.0,\n    saveat=[i * 0.5 for i in range(241)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Day 5 (steady state)\nday5_start = int(96 / 0.5)\nday5_conc = conc[day5_start:]\n\nprint(\"Multiple Dose Profile (Day 5):\")\nprint(f\"  Cmax,ss: {max(day5_conc):.2f} mg/L\")\nprint(f\"  Cmin,ss: {min(day5_conc):.2f} mg/L\")\nprint(f\"  Average: {sum(day5_conc)/len(day5_conc):.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/enterohepatic/#equations-summary","title":"Equations Summary","text":"Quantity Formula GI absorption \\(K_a \\cdot A_{gut}\\) Biliary excretion \\(K_{bile} \\cdot A_c\\) Reabsorption \\(F_{reab} \\cdot K_{reab} \\cdot A_{bile}\\) Net elimination \\(CL \\cdot C + (1-F_{reab}) \\cdot K_{reab} \\cdot A_{bile}\\) Effective half-life Prolonged due to recycling"},{"location":"python/models/pk/enterohepatic/#see-also","title":"See Also","text":"<ul> <li>Oral First-Order - Without EHR</li> <li>Transit Absorption - Delayed absorption</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pk/iv-bolus/","title":"One-Compartment IV Bolus","text":"<p>Single-compartment pharmacokinetic model with instantaneous IV bolus or zero-order infusion administration.</p>"},{"location":"python/models/pk/iv-bolus/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_iv_bolus(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance (volume/time, e.g., L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events (see below) <code>t0</code> float Simulation start time <code>t1</code> float Simulation end time <code>saveat</code> list[float] Time points for output <code>alg</code> str ODE solver algorithm (default: \"Tsit5\") <code>reltol</code> float Relative tolerance (default: 1e-10) <code>abstol</code> float Absolute tolerance (default: 1e-12) <code>maxiters</code> int Maximum solver iterations <code>alag</code> float Absorption lag time (optional) <code>bioavailability</code> float Fraction absorbed, 0-1 (optional)"},{"location":"python/models/pk/iv-bolus/#dose-event-format","title":"Dose Event Format","text":"<pre><code>doses = [\n    {\"time\": 0.0, \"amount\": 100.0},                    # IV bolus\n    {\"time\": 8.0, \"amount\": 100.0, \"duration\": 1.0},   # 1-hour infusion\n]\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, 2.0, ...],           # Time points\n    \"states\": {\n        \"A\": [100.0, 90.5, ...]          # Amount in compartment\n    },\n    \"observations\": {\n        \"conc\": [10.0, 9.05, ...]        # Concentration (A/V)\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#model-equations","title":"Model Equations","text":"\\[\\frac{dA}{dt} = -k \\cdot A\\] \\[C = \\frac{A}{V}\\] \\[k = \\frac{CL}{V}\\] <p>For infusion (duration &gt; 0): $\\(\\frac{dA}{dt} = R_0 - k \\cdot A\\)$</p> <p>where \\(R_0 = \\text{amount} / \\text{duration}\\)</p>"},{"location":"python/models/pk/iv-bolus/#basic-examples","title":"Basic Examples","text":""},{"location":"python/models/pk/iv-bolus/#single-iv-bolus","title":"Single IV Bolus","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=10.0,      # 10 L/h clearance\n    v=50.0,       # 50 L volume\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[0, 1, 2, 4, 6, 8, 12, 24]\n)\n\n# Access results\nprint(f\"C0 = {result['observations']['conc'][0]:.1f} mg/L\")  # 10.0 mg/L\nprint(f\"Half-life = {0.693 * 50 / 10:.1f} h\")                # 3.47 h\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#iv-infusion","title":"IV Infusion","text":"<pre><code># 500 mg over 2 hours\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=10.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0, \"duration\": 2.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.5 for i in range(49)]\n)\n\n# Peak occurs at end of infusion\nconc = result['observations']['conc']\nt = result['t']\ncmax_idx = max(range(len(conc)), key=lambda i: conc[i])\nprint(f\"Cmax = {conc[cmax_idx]:.2f} mg/L at t = {t[cmax_idx]} h\")\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#multiple-dosing","title":"Multiple Dosing","text":""},{"location":"python/models/pk/iv-bolus/#repeated-iv-boluses","title":"Repeated IV Boluses","text":"<pre><code># 500 mg every 8 hours for 5 doses\ndoses = [{\"time\": i * 8.0, \"amount\": 500.0} for i in range(5)]\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=10.0,\n    v=50.0,\n    doses=doses,\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\n# Find Cmax and Cmin in last dosing interval\nconc = result['observations']['conc']\nt = result['t']\n\n# Last interval: 32-40 h\nlast_start = next(i for i, x in enumerate(t) if x &gt;= 32)\nlast_end = next(i for i, x in enumerate(t) if x &gt;= 40)\n\ncmax = max(conc[last_start:last_end])\ncmin = min(conc[last_start:last_end])\n\nprint(f\"Steady-state Cmax: {cmax:.2f} mg/L\")\nprint(f\"Steady-state Cmin: {cmin:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#continuous-infusion","title":"Continuous Infusion","text":"<pre><code># Continuous infusion: 20 mg/h for 24 hours\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=10.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 480.0, \"duration\": 24.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\n# Steady-state concentration\ncss = 480.0 / 24.0 / 10.0  # Rate / CL = 2 mg/L\nprint(f\"Theoretical Css: {css:.1f} mg/L\")\nprint(f\"Simulated C at 24h: {result['observations']['conc'][48]:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#loading-dose-strategy","title":"Loading Dose Strategy","text":"<pre><code># Loading dose followed by maintenance infusion\ncl = 10.0\nv = 50.0\ntarget_css = 5.0  # mg/L\n\n# Loading dose to immediately reach target\nloading_dose = target_css * v  # 250 mg\n\n# Maintenance rate to sustain target\nmaint_rate = target_css * cl  # 50 mg/h\n\ndoses = [\n    {\"time\": 0.0, \"amount\": loading_dose},                     # Loading bolus\n    {\"time\": 0.0, \"amount\": maint_rate * 24, \"duration\": 24.0} # 24h infusion\n]\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=cl, v=v,\n    doses=doses,\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Concentration should stay near 5 mg/L throughout\nprint(f\"C at 0h: {result['observations']['conc'][0]:.2f} mg/L\")\nprint(f\"C at 12h: {result['observations']['conc'][48]:.2f} mg/L\")\nprint(f\"C at 24h: {result['observations']['conc'][-1]:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Plot concentration-time profile\nfig = plot_pk_profile(\n    result['t'],\n    result['observations']['conc'],\n    title=\"One-Compartment IV Bolus\",\n    xlabel=\"Time (h)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#derived-parameters","title":"Derived Parameters","text":""},{"location":"python/models/pk/iv-bolus/#from-simulation-results","title":"From Simulation Results","text":"<pre><code>import numpy as np\n\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\nconc = np.array(result['observations']['conc'])\nt = np.array(result['t'])\n\n# AUC (trapezoidal rule)\nauc = np.trapz(conc, t)\nprint(f\"AUC: {auc:.1f} mg*h/L\")\nprint(f\"Theoretical AUC (Dose/CL): {500/10:.1f} mg*h/L\")\n\n# Half-life from log-linear regression\nlog_conc = np.log(conc[conc &gt; 0])\nt_valid = t[conc &gt; 0]\nslope = np.polyfit(t_valid, log_conc, 1)[0]\nhalf_life = -0.693 / slope\nprint(f\"Half-life: {half_life:.2f} h\")\n</code></pre>"},{"location":"python/models/pk/iv-bolus/#equations-summary","title":"Equations Summary","text":"Quantity Formula Elimination rate constant \\(k = CL/V\\) Half-life \\(t_{1/2} = 0.693/k\\) C(t) after bolus \\(C_0 \\cdot e^{-kt}\\) Css (infusion) \\(R_0/CL\\) AUC (single dose) \\(Dose/CL\\)"},{"location":"python/models/pk/iv-bolus/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - First-order absorption</li> <li>Two-Compartment IV - With distribution</li> <li>NCA Analysis - Non-compartmental analysis</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pk/michaelis-menten/","title":"Michaelis-Menten Elimination","text":"<p>One-compartment model with saturable (capacity-limited) elimination kinetics.</p>"},{"location":"python/models/pk/michaelis-menten/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_michaelis_menten(\n    vmax: float,\n    km: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#parameters","title":"Parameters","text":"Parameter Type Description <code>vmax</code> float Maximum elimination rate (mg/h) <code>km</code> float Michaelis constant (mg/L) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/michaelis-menten/#model-equation","title":"Model Equation","text":"\\[\\frac{dA}{dt} = -\\frac{V_{max} \\cdot C}{K_m + C}\\] \\[C = \\frac{A}{V}\\]"},{"location":"python/models/pk/michaelis-menten/#kinetic-behavior","title":"Kinetic Behavior","text":"Condition Behavior Apparent CL C &lt;&lt; Km First-order (linear) CL \u2248 Vmax/Km C \u2248 Km Mixed-order Variable C &gt;&gt; Km Zero-order (saturated) Rate \u2248 Vmax"},{"location":"python/models/pk/michaelis-menten/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_michaelis_menten(\n    vmax=500.0,   # Maximum rate (mg/h)\n    km=10.0,      # Km (mg/L)\n    v=50.0,       # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 1000.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Initial concentration\nc0 = conc[0]  # 1000/50 = 20 mg/L\n\nprint(f\"C0: {c0:.1f} mg/L (C &gt;&gt; Km: saturated)\")\nprint(f\"C at 6h: {conc[24]:.2f} mg/L\")\nprint(f\"C at 24h: {conc[96]:.3f} mg/L (C &lt; Km: linear)\")\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#dose-dependent-half-life","title":"Dose-Dependent Half-Life","text":"<p>With Michaelis-Menten kinetics, half-life increases with dose:</p> <pre><code>import openpkpd\n\ndoses_list = [100.0, 500.0, 1000.0, 2000.0]\n\nprint(\"Dose (mg) | C0 (mg/L) | t1/2 (h)\")\nprint(\"-\" * 40)\n\nfor dose in doses_list:\n    result = openpkpd.simulate_pk_michaelis_menten(\n        vmax=500.0, km=10.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": dose}],\n        t0=0.0, t1=96.0,\n        saveat=[i * 0.5 for i in range(193)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n\n    # Find t1/2 (time to reach half of initial)\n    c0 = conc[0]\n    target = c0 / 2\n\n    t_half = None\n    for i, c in enumerate(conc):\n        if c &lt;= target:\n            t_half = t[i]\n            break\n\n    if t_half:\n        print(f\"{dose:9.0f} | {c0:9.1f} | {t_half:7.1f}\")\n    else:\n        print(f\"{dose:9.0f} | {c0:9.1f} | &gt; 96\")\n</code></pre> <p>Expected Pattern: - Higher doses \u2192 Longer t1/2 (saturation) - Low doses \u2192 Shorter t1/2 (linear kinetics)</p>"},{"location":"python/models/pk/michaelis-menten/#dose-proportionality","title":"Dose Proportionality","text":"<p>AUC increases more than proportionally with dose:</p> <pre><code>import openpkpd\nimport numpy as np\n\ndoses_list = [100.0, 200.0, 500.0, 1000.0]\nauc_values = []\n\nprint(\"Dose (mg) | AUC (mg*h/L)\")\nprint(\"-\" * 30)\n\nfor dose in doses_list:\n    result = openpkpd.simulate_pk_michaelis_menten(\n        vmax=500.0, km=10.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": dose}],\n        t0=0.0, t1=120.0,\n        saveat=[i * 0.1 for i in range(1201)]\n    )\n\n    conc = np.array(result['observations']['conc'])\n    t = np.array(result['t'])\n\n    auc = np.trapz(conc, t)\n    auc_values.append(auc)\n\n    print(f\"{dose:9.0f} | {auc:12.1f}\")\n\n# Check proportionality\nprint(f\"\\nDose ratio (10x): {doses_list[-1] / doses_list[0]:.0f}\")\nprint(f\"AUC ratio: {auc_values[-1] / auc_values[0]:.2f}\")\n# AUC ratio &gt; 10 indicates saturation\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#clinical-example-phenytoin","title":"Clinical Example: Phenytoin","text":"<pre><code>import openpkpd\n\n# Phenytoin typical parameters (for 70 kg patient)\n# Vmax \u2248 7 mg/kg/day, Km \u2248 4-6 mg/L, V \u2248 0.65 L/kg\nvmax = 7.0 * 70 / 24  # mg/h\nkm = 5.0              # mg/L\nv = 0.65 * 70         # L\n\n# Loading dose\nloading = 15 * 70  # 15 mg/kg = 1050 mg\n\nresult = openpkpd.simulate_pk_michaelis_menten(\n    vmax=vmax, km=km, v=v,\n    doses=[{\"time\": 0.0, \"amount\": loading}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.5 for i in range(49)]\n)\n\nconc = result['observations']['conc']\n\n# Therapeutic range: 10-20 mg/L\nprint(f\"Post-loading C: {conc[0]:.1f} mg/L\")\nprint(f\"24h C: {conc[-1]:.1f} mg/L\")\nprint(\"Therapeutic range: 10-20 mg/L\")\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#steady-state-considerations","title":"Steady-State Considerations","text":"<p>At steady state with constant infusion rate R:</p> \\[C_{ss} = \\frac{R \\cdot K_m}{V_{max} - R}\\] <p>This only applies when R &lt; Vmax.</p> <pre><code>vmax = 500.0  # mg/h\nkm = 10.0     # mg/L\n\nprint(f\"Maximum sustainable infusion rate: {vmax} mg/h\")\n\n# At different infusion rates\nfor fraction in [0.5, 0.8, 0.9, 0.95]:\n    r = fraction * vmax\n    css = (r * km) / (vmax - r)\n    print(f\"At R = {r:.0f} mg/h ({fraction*100:.0f}% of Vmax): Css = {css:.1f} mg/L\")\n\n# If R &gt;= Vmax, no steady state is achievable!\nprint(\"\\nWARNING: If R &gt;= Vmax, concentrations increase indefinitely!\")\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#comparison-with-linear-model","title":"Comparison with Linear Model","text":"<pre><code>import openpkpd\n\n# Michaelis-Menten at low dose (approximately linear)\nresult_mm = openpkpd.simulate_pk_michaelis_menten(\n    vmax=500.0, km=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],  # Low dose: C0 = 2 mg/L &lt;&lt; Km\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\n# Equivalent linear model: CL = Vmax/Km = 50 L/h\nresult_linear = openpkpd.simulate_pk_iv_bolus(\n    cl=50.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\n# At low dose, profiles should be nearly identical\nmm_conc = result_mm['observations']['conc']\nlin_conc = result_linear['observations']['conc']\n\nprint(\"Low dose (C &lt;&lt; Km): MM \u2248 Linear\")\nprint(f\"MM at 4h: {mm_conc[40]:.3f} mg/L\")\nprint(f\"Linear at 4h: {lin_conc[40]:.3f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\n# Compare different doses\ndoses = [100.0, 500.0, 1000.0]\n\nfor dose in doses:\n    result = openpkpd.simulate_pk_michaelis_menten(\n        vmax=500.0, km=10.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": dose}],\n        t0=0.0, t1=48.0,\n        saveat=[i * 0.25 for i in range(193)]\n    )\n\n    # Plot each dose level\n    # fig = plot_pk_profile(result['t'], result['observations']['conc'], ...)\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#apparent-clearance","title":"Apparent Clearance","text":"\\[CL_{app} = \\frac{V_{max}}{K_m + C}\\] <p>At low concentrations: \\(CL_{max} = V_{max}/K_m\\)</p> <pre><code>vmax = 500.0  # mg/h\nkm = 10.0     # mg/L\n\nprint(\"C (mg/L) | CL_app (L/h)\")\nprint(\"-\" * 25)\n\nfor c in [0.1, 1.0, 5.0, 10.0, 20.0, 50.0, 100.0]:\n    cl_app = vmax / (km + c)\n    print(f\"{c:8.1f} | {cl_app:11.1f}\")\n\nprint(f\"\\nCL_max (C\u21920): {vmax/km:.1f} L/h\")\n</code></pre>"},{"location":"python/models/pk/michaelis-menten/#equations-summary","title":"Equations Summary","text":"Quantity Formula Elimination rate \\(-V_{max} \\cdot C / (K_m + C)\\) CL_apparent \\(V_{max} / (K_m + C)\\) CL_max (C\u21920) \\(V_{max} / K_m\\) t1/2 (apparent) \\(0.693 \\cdot V \\cdot (K_m + C) / V_{max}\\) Css (infusion R) \\(R \\cdot K_m / (V_{max} - R)\\)"},{"location":"python/models/pk/michaelis-menten/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV - Linear model</li> <li>Transit Absorption - Complex absorption</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pk/oral/","title":"One-Compartment Oral First-Order","text":"<p>Single-compartment pharmacokinetic model with first-order oral absorption.</p>"},{"location":"python/models/pk/oral/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_oral_first_order(\n    ka: float,\n    cl: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/oral/#parameters","title":"Parameters","text":"Parameter Type Description <code>ka</code> float Absorption rate constant (1/h) <code>cl</code> float Apparent clearance CL/F (L/h) <code>v</code> float Apparent volume V/F (L) <code>doses</code> list[dict] Dose events with time and amount <code>t0</code> float Simulation start time <code>t1</code> float Simulation end time <code>saveat</code> list[float] Time points for output <code>alag</code> float Absorption lag time (optional) <code>bioavailability</code> float Fraction absorbed F (optional)"},{"location":"python/models/pk/oral/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, 2.0, ...],\n    \"states\": {\n        \"A_gut\": [...],          # Amount in gut\n        \"A\": [...]               # Amount in central\n    },\n    \"observations\": {\n        \"conc\": [...]            # Plasma concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/oral/#model-equations","title":"Model Equations","text":"\\[\\frac{dA_{gut}}{dt} = -K_a \\cdot A_{gut}\\] \\[\\frac{dA}{dt} = K_a \\cdot A_{gut} - k \\cdot A\\] \\[C = \\frac{A}{V}\\]"},{"location":"python/models/pk/oral/#analytical-solution-bateman-function","title":"Analytical Solution (Bateman Function)","text":"\\[C(t) = \\frac{F \\cdot D \\cdot K_a}{V \\cdot (K_a - k)} \\cdot (e^{-kt} - e^{-K_a t})\\]"},{"location":"python/models/pk/oral/#basic-examples","title":"Basic Examples","text":""},{"location":"python/models/pk/oral/#single-oral-dose","title":"Single Oral Dose","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5,       # Absorption rate (1/h)\n    cl=10.0,      # Clearance (L/h)\n    v=50.0,       # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\n# Find Cmax and Tmax\nconc = result['observations']['conc']\nt = result['t']\ncmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\nprint(f\"Cmax: {conc[cmax_idx]:.2f} mg/L\")\nprint(f\"Tmax: {t[cmax_idx]:.2f} h\")\n</code></pre>"},{"location":"python/models/pk/oral/#with-lag-time-and-bioavailability","title":"With Lag Time and Bioavailability","text":"<pre><code># Drug with 30-minute lag and 60% bioavailability\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5,\n    cl=10.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)],\n    alag=0.5,              # 30-minute lag\n    bioavailability=0.6    # 60% absorbed\n)\n\n# Compare to theoretical\n# Effective dose = 500 * 0.6 = 300 mg\n# AUC = 300 / 10 = 30 mg*h/L\n</code></pre>"},{"location":"python/models/pk/oral/#multiple-dosing","title":"Multiple Dosing","text":""},{"location":"python/models/pk/oral/#bid-twice-daily-dosing","title":"BID (Twice Daily) Dosing","text":"<pre><code># 250 mg every 12 hours for 5 days\ndoses = [{\"time\": i * 12.0, \"amount\": 250.0} for i in range(10)]\n\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5,\n    cl=10.0,\n    v=50.0,\n    doses=doses,\n    t0=0.0,\n    t1=120.0,\n    saveat=[i * 0.5 for i in range(241)]\n)\n\n# Steady-state metrics in last interval (108-120 h)\nconc = result['observations']['conc']\nt = result['t']\n\nss_start = next(i for i, x in enumerate(t) if x &gt;= 108)\nss_conc = conc[ss_start:]\n\nprint(f\"Cmax,ss: {max(ss_conc):.2f} mg/L\")\nprint(f\"Cmin,ss: {min(ss_conc):.2f} mg/L\")\nprint(f\"Cavg,ss: {sum(ss_conc)/len(ss_conc):.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/oral/#tid-three-times-daily-dosing","title":"TID (Three Times Daily) Dosing","text":"<pre><code># 100 mg every 8 hours\ndoses = [{\"time\": i * 8.0, \"amount\": 100.0} for i in range(15)]\n\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=2.0, cl=8.0, v=40.0,\n    doses=doses,\n    t0=0.0, t1=120.0,\n    saveat=[i * 0.25 for i in range(481)]\n)\n</code></pre>"},{"location":"python/models/pk/oral/#absorption-rate-effects","title":"Absorption Rate Effects","text":"<pre><code>import openpkpd\n\n# Compare different Ka values (same AUC, different profiles)\nka_values = [0.5, 1.0, 2.0, 4.0]\n\nfor ka in ka_values:\n    result = openpkpd.simulate_pk_oral_first_order(\n        ka=ka, cl=10.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        t0=0.0, t1=24.0,\n        saveat=[i * 0.1 for i in range(241)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n    cmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\n    print(f\"Ka={ka}: Cmax={conc[cmax_idx]:.2f} mg/L, Tmax={t[cmax_idx]:.1f} h\")\n</code></pre> <p>Expected Output: <pre><code>Ka=0.5: Cmax=5.12 mg/L, Tmax=3.5 h\nKa=1.0: Cmax=6.84 mg/L, Tmax=2.0 h\nKa=2.0: Cmax=7.89 mg/L, Tmax=1.2 h\nKa=4.0: Cmax=8.55 mg/L, Tmax=0.7 h\n</code></pre></p>"},{"location":"python/models/pk/oral/#flip-flop-kinetics","title":"Flip-Flop Kinetics","text":"<p>When Ka &lt; k (elimination faster than absorption):</p> <pre><code># Standard case: Ka &gt; k (absorption-rate limited)\nresult_standard = openpkpd.simulate_pk_oral_first_order(\n    ka=2.0, cl=10.0, v=50.0,  # k = 0.2/h, Ka = 2.0/h\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\n# Flip-flop case: Ka &lt; k (elimination-rate limited)\nresult_flipflop = openpkpd.simulate_pk_oral_first_order(\n    ka=0.1, cl=10.0, v=50.0,  # k = 0.2/h, Ka = 0.1/h\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\n# In flip-flop, the \"terminal\" slope reflects Ka, not k\nprint(\"Standard: terminal slope reflects k\")\nprint(\"Flip-flop: terminal slope reflects Ka\")\n</code></pre>"},{"location":"python/models/pk/oral/#tmax-calculation","title":"Tmax Calculation","text":"<p>Theoretical Tmax (when Ka \u2260 k):</p> \\[T_{max} = \\frac{\\ln(K_a/k)}{K_a - k}\\] <pre><code>import math\n\ndef calculate_tmax(ka, cl, v):\n    k = cl / v\n    if abs(ka - k) &lt; 1e-10:\n        return 1 / ka  # When Ka \u2248 k\n    return math.log(ka / k) / (ka - k)\n\n# Example\nka, cl, v = 1.5, 10.0, 50.0\ntmax_theoretical = calculate_tmax(ka, cl, v)\nprint(f\"Theoretical Tmax: {tmax_theoretical:.2f} h\")\n\n# Verify with simulation\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=ka, cl=cl, v=v,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.01 for i in range(2401)]  # Fine resolution\n)\n\nconc = result['observations']['conc']\nt = result['t']\ntmax_simulated = t[max(range(len(conc)), key=lambda i: conc[i])]\nprint(f\"Simulated Tmax: {tmax_simulated:.2f} h\")\n</code></pre>"},{"location":"python/models/pk/oral/#auc-calculation","title":"AUC Calculation","text":"<pre><code>import numpy as np\n\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=120.0,  # Long enough for complete elimination\n    saveat=[i * 0.1 for i in range(1201)]\n)\n\nconc = np.array(result['observations']['conc'])\nt = np.array(result['t'])\n\n# AUC by trapezoidal rule\nauc = np.trapz(conc, t)\n\nprint(f\"AUC: {auc:.1f} mg*h/L\")\nprint(f\"Theoretical (Dose/CL): {500/10:.1f} mg*h/L\")\n</code></pre>"},{"location":"python/models/pk/oral/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\nresult = openpkpd.simulate_pk_oral_first_order(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nfig = plot_pk_profile(\n    result['t'],\n    result['observations']['conc'],\n    title=\"One-Compartment Oral\",\n    xlabel=\"Time (h)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n</code></pre>"},{"location":"python/models/pk/oral/#equations-summary","title":"Equations Summary","text":"Quantity Formula Absorption half-life \\(t_{1/2,a} = 0.693/K_a\\) Elimination half-life \\(t_{1/2} = 0.693 \\cdot V/CL\\) Tmax \\(\\ln(K_a/k) / (K_a - k)\\) Cmax Complex (use simulation) AUC \\(F \\cdot Dose / CL\\)"},{"location":"python/models/pk/oral/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV - IV administration</li> <li>Two-Compartment Oral - With distribution</li> <li>Transit Absorption - Delayed absorption</li> <li>NCA Analysis - Exposure calculations</li> </ul>"},{"location":"python/models/pk/parallel-absorption/","title":"Parallel First-Order Absorption","text":"<p>PK model for drugs with multiple absorption sites or mechanisms, each with distinct absorption rate constants.</p>"},{"location":"python/models/pk/parallel-absorption/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_parallel_absorption(\n    ka1: float,\n    ka2: float,\n    f1: float,\n    cl: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#parameters","title":"Parameters","text":"Parameter Type Description <code>ka1</code> float First absorption rate constant (1/h) <code>ka2</code> float Second absorption rate constant (1/h) <code>f1</code> float Fraction to first depot (0-1, F2 = 1-F1) <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/parallel-absorption/#model-equations","title":"Model Equations","text":"<p>Three-compartment system (two depot, one central):</p> \\[\\frac{dA_1}{dt} = -K_{a1} \\cdot A_1\\] \\[\\frac{dA_2}{dt} = -K_{a2} \\cdot A_2\\] \\[\\frac{dA_c}{dt} = K_{a1} \\cdot A_1 + K_{a2} \\cdot A_2 - \\frac{CL}{V} \\cdot A_c\\] \\[C = \\frac{A_c}{V}\\] <p>Initial conditions after dose D: - \\(A_1(0) = F_1 \\cdot D\\) - \\(A_2(0) = (1-F_1) \\cdot D\\)</p>"},{"location":"python/models/pk/parallel-absorption/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_depot1\": [...],    # Amount in first depot\n        \"A_depot2\": [...],    # Amount in second depot\n        \"A_central\": [...]    # Amount in central compartment\n    },\n    \"observations\": {\n        \"conc\": [...]         # Plasma concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_parallel_absorption(\n    ka1=2.0,      # Fast absorption (1/h)\n    ka2=0.5,      # Slow absorption (1/h)\n    f1=0.6,       # 60% to fast pathway\n    cl=10.0,      # Clearance (L/h)\n    v=50.0,       # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Characteristic double-peak or shoulder\ntmax_idx = max(range(len(conc)), key=lambda i: conc[i])\nprint(f\"Tmax: {t[tmax_idx]:.2f} h\")\nprint(f\"Cmax: {conc[tmax_idx]:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#effect-of-fraction-split","title":"Effect of Fraction Split","text":"<pre><code>import openpkpd\n\nf1_values = [0.2, 0.4, 0.6, 0.8]\n\nprint(\"F1 (fast) | Cmax (mg/L) | Tmax (h)\")\nprint(\"-\" * 40)\n\nfor f1 in f1_values:\n    result = openpkpd.simulate_pk_parallel_absorption(\n        ka1=3.0, ka2=0.3, f1=f1, cl=10.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": 500.0}],\n        t0=0.0, t1=24.0,\n        saveat=[i * 0.1 for i in range(241)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n\n    cmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\n    print(f\"{f1:9.1f} | {conc[cmax_idx]:11.2f} | {t[cmax_idx]:8.2f}\")\n</code></pre> <p>Expected: Higher F1 leads to higher, earlier Cmax.</p>"},{"location":"python/models/pk/parallel-absorption/#biphasic-absorption-profile","title":"Biphasic Absorption Profile","text":"<pre><code>import openpkpd\n\n# Strong separation between fast and slow components\nresult = openpkpd.simulate_pk_parallel_absorption(\n    ka1=5.0,      # Very fast component\n    ka2=0.2,      # Very slow component\n    f1=0.3,       # 30% fast, 70% slow\n    cl=5.0,\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Look for double peak or shoulder\n# Find local maxima\nlocal_max = []\nfor i in range(1, len(conc)-1):\n    if conc[i] &gt; conc[i-1] and conc[i] &gt; conc[i+1]:\n        local_max.append((t[i], conc[i]))\n\nprint(\"Profile shape analysis:\")\nprint(f\"  Number of peaks/shoulders: {len(local_max)}\")\nfor i, (time, c) in enumerate(local_max):\n    print(f\"  Peak {i+1}: t = {time:.2f} h, C = {c:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#clinical-example-extended-release-formulation","title":"Clinical Example: Extended-Release Formulation","text":"<pre><code>import openpkpd\n\n# ER formulation with immediate release coat + slow release core\nresult = openpkpd.simulate_pk_parallel_absorption(\n    ka1=2.5,      # IR coat: fast\n    ka2=0.15,     # ER core: slow\n    f1=0.25,      # 25% IR, 75% ER\n    cl=8.0,\n    v=60.0,\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# ER formulation characteristics\ncmax_idx = max(range(len(conc)), key=lambda i: conc[i])\ncmin = min(conc)\n\nprint(\"Extended-Release Profile:\")\nprint(f\"  Cmax: {conc[cmax_idx]:.2f} mg/L at {t[cmax_idx]:.1f} h\")\nprint(f\"  C at 12h: {conc[48]:.2f} mg/L\")\nprint(f\"  C at 24h: {conc[-1]:.2f} mg/L\")\nprint(f\"  Fluctuation: {(conc[cmax_idx] - conc[-1]) / conc[cmax_idx] * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#comparison-with-single-absorption","title":"Comparison with Single Absorption","text":"<pre><code>import openpkpd\n\n# Parallel absorption\nresult_parallel = openpkpd.simulate_pk_parallel_absorption(\n    ka1=3.0, ka2=0.5, f1=0.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\n# Single absorption (weighted average ka)\nka_avg = 0.5 * 3.0 + 0.5 * 0.5  # 1.75\n\nresult_single = openpkpd.simulate_pk_oral_first_order(\n    ka=ka_avg, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\nparallel_conc = result_parallel['observations']['conc']\nsingle_conc = result_single['observations']['conc']\nt = result_parallel['t']\n\nprint(\"Parallel vs Single Absorption:\")\nprint(f\"  Parallel Cmax: {max(parallel_conc):.2f} mg/L\")\nprint(f\"  Single Cmax: {max(single_conc):.2f} mg/L\")\n\n# AUC should be similar (same total dose)\nauc_parallel = sum(0.5 * (parallel_conc[i] + parallel_conc[i+1]) * 0.1\n                   for i in range(len(parallel_conc)-1))\nauc_single = sum(0.5 * (single_conc[i] + single_conc[i+1]) * 0.1\n                 for i in range(len(single_conc)-1))\nprint(f\"  Parallel AUC: {auc_parallel:.1f} mg*h/L\")\nprint(f\"  Single AUC: {auc_single:.1f} mg*h/L\")\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code>import openpkpd\n\n# Twice daily dosing\ndoses = [{\"time\": i * 12.0, \"amount\": 250.0} for i in range(6)]\n\nresult = openpkpd.simulate_pk_parallel_absorption(\n    ka1=2.0, ka2=0.3, f1=0.4, cl=10.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=72.0,\n    saveat=[i * 0.25 for i in range(289)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Steady-state characteristics (last dosing interval)\nss_start = 48  # Start of last full interval\nss_conc = [conc[i] for i in range(int(ss_start/0.25), len(conc))]\n\nprint(\"Steady-State Profile (48-72h):\")\nprint(f\"  Cmax,ss: {max(ss_conc):.2f} mg/L\")\nprint(f\"  Cmin,ss: {min(ss_conc):.2f} mg/L\")\nprint(f\"  Fluctuation: {(max(ss_conc) - min(ss_conc)) / min(ss_conc) * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#food-effect-simulation","title":"Food Effect Simulation","text":"<pre><code>import openpkpd\n\n# Fasted: faster absorption, smaller fraction\nresult_fasted = openpkpd.simulate_pk_parallel_absorption(\n    ka1=3.0, ka2=0.8, f1=0.7, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\n# Fed: slower absorption, larger slow fraction\nresult_fed = openpkpd.simulate_pk_parallel_absorption(\n    ka1=1.5, ka2=0.3, f1=0.4, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\nfasted_conc = result_fasted['observations']['conc']\nfed_conc = result_fed['observations']['conc']\nt = result_fasted['t']\n\nprint(\"Food Effect on Parallel Absorption:\")\nprint(f\"  Fasted Cmax: {max(fasted_conc):.2f} mg/L\")\nprint(f\"  Fed Cmax: {max(fed_conc):.2f} mg/L\")\nprint(f\"  Cmax ratio (Fed/Fasted): {max(fed_conc)/max(fasted_conc):.2f}\")\n\n# Tmax\ntmax_fasted = t[max(range(len(fasted_conc)), key=lambda i: fasted_conc[i])]\ntmax_fed = t[max(range(len(fed_conc)), key=lambda i: fed_conc[i])]\nprint(f\"  Fasted Tmax: {tmax_fasted:.2f} h\")\nprint(f\"  Fed Tmax: {tmax_fed:.2f} h\")\n</code></pre>"},{"location":"python/models/pk/parallel-absorption/#equations-summary","title":"Equations Summary","text":"Quantity Formula Depot 1 initial \\(A_1(0) = F_1 \\cdot Dose\\) Depot 2 initial \\(A_2(0) = (1-F_1) \\cdot Dose\\) Total absorption rate \\(K_{a1} \\cdot A_1 + K_{a2} \\cdot A_2\\) Concentration \\(C = A_c / V\\) Elimination \\(CL \\cdot C = (CL/V) \\cdot A_c\\)"},{"location":"python/models/pk/parallel-absorption/#see-also","title":"See Also","text":"<ul> <li>Oral First-Order - Single absorption pathway</li> <li>Transit Absorption - Delayed absorption</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pk/threecomp/","title":"Three-Compartment IV Bolus","text":"<p>Three-compartment mammillary model with central, shallow peripheral, and deep peripheral compartments.</p>"},{"location":"python/models/pk/threecomp/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl: float,\n    v1: float,\n    q2: float,\n    v2: float,\n    q3: float,\n    v3: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/threecomp/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance from central (L/h) <code>v1</code> float Central compartment volume (L) <code>q2</code> float Clearance to shallow peripheral (L/h) <code>v2</code> float Shallow peripheral volume (L) <code>q3</code> float Clearance to deep peripheral (L/h) <code>v3</code> float Deep peripheral volume (L) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/threecomp/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_central\": [...],        # Amount in central\n        \"A_periph1\": [...],        # Amount in shallow peripheral\n        \"A_periph2\": [...]         # Amount in deep peripheral\n    },\n    \"observations\": {\n        \"conc\": [...]              # Central concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/threecomp/#model-structure","title":"Model Structure","text":"<ul> <li>Central (V1): Receives dose, site of elimination</li> <li>Shallow Peripheral (V2): Rapid equilibration with central (Q2)</li> <li>Deep Peripheral (V3): Slow equilibration with central (Q3)</li> </ul> <p>The concentration-time profile shows tri-exponential decay: - Alpha phase: Rapid initial decline - Beta phase: Intermediate decline - Gamma phase: Terminal elimination</p>"},{"location":"python/models/pk/threecomp/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl=5.0,       # Clearance (L/h)\n    v1=10.0,      # Central volume (L)\n    q2=20.0,      # Rapid distribution clearance (L/h)\n    v2=30.0,      # Shallow peripheral (L)\n    q3=5.0,       # Slow distribution clearance (L/h)\n    v3=100.0,     # Deep peripheral (L)\n    doses=[{\"time\": 0.0, \"amount\": 1000.0}],\n    t0=0.0,\n    t1=168.0,     # 7 days\n    saveat=[i * 0.5 for i in range(337)]\n)\n\n# Three phases visible in concentration decline\nconc = result['observations']['conc']\nt = result['t']\n\nprint(f\"C at 0h: {conc[0]:.2f} mg/L (initial)\")\nprint(f\"C at 1h: {conc[2]:.2f} mg/L (alpha phase)\")\nprint(f\"C at 12h: {conc[24]:.2f} mg/L (beta phase)\")\nprint(f\"C at 168h: {conc[-1]:.4f} mg/L (gamma phase)\")\n</code></pre>"},{"location":"python/models/pk/threecomp/#clinical-example-propofol","title":"Clinical Example: Propofol","text":"<pre><code>import openpkpd\n\n# Propofol typical parameters (per-minute converted to per-hour)\nresult = openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl=1.6 * 60,      # 96 L/h\n    v1=4.3,           # L (central - blood)\n    q2=2.3 * 60,      # 138 L/h (rapid - muscle)\n    v2=22.0,          # L\n    q3=0.8 * 60,      # 48 L/h (slow - fat)\n    v3=200.0,         # L\n    doses=[{\"time\": 0.0, \"amount\": 200.0}],  # 200 mg bolus\n    t0=0.0,\n    t1=6.0,           # 6 hours\n    saveat=[i * 0.05 for i in range(121)]  # 3-min resolution\n)\n\n# Rapid redistribution from brain (central) to muscle\nconc = result['observations']['conc']\nt = result['t']\n\n# Find time to 50% of initial concentration\nc0 = conc[0]\nidx_50 = next(i for i, c in enumerate(conc) if c &lt; c0 * 0.5)\nprint(f\"Time to 50% of C0: {t[idx_50]:.2f} h ({t[idx_50]*60:.1f} min)\")\n</code></pre>"},{"location":"python/models/pk/threecomp/#drug-distribution-over-time","title":"Drug Distribution Over Time","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl=5.0, v1=10.0, q2=20.0, v2=30.0, q3=5.0, v3=100.0,\n    doses=[{\"time\": 0.0, \"amount\": 1000.0}],\n    t0=0.0, t1=168.0,\n    saveat=[0, 1, 4, 12, 24, 48, 96, 168]\n)\n\na_central = result['states']['A_central']\na_shallow = result['states']['A_periph1']\na_deep = result['states']['A_periph2']\nt = result['t']\n\nprint(\"Time (h) | Central | Shallow | Deep   | Total\")\nprint(\"-\" * 55)\nfor i, time in enumerate(t):\n    total = a_central[i] + a_shallow[i] + a_deep[i]\n    print(f\"{time:8.0f} | {a_central[i]:7.1f} | {a_shallow[i]:7.1f} | {a_deep[i]:6.1f} | {total:.1f}\")\n</code></pre> <p>Expected Pattern: - t=0: All drug in central - t=1-4h: Redistribution to shallow peripheral - t=12-48h: Accumulation in deep peripheral - t&gt;48h: Deep peripheral contains most drug</p>"},{"location":"python/models/pk/threecomp/#half-lives","title":"Half-Lives","text":"<pre><code>import numpy as np\n\n# Parameters\ncl, v1, q2, v2, q3, v3 = 5.0, 10.0, 20.0, 30.0, 5.0, 100.0\n\n# Micro-rate constants\nk10 = cl / v1      # Elimination\nk12 = q2 / v1      # To shallow\nk21 = q2 / v2      # From shallow\nk13 = q3 / v1      # To deep\nk31 = q3 / v3      # From deep\n\nprint(f\"k10 (elimination): {k10:.3f} /h\")\nprint(f\"k12 (to shallow): {k12:.3f} /h\")\nprint(f\"k21 (from shallow): {k21:.3f} /h\")\nprint(f\"k13 (to deep): {k13:.3f} /h\")\nprint(f\"k31 (from deep): {k31:.3f} /h\")\n\n# Volume at steady state\nvss = v1 + v2 + v3\nmrt = vss / cl\nprint(f\"\\nVss: {vss} L\")\nprint(f\"MRT: {mrt:.1f} h\")\n</code></pre>"},{"location":"python/models/pk/threecomp/#iv-infusion","title":"IV Infusion","text":"<pre><code># Continuous infusion to steady state\nresult = openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl=5.0, v1=10.0, q2=20.0, v2=30.0, q3=5.0, v3=100.0,\n    doses=[{\"time\": 0.0, \"amount\": 480.0, \"duration\": 24.0}],  # 20 mg/h\n    t0=0.0, t1=72.0,\n    saveat=[i * 0.5 for i in range(145)]\n)\n\n# Steady-state concentration\ncss_theoretical = (480.0 / 24.0) / 5.0  # Rate / CL\nprint(f\"Theoretical Css: {css_theoretical:.1f} mg/L\")\nprint(f\"Simulated C at 24h: {result['observations']['conc'][48]:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/threecomp/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code># 1000 mg every 24 hours for 7 days\ndoses = [{\"time\": i * 24.0, \"amount\": 1000.0} for i in range(7)]\n\nresult = openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl=5.0, v1=10.0, q2=20.0, v2=30.0, q3=5.0, v3=100.0,\n    doses=doses,\n    t0=0.0, t1=168.0,\n    saveat=[i * 1.0 for i in range(169)]\n)\n\n# With deep peripheral, accumulation continues longer\nconc = result['observations']['conc']\nt = result['t']\n\n# Compare first and last trough\nfirst_trough = conc[24]   # 24h\nlast_trough = conc[168]   # 168h\n\nprint(f\"First trough (24h): {first_trough:.2f} mg/L\")\nprint(f\"Last trough (168h): {last_trough:.2f} mg/L\")\nprint(f\"Accumulation ratio: {last_trough/first_trough:.2f}\")\n</code></pre>"},{"location":"python/models/pk/threecomp/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\nresult = openpkpd.simulate_pk_threecomp_iv_bolus(\n    cl=5.0, v1=10.0, q2=20.0, v2=30.0, q3=5.0, v3=100.0,\n    doses=[{\"time\": 0.0, \"amount\": 1000.0}],\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\n# Semi-log plot shows three phases\nfig = plot_pk_profile(\n    result['t'],\n    result['observations']['conc'],\n    title=\"Three-Compartment IV Bolus\",\n    xlabel=\"Time (h)\",\n    ylabel=\"Concentration (mg/L)\",\n    log_y=True\n)\n</code></pre>"},{"location":"python/models/pk/threecomp/#equations-summary","title":"Equations Summary","text":"Quantity Formula k10 CL / V1 k12, k21 Q2/V1, Q2/V2 k13, k31 Q3/V1, Q3/V3 C(t) \\(Ae^{-\\alpha t} + Be^{-\\beta t} + Ce^{-\\gamma t}\\) Vss V1 + V2 + V3 MRT Vss / CL Terminal t1/2 0.693 / gamma"},{"location":"python/models/pk/threecomp/#see-also","title":"See Also","text":"<ul> <li>Two-Compartment IV - Simpler model</li> <li>One-Compartment IV - Simplest model</li> <li>Population Simulation</li> </ul>"},{"location":"python/models/pk/tmdd/","title":"Target-Mediated Drug Disposition (TMDD)","text":"<p>Advanced PK model for drugs that bind to their pharmacological target, forming drug-target complexes that affect both PK and PD behavior.</p>"},{"location":"python/models/pk/tmdd/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_tmdd_custom(\n    kel: float,\n    kon: float,\n    koff: float,\n    ksyn: float,\n    kdeg: float,\n    kint: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/tmdd/#parameters","title":"Parameters","text":"Parameter Type Description <code>kel</code> float Drug elimination rate constant (1/h) <code>kon</code> float Association rate constant (1/(concentration*h)) <code>koff</code> float Dissociation rate constant (1/h) <code>ksyn</code> float Receptor synthesis rate (concentration/h) <code>kdeg</code> float Receptor degradation rate constant (1/h) <code>kint</code> float Complex internalization rate constant (1/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/tmdd/#derived-parameters","title":"Derived Parameters","text":"<ul> <li>KD (dissociation constant): \\(K_D = k_{off} / k_{on}\\)</li> <li>Receptor baseline: \\(R_0 = k_{syn} / k_{deg}\\)</li> </ul>"},{"location":"python/models/pk/tmdd/#model-equations","title":"Model Equations","text":"<p>Three-state system: $\\(\\frac{dL}{dt} = -k_{el} \\cdot L - k_{on} \\cdot L \\cdot R + k_{off} \\cdot RL\\)$</p> \\[\\frac{dR}{dt} = k_{syn} - k_{deg} \\cdot R - k_{on} \\cdot L \\cdot R + k_{off} \\cdot RL\\] \\[\\frac{dRL}{dt} = k_{on} \\cdot L \\cdot R - k_{off} \\cdot RL - k_{int} \\cdot RL\\] <p>Where: - L = Free drug (ligand) concentration - R = Free receptor concentration - RL = Drug-receptor complex concentration</p>"},{"location":"python/models/pk/tmdd/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"L_free\": [...],      # Free drug\n        \"R_free\": [...],      # Free receptor\n        \"RL_complex\": [...]   # Drug-receptor complex\n    },\n    \"observations\": {\n        \"conc\": [...]         # Free drug concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/tmdd/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_tmdd_custom(\n    kel=0.1,      # Drug elimination (1/h)\n    kon=0.01,     # Association rate\n    koff=0.001,   # Dissociation rate\n    ksyn=1.0,     # Receptor synthesis\n    kdeg=0.1,     # Receptor degradation\n    kint=0.05,    # Complex internalization\n    v=50.0,       # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=72.0,\n    saveat=list(range(73))\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\nprint(f\"Initial free drug: {conc[0]:.2f} mg/L\")\nprint(f\"Free drug at 24h: {conc[24]:.3f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/tmdd/#non-linear-pk-behavior","title":"Non-Linear PK Behavior","text":"<p>TMDD causes characteristic non-linear PK:</p> <pre><code>import openpkpd\n\ndoses_list = [50.0, 100.0, 200.0, 500.0, 1000.0]\n\nprint(\"Dose (mg) | Cmax (mg/L) | AUC ratio\")\nprint(\"-\" * 45)\n\nauc_ref = None\nfor dose in doses_list:\n    result = openpkpd.simulate_pk_tmdd_custom(\n        kel=0.1, kon=0.01, koff=0.001,\n        ksyn=1.0, kdeg=0.1, kint=0.05, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": dose}],\n        t0=0.0, t1=96.0,\n        saveat=[i * 0.5 for i in range(193)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n\n    cmax = max(conc)\n\n    # Calculate AUC (trapezoidal)\n    auc = sum(0.5 * (conc[i] + conc[i+1]) * (t[i+1] - t[i])\n              for i in range(len(conc)-1))\n\n    if auc_ref is None:\n        auc_ref = auc\n\n    print(f\"{dose:9.0f} | {cmax:11.2f} | {auc/auc_ref:9.2f}\")\n</code></pre> <p>Expected: More-than-proportional increase in AUC at higher doses due to receptor saturation.</p>"},{"location":"python/models/pk/tmdd/#target-mediated-clearance","title":"Target-Mediated Clearance","text":"<pre><code>import openpkpd\n\n# At low concentrations: high clearance (receptor-mediated)\n# At high concentrations: low clearance (receptor saturated)\n\nresult = openpkpd.simulate_pk_tmdd_custom(\n    kel=0.05,      # Low linear elimination\n    kon=0.1,       # Fast binding\n    koff=0.01,     # Slow unbinding (high affinity)\n    ksyn=0.5,      # Receptor turnover\n    kdeg=0.05,\n    kint=0.2,      # Fast internalization\n    v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Find apparent terminal half-life at different phases\n# Early: rapid decline (receptor-mediated)\n# Late: slower decline (linear elimination dominates)\nprint(\"Phase analysis:\")\nprint(f\"  Conc at 4h: {conc[8]:.3f} mg/L\")\nprint(f\"  Conc at 24h: {conc[48]:.4f} mg/L\")\nprint(f\"  Conc at 72h: {conc[144]:.5f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/tmdd/#clinical-example-monoclonal-antibody","title":"Clinical Example: Monoclonal Antibody","text":"<pre><code>import openpkpd\n\n# Typical mAb TMDD parameters\nresult = openpkpd.simulate_pk_tmdd_custom(\n    kel=0.01,        # Slow linear elimination (typical mAb)\n    kon=0.1,         # Fast target binding\n    koff=0.001,      # Very slow unbinding (high affinity)\n    ksyn=0.1,        # Target synthesis\n    kdeg=0.05,       # Target degradation\n    kint=0.02,       # Complex internalization\n    v=3.0,           # Central volume (L, typical mAb)\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],  # 100 mg dose\n    t0=0.0, t1=672.0,  # 4 weeks\n    saveat=[i * 6.0 for i in range(113)]  # Every 6 hours\n)\n\n# Access states\nl_free = result['states']['L_free']\nr_free = result['states']['R_free']\nrl_complex = result['states']['RL_complex']\nt = result['t']\n\nprint(\"Monoclonal Antibody TMDD Profile:\")\nprint(f\"  Initial free drug: {l_free[0]:.2f} mg/L\")\nprint(f\"  Initial free receptor: {r_free[0]:.2f}\")\nprint(f\"  Free receptor at 24h: {r_free[4]:.3f} (suppressed)\")\nprint(f\"  Complex at 24h: {rl_complex[4]:.2f}\")\n</code></pre>"},{"location":"python/models/pk/tmdd/#receptor-dynamics","title":"Receptor Dynamics","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_tmdd_custom(\n    kel=0.1, kon=0.05, koff=0.005,\n    ksyn=1.0, kdeg=0.1, kint=0.1, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=168.0,\n    saveat=[i * 1.0 for i in range(169)]\n)\n\nr_free = result['states']['R_free']\nt = result['t']\n\n# Baseline receptor level\nr_baseline = 1.0 / 0.1  # ksyn / kdeg = 10\n\nprint(\"Receptor Dynamics:\")\nprint(f\"  Baseline R: {r_baseline:.1f}\")\nprint(f\"  R at 1h: {r_free[1]:.2f} (depleted by drug)\")\nprint(f\"  R at 24h: {r_free[24]:.2f}\")\nprint(f\"  R at 168h: {r_free[168]:.2f} (recovering)\")\n</code></pre>"},{"location":"python/models/pk/tmdd/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code>import openpkpd\n\n# Weekly dosing of mAb\ndoses = [{\"time\": i * 168.0, \"amount\": 200.0} for i in range(4)]\n\nresult = openpkpd.simulate_pk_tmdd_custom(\n    kel=0.01, kon=0.1, koff=0.001,\n    ksyn=0.1, kdeg=0.05, kint=0.02, v=3.0,\n    doses=doses,\n    t0=0.0, t1=672.0,\n    saveat=[i * 6.0 for i in range(113)]\n)\n\nconc = result['observations']['conc']\nr_free = result['states']['R_free']\n\nprint(\"Weekly Dosing Profile:\")\nprint(f\"  Peak after dose 1: {max(conc[:28]):.2f} mg/L\")\nprint(f\"  Trough before dose 2: {conc[27]:.3f} mg/L\")\nprint(f\"  Receptor suppression at week 4: {r_free[-1] / (0.1/0.05) * 100:.1f}% of baseline\")\n</code></pre>"},{"location":"python/models/pk/tmdd/#dose-selection-considerations","title":"Dose Selection Considerations","text":"<pre><code>import openpkpd\n\n# Find dose needed for &gt;90% receptor occupancy\nr_baseline = 1.0 / 0.1  # ksyn / kdeg\n\nfor dose in [10, 50, 100, 200, 500]:\n    result = openpkpd.simulate_pk_tmdd_custom(\n        kel=0.1, kon=0.05, koff=0.005,\n        ksyn=1.0, kdeg=0.1, kint=0.1, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": float(dose)}],\n        t0=0.0, t1=24.0,\n        saveat=[i * 0.5 for i in range(49)]\n    )\n\n    r_free = result['states']['R_free']\n    min_r = min(r_free)\n    max_occupancy = (r_baseline - min_r) / r_baseline * 100\n\n    print(f\"Dose {dose:3d} mg: Max receptor occupancy = {max_occupancy:.1f}%\")\n</code></pre>"},{"location":"python/models/pk/tmdd/#equations-summary","title":"Equations Summary","text":"Quantity Formula KD \\(k_{off} / k_{on}\\) Receptor baseline \\(R_0 = k_{syn} / k_{deg}\\) Free drug rate \\(-k_{el}L - k_{on}LR + k_{off}RL\\) Complex rate \\(k_{on}LR - k_{off}RL - k_{int}RL\\) Total drug \\(L + RL\\)"},{"location":"python/models/pk/tmdd/#see-also","title":"See Also","text":"<ul> <li>Michaelis-Menten - Saturable elimination</li> <li>Two-Compartment IV - Distribution kinetics</li> <li>Population Simulation - Adding variability</li> </ul>"},{"location":"python/models/pk/transit/","title":"Transit Compartment Absorption","text":"<p>Transit compartment model for delayed and complex oral absorption, using a chain of compartments to model gastrointestinal transit.</p>"},{"location":"python/models/pk/transit/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_transit_absorption(\n    n: int,\n    ktr: float,\n    ka: float,\n    cl: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/transit/#parameters","title":"Parameters","text":"Parameter Type Description <code>n</code> int Number of transit compartments (1-20) <code>ktr</code> float Transit rate constant (1/h) <code>ka</code> float Final absorption rate constant (1/h) <code>cl</code> float Clearance (L/h) <code>v</code> float Volume of distribution (L) <code>doses</code> list[dict] Dose events"},{"location":"python/models/pk/transit/#key-derived-parameter","title":"Key Derived Parameter","text":"<p>Mean Transit Time (MTT): $\\(MTT = \\frac{N + 1}{K_{tr}}\\)$</p>"},{"location":"python/models/pk/transit/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"Transit_1\": [...],        # First transit\n        \"Transit_2\": [...],        # Second transit\n        ...\n        \"Transit_N\": [...],        # Last transit\n        \"A_central\": [...]         # Central compartment\n    },\n    \"observations\": {\n        \"conc\": [...]              # Plasma concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/transit/#model-equations","title":"Model Equations","text":"\\[\\frac{dT_1}{dt} = -K_{tr} \\cdot T_1\\] \\[\\frac{dT_i}{dt} = K_{tr} \\cdot T_{i-1} - K_{tr} \\cdot T_i \\quad (i = 2..N)\\] \\[\\frac{dA}{dt} = K_a \\cdot T_N - k \\cdot A\\] <p>The absorption input follows a gamma distribution profile.</p>"},{"location":"python/models/pk/transit/#basic-example","title":"Basic Example","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_transit_absorption(\n    n=5,          # 5 transit compartments\n    ktr=0.5,      # Transit rate (1/h)\n    ka=2.0,       # Absorption rate (1/h)\n    cl=10.0,      # Clearance (L/h)\n    v=70.0,       # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 300.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\n# Find Cmax and Tmax\nconc = result['observations']['conc']\nt = result['t']\ncmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\nprint(f\"Cmax: {conc[cmax_idx]:.2f} mg/L\")\nprint(f\"Tmax: {t[cmax_idx]:.2f} h\")\n\n# Compare to Mean Transit Time\nmtt = (5 + 1) / 0.5  # 12 hours\nprint(f\"MTT: {mtt} h\")\n</code></pre>"},{"location":"python/models/pk/transit/#effect-of-number-of-transit-compartments","title":"Effect of Number of Transit Compartments","text":"<pre><code>import openpkpd\n\n# Keep MTT constant at 12 hours\nmtt = 12.0\nn_values = [1, 3, 5, 10]\n\nprint(\"N | Ktr (1/h) | Cmax (mg/L) | Tmax (h)\")\nprint(\"-\" * 45)\n\nfor n in n_values:\n    ktr = (n + 1) / mtt\n\n    result = openpkpd.simulate_pk_transit_absorption(\n        n=n, ktr=ktr, ka=2.0, cl=10.0, v=70.0,\n        doses=[{\"time\": 0.0, \"amount\": 300.0}],\n        t0=0.0, t1=48.0,\n        saveat=[i * 0.1 for i in range(481)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n    cmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\n    print(f\"{n:2d} | {ktr:9.3f} | {conc[cmax_idx]:11.2f} | {t[cmax_idx]:7.2f}\")\n</code></pre> <p>Expected Pattern: - Higher N \u2192 More delayed Tmax - Higher N \u2192 Lower, broader Cmax - Same AUC (same CL)</p>"},{"location":"python/models/pk/transit/#comparison-transit-vs-simple-oral","title":"Comparison: Transit vs Simple Oral","text":"<pre><code>import openpkpd\nimport numpy as np\n\n# Transit absorption (5 compartments, MTT = 12h)\nresult_transit = openpkpd.simulate_pk_transit_absorption(\n    n=5, ktr=0.5, ka=2.0, cl=10.0, v=70.0,\n    doses=[{\"time\": 0.0, \"amount\": 300.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\n# Simple first-order oral (slower Ka to approximate)\nresult_simple = openpkpd.simulate_pk_oral_first_order(\n    ka=0.3, cl=10.0, v=70.0,\n    doses=[{\"time\": 0.0, \"amount\": 300.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\n# Transit model has:\n# - Delayed onset (sigmoidal rise)\n# - Broader peak\n# - More physiological shape\nprint(\"Transit model: delayed onset, broader peak\")\nprint(\"Simple model: immediate onset, sharper peak\")\n</code></pre>"},{"location":"python/models/pk/transit/#controlled-release-formulation","title":"Controlled-Release Formulation","text":"<pre><code>import openpkpd\n\n# Extended-release tablet: Long MTT\nresult_er = openpkpd.simulate_pk_transit_absorption(\n    n=8,          # More transit compartments\n    ktr=0.5,      # MTT = 9/0.5 = 18 hours\n    ka=0.5,       # Slow final absorption\n    cl=10.0,\n    v=70.0,\n    doses=[{\"time\": 0.0, \"amount\": 300.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\n# Immediate-release for comparison (once daily dose split into TID)\n# ... would show higher peaks and valleys\n\nconc = result_er['observations']['conc']\nprint(f\"ER Cmax: {max(conc):.2f} mg/L\")\nprint(f\"ER Cmin (24h): {conc[96]:.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/transit/#estimation-considerations","title":"Estimation Considerations","text":"<p>When fitting transit models:</p> <pre><code># N and Ktr are correlated (same MTT with different combinations)\n# Typically fix N based on physiology (3-7 for oral drugs)\n# Estimate Ktr (or MTT directly)\n\n# From observed Tmax, estimate initial MTT\nobserved_tmax = 8.0  # hours\n\n# MTT \u2248 Tmax for transit models\n# Choose N based on formulation type\nn_guess = 5\nktr_guess = (n_guess + 1) / observed_tmax  # 0.75/h\n\nprint(f\"Initial N: {n_guess}\")\nprint(f\"Initial Ktr: {ktr_guess:.3f} /h\")\nprint(f\"Initial MTT: {(n_guess + 1) / ktr_guess:.1f} h\")\n</code></pre>"},{"location":"python/models/pk/transit/#absorption-variability","title":"Absorption Variability","text":"<p>The coefficient of variation of the absorption profile:</p> \\[CV_{absorption} = \\frac{1}{\\sqrt{N + 1}}\\] <pre><code># More transit compartments = narrower, more reproducible absorption\nn_values = [1, 3, 5, 10, 20]\n\nprint(\"N | CV_absorption\")\nprint(\"-\" * 20)\nfor n in n_values:\n    cv = 1 / (n + 1)**0.5 * 100\n    print(f\"{n:2d} | {cv:5.1f}%\")\n</code></pre>"},{"location":"python/models/pk/transit/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\nresult = openpkpd.simulate_pk_transit_absorption(\n    n=5, ktr=0.5, ka=2.0, cl=10.0, v=70.0,\n    doses=[{\"time\": 0.0, \"amount\": 300.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\nfig = plot_pk_profile(\n    result['t'],\n    result['observations']['conc'],\n    title=\"Transit Compartment Absorption\",\n    xlabel=\"Time (h)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n</code></pre>"},{"location":"python/models/pk/transit/#equations-summary","title":"Equations Summary","text":"Quantity Formula MTT \\((N+1)/K_{tr}\\) t_max,input \\(N/K_{tr}\\) CV_absorption \\(1/\\sqrt{N+1}\\) Input rate \\(\\frac{D \\cdot K_{tr}^{N+1} \\cdot t^N \\cdot e^{-K_{tr}t}}{N!}\\) dT_1/dt \\(-K_{tr} \\cdot T_1\\) dT_i/dt \\(K_{tr}(T_{i-1} - T_i)\\) dA/dt \\(K_a T_N - (CL/V) A\\)"},{"location":"python/models/pk/transit/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - Simple absorption</li> <li>Two-Compartment Oral - With distribution</li> <li>Michaelis-Menten - Nonlinear elimination</li> <li>NCA Analysis - Exposure calculations</li> </ul>"},{"location":"python/models/pk/twocomp-iv/","title":"Two-Compartment IV Bolus","text":"<p>Two-compartment mammillary model with central and peripheral compartments, exhibiting bi-exponential concentration decline.</p>"},{"location":"python/models/pk/twocomp-iv/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl: float,\n    v1: float,\n    q: float,\n    v2: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#parameters","title":"Parameters","text":"Parameter Type Description <code>cl</code> float Clearance from central (L/h) <code>v1</code> float Central compartment volume (L) <code>q</code> float Inter-compartmental clearance (L/h) <code>v2</code> float Peripheral compartment volume (L) <code>doses</code> list[dict] Dose events <code>t0</code>, <code>t1</code> float Simulation time range <code>saveat</code> list[float] Output time points"},{"location":"python/models/pk/twocomp-iv/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_central\": [...],        # Amount in central\n        \"A_peripheral\": [...]      # Amount in peripheral\n    },\n    \"observations\": {\n        \"conc\": [...]              # Central concentration (A_central/V1)\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#model-equations","title":"Model Equations","text":"\\[\\frac{dA_1}{dt} = -(k_{10} + k_{12}) \\cdot A_1 + k_{21} \\cdot A_2\\] \\[\\frac{dA_2}{dt} = k_{12} \\cdot A_1 - k_{21} \\cdot A_2\\]"},{"location":"python/models/pk/twocomp-iv/#micro-rate-constants","title":"Micro-rate Constants","text":"Constant Formula k10 CL / V1 k12 Q / V1 k21 Q / V2"},{"location":"python/models/pk/twocomp-iv/#bi-exponential-solution","title":"Bi-exponential Solution","text":"\\[C(t) = A \\cdot e^{-\\alpha t} + B \\cdot e^{-\\beta t}\\] <p>where \\(\\alpha &gt; \\beta\\) (distribution and terminal phases).</p>"},{"location":"python/models/pk/twocomp-iv/#basic-examples","title":"Basic Examples","text":""},{"location":"python/models/pk/twocomp-iv/#single-iv-bolus","title":"Single IV Bolus","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0,      # Clearance (L/h)\n    v1=20.0,      # Central volume (L)\n    q=15.0,       # Inter-compartmental clearance (L/h)\n    v2=50.0,      # Peripheral volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.5 for i in range(97)]\n)\n\n# Initial concentration (C0)\nprint(f\"C0: {result['observations']['conc'][0]:.1f} mg/L\")  # 500/20 = 25 mg/L\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#iv-infusion","title":"IV Infusion","text":"<pre><code># 500 mg over 2 hours\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0, v1=20.0, q=15.0, v2=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0, \"duration\": 2.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\nconc = result['observations']['conc']\ncmax = max(conc)\nprint(f\"Cmax: {cmax:.2f} mg/L (at end of infusion)\")\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#distribution-phases","title":"Distribution Phases","text":"<pre><code>import openpkpd\nimport numpy as np\n\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0, v1=20.0, q=15.0, v2=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.1 for i in range(241)]\n)\n\nt = np.array(result['t'])\nconc = np.array(result['observations']['conc'])\n\n# Log-linear plot shows two phases\nlog_conc = np.log(conc)\n\n# Distribution phase (early - fast decline)\nprint(f\"C at 0h: {conc[0]:.2f} mg/L\")\nprint(f\"C at 1h: {conc[10]:.2f} mg/L (distribution phase)\")\n\n# Terminal phase (late - slow decline)\nprint(f\"C at 6h: {conc[60]:.2f} mg/L\")\nprint(f\"C at 12h: {conc[120]:.2f} mg/L (terminal phase)\")\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#calculate-rate-constants","title":"Calculate Rate Constants","text":"<pre><code>import numpy as np\n\n# Parameters\ncl, v1, q, v2 = 10.0, 20.0, 15.0, 50.0\n\n# Micro-rate constants\nk10 = cl / v1      # 0.5 /h\nk12 = q / v1       # 0.75 /h\nk21 = q / v2       # 0.3 /h\n\n# Hybrid constants (alpha and beta)\nsum_k = k10 + k12 + k21\nprod_k = k10 * k21\ndiscriminant = np.sqrt(sum_k**2 - 4*prod_k)\n\nalpha = (sum_k + discriminant) / 2\nbeta = (sum_k - discriminant) / 2\n\n# Half-lives\nt_half_alpha = 0.693 / alpha\nt_half_beta = 0.693 / beta\n\nprint(f\"Distribution t1/2 (alpha): {t_half_alpha:.2f} h\")\nprint(f\"Terminal t1/2 (beta): {t_half_beta:.2f} h\")\n\n# Volume at steady state\nvss = v1 + v2\nprint(f\"Vss: {vss} L\")\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#multiple-dosing","title":"Multiple Dosing","text":"<pre><code># 500 mg every 8 hours for 3 days\ndoses = [{\"time\": i * 8.0, \"amount\": 500.0} for i in range(9)]\n\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0, v1=20.0, q=15.0, v2=50.0,\n    doses=doses,\n    t0=0.0, t1=72.0,\n    saveat=[i * 0.5 for i in range(145)]\n)\n\n# Steady-state metrics in last interval (64-72 h)\nconc = result['observations']['conc']\nt = result['t']\n\nss_start = next(i for i, x in enumerate(t) if x &gt;= 64)\nss_conc = conc[ss_start:]\n\nprint(f\"Cmax,ss: {max(ss_conc):.2f} mg/L\")\nprint(f\"Cmin,ss: {min(ss_conc):.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#compartment-amounts","title":"Compartment Amounts","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0, v1=20.0, q=15.0, v2=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[0, 1, 4, 8, 12, 24]\n)\n\n# Track drug distribution over time\na_central = result['states']['A_central']\na_periph = result['states']['A_peripheral']\nt = result['t']\n\nprint(\"Time | Central | Peripheral | % Central\")\nprint(\"-\" * 45)\nfor i, time in enumerate(t):\n    total = a_central[i] + a_periph[i]\n    if total &gt; 0:\n        pct_central = 100 * a_central[i] / total\n        print(f\"{time:4.0f}h | {a_central[i]:7.1f} | {a_periph[i]:10.1f} | {pct_central:6.1f}%\")\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#clinical-example-vancomycin","title":"Clinical Example: Vancomycin","text":"<pre><code>import openpkpd\n\n# Typical vancomycin parameters\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=4.5,       # L/h\n    v1=15.0,      # L (central)\n    q=4.0,        # L/h\n    v2=40.0,      # L (peripheral)\n    doses=[{\"time\": 0.0, \"amount\": 1000.0, \"duration\": 1.0}],  # 1g over 1h\n    t0=0.0,\n    t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# TDM sampling times\nidx_2h = next(i for i, x in enumerate(t) if x &gt;= 2.0)\nidx_trough = next(i for i, x in enumerate(t) if x &gt;= 12.0)\n\nprint(f\"Peak (2h): {conc[idx_2h]:.1f} mg/L\")\nprint(f\"Trough (12h): {conc[idx_trough]:.1f} mg/L\")\n\n# Target ranges: Peak 30-40 mg/L, Trough 15-20 mg/L\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\nresult = openpkpd.simulate_pk_twocomp_iv_bolus(\n    cl=10.0, v1=20.0, q=15.0, v2=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0,\n    saveat=[i * 0.25 for i in range(97)]\n)\n\nfig = plot_pk_profile(\n    result['t'],\n    result['observations']['conc'],\n    title=\"Two-Compartment IV Bolus\",\n    xlabel=\"Time (h)\",\n    ylabel=\"Concentration (mg/L)\",\n    log_y=True  # Semi-log plot shows bi-exponential phases\n)\n</code></pre>"},{"location":"python/models/pk/twocomp-iv/#equations-summary","title":"Equations Summary","text":"Quantity Formula k10 CL / V1 k12, k21 Q/V1, Q/V2 alpha \\((k_{10}+k_{12}+k_{21}+\\sqrt{\\Delta})/2\\) beta \\((k_{10}+k_{12}+k_{21}-\\sqrt{\\Delta})/2\\) Vss V1 + V2 Terminal t1/2 0.693 / beta AUC Dose / CL"},{"location":"python/models/pk/twocomp-iv/#see-also","title":"See Also","text":"<ul> <li>One-Compartment IV - Simpler model</li> <li>Two-Compartment Oral - With absorption</li> <li>Three-Compartment IV - More compartments</li> <li>Population Simulation</li> </ul>"},{"location":"python/models/pk/twocomp-oral/","title":"Two-Compartment Oral","text":"<p>Two-compartment model with first-order oral absorption, combining absorption kinetics with distribution.</p>"},{"location":"python/models/pk/twocomp-oral/#function-signature","title":"Function Signature","text":"<pre><code>openpkpd.simulate_pk_twocomp_oral(\n    ka: float,\n    cl: float,\n    v1: float,\n    q: float,\n    v2: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: list[float],\n    alg: str = \"Tsit5\",\n    reltol: float = 1e-10,\n    abstol: float = 1e-12,\n    maxiters: int = 10**7,\n    alag: float | None = None,\n    bioavailability: float | None = None,\n) -&gt; dict\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#parameters","title":"Parameters","text":"Parameter Type Description <code>ka</code> float Absorption rate constant (1/h) <code>cl</code> float Apparent clearance CL/F (L/h) <code>v1</code> float Apparent central volume V1/F (L) <code>q</code> float Apparent inter-compartmental clearance Q/F (L/h) <code>v2</code> float Apparent peripheral volume V2/F (L) <code>doses</code> list[dict] Dose events <code>alag</code> float Absorption lag time (optional) <code>bioavailability</code> float Fraction absorbed (optional)"},{"location":"python/models/pk/twocomp-oral/#returns","title":"Returns","text":"<pre><code>{\n    \"t\": [0.0, 1.0, ...],\n    \"states\": {\n        \"A_gut\": [...],            # Amount in gut\n        \"A_central\": [...],        # Amount in central\n        \"A_peripheral\": [...]      # Amount in peripheral\n    },\n    \"observations\": {\n        \"conc\": [...]              # Plasma concentration\n    },\n    \"metadata\": {...}\n}\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#model-equations","title":"Model Equations","text":"\\[\\frac{dA_{gut}}{dt} = -K_a \\cdot A_{gut}\\] \\[\\frac{dA_1}{dt} = K_a \\cdot A_{gut} - \\frac{CL}{V_1} \\cdot A_1 - \\frac{Q}{V_1} \\cdot A_1 + \\frac{Q}{V_2} \\cdot A_2\\] \\[\\frac{dA_2}{dt} = \\frac{Q}{V_1} \\cdot A_1 - \\frac{Q}{V_2} \\cdot A_2\\]"},{"location":"python/models/pk/twocomp-oral/#basic-examples","title":"Basic Examples","text":""},{"location":"python/models/pk/twocomp-oral/#single-oral-dose","title":"Single Oral Dose","text":"<pre><code>import openpkpd\n\nresult = openpkpd.simulate_pk_twocomp_oral(\n    ka=1.2,       # Absorption rate (1/h)\n    cl=8.0,       # Clearance (L/h)\n    v1=25.0,      # Central volume (L)\n    q=12.0,       # Inter-compartmental clearance (L/h)\n    v2=60.0,      # Peripheral volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0,\n    t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\n# Find Cmax and Tmax\nconc = result['observations']['conc']\nt = result['t']\ncmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\nprint(f\"Cmax: {conc[cmax_idx]:.2f} mg/L\")\nprint(f\"Tmax: {t[cmax_idx]:.2f} h\")\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#with-lag-time","title":"With Lag Time","text":"<pre><code># 30-minute lag, 80% bioavailability\nresult = openpkpd.simulate_pk_twocomp_oral(\n    ka=1.2, cl=8.0, v1=25.0, q=12.0, v2=60.0,\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)],\n    alag=0.5,\n    bioavailability=0.8\n)\n\nprint(f\"Effective dose: {400 * 0.8:.0f} mg\")\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#absorption-rate-effects","title":"Absorption Rate Effects","text":"<pre><code>import openpkpd\n\n# Compare fast vs slow absorption\nka_values = [0.5, 1.0, 2.0, 4.0]\n\nprint(\"Ka (1/h) | Cmax (mg/L) | Tmax (h)\")\nprint(\"-\" * 40)\n\nfor ka in ka_values:\n    result = openpkpd.simulate_pk_twocomp_oral(\n        ka=ka, cl=8.0, v1=25.0, q=12.0, v2=60.0,\n        doses=[{\"time\": 0.0, \"amount\": 400.0}],\n        t0=0.0, t1=24.0,\n        saveat=[i * 0.1 for i in range(241)]\n    )\n\n    conc = result['observations']['conc']\n    t = result['t']\n    cmax_idx = max(range(len(conc)), key=lambda i: conc[i])\n\n    print(f\"{ka:8.1f} | {conc[cmax_idx]:11.2f} | {t[cmax_idx]:7.2f}\")\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#multiple-dosing","title":"Multiple Dosing","text":""},{"location":"python/models/pk/twocomp-oral/#bid-regimen-to-steady-state","title":"BID Regimen to Steady State","text":"<pre><code># 400 mg every 12 hours for 7 days\ndoses = [{\"time\": i * 12.0, \"amount\": 400.0} for i in range(14)]\n\nresult = openpkpd.simulate_pk_twocomp_oral(\n    ka=1.2, cl=8.0, v1=25.0, q=12.0, v2=60.0,\n    doses=doses,\n    t0=0.0, t1=168.0,\n    saveat=[i * 0.5 for i in range(337)]\n)\n\nconc = result['observations']['conc']\nt = result['t']\n\n# Steady-state in last interval (156-168 h)\nss_start = next(i for i, x in enumerate(t) if x &gt;= 156)\nss_conc = conc[ss_start:]\n\nprint(f\"Cmax,ss: {max(ss_conc):.2f} mg/L\")\nprint(f\"Cmin,ss: {min(ss_conc):.2f} mg/L\")\nprint(f\"Fluctuation: {(max(ss_conc) - min(ss_conc)) / min(ss_conc) * 100:.1f}%\")\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#food-effect-study-design","title":"Food Effect Study Design","text":"<pre><code>import openpkpd\n\n# Fasted: Fast absorption\nparams_fasted = {\n    \"ka\": 2.0,\n    \"cl\": 8.0,\n    \"v1\": 25.0,\n    \"q\": 12.0,\n    \"v2\": 60.0\n}\n\n# Fed: Slower absorption, enhanced bioavailability (25%)\nparams_fed = {\n    \"ka\": 0.8,\n    \"cl\": 6.4,  # CL/F decreases as F increases\n    \"v1\": 25.0,\n    \"q\": 12.0,\n    \"v2\": 60.0\n}\n\nresult_fasted = openpkpd.simulate_pk_twocomp_oral(\n    **params_fasted,\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\nresult_fed = openpkpd.simulate_pk_twocomp_oral(\n    **params_fed,\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\n# Compare exposure\nimport numpy as np\n\nauc_fasted = np.trapz(result_fasted['observations']['conc'], result_fasted['t'])\nauc_fed = np.trapz(result_fed['observations']['conc'], result_fed['t'])\n\ncmax_fasted = max(result_fasted['observations']['conc'])\ncmax_fed = max(result_fed['observations']['conc'])\n\nprint(f\"Fed/Fasted AUC ratio: {auc_fed/auc_fasted:.2f}\")\nprint(f\"Fed/Fasted Cmax ratio: {cmax_fed/cmax_fasted:.2f}\")\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#comparison-one-comp-vs-two-comp","title":"Comparison: One-Comp vs Two-Comp","text":"<pre><code>import openpkpd\nimport numpy as np\n\n# Two-compartment oral\nresult_2comp = openpkpd.simulate_pk_twocomp_oral(\n    ka=1.2, cl=8.0, v1=25.0, q=12.0, v2=60.0,\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\n# One-compartment oral (same total volume)\nresult_1comp = openpkpd.simulate_pk_oral_first_order(\n    ka=1.2, cl=8.0, v=85.0,  # V = V1 + V2\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.1 for i in range(481)]\n)\n\n# Key differences:\n# - 2-comp has higher initial peak (smaller V1)\n# - 2-comp shows distribution phase\n# - Same terminal AUC\nprint(f\"2-comp Cmax: {max(result_2comp['observations']['conc']):.2f} mg/L\")\nprint(f\"1-comp Cmax: {max(result_1comp['observations']['conc']):.2f} mg/L\")\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#visualization","title":"Visualization","text":"<pre><code>import openpkpd\nfrom openpkpd.viz import plot_pk_profile\n\nresult = openpkpd.simulate_pk_twocomp_oral(\n    ka=1.2, cl=8.0, v1=25.0, q=12.0, v2=60.0,\n    doses=[{\"time\": 0.0, \"amount\": 400.0}],\n    t0=0.0, t1=48.0,\n    saveat=[i * 0.25 for i in range(193)]\n)\n\nfig = plot_pk_profile(\n    result['t'],\n    result['observations']['conc'],\n    title=\"Two-Compartment Oral\",\n    xlabel=\"Time (h)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n</code></pre>"},{"location":"python/models/pk/twocomp-oral/#equations-summary","title":"Equations Summary","text":"Quantity Formula dA_gut/dt \\(-K_a \\cdot A_{gut}\\) dA1/dt \\(K_a A_{gut} - (k_{10} + k_{12})A_1 + k_{21}A_2\\) dA2/dt \\(k_{12}A_1 - k_{21}A_2\\) AUC \\(F \\cdot Dose / CL\\) Absorption t1/2 \\(0.693 / K_a\\) Terminal t1/2 \\(0.693 / \\beta\\)"},{"location":"python/models/pk/twocomp-oral/#see-also","title":"See Also","text":"<ul> <li>One-Compartment Oral - Simpler model</li> <li>Two-Compartment IV - Without absorption</li> <li>Transit Absorption - Complex absorption</li> <li>NCA Analysis - Exposure calculations</li> </ul>"},{"location":"python/nca/","title":"Non-Compartmental Analysis","text":"<p>The <code>openpkpd.nca</code> module provides FDA/EMA-compliant non-compartmental analysis with comprehensive exposure metrics.</p>"},{"location":"python/nca/#overview","title":"Overview","text":"<ul> <li> <p> run_nca</p> <p>Complete NCA analysis function</p> <p> run_nca</p> </li> <li> <p> Configuration</p> <p>NCAConfig options</p> <p> Config</p> </li> <li> <p> Population NCA</p> <p>Multi-subject analysis</p> <p> Population</p> </li> <li> <p> Bioequivalence</p> <p>90% CI and TOST</p> <p> BE Analysis</p> </li> </ul>"},{"location":"python/nca/#quick-start","title":"Quick Start","text":""},{"location":"python/nca/#basic-nca","title":"Basic NCA","text":"<pre><code>from openpkpd.nca import run_nca\n\n# Concentration-time data\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nconc = [0.0, 1.8, 2.0, 1.5, 1.0, 0.5, 0.25, 0.06]\ndose = 100.0\n\n# Run NCA\nresult = run_nca(times, conc, dose)\n\n# Access results\nprint(f\"Cmax: {result.cmax:.2f} mg/L\")\nprint(f\"Tmax: {result.tmax:.2f} h\")\nprint(f\"AUC0-t: {result.auc_0_t:.2f} mg\u00b7h/L\")\nprint(f\"AUC0-inf: {result.auc_0_inf:.2f} mg\u00b7h/L\")\nprint(f\"t\u00bd: {result.t_half:.2f} h\")\nprint(f\"CL/F: {result.cl_f:.2f} L/h\")\n</code></pre>"},{"location":"python/nca/#with-configuration","title":"With Configuration","text":"<pre><code>from openpkpd.nca import run_nca, NCAConfig\n\nconfig = NCAConfig(\n    method=\"log_linear\",           # AUC calculation method\n    lambda_z_min_points=3,         # Min points for \u03bbz\n    lambda_z_r2_threshold=0.9,     # R\u00b2 threshold\n    extrapolation_max_pct=20.0,    # Warning threshold\n    blq_handling=\"zero\"            # BLQ handling\n)\n\nresult = run_nca(times, conc, dose, config=config)\nprint(f\"\u03bbz R\u00b2: {result.lambda_z_r_squared:.4f}\")\n</code></pre>"},{"location":"python/nca/#nca-metrics","title":"NCA Metrics","text":"Metric Attribute Units Description Cmax <code>.cmax</code> mg/L Maximum observed concentration Tmax <code>.tmax</code> h Time of Cmax AUC0-t <code>.auc_0_t</code> mg\u00b7h/L AUC to last observation AUC0-inf <code>.auc_0_inf</code> mg\u00b7h/L AUC extrapolated to infinity t\u00bd <code>.t_half</code> h Terminal half-life \u03bbz <code>.lambda_z</code> 1/h Terminal elimination rate CL/F <code>.cl_f</code> L/h Apparent clearance Vz/F <code>.vz_f</code> L Apparent volume MRT <code>.mrt</code> h Mean residence time"},{"location":"python/nca/#auc-methods","title":"AUC Methods","text":"Method Description Use Case <code>\"linear\"</code> Linear trapezoidal Ascending phase <code>\"log_linear\"</code> Log-linear trapezoidal Descending phase <code>\"lin_log_mixed\"</code> Mixed (recommended) General purpose <pre><code># Mixed method (default)\nconfig = NCAConfig(method=\"lin_log_mixed\")\n</code></pre>"},{"location":"python/nca/#individual-functions","title":"Individual Functions","text":"<pre><code>from openpkpd import nca\n\n# Peak metrics\ncmax = nca.nca_cmax(times, conc)\ntmax = nca.nca_tmax(times, conc)\n\n# AUC calculations\nauc_0_t = nca.auc_0_t(times, conc, method=\"log_linear\")\nauc_0_inf, extra_pct = nca.auc_0_inf(times, conc, lambda_z)\n\n# Terminal phase\nlambda_z, t_half, r_squared = nca.estimate_lambda_z(times, conc)\n</code></pre>"},{"location":"python/nca/#population-nca","title":"Population NCA","text":"<pre><code>from openpkpd.nca import run_population_nca, summarize_population_nca\n\n# Run NCA for all subjects\npop_results = run_population_nca(population_result, dose=100.0)\n\n# Summarize\nsummary = summarize_population_nca(pop_results)\n\nprint(f\"Cmax: {summary['cmax']['mean']:.2f} (CV: {summary['cmax']['cv']:.1f}%)\")\nprint(f\"AUC: {summary['auc_0_inf']['mean']:.2f} (CV: {summary['auc_0_inf']['cv']:.1f}%)\")\n</code></pre>"},{"location":"python/nca/#bioequivalence","title":"Bioequivalence","text":"<pre><code>from openpkpd.nca import bioequivalence_90ci, tost_analysis, be_conclusion\n\n# 90% CI for geometric mean ratio\nlower, upper = bioequivalence_90ci(test_auc, reference_auc)\nprint(f\"90% CI: ({lower:.3f}, {upper:.3f})\")\n\n# TOST analysis\nresult = tost_analysis(\n    test_auc,\n    reference_auc,\n    theta_lower=0.80,\n    theta_upper=1.25\n)\n\n# Conclusion\nis_be = be_conclusion(lower, upper, theta_lower=0.80, theta_upper=1.25)\nprint(f\"Bioequivalent: {is_be}\")\n</code></pre>"},{"location":"python/nca/#nca-result-object","title":"NCA Result Object","text":"<pre><code>class NCAResult:\n    # Primary metrics\n    cmax: float\n    tmax: float\n    auc_0_t: float\n    auc_0_inf: float\n    t_half: float\n\n    # Terminal phase\n    lambda_z: float\n    lambda_z_r_squared: float\n    lambda_z_n_points: int\n\n    # PK parameters\n    cl_f: float\n    vz_f: float\n    mrt: float\n\n    # Quality metrics\n    auc_extrapolated_pct: float\n\n    # Metadata\n    dose: float\n    method: str\n</code></pre>"},{"location":"python/nca/#next-steps","title":"Next Steps","text":"<ul> <li>run_nca Details</li> <li>NCA Configuration</li> <li>Bioequivalence Analysis</li> <li>NCA Visualization</li> </ul>"},{"location":"python/nca/bioequivalence/","title":"Bioequivalence Analysis","text":"<p>Bioequivalence (BE) assessment following FDA, EMA, and Health Canada guidance.</p>"},{"location":"python/nca/bioequivalence/#overview","title":"Overview","text":"<pre><code>from openpkpd.nca import bioequivalence_90ci, tost_analysis, be_conclusion\n\n# Calculate 90% CI for GMR\nci = bioequivalence_90ci(test_values, reference_values)\nprint(f\"90% CI: ({ci.lower:.3f}, {ci.upper:.3f})\")\nprint(f\"BE: {ci.be_met}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#quick-start","title":"Quick Start","text":"<pre><code>from openpkpd.nca import bioequivalence_90ci\n\n# AUC values from crossover study\ntest_auc = [45.2, 52.1, 38.7, 61.3, 49.8, 55.4, 42.1, 58.9]\nref_auc = [48.1, 55.3, 41.2, 58.9, 52.4, 53.2, 44.8, 60.1]\n\n# Calculate 90% confidence interval\nci = bioequivalence_90ci(test_auc, ref_auc)\n\nprint(f\"GMR: {ci.gmr * 100:.2f}%\")\nprint(f\"90% CI: [{ci.lower * 100:.2f}%, {ci.upper * 100:.2f}%]\")\nprint(f\"Within-subject CV: {ci.cv_within * 100:.1f}%\")\nprint(f\"BE criteria met: {ci.be_met}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#90-confidence-interval","title":"90% Confidence Interval","text":""},{"location":"python/nca/bioequivalence/#basic-calculation","title":"Basic Calculation","text":"<pre><code>from openpkpd.nca import bioequivalence_90ci\n\nci = bioequivalence_90ci(test_values, ref_values)\n\n# Results\nprint(f\"Geometric Mean Ratio: {ci.gmr * 100:.2f}%\")\nprint(f\"90% CI Lower: {ci.lower * 100:.2f}%\")\nprint(f\"90% CI Upper: {ci.upper * 100:.2f}%\")\nprint(f\"BE Met (80-125%): {ci.be_met}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#result-attributes","title":"Result Attributes","text":"<pre><code>class BioequivalenceResult:\n    gmr: float           # Geometric mean ratio (Test/Reference)\n    lower: float         # 90% CI lower bound\n    upper: float         # 90% CI upper bound\n    be_met: bool         # True if within 80-125%\n    cv_within: float     # Within-subject CV\n    n_subjects: int      # Number of subjects\n    se: float            # Standard error of log GMR\n</code></pre>"},{"location":"python/nca/bioequivalence/#custom-acceptance-limits","title":"Custom Acceptance Limits","text":"<pre><code># Custom limits for narrow therapeutic index drugs\nci = bioequivalence_90ci(\n    test_values, ref_values,\n    lower_limit=0.90,  # 90%\n    upper_limit=1.11   # 111%\n)\n</code></pre>"},{"location":"python/nca/bioequivalence/#tost-analysis","title":"TOST Analysis","text":"<p>Two One-Sided Tests for equivalence:</p> <pre><code>from openpkpd.nca import tost_analysis\n\nresult = tost_analysis(\n    test_values,\n    ref_values,\n    theta_lower=0.80,\n    theta_upper=1.25,\n    alpha=0.05\n)\n\nprint(f\"Lower test p-value: {result.p_lower:.4f}\")\nprint(f\"Upper test p-value: {result.p_upper:.4f}\")\nprint(f\"BE concluded: {result.be_concluded}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#tost-result","title":"TOST Result","text":"<pre><code>class TOSTResult:\n    t_lower: float       # t-statistic for lower bound\n    t_upper: float       # t-statistic for upper bound\n    p_lower: float       # p-value for lower test\n    p_upper: float       # p-value for upper test\n    be_concluded: bool   # True if both p &lt; alpha\n</code></pre>"},{"location":"python/nca/bioequivalence/#geometric-mean-ratio","title":"Geometric Mean Ratio","text":"<pre><code>from openpkpd.nca import geometric_mean_ratio\n\ngmr = geometric_mean_ratio(test_values, ref_values)\nprint(f\"GMR: {gmr * 100:.2f}%\")\n\n# Point estimate only (no CI)\n</code></pre>"},{"location":"python/nca/bioequivalence/#within-subject-cv","title":"Within-Subject CV","text":"<pre><code>from openpkpd.nca import within_subject_cv\n\n# From crossover data\ncv = within_subject_cv(\n    data,\n    value_col='auc',\n    subject_col='subject_id',\n    period_col='period'\n)\n\nprint(f\"Within-subject CV: {cv * 100:.1f}%\")\n\n# Classification\nif cv &lt; 0.30:\n    print(\"Standard variability drug\")\nelif cv &lt; 0.40:\n    print(\"Moderately variable drug\")\nelse:\n    print(\"Highly variable drug (HVD)\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#study-designs","title":"Study Designs","text":""},{"location":"python/nca/bioequivalence/#2x2-crossover-standard","title":"2x2 Crossover (Standard)","text":"<pre><code>from openpkpd.nca import analyze_crossover_be\n\nresult = analyze_crossover_be(\n    data,\n    treatment_col='formulation',\n    subject_col='subject_id',\n    period_col='period',\n    sequence_col='sequence',\n    response_col='auc',\n    design='2x2'\n)\n\nprint(f\"GMR: {result.gmr * 100:.2f}%\")\nprint(f\"90% CI: [{result.lower * 100:.2f}%, {result.upper * 100:.2f}%]\")\nprint(f\"Period effect p-value: {result.period_pvalue:.4f}\")\nprint(f\"Sequence effect p-value: {result.sequence_pvalue:.4f}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#replicate-designs","title":"Replicate Designs","text":"<pre><code># 2x4 Replicate (for HVD)\nresult = analyze_crossover_be(\n    data,\n    design='2x4_replicate',\n    response_col='auc'\n)\n\n# Partial replicate 3x3\nresult = analyze_crossover_be(\n    data,\n    design='3x3_partial',\n    response_col='auc'\n)\n</code></pre>"},{"location":"python/nca/bioequivalence/#parallel-group","title":"Parallel Group","text":"<pre><code>result = analyze_parallel_be(\n    data,\n    treatment_col='formulation',\n    subject_col='subject_id',\n    response_col='auc'\n)\n</code></pre>"},{"location":"python/nca/bioequivalence/#reference-scaled-be-hvd","title":"Reference-Scaled BE (HVD)","text":""},{"location":"python/nca/bioequivalence/#rsabe-fda","title":"RSABE (FDA)","text":"<p>For highly variable drugs (CV &gt; 30%):</p> <pre><code>from openpkpd.nca import rsabe_analysis\n\nresult = rsabe_analysis(\n    test_values,\n    ref_values,\n    design='2x4_replicate'\n)\n\nprint(f\"Reference CV: {result.cv_reference * 100:.1f}%\")\nprint(f\"Scaling applied: {result.scaling_applied}\")\nprint(f\"Scaled criterion met: {result.scaled_criterion_met}\")\nprint(f\"GMR constraint (80-125%): {result.gmr_constraint_met}\")\nprint(f\"RSABE conclusion: {result.be_met}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#abel-ema","title":"ABEL (EMA)","text":"<p>Average Bioequivalence with Expanding Limits:</p> <pre><code>from openpkpd.nca import abel_analysis\n\nresult = abel_analysis(\n    test_values,\n    ref_values,\n    design='2x4_replicate'\n)\n\nprint(f\"Reference CV: {result.cv_reference * 100:.1f}%\")\nprint(f\"Widened limits: [{result.lower_limit * 100:.2f}%, {result.upper_limit * 100:.2f}%]\")\nprint(f\"GMR within limits: {result.within_widened}\")\nprint(f\"GMR constraint (80-125%): {result.gmr_constraint_met}\")\nprint(f\"ABEL conclusion: {result.be_met}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#sample-size-calculation","title":"Sample Size Calculation","text":""},{"location":"python/nca/bioequivalence/#for-be-study","title":"For BE Study","text":"<pre><code>from openpkpd.nca import be_sample_size\n\nn = be_sample_size(\n    cv=0.25,           # Expected within-subject CV (25%)\n    gmr=0.95,          # Expected GMR\n    power=0.80,        # Target power\n    alpha=0.05,        # Significance level\n    design='2x2'       # Study design\n)\n\nprint(f\"Required subjects per sequence: {n}\")\nprint(f\"Total subjects: {2 * n}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#power-calculation","title":"Power Calculation","text":"<pre><code>from openpkpd.nca import be_power\n\npower = be_power(\n    n=24,\n    cv=0.25,\n    gmr=0.95,\n    design='2x2'\n)\n\nprint(f\"Expected power: {power * 100:.1f}%\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#sample-size-table","title":"Sample Size Table","text":"CV% GMR=0.95 GMR=0.90 GMR=1.00 15 10 14 8 20 16 24 12 25 24 36 18 30 34 50 26 35 46 68 36"},{"location":"python/nca/bioequivalence/#complete-be-analysis","title":"Complete BE Analysis","text":"<pre><code>import pandas as pd\nfrom openpkpd.nca import (\n    run_population_nca, bioequivalence_90ci,\n    tost_analysis, within_subject_cv, NCAConfig\n)\n\n# Load crossover study data\ndata = pd.read_csv('be_study_data.csv')\n\n# Run NCA for all subjects\nconfig = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9\n)\n\npop_result = run_population_nca(\n    data,\n    subject_col='SUBJID',\n    time_col='TIME',\n    conc_col='CONC',\n    dose_col='DOSE',\n    config=config\n)\n\n# Get NCA results by formulation\nresults_df = pop_result.to_dataframe()\nresults_df = results_df.merge(\n    data[['SUBJID', 'FORMULATION']].drop_duplicates(),\n    on='SUBJID'\n)\n\ntest_auc = results_df[results_df['FORMULATION'] == 'Test']['auc_0_inf'].values\nref_auc = results_df[results_df['FORMULATION'] == 'Reference']['auc_0_inf'].values\ntest_cmax = results_df[results_df['FORMULATION'] == 'Test']['cmax'].values\nref_cmax = results_df[results_df['FORMULATION'] == 'Reference']['cmax'].values\n\n# BE Analysis for AUC\nprint(\"=\" * 60)\nprint(\"BIOEQUIVALENCE ANALYSIS\")\nprint(\"=\" * 60)\n\nprint(\"\\n--- AUC0-inf ---\")\nauc_be = bioequivalence_90ci(test_auc, ref_auc)\nprint(f\"N: {auc_be.n_subjects}\")\nprint(f\"GMR: {auc_be.gmr * 100:.2f}%\")\nprint(f\"90% CI: [{auc_be.lower * 100:.2f}%, {auc_be.upper * 100:.2f}%]\")\nprint(f\"Within-subject CV: {auc_be.cv_within * 100:.1f}%\")\nprint(f\"BE criteria met: {'YES' if auc_be.be_met else 'NO'}\")\n\n# BE Analysis for Cmax\nprint(\"\\n--- Cmax ---\")\ncmax_be = bioequivalence_90ci(test_cmax, ref_cmax)\nprint(f\"N: {cmax_be.n_subjects}\")\nprint(f\"GMR: {cmax_be.gmr * 100:.2f}%\")\nprint(f\"90% CI: [{cmax_be.lower * 100:.2f}%, {cmax_be.upper * 100:.2f}%]\")\nprint(f\"Within-subject CV: {cmax_be.cv_within * 100:.1f}%\")\nprint(f\"BE criteria met: {'YES' if cmax_be.be_met else 'NO'}\")\n\n# Overall Conclusion\nprint(\"\\n\" + \"=\" * 60)\noverall_be = auc_be.be_met and cmax_be.be_met\nprint(f\"OVERALL BIOEQUIVALENCE: {'ESTABLISHED' if overall_be else 'NOT ESTABLISHED'}\")\nprint(\"=\" * 60)\n\n# TOST confirmation\nprint(\"\\n--- TOST Analysis ---\")\nauc_tost = tost_analysis(test_auc, ref_auc)\nprint(f\"AUC: Lower p={auc_tost.p_lower:.4f}, Upper p={auc_tost.p_upper:.4f}\")\nprint(f\"     BE concluded: {auc_tost.be_concluded}\")\n\ncmax_tost = tost_analysis(test_cmax, ref_cmax)\nprint(f\"Cmax: Lower p={cmax_tost.p_lower:.4f}, Upper p={cmax_tost.p_upper:.4f}\")\nprint(f\"      BE concluded: {cmax_tost.be_concluded}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#regulatory-reports","title":"Regulatory Reports","text":""},{"location":"python/nca/bioequivalence/#fda-style-report","title":"FDA-Style Report","text":"<pre><code>from openpkpd.nca import generate_be_report\n\nreport = generate_be_report(\n    test_auc, ref_auc, test_cmax, ref_cmax,\n    regulatory='FDA',\n    study_design='2x2_crossover'\n)\n\nprint(report)\n</code></pre>"},{"location":"python/nca/bioequivalence/#ema-style-report","title":"EMA-Style Report","text":"<pre><code>report = generate_be_report(\n    test_auc, ref_auc, test_cmax, ref_cmax,\n    regulatory='EMA',\n    study_design='2x2_crossover',\n    include_tmax=True  # EMA includes Tmax\n)\n\nprint(report)\n</code></pre>"},{"location":"python/nca/bioequivalence/#highly-variable-drug-analysis","title":"Highly Variable Drug Analysis","text":"<pre><code>from openpkpd.nca import (\n    within_subject_cv, rsabe_analysis, abel_analysis\n)\n\n# Check if HVD criteria met\ncv = within_subject_cv(data, 'auc', 'subject_id', 'period')\nprint(f\"Within-subject CV: {cv * 100:.1f}%\")\n\nif cv &gt; 0.30:\n    print(\"HVD criteria met - applying reference scaling\")\n\n    # FDA RSABE\n    rsabe = rsabe_analysis(\n        test_values, ref_values,\n        design='2x4_replicate'\n    )\n    print(f\"\\nRSABE (FDA): {rsabe.be_met}\")\n\n    # EMA ABEL\n    abel = abel_analysis(\n        test_values, ref_values,\n        design='2x4_replicate'\n    )\n    print(f\"ABEL (EMA): {abel.be_met}\")\nelse:\n    print(\"Standard ABE analysis applicable\")\n    be = bioequivalence_90ci(test_values, ref_values)\n    print(f\"ABE: {be.be_met}\")\n</code></pre>"},{"location":"python/nca/bioequivalence/#acceptance-criteria","title":"Acceptance Criteria","text":""},{"location":"python/nca/bioequivalence/#standard-be-80-125","title":"Standard BE (80-125%)","text":"Parameter Acceptance Range AUC 80.00% - 125.00% Cmax 80.00% - 125.00%"},{"location":"python/nca/bioequivalence/#narrow-therapeutic-index-90-111","title":"Narrow Therapeutic Index (90-111%)","text":"<pre><code># NTI drugs (warfarin, phenytoin, etc.)\nbe = bioequivalence_90ci(\n    test_values, ref_values,\n    lower_limit=0.90,\n    upper_limit=1.11\n)\n</code></pre>"},{"location":"python/nca/bioequivalence/#highly-variable-drugs-widened","title":"Highly Variable Drugs (Widened)","text":"Reference CV EMA Widened Range 30-50% Calculated per CV &gt;50% 69.84% - 143.19%"},{"location":"python/nca/bioequivalence/#see-also","title":"See Also","text":"<ul> <li>run_nca Function - NCA calculation</li> <li>NCA Configuration - Configuration options</li> <li>Population NCA - Multi-subject analysis</li> </ul>"},{"location":"python/nca/config/","title":"NCA Configuration","text":"<p>Complete documentation for <code>NCAConfig</code> options controlling NCA calculations.</p>"},{"location":"python/nca/config/#overview","title":"Overview","text":"<pre><code>from openpkpd.nca import NCAConfig, run_nca\n\nconfig = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9\n)\n\nresult = run_nca(times, conc, dose, config=config)\n</code></pre>"},{"location":"python/nca/config/#ncaconfig-parameters","title":"NCAConfig Parameters","text":""},{"location":"python/nca/config/#complete-parameter-list","title":"Complete Parameter List","text":"<pre><code>from openpkpd.nca import NCAConfig\n\nconfig = NCAConfig(\n    # AUC Calculation Method\n    method=\"lin_log_mixed\",          # \"linear\", \"log_linear\", \"lin_log_mixed\"\n\n    # Lambda_z Estimation\n    lambda_z_min_points=3,           # Minimum points for terminal regression\n    lambda_z_max_points=None,        # Maximum points (None = all valid)\n    lambda_z_r2_threshold=0.9,       # R\u00b2 quality threshold\n    lambda_z_selection=\"min_points_first\",  # Point selection method\n    lambda_z_start_time=None,        # Earliest time to include\n    lambda_z_start_idx=None,         # First index to include\n    lambda_z_end_idx=None,           # Last index to include\n\n    # BLQ Handling\n    lloq=None,                       # Lower limit of quantification\n    blq_handling=\"missing\",          # \"zero\", \"lloq_half\", \"missing\"\n\n    # Quality Thresholds\n    extrapolation_max_pct=20.0,      # Warning if AUC extrap &gt; this %\n)\n</code></pre>"},{"location":"python/nca/config/#auc-calculation-methods","title":"AUC Calculation Methods","text":""},{"location":"python/nca/config/#method-options","title":"Method Options","text":"Method Description Formula <code>\"linear\"</code> Linear trapezoidal \\((C_1 + C_2) \\cdot \\Delta t / 2\\) <code>\"log_linear\"</code> Log-linear trapezoidal \\((C_1 - C_2) / \\ln(C_1/C_2) \\cdot \\Delta t\\) <code>\"lin_log_mixed\"</code> Linear up, log down (recommended) Mixed"},{"location":"python/nca/config/#linear-trapezoidal","title":"Linear Trapezoidal","text":"<pre><code>config = NCAConfig(method=\"linear\")\n</code></pre> <p>Best for ascending concentration phases.</p>"},{"location":"python/nca/config/#log-linear-trapezoidal","title":"Log-Linear Trapezoidal","text":"<pre><code>config = NCAConfig(method=\"log_linear\")\n</code></pre> <p>Best for descending (elimination) phases when concentrations are decreasing.</p>"},{"location":"python/nca/config/#linear-log-mixed-recommended","title":"Linear-Log Mixed (Recommended)","text":"<pre><code>config = NCAConfig(method=\"lin_log_mixed\")  # Default\n</code></pre> <p>FDA/EMA recommended method: - Uses linear trapezoidal when concentration is increasing - Uses log-linear trapezoidal when concentration is decreasing</p>"},{"location":"python/nca/config/#lambda_z-configuration","title":"Lambda_z Configuration","text":""},{"location":"python/nca/config/#minimum-points","title":"Minimum Points","text":"<pre><code># Require at least 4 points for \u03bbz estimation\nconfig = NCAConfig(lambda_z_min_points=4)\n</code></pre> <p>FDA/EMA typically require minimum 3 points.</p>"},{"location":"python/nca/config/#r2-threshold","title":"R\u00b2 Threshold","text":"<pre><code># Require R\u00b2 \u2265 0.95\nconfig = NCAConfig(lambda_z_r2_threshold=0.95)\n</code></pre>"},{"location":"python/nca/config/#point-selection-methods","title":"Point Selection Methods","text":"<pre><code># Method 1: MinPointsFirst (FDA/EMA default)\n# Starts with minimum points from end, adds more if R\u00b2 improves\nconfig = NCAConfig(lambda_z_selection=\"min_points_first\")\n\n# Method 2: MaxAdjR2\n# Tests all combinations, selects best adjusted R\u00b2\nconfig = NCAConfig(lambda_z_selection=\"max_adj_r2\")\n</code></pre>"},{"location":"python/nca/config/#manual-point-selection","title":"Manual Point Selection","text":"<pre><code># Specify exact points to use\nconfig = NCAConfig(\n    lambda_z_start_idx=5,   # Start from index 5\n    lambda_z_end_idx=10     # End at index 10\n)\n\n# Or by time\nconfig = NCAConfig(\n    lambda_z_start_time=4.0  # Only use times \u2265 4h\n)\n</code></pre>"},{"location":"python/nca/config/#blq-handling","title":"BLQ Handling","text":""},{"location":"python/nca/config/#lloq-setting","title":"LLOQ Setting","text":"<pre><code># Set lower limit of quantification\nconfig = NCAConfig(lloq=0.05)  # 0.05 mg/L\n</code></pre>"},{"location":"python/nca/config/#blq-handling-methods","title":"BLQ Handling Methods","text":"Method Description Use Case <code>\"zero\"</code> Replace BLQ with 0 Pre-dose samples <code>\"lloq_half\"</code> Replace BLQ with LLOQ/2 Mid-profile BLQ <code>\"missing\"</code> Exclude from calculations General use <pre><code># Treat BLQ as zero\nconfig = NCAConfig(lloq=0.05, blq_handling=\"zero\")\n\n# Treat BLQ as LLOQ/2\nconfig = NCAConfig(lloq=0.05, blq_handling=\"lloq_half\")\n\n# Exclude BLQ values\nconfig = NCAConfig(lloq=0.05, blq_handling=\"missing\")\n</code></pre>"},{"location":"python/nca/config/#quality-thresholds","title":"Quality Thresholds","text":""},{"location":"python/nca/config/#auc-extrapolation-warning","title":"AUC Extrapolation Warning","text":"<pre><code># Warn if &gt;15% of AUC is extrapolated\nconfig = NCAConfig(extrapolation_max_pct=15.0)\n</code></pre> <p>FDA/EMA typically flag studies where extrapolation exceeds 20%.</p>"},{"location":"python/nca/config/#preset-configurations","title":"Preset Configurations","text":""},{"location":"python/nca/config/#fda-compliant","title":"FDA-Compliant","text":"<pre><code>def fda_config():\n    return NCAConfig(\n        method=\"lin_log_mixed\",\n        lambda_z_min_points=3,\n        lambda_z_r2_threshold=0.9,\n        lambda_z_selection=\"min_points_first\",\n        extrapolation_max_pct=20.0,\n        blq_handling=\"missing\"\n    )\n\nconfig = fda_config()\n</code></pre>"},{"location":"python/nca/config/#ema-compliant","title":"EMA-Compliant","text":"<pre><code>def ema_config():\n    return NCAConfig(\n        method=\"lin_log_mixed\",\n        lambda_z_min_points=3,\n        lambda_z_r2_threshold=0.9,\n        lambda_z_selection=\"min_points_first\",\n        extrapolation_max_pct=20.0,\n        blq_handling=\"missing\"\n    )\n\nconfig = ema_config()\n</code></pre>"},{"location":"python/nca/config/#conservative-strict-qc","title":"Conservative (Strict QC)","text":"<pre><code>def strict_config():\n    return NCAConfig(\n        method=\"lin_log_mixed\",\n        lambda_z_min_points=4,\n        lambda_z_r2_threshold=0.95,\n        extrapolation_max_pct=15.0\n    )\n\nconfig = strict_config()\n</code></pre>"},{"location":"python/nca/config/#example-custom-configuration","title":"Example: Custom Configuration","text":"<pre><code>from openpkpd.nca import run_nca, NCAConfig\n\n# Bioanalytical assay has LLOQ of 0.1 mg/L\n# Study has sparse terminal sampling\n\nconfig = NCAConfig(\n    # Use mixed method per FDA guidance\n    method=\"lin_log_mixed\",\n\n    # Lambda_z settings\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9,\n    lambda_z_selection=\"min_points_first\",\n\n    # BLQ handling\n    lloq=0.1,\n    blq_handling=\"missing\",  # Exclude BLQ from calculations\n\n    # Quality thresholds\n    extrapolation_max_pct=20.0\n)\n\n# Run NCA with configuration\nresult = run_nca(times, conc, dose, config=config)\n\n# Check quality\nprint(f\"\u03bbz R\u00b2: {result.lambda_z_result.r_squared:.4f}\")\nprint(f\"AUC extrapolated: {result.auc_extra_pct:.1f}%\")\n\nif result.lambda_z_result.r_squared &lt; config.lambda_z_r2_threshold:\n    print(\"WARNING: \u03bbz R\u00b2 below threshold\")\n\nif result.auc_extra_pct &gt; config.extrapolation_max_pct:\n    print(\"WARNING: High AUC extrapolation\")\n</code></pre>"},{"location":"python/nca/config/#configuration-for-study-types","title":"Configuration for Study Types","text":""},{"location":"python/nca/config/#single-dose-pk-study","title":"Single Dose PK Study","text":"<pre><code>config = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9,\n    extrapolation_max_pct=20.0\n)\n\nresult = run_nca(times, conc, dose, config=config, dosing_type=\"single\")\n</code></pre>"},{"location":"python/nca/config/#steady-state-study","title":"Steady-State Study","text":"<pre><code>config = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9\n)\n\nresult = run_nca(\n    times, conc, dose,\n    config=config,\n    dosing_type=\"steady_state\",\n    tau=12.0\n)\n</code></pre>"},{"location":"python/nca/config/#bioequivalence-study","title":"Bioequivalence Study","text":"<pre><code>config = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9,\n    extrapolation_max_pct=20.0,  # Critical for BE\n    lloq=0.05,\n    blq_handling=\"missing\"\n)\n</code></pre>"},{"location":"python/nca/config/#validating-configuration","title":"Validating Configuration","text":"<pre><code>from openpkpd.nca import NCAConfig\n\nconfig = NCAConfig(\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9\n)\n\n# Check configuration is valid\nprint(f\"Method: {config.method}\")\nprint(f\"Min \u03bbz points: {config.lambda_z_min_points}\")\nprint(f\"R\u00b2 threshold: {config.lambda_z_r2_threshold}\")\nprint(f\"LLOQ: {config.lloq}\")\nprint(f\"BLQ handling: {config.blq_handling}\")\n</code></pre>"},{"location":"python/nca/config/#see-also","title":"See Also","text":"<ul> <li>run_nca Function - Main NCA function</li> <li>Population NCA - Multi-subject analysis</li> <li>Bioequivalence - BE studies</li> </ul>"},{"location":"python/nca/population/","title":"Population NCA","text":"<p>Multi-subject non-compartmental analysis with summary statistics.</p>"},{"location":"python/nca/population/#overview","title":"Overview","text":"<pre><code>from openpkpd.nca import run_population_nca, summarize_population_nca\n\npop_result = run_population_nca(data, dose=100.0)\nsummary = summarize_population_nca(pop_result)\n</code></pre>"},{"location":"python/nca/population/#data-format","title":"Data Format","text":""},{"location":"python/nca/population/#required-structure","title":"Required Structure","text":"<pre><code>import pandas as pd\n\n# DataFrame with required columns\ndata = pd.DataFrame({\n    'subject_id': [1, 1, 1, 2, 2, 2, ...],      # Subject identifier\n    'time': [0.0, 1.0, 4.0, 0.0, 1.0, 4.0, ...],  # Time points\n    'conc': [0.0, 5.2, 2.1, 0.0, 4.8, 1.9, ...]   # Concentrations\n})\n\n# Dose can be column or single value\ndata['dose'] = [100.0, 100.0, 100.0, 150.0, ...]  # Per-subject dose\n# OR\ndose = 100.0  # Same dose for all\n</code></pre>"},{"location":"python/nca/population/#with-covariates","title":"With Covariates","text":"<pre><code>data = pd.DataFrame({\n    'subject_id': [...],\n    'time': [...],\n    'conc': [...],\n    'dose': [...],\n    'weight': [70.0, 85.0, ...],\n    'sex': ['M', 'F', ...],\n    'formulation': ['Test', 'Reference', ...]\n})\n</code></pre>"},{"location":"python/nca/population/#running-population-nca","title":"Running Population NCA","text":""},{"location":"python/nca/population/#basic-usage","title":"Basic Usage","text":"<pre><code>from openpkpd.nca import run_population_nca\n\npop_result = run_population_nca(\n    data,\n    subject_col='subject_id',\n    time_col='time',\n    conc_col='conc',\n    dose=100.0  # OR dose_col='dose'\n)\n\n# Access individual results\nfor subject_id, result in pop_result.individual_results.items():\n    print(f\"Subject {subject_id}: AUC={result.auc_0_inf:.2f}\")\n</code></pre>"},{"location":"python/nca/population/#with-configuration","title":"With Configuration","text":"<pre><code>from openpkpd.nca import run_population_nca, NCAConfig\n\nconfig = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9,\n    lloq=0.05,\n    blq_handling=\"missing\"\n)\n\npop_result = run_population_nca(\n    data,\n    config=config,\n    route=\"extravascular\",\n    dose=100.0\n)\n</code></pre>"},{"location":"python/nca/population/#variable-dose-per-subject","title":"Variable Dose per Subject","text":"<pre><code># Dose in data column\npop_result = run_population_nca(\n    data,\n    dose_col='dose'  # Use dose column\n)\n</code></pre>"},{"location":"python/nca/population/#summary-statistics","title":"Summary Statistics","text":""},{"location":"python/nca/population/#generate-summary","title":"Generate Summary","text":"<pre><code>from openpkpd.nca import summarize_population_nca\n\nsummary = summarize_population_nca(pop_result)\n\n# Access parameter statistics\nprint(\"=== AUC0-inf Summary ===\")\nprint(f\"N:        {summary['auc_0_inf']['n']}\")\nprint(f\"Mean:     {summary['auc_0_inf']['mean']:.2f}\")\nprint(f\"SD:       {summary['auc_0_inf']['sd']:.2f}\")\nprint(f\"CV%:      {summary['auc_0_inf']['cv_pct']:.1f}\")\nprint(f\"Median:   {summary['auc_0_inf']['median']:.2f}\")\nprint(f\"Min:      {summary['auc_0_inf']['min']:.2f}\")\nprint(f\"Max:      {summary['auc_0_inf']['max']:.2f}\")\nprint(f\"GeoMean:  {summary['auc_0_inf']['geomean']:.2f}\")\nprint(f\"GeoCV%:   {summary['auc_0_inf']['geocv_pct']:.1f}\")\n</code></pre>"},{"location":"python/nca/population/#summary-table","title":"Summary Table","text":"<pre><code># Get formatted table\ntable = pop_result.summary_table()\nprint(table)\n\n# Output:\n# Parameter     N    Mean    SD     CV%    Median   GeoMean  GeoCV%\n# -------------------------------------------------------------------\n# Cmax          24   5.23    1.12   21.4   5.15     5.12     22.1\n# Tmax          24   1.25    0.35   28.0   1.00     -        -\n# AUC0-t        24   45.2    8.7    19.3   44.1     44.5     19.8\n# AUC0-inf      24   48.1    9.2    19.1   47.2     47.4     19.5\n# t1/2          24   4.52    0.85   18.8   4.35     4.45     19.2\n# CL/F          24   2.12    0.42   19.8   2.08     2.08     20.1\n</code></pre>"},{"location":"python/nca/population/#specific-parameters","title":"Specific Parameters","text":"<pre><code># Summary for specific parameters only\nsummary = summarize_population_nca(\n    pop_result,\n    parameters=['cmax', 'auc_0_inf', 't_half', 'cl_f']\n)\n</code></pre>"},{"location":"python/nca/population/#stratified-analysis","title":"Stratified Analysis","text":""},{"location":"python/nca/population/#by-single-variable","title":"By Single Variable","text":"<pre><code>from openpkpd.nca import stratified_population_nca\n\n# Stratify by formulation\nstratified = stratified_population_nca(\n    data,\n    strat_col='formulation',\n    dose=100.0\n)\n\nfor stratum, result in stratified.items():\n    summary = summarize_population_nca(result)\n    print(f\"\\n{stratum}:\")\n    print(f\"  AUC mean: {summary['auc_0_inf']['mean']:.2f}\")\n    print(f\"  Cmax mean: {summary['cmax']['mean']:.2f}\")\n</code></pre>"},{"location":"python/nca/population/#by-multiple-variables","title":"By Multiple Variables","text":"<pre><code># Stratify by formulation and fed state\nstratified = stratified_population_nca(\n    data,\n    strat_cols=['formulation', 'fed_state'],\n    dose_col='dose'\n)\n\n# Access specific stratum\ntest_fed = stratified[('Test', 'Fed')]\nref_fasted = stratified[('Reference', 'Fasted')]\n</code></pre>"},{"location":"python/nca/population/#geometric-mean-ratio-between-strata","title":"Geometric Mean Ratio Between Strata","text":"<pre><code>test_summary = summarize_population_nca(stratified['Test'])\nref_summary = summarize_population_nca(stratified['Reference'])\n\n# Calculate GMR\ngmr_auc = test_summary['auc_0_inf']['geomean'] / ref_summary['auc_0_inf']['geomean']\ngmr_cmax = test_summary['cmax']['geomean'] / ref_summary['cmax']['geomean']\n\nprint(f\"AUC GMR: {gmr_auc * 100:.2f}%\")\nprint(f\"Cmax GMR: {gmr_cmax * 100:.2f}%\")\n</code></pre>"},{"location":"python/nca/population/#export-results","title":"Export Results","text":""},{"location":"python/nca/population/#to-dataframe","title":"To DataFrame","text":"<pre><code># Convert to DataFrame\nresults_df = pop_result.to_dataframe()\n\n# Columns: subject_id, cmax, tmax, auc_0_t, auc_0_inf, t_half, cl_f, ...\nprint(results_df.head())\n</code></pre>"},{"location":"python/nca/population/#to-csv","title":"To CSV","text":"<pre><code># Export to CSV\npop_result.to_csv('nca_results.csv')\n</code></pre>"},{"location":"python/nca/population/#to-json","title":"To JSON","text":"<pre><code># Export to JSON\npop_result.to_json('nca_results.json')\n</code></pre>"},{"location":"python/nca/population/#quality-assessment","title":"Quality Assessment","text":""},{"location":"python/nca/population/#check-individual-results","title":"Check Individual Results","text":"<pre><code># Identify subjects with quality issues\nfor subject_id, result in pop_result.individual_results.items():\n    issues = []\n\n    # Check \u03bbz R\u00b2\n    if result.lambda_z_result.r_squared &lt; 0.9:\n        issues.append(f\"Low \u03bbz R\u00b2: {result.lambda_z_result.r_squared:.3f}\")\n\n    # Check extrapolation\n    if result.auc_extra_pct &gt; 20:\n        issues.append(f\"High extrapolation: {result.auc_extra_pct:.1f}%\")\n\n    # Check \u03bbz estimation\n    if math.isnan(result.lambda_z_result.lambda_z):\n        issues.append(\"\u03bbz not estimable\")\n\n    if issues:\n        print(f\"Subject {subject_id}: {', '.join(issues)}\")\n</code></pre>"},{"location":"python/nca/population/#summary-quality-metrics","title":"Summary Quality Metrics","text":"<pre><code>import math\n\n# Count quality issues\nn_total = len(pop_result.individual_results)\nn_good_lz = sum(\n    1 for r in pop_result.individual_results.values()\n    if r.lambda_z_result.r_squared &gt;= 0.9\n)\nn_low_extrap = sum(\n    1 for r in pop_result.individual_results.values()\n    if r.auc_extra_pct &lt;= 20\n)\n\nprint(f\"\u03bbz R\u00b2 \u2265 0.9: {n_good_lz}/{n_total} ({100*n_good_lz/n_total:.1f}%)\")\nprint(f\"AUC extrap \u2264 20%: {n_low_extrap}/{n_total} ({100*n_low_extrap/n_total:.1f}%)\")\n</code></pre>"},{"location":"python/nca/population/#failed-subjects","title":"Failed Subjects","text":"<pre><code># Check for subjects with failed NCA\nif pop_result.failed_subjects:\n    print(\"Subjects with NCA failures:\")\n    for subject_id, reason in pop_result.failed_subjects.items():\n        print(f\"  {subject_id}: {reason}\")\n</code></pre>"},{"location":"python/nca/population/#example-complete-population-analysis","title":"Example: Complete Population Analysis","text":"<pre><code>import pandas as pd\nfrom openpkpd.nca import (\n    run_population_nca, summarize_population_nca,\n    stratified_population_nca, NCAConfig\n)\n\n# Load study data\ndata = pd.read_csv('pk_study_data.csv')\n\n# Configure NCA\nconfig = NCAConfig(\n    method=\"lin_log_mixed\",\n    lambda_z_min_points=3,\n    lambda_z_r2_threshold=0.9,\n    lloq=0.1,\n    blq_handling=\"missing\"\n)\n\n# Run population NCA\npop_result = run_population_nca(\n    data,\n    subject_col='SUBJID',\n    time_col='TIME',\n    conc_col='CONC',\n    dose_col='DOSE',\n    config=config,\n    route='extravascular'\n)\n\n# Overall summary\nprint(\"=\" * 60)\nprint(\"POPULATION NCA SUMMARY\")\nprint(\"=\" * 60)\n\nsummary = summarize_population_nca(pop_result)\nprint(f\"\\nTotal subjects: {len(pop_result.individual_results)}\")\nprint(f\"Failed subjects: {len(pop_result.failed_subjects)}\")\n\nprint(\"\\n{:&lt;12} {:&gt;6} {:&gt;10} {:&gt;10} {:&gt;8} {:&gt;10} {:&gt;8}\".format(\n    \"Parameter\", \"N\", \"Mean\", \"SD\", \"CV%\", \"GeoMean\", \"GeoCV%\"\n))\nprint(\"-\" * 60)\n\nfor param in ['cmax', 'tmax', 'auc_0_t', 'auc_0_inf', 't_half', 'cl_f']:\n    s = summary[param]\n    if param == 'tmax':\n        print(f\"{param:&lt;12} {s['n']:&gt;6} {s['mean']:&gt;10.2f} {s['sd']:&gt;10.2f} {s['cv_pct']:&gt;8.1f} {'N/A':&gt;10} {'N/A':&gt;8}\")\n    else:\n        print(f\"{param:&lt;12} {s['n']:&gt;6} {s['mean']:&gt;10.2f} {s['sd']:&gt;10.2f} {s['cv_pct']:&gt;8.1f} {s['geomean']:&gt;10.2f} {s['geocv_pct']:&gt;8.1f}\")\n\n# Stratified by formulation\nif 'FORMULATION' in data.columns:\n    print(\"\\n\" + \"=\" * 60)\n    print(\"STRATIFIED BY FORMULATION\")\n    print(\"=\" * 60)\n\n    stratified = stratified_population_nca(\n        data,\n        strat_col='FORMULATION',\n        config=config,\n        dose_col='DOSE'\n    )\n\n    for form in stratified:\n        s = summarize_population_nca(stratified[form])\n        print(f\"\\n{form}:\")\n        print(f\"  N:        {s['auc_0_inf']['n']}\")\n        print(f\"  AUC0-inf: {s['auc_0_inf']['geomean']:.2f} (GeoCV: {s['auc_0_inf']['geocv_pct']:.1f}%)\")\n        print(f\"  Cmax:     {s['cmax']['geomean']:.2f} (GeoCV: {s['cmax']['geocv_pct']:.1f}%)\")\n\n# Export results\nresults_df = pop_result.to_dataframe()\nresults_df.to_csv('nca_individual_results.csv', index=False)\nprint(f\"\\nResults exported to nca_individual_results.csv\")\n</code></pre>"},{"location":"python/nca/population/#multiple-dose-population-nca","title":"Multiple Dose Population NCA","text":"<pre><code># Steady-state population analysis\npop_result = run_population_nca(\n    data,\n    subject_col='SUBJID',\n    time_col='TIME',\n    conc_col='CONC',\n    dose=100.0,\n    dosing_type='steady_state',\n    tau=12.0,\n    config=config\n)\n\n# Access steady-state metrics\nsummary = summarize_population_nca(pop_result)\nprint(f\"Cmax,ss:    {summary['cmax']['geomean']:.2f}\")\nprint(f\"Cmin,ss:    {summary['cmin']['geomean']:.2f}\")\nprint(f\"Cavg,ss:    {summary['cavg']['geomean']:.2f}\")\nprint(f\"AUC0-tau:   {summary['auc_0_tau']['geomean']:.2f}\")\nprint(f\"PTF:        {summary['fluctuation']['mean']:.1f}%\")\n</code></pre>"},{"location":"python/nca/population/#see-also","title":"See Also","text":"<ul> <li>run_nca Function - Individual NCA</li> <li>NCA Configuration - Configuration options</li> <li>Bioequivalence - BE analysis from population NCA</li> </ul>"},{"location":"python/nca/run-nca/","title":"run_nca Function","text":"<p>The primary function for performing non-compartmental analysis in Python.</p>"},{"location":"python/nca/run-nca/#overview","title":"Overview","text":"<pre><code>from openpkpd.nca import run_nca\n\nresult = run_nca(times, conc, dose)\n</code></pre>"},{"location":"python/nca/run-nca/#function-signature","title":"Function Signature","text":"<pre><code>def run_nca(\n    times: list[float] | np.ndarray,\n    conc: list[float] | np.ndarray,\n    dose: float,\n    *,\n    config: NCAConfig | None = None,\n    route: str = \"extravascular\",\n    dosing_type: str = \"single\",\n    tau: float | None = None,\n    infusion_time: float | None = None,\n) -&gt; NCAResult:\n    \"\"\"\n    Perform non-compartmental analysis on concentration-time data.\n\n    Parameters\n    ----------\n    times : array-like\n        Time points (hours)\n    conc : array-like\n        Concentrations (mass/volume, e.g., mg/L)\n    dose : float\n        Administered dose (mass, e.g., mg)\n    config : NCAConfig, optional\n        NCA configuration options\n    route : str\n        \"extravascular\", \"iv_bolus\", or \"iv_infusion\"\n    dosing_type : str\n        \"single\", \"multiple\", or \"steady_state\"\n    tau : float, optional\n        Dosing interval (hours) for multiple dose\n    infusion_time : float, optional\n        IV infusion duration (hours)\n\n    Returns\n    -------\n    NCAResult\n        Object containing all NCA parameters\n    \"\"\"\n</code></pre>"},{"location":"python/nca/run-nca/#basic-usage","title":"Basic Usage","text":""},{"location":"python/nca/run-nca/#single-dose-oral","title":"Single Dose Oral","text":"<pre><code>from openpkpd.nca import run_nca\n\ntimes = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nconc = [0.0, 1.8, 2.5, 2.0, 1.2, 0.6, 0.3, 0.075]\ndose = 100.0  # mg\n\nresult = run_nca(times, conc, dose)\n\nprint(f\"Cmax: {result.cmax:.2f} mg/L\")\nprint(f\"Tmax: {result.tmax:.2f} h\")\nprint(f\"AUC0-t: {result.auc_0_t:.2f} mg\u00b7h/L\")\nprint(f\"AUC0-inf: {result.auc_0_inf:.2f} mg\u00b7h/L\")\nprint(f\"t\u00bd: {result.t_half:.2f} h\")\nprint(f\"CL/F: {result.cl_f:.2f} L/h\")\nprint(f\"Vz/F: {result.vz_f:.1f} L\")\n</code></pre>"},{"location":"python/nca/run-nca/#iv-bolus","title":"IV Bolus","text":"<pre><code>result = run_nca(times, conc, dose, route=\"iv_bolus\")\n\nprint(f\"CL: {result.cl:.2f} L/h\")  # Absolute clearance\nprint(f\"Vz: {result.vz:.1f} L\")    # Absolute volume\nprint(f\"Vss: {result.vss:.1f} L\")  # Volume at steady state\n</code></pre>"},{"location":"python/nca/run-nca/#iv-infusion","title":"IV Infusion","text":"<pre><code># 1-hour infusion\nresult = run_nca(\n    times, conc, dose,\n    route=\"iv_infusion\",\n    infusion_time=1.0\n)\n\nprint(f\"MRT (corrected): {result.mrt:.2f} h\")\n</code></pre>"},{"location":"python/nca/run-nca/#administration-routes","title":"Administration Routes","text":""},{"location":"python/nca/run-nca/#route-parameter-options","title":"Route Parameter Options","text":"Route Description MRT Correction <code>\"extravascular\"</code> Oral, SC, IM, etc. None <code>\"iv_bolus\"</code> IV bolus injection None <code>\"iv_infusion\"</code> IV infusion Subtract Tinf/2 <pre><code># Extravascular (default)\nresult = run_nca(times, conc, dose, route=\"extravascular\")\n\n# IV bolus\nresult = run_nca(times, conc, dose, route=\"iv_bolus\")\n\n# IV infusion (requires infusion_time)\nresult = run_nca(times, conc, dose, route=\"iv_infusion\", infusion_time=2.0)\n</code></pre>"},{"location":"python/nca/run-nca/#dosing-types","title":"Dosing Types","text":""},{"location":"python/nca/run-nca/#single-dose-default","title":"Single Dose (Default)","text":"<pre><code>result = run_nca(times, conc, dose, dosing_type=\"single\")\n</code></pre>"},{"location":"python/nca/run-nca/#multiple-dose-non-steady-state","title":"Multiple Dose (Non-Steady-State)","text":"<pre><code># Analysis during accumulation\nresult = run_nca(\n    times, conc, dose,\n    dosing_type=\"multiple\",\n    tau=12.0  # Dosing interval\n)\n\nprint(f\"AUC0-tau: {result.auc_0_tau:.2f}\")\n</code></pre>"},{"location":"python/nca/run-nca/#steady-state","title":"Steady State","text":"<pre><code># Steady-state analysis\nresult = run_nca(\n    times, conc, dose,\n    dosing_type=\"steady_state\",\n    tau=12.0\n)\n\nprint(f\"Cmax,ss: {result.cmax:.2f}\")\nprint(f\"Cmin,ss: {result.cmin:.2f}\")\nprint(f\"Cavg,ss: {result.cavg:.2f}\")\nprint(f\"AUC0-tau: {result.auc_0_tau:.2f}\")\nprint(f\"Fluctuation: {result.fluctuation:.1f}%\")\nprint(f\"Swing: {result.swing:.1f}%\")\nprint(f\"Accumulation Index: {result.accumulation_index:.2f}\")\n</code></pre>"},{"location":"python/nca/run-nca/#configuration-options","title":"Configuration Options","text":""},{"location":"python/nca/run-nca/#with-ncaconfig","title":"With NCAConfig","text":"<pre><code>from openpkpd.nca import run_nca, NCAConfig\n\nconfig = NCAConfig(\n    method=\"lin_log_mixed\",        # AUC calculation method\n    lambda_z_min_points=3,         # Minimum points for \u03bbz\n    lambda_z_r2_threshold=0.9,     # R\u00b2 threshold\n    extrapolation_max_pct=20.0,    # Warning threshold\n    lloq=0.05,                     # Lower limit of quantification\n    blq_handling=\"missing\"         # BLQ handling method\n)\n\nresult = run_nca(times, conc, dose, config=config)\n</code></pre> <p>See NCA Configuration for complete options.</p>"},{"location":"python/nca/run-nca/#ncaresult-attributes","title":"NCAResult Attributes","text":""},{"location":"python/nca/run-nca/#primary-exposure-metrics","title":"Primary Exposure Metrics","text":"<pre><code>result.cmax         # Maximum concentration\nresult.tmax         # Time of Cmax\nresult.cmin         # Minimum concentration (multiple dose)\nresult.clast        # Last measurable concentration\nresult.tlast        # Time of last measurable concentration\nresult.cavg         # Average concentration (steady state)\n</code></pre>"},{"location":"python/nca/run-nca/#auc-metrics","title":"AUC Metrics","text":"<pre><code>result.auc_0_t      # AUC from 0 to tlast\nresult.auc_0_inf    # AUC from 0 to infinity\nresult.auc_0_tau    # AUC over dosing interval\nresult.aumc_0_t     # AUMC from 0 to tlast\nresult.aumc_0_inf   # AUMC from 0 to infinity\nresult.auc_extra_pct  # % AUC extrapolated\n</code></pre>"},{"location":"python/nca/run-nca/#terminal-phase","title":"Terminal Phase","text":"<pre><code>result.t_half       # Terminal half-life\nresult.lambda_z_result.lambda_z       # Elimination rate constant\nresult.lambda_z_result.r_squared      # R\u00b2 of terminal regression\nresult.lambda_z_result.n_points       # Points used\nresult.lambda_z_result.intercept      # Y-intercept\n</code></pre>"},{"location":"python/nca/run-nca/#pk-parameters","title":"PK Parameters","text":"<pre><code>result.cl_f         # Apparent clearance (CL/F)\nresult.cl           # Clearance (IV route)\nresult.vz_f         # Apparent volume at terminal phase (Vz/F)\nresult.vz           # Volume at terminal phase (IV)\nresult.vss_f        # Apparent Vss\nresult.vss          # Volume at steady state (IV)\nresult.mrt          # Mean residence time\n</code></pre>"},{"location":"python/nca/run-nca/#multiple-dose-metrics","title":"Multiple Dose Metrics","text":"<pre><code>result.fluctuation         # Peak-trough fluctuation %\nresult.swing               # Swing %\nresult.accumulation_index  # Racc\n</code></pre>"},{"location":"python/nca/run-nca/#dose-normalized-metrics","title":"Dose-Normalized Metrics","text":"<pre><code>result.cmax_dn      # Cmax/Dose\nresult.auc_dn       # AUC/Dose\n</code></pre>"},{"location":"python/nca/run-nca/#quality-indicators","title":"Quality Indicators","text":"<pre><code>result.quality_flags   # List of quality issues\nresult.warnings        # Warning messages\n</code></pre>"},{"location":"python/nca/run-nca/#example-complete-analysis","title":"Example: Complete Analysis","text":"<pre><code>from openpkpd.nca import run_nca, NCAConfig\n\n# PK data from oral administration\ntimes = [0.0, 0.25, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 6.0, 8.0, 12.0, 24.0]\nconc = [0.0, 2.5, 4.8, 5.2, 4.5, 3.8, 2.6, 1.9, 1.0, 0.55, 0.18, 0.02]\ndose = 500.0  # mg\n\n# Configure with FDA/EMA-recommended settings\nconfig = NCAConfig(\n    method=\"lin_log_mixed\",      # Linear-up, log-linear down\n    lambda_z_min_points=3,       # At least 3 points for \u03bbz\n    lambda_z_r2_threshold=0.9,   # R\u00b2 \u2265 0.9\n    extrapolation_max_pct=20.0,  # Warn if &gt;20% extrapolated\n    lloq=0.01                    # LLOQ = 0.01 mg/L\n)\n\n# Run NCA\nresult = run_nca(times, conc, dose, config=config, route=\"extravascular\")\n\n# Report results\nprint(\"=\" * 50)\nprint(\"Non-Compartmental Analysis Report\")\nprint(\"=\" * 50)\n\nprint(\"\\n--- Primary Exposure Metrics ---\")\nprint(f\"Cmax:     {result.cmax:.2f} mg/L\")\nprint(f\"Tmax:     {result.tmax:.2f} h\")\nprint(f\"AUC0-t:   {result.auc_0_t:.2f} mg\u00b7h/L\")\nprint(f\"AUC0-inf: {result.auc_0_inf:.2f} mg\u00b7h/L\")\nprint(f\"AUC extrapolated: {result.auc_extra_pct:.1f}%\")\n\nprint(\"\\n--- Terminal Phase ---\")\nprint(f\"t\u00bd:       {result.t_half:.2f} h\")\nprint(f\"\u03bbz:       {result.lambda_z_result.lambda_z:.4f} 1/h\")\nprint(f\"\u03bbz R\u00b2:    {result.lambda_z_result.r_squared:.4f}\")\nprint(f\"Points:   {result.lambda_z_result.n_points}\")\n\nprint(\"\\n--- PK Parameters ---\")\nprint(f\"CL/F:     {result.cl_f:.2f} L/h\")\nprint(f\"Vz/F:     {result.vz_f:.1f} L\")\nprint(f\"Vss/F:    {result.vss_f:.1f} L\")\nprint(f\"MRT:      {result.mrt:.2f} h\")\n\nprint(\"\\n--- Dose-Normalized ---\")\nprint(f\"Cmax/D:   {result.cmax_dn:.4f} mg/L/mg\")\nprint(f\"AUC/D:    {result.auc_dn:.4f} h/L\")\n\n# Quality assessment\nprint(\"\\n--- Quality Assessment ---\")\nif result.lambda_z_result.r_squared &gt;= 0.9:\n    print(\"\u2713 \u03bbz R\u00b2 meets threshold\")\nelse:\n    print(\"\u26a0 \u03bbz R\u00b2 below threshold\")\n\nif result.auc_extra_pct &lt;= 20:\n    print(\"\u2713 AUC extrapolation acceptable\")\nelse:\n    print(\"\u26a0 High AUC extrapolation\")\n\nif result.warnings:\n    print(f\"Warnings: {result.warnings}\")\n</code></pre>"},{"location":"python/nca/run-nca/#working-with-numpy-arrays","title":"Working with NumPy Arrays","text":"<pre><code>import numpy as np\nfrom openpkpd.nca import run_nca\n\n# NumPy arrays work directly\ntimes = np.array([0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0])\nconc = np.array([0.0, 1.8, 2.5, 2.0, 1.2, 0.6, 0.3, 0.075])\n\nresult = run_nca(times, conc, 100.0)\n</code></pre>"},{"location":"python/nca/run-nca/#working-with-pandas","title":"Working with Pandas","text":"<pre><code>import pandas as pd\nfrom openpkpd.nca import run_nca\n\n# From DataFrame\ndf = pd.DataFrame({\n    'time': [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0],\n    'conc': [0.0, 1.8, 2.5, 2.0, 1.2, 0.6, 0.3, 0.075]\n})\n\nresult = run_nca(\n    df['time'].values,\n    df['conc'].values,\n    dose=100.0\n)\n</code></pre>"},{"location":"python/nca/run-nca/#error-handling","title":"Error Handling","text":"<pre><code>from openpkpd.nca import run_nca, NCAConfig\nimport math\n\n# Handle potential issues\nresult = run_nca(times, conc, dose)\n\n# Check for valid \u03bbz estimation\nif math.isnan(result.lambda_z_result.lambda_z):\n    print(\"WARNING: \u03bbz could not be estimated\")\n    print(\"AUC0-inf and t\u00bd are not reliable\")\n\n# Check extrapolation\nif result.auc_extra_pct &gt; 20:\n    print(f\"WARNING: {result.auc_extra_pct:.1f}% of AUC extrapolated\")\n\n# Access quality flags\nfor flag in result.quality_flags:\n    print(f\"Quality issue: {flag}\")\n</code></pre>"},{"location":"python/nca/run-nca/#see-also","title":"See Also","text":"<ul> <li>NCA Configuration - Configuration options</li> <li>Population NCA - Multi-subject analysis</li> <li>Bioequivalence - BE analysis</li> </ul>"},{"location":"python/population/","title":"Population Modeling","text":"<p>Comprehensive guide for population pharmacokinetic and pharmacodynamic modeling in OpenPKPD Python.</p>"},{"location":"python/population/#overview","title":"Overview","text":"<p>Population modeling accounts for variability between and within individuals, enabling realistic simulations and personalized predictions.</p> <pre><code>from openpkpd import simulate_population_oral\n\n# Simulate 100 subjects with IIV\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04, \"Ka\": 0.16},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/#documentation","title":"Documentation","text":"<ul> <li> <p> Population IV Bolus</p> <p>IV bolus simulation with IIV</p> <p> IV Bolus</p> </li> <li> <p> Population Oral</p> <p>Oral absorption with full variability</p> <p> Oral</p> </li> <li> <p> Covariates</p> <p>Weight, age, renal function effects</p> <p> Covariates</p> </li> </ul>"},{"location":"python/population/#key-concepts","title":"Key Concepts","text":""},{"location":"python/population/#inter-individual-variability-iiv","title":"Inter-Individual Variability (IIV)","text":"<p>Individual parameters differ from population values:</p> \\[P_i = \\theta \\cdot e^{\\eta_i}\\] <p>Where: - \\(P_i\\) = Individual parameter - \\(\\theta\\) = Population typical value - \\(\\eta_i\\) = Random effect, \\(\\eta_i \\sim N(0, \\omega^2)\\)</p> <pre><code># Omega values define variability\n# \u03c9\u00b2 = 0.09 corresponds to ~30% CV\nomegas = {\n    \"CL\": 0.09,   # 30% CV on clearance\n    \"V\": 0.04,    # 20% CV on volume\n    \"Ka\": 0.16    # 40% CV on absorption\n}\n</code></pre>"},{"location":"python/population/#omega-to-cv-relationship","title":"Omega to CV Relationship","text":"\u03c9\u00b2 \u03c9 CV (%) 0.01 0.10 10% 0.04 0.20 20% 0.09 0.30 30% 0.16 0.40 40% 0.25 0.50 50% <p>For small \u03c9: \\(CV \\approx \\omega\\)</p> <p>For larger \u03c9: \\(CV = \\sqrt{e^{\\omega^2} - 1}\\)</p>"},{"location":"python/population/#quick-start","title":"Quick Start","text":""},{"location":"python/population/#basic-population-simulation","title":"Basic Population Simulation","text":"<pre><code>from openpkpd import simulate_population_oral\n\n# Define parameters\nka = 1.5        # Absorption rate (/hr)\ncl = 10.0       # Clearance (L/hr)\nv = 50.0        # Volume (L)\n\n# Define dosing\ndoses = [{\"time\": 0.0, \"amount\": 500.0}]\n\n# Define IIV\nomegas = {\"CL\": 0.09, \"V\": 0.04, \"Ka\": 0.16}\n\n# Simulate population\nresult = simulate_population_oral(\n    ka=ka, cl=cl, v=v,\n    doses=doses,\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,                    # 100 subjects\n    omegas=omegas,\n    seed=42                   # For reproducibility\n)\n\n# Access results\nprint(f\"Subjects simulated: {len(result.individuals)}\")\nprint(f\"Time points: {len(result.times)}\")\n</code></pre>"},{"location":"python/population/#accessing-individual-results","title":"Accessing Individual Results","text":"<pre><code># Individual concentration profiles\nfor i, individual in enumerate(result.individuals[:5]):\n    cmax = max(individual.concentrations)\n    tmax_idx = individual.concentrations.index(cmax)\n    tmax = result.times[tmax_idx]\n    print(f\"Subject {i+1}: Cmax={cmax:.2f} mg/L at Tmax={tmax:.1f} hr\")\n\n# Individual parameters\nfor i, params in enumerate(result.individual_params[:5]):\n    print(f\"Subject {i+1}: CL={params['CL']:.2f}, V={params['V']:.2f}, Ka={params['Ka']:.2f}\")\n</code></pre>"},{"location":"python/population/#population-summaries","title":"Population Summaries","text":"<pre><code># Summary statistics at each time point\nprint(f\"Mean concentrations: {result.mean}\")\nprint(f\"Median concentrations: {result.median}\")\nprint(f\"5th percentile: {result.percentiles[5]}\")\nprint(f\"95th percentile: {result.percentiles[95]}\")\n\n# Population metrics\nimport numpy as np\nall_cmax = [max(ind.concentrations) for ind in result.individuals]\nprint(f\"Mean Cmax: {np.mean(all_cmax):.2f} \u00b1 {np.std(all_cmax):.2f} mg/L\")\nprint(f\"CV(Cmax): {np.std(all_cmax)/np.mean(all_cmax)*100:.1f}%\")\n</code></pre>"},{"location":"python/population/#simulation-functions","title":"Simulation Functions","text":""},{"location":"python/population/#simulate_population_iv_bolus","title":"simulate_population_iv_bolus","text":"<pre><code>from openpkpd import simulate_population_iv_bolus\n\nresult = simulate_population_iv_bolus(\n    cl=10.0,                    # Clearance (L/hr)\n    v=50.0,                     # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,                     # Start time\n    t1=24.0,                    # End time\n    saveat=0.5,                 # Time step\n    n=100,                      # Number of subjects\n    omegas={\"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/#simulate_population_oral","title":"simulate_population_oral","text":"<pre><code>from openpkpd import simulate_population_oral\n\nresult = simulate_population_oral(\n    ka=1.5,                     # Absorption rate (/hr)\n    cl=10.0,                    # Clearance (L/hr)\n    v=50.0,                     # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04, \"Ka\": 0.16},\n    seed=42,\n\n    # Optional: IOV\n    iov_pis={\"CL\": 0.0225, \"Ka\": 0.01},\n    iov_seed=12345,\n\n    # Optional: Covariates\n    covariates=[{\"WT\": 80.0, \"AGE\": 45.0} for _ in range(100)],\n    covariate_effects=[\n        {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75}\n    ]\n)\n</code></pre>"},{"location":"python/population/#populationresult-structure","title":"PopulationResult Structure","text":"<pre><code>@dataclass\nclass PopulationResult:\n    \"\"\"Result of population simulation.\"\"\"\n\n    # Time grid\n    times: list[float]\n\n    # Individual results\n    individuals: list[IndividualResult]\n    individual_params: list[dict[str, float]]\n    etas: dict[str, list[float]]\n\n    # Summary statistics\n    mean: list[float]\n    median: list[float]\n    sd: list[float]\n    percentiles: dict[int, list[float]]\n\n    # Metadata\n    n_subjects: int\n    seed: int\n</code></pre>"},{"location":"python/population/#correlated-random-effects","title":"Correlated Random Effects","text":""},{"location":"python/population/#full-omega-matrix","title":"Full Omega Matrix","text":"<pre><code>import numpy as np\nfrom openpkpd import simulate_population_oral\n\n# Define correlation between CL and V\n# Variance: CL=0.09, V=0.04\n# Covariance: 0.03 (correlation \u2248 0.5)\nomega_matrix = np.array([\n    [0.09, 0.03],   # CL\n    [0.03, 0.04]    # V\n])\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omega_matrix=omega_matrix,\n    omega_params=[\"CL\", \"V\"],\n    omegas={\"Ka\": 0.16},  # Ka uncorrelated\n    seed=42\n)\n\n# Check correlation in realized parameters\ncl_vals = [p[\"CL\"] for p in result.individual_params]\nv_vals = [p[\"V\"] for p in result.individual_params]\nprint(f\"Correlation CL-V: {np.corrcoef(cl_vals, v_vals)[0,1]:.3f}\")\n</code></pre>"},{"location":"python/population/#multiple-dose-simulations","title":"Multiple Dose Simulations","text":""},{"location":"python/population/#steady-state-simulation","title":"Steady-State Simulation","text":"<pre><code># Multiple dose regimen (7 days QD)\ndoses = [\n    {\"time\": i * 24.0, \"amount\": 500.0}\n    for i in range(7)\n]\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=168.0, saveat=1.0,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04, \"Ka\": 0.16},\n    seed=42\n)\n\n# Extract steady-state metrics (last dosing interval)\nss_start_idx = result.times.index(144.0)  # Day 7\nfor ind in result.individuals[:5]:\n    ss_conc = ind.concentrations[ss_start_idx:]\n    cmax_ss = max(ss_conc)\n    cmin_ss = min(ss_conc)\n    print(f\"Cmax,ss={cmax_ss:.2f}, Cmin,ss={cmin_ss:.2f}\")\n</code></pre>"},{"location":"python/population/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import simulate_population_oral\nimport numpy as np\n\n# =========================================\n# Comprehensive Population Simulation\n# =========================================\n\nprint(\"=== Population PK Simulation ===\\n\")\n\n# 1. Model parameters\nprint(\"--- Model Parameters ---\")\nka = 1.5       # /hr\ncl = 10.0      # L/hr\nv = 50.0       # L\nprint(f\"Ka = {ka} /hr, CL = {cl} L/hr, V = {v} L\")\nprint(f\"t1/2 = {0.693 * v / cl:.1f} hr\")\n\n# 2. IIV specification\nprint(\"\\n--- Inter-Individual Variability ---\")\nomegas = {\"CL\": 0.09, \"V\": 0.04, \"Ka\": 0.16}\nfor param, omega in omegas.items():\n    cv = np.sqrt(np.exp(omega) - 1) * 100\n    print(f\"  {param}: \u03c9\u00b2 = {omega}, CV \u2248 {cv:.0f}%\")\n\n# 3. Covariate effects\nprint(\"\\n--- Covariate Model ---\")\ncovariate_effects = [\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0},\n    {\"param\": \"CL\", \"cov\": \"AGE\", \"ref\": 45.0, \"kind\": \"LinearCovariate\", \"beta\": -0.005}\n]\nfor eff in covariate_effects:\n    print(f\"  {eff['param']} ~ {eff['cov']}: {eff['kind']} (\u03b2={eff['beta']})\")\n\n# 4. Generate population covariates\nnp.random.seed(42)\nn = 200\ncovariates = []\nfor _ in range(n):\n    wt = np.random.normal(75, 15)\n    age = np.random.normal(50, 12)\n    covariates.append({\"WT\": max(45, min(150, wt)), \"AGE\": max(18, min(85, age))})\n\nwts = [c[\"WT\"] for c in covariates]\nages = [c[\"AGE\"] for c in covariates]\nprint(f\"\\n--- Population Covariates ---\")\nprint(f\"  WT: {np.mean(wts):.1f} \u00b1 {np.std(wts):.1f} kg\")\nprint(f\"  AGE: {np.mean(ages):.1f} \u00b1 {np.std(ages):.1f} years\")\n\n# 5. Dosing\ndoses = [{\"time\": 0.0, \"amount\": 500.0}]\n\n# 6. Simulate\nprint(\"\\n--- Simulation ---\")\nresult = simulate_population_oral(\n    ka=ka, cl=cl, v=v,\n    doses=doses,\n    t0=0.0, t1=48.0, saveat=0.5,\n    n=n,\n    omegas=omegas,\n    covariates=covariates,\n    covariate_effects=covariate_effects,\n    seed=12345\n)\nprint(f\"Simulated {result.n_subjects} subjects\")\n\n# 7. PK metrics\nprint(\"\\n--- PK Metrics ---\")\nall_cmax = [max(ind.concentrations) for ind in result.individuals]\nall_tmax = [result.times[ind.concentrations.index(max(ind.concentrations))]\n            for ind in result.individuals]\n\n# Approximate AUC\ndef trapezoidal_auc(times, conc):\n    auc = 0.0\n    for i in range(1, len(times)):\n        auc += 0.5 * (conc[i] + conc[i-1]) * (times[i] - times[i-1])\n    return auc\n\nall_auc = [trapezoidal_auc(result.times, ind.concentrations)\n           for ind in result.individuals]\n\nprint(f\"Cmax: {np.mean(all_cmax):.2f} \u00b1 {np.std(all_cmax):.2f} mg/L\")\nprint(f\"Tmax: {np.mean(all_tmax):.2f} \u00b1 {np.std(all_tmax):.2f} hr\")\nprint(f\"AUC:  {np.mean(all_auc):.1f} \u00b1 {np.std(all_auc):.1f} mg\u00b7hr/L\")\n\nprint(f\"\\nCV(Cmax): {np.std(all_cmax)/np.mean(all_cmax)*100:.1f}%\")\nprint(f\"CV(AUC):  {np.std(all_auc)/np.mean(all_auc)*100:.1f}%\")\n\n# 8. Percentiles\nprint(\"\\n--- Population Percentiles ---\")\nfor pct in [5, 25, 50, 75, 95]:\n    cmax_pct = np.percentile(all_cmax, pct)\n    auc_pct = np.percentile(all_auc, pct)\n    print(f\"  {pct}th: Cmax={cmax_pct:.2f}, AUC={auc_pct:.1f}\")\n\n# 9. Covariate impact\nprint(\"\\n--- Covariate Impact ---\")\n# By weight\nlow_wt = [all_auc[i] for i in range(n) if covariates[i][\"WT\"] &lt; 60]\nhigh_wt = [all_auc[i] for i in range(n) if covariates[i][\"WT\"] &gt; 90]\nprint(f\"AUC (WT &lt; 60 kg): {np.mean(low_wt):.1f} mg\u00b7hr/L\")\nprint(f\"AUC (WT &gt; 90 kg): {np.mean(high_wt):.1f} mg\u00b7hr/L\")\n\n# By age\nyoung = [all_auc[i] for i in range(n) if covariates[i][\"AGE\"] &lt; 35]\nold = [all_auc[i] for i in range(n) if covariates[i][\"AGE\"] &gt; 65]\nprint(f\"AUC (AGE &lt; 35): {np.mean(young):.1f} mg\u00b7hr/L\")\nprint(f\"AUC (AGE &gt; 65): {np.mean(old):.1f} mg\u00b7hr/L\")\n</code></pre>"},{"location":"python/population/#next-steps","title":"Next Steps","text":"<ul> <li>Population IV Bolus - IV bolus with IIV</li> <li>Population Oral - Oral absorption models</li> <li>Covariates - Covariate modeling details</li> <li>Estimation - Fitting population models</li> <li>VPC - Visual predictive checks</li> </ul>"},{"location":"python/population/covariates/","title":"Covariates","text":"<p>Comprehensive guide for incorporating patient characteristics into population models in OpenPKPD Python.</p>"},{"location":"python/population/covariates/#overview","title":"Overview","text":"<p>Covariate models explain inter-individual variability by relating PK parameters to measurable patient characteristics.</p> <pre><code>from openpkpd import simulate_population_oral\n\n# Weight effect on CL and V\ncovariate_effects = [\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0}\n]\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.04, \"V\": 0.02},\n    covariates=[{\"WT\": w} for w in weights],\n    covariate_effects=covariate_effects,\n    seed=42\n)\n</code></pre>"},{"location":"python/population/covariates/#covariate-effect-types","title":"Covariate Effect Types","text":""},{"location":"python/population/covariates/#power-model","title":"Power Model","text":"<p>Most common for body size effects:</p> \\[\\theta_i = \\theta_{pop} \\cdot \\left(\\frac{cov_i}{ref}\\right)^{\\beta}\\] <pre><code># Allometric scaling\neffect = {\n    \"param\": \"CL\",\n    \"cov\": \"WT\",\n    \"ref\": 70.0,           # Reference weight\n    \"kind\": \"PowerCovariate\",\n    \"beta\": 0.75           # Allometric exponent\n}\n\n# Common allometric exponents:\n# Clearance: 0.75 (3/4 power law)\n# Volume: 1.0 (proportional to body size)\n# Half-life: 0.25 (1/4 power)\n</code></pre>"},{"location":"python/population/covariates/#linear-model","title":"Linear Model","text":"<p>Effect proportional to deviation from reference:</p> \\[\\theta_i = \\theta_{pop} \\cdot (1 + \\beta \\cdot (cov_i - ref))\\] <pre><code># Age effect\neffect = {\n    \"param\": \"CL\",\n    \"cov\": \"AGE\",\n    \"ref\": 45.0,           # Reference age\n    \"kind\": \"LinearCovariate\",\n    \"beta\": -0.006         # -0.6% per year\n}\n\n# For a 65-year-old:\n# CL = CL_pop * (1 + (-0.006) * (65 - 45))\n# CL = CL_pop * 0.88 (12% lower)\n</code></pre>"},{"location":"python/population/covariates/#exponential-model","title":"Exponential Model","text":"<p>Multiplicative effect:</p> \\[\\theta_i = \\theta_{pop} \\cdot e^{\\beta \\cdot (cov_i - ref)}\\] <pre><code># Renal function effect\neffect = {\n    \"param\": \"CL\",\n    \"cov\": \"CRCL\",\n    \"ref\": 100.0,          # Normal CRCL\n    \"kind\": \"ExpCovariate\",\n    \"beta\": 0.005\n}\n\n# For CRCL = 50:\n# CL = CL_pop * exp(0.005 * (50 - 100))\n# CL = CL_pop * 0.78 (22% lower)\n</code></pre>"},{"location":"python/population/covariates/#effect-specification-format","title":"Effect Specification Format","text":""},{"location":"python/population/covariates/#dictionary-format","title":"Dictionary Format","text":"<pre><code>covariate_effects = [\n    {\n        \"param\": str,      # Target parameter: \"CL\", \"V\", \"Ka\", etc.\n        \"cov\": str,        # Covariate name: \"WT\", \"AGE\", \"CRCL\", etc.\n        \"ref\": float,      # Reference value for centering\n        \"kind\": str,       # \"PowerCovariate\", \"LinearCovariate\", \"ExpCovariate\"\n        \"beta\": float      # Effect coefficient\n    }\n]\n</code></pre>"},{"location":"python/population/covariates/#multiple-effects","title":"Multiple Effects","text":"<pre><code># Comprehensive covariate model\ncovariate_effects = [\n    # Body size effects\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0},\n\n    # Age effect\n    {\"param\": \"CL\", \"cov\": \"AGE\", \"ref\": 45.0, \"kind\": \"LinearCovariate\", \"beta\": -0.005},\n\n    # Renal function\n    {\"param\": \"CL\", \"cov\": \"CRCL\", \"ref\": 100.0, \"kind\": \"LinearCovariate\", \"beta\": 0.004},\n\n    # Sex effect (0=male, 1=female)\n    {\"param\": \"CL\", \"cov\": \"SEX\", \"ref\": 0.0, \"kind\": \"LinearCovariate\", \"beta\": -0.15}\n]\n</code></pre>"},{"location":"python/population/covariates/#subject-covariates","title":"Subject Covariates","text":""},{"location":"python/population/covariates/#providing-covariate-data","title":"Providing Covariate Data","text":"<pre><code>import numpy as np\n\n# Generate realistic population\nnp.random.seed(42)\nn = 200\n\ncovariates = []\nfor _ in range(n):\n    sex = 1 if np.random.random() &lt; 0.5 else 0\n    age = np.clip(np.random.normal(50, 12), 18, 85)\n    # Weight depends on sex\n    wt = np.random.normal(75 if sex == 0 else 65, 12 if sex == 0 else 10)\n    wt = np.clip(wt, 45, 150)\n    # CRCL depends on age\n    crcl = np.clip(130 - age * 0.8 + np.random.normal(0, 15), 15, 150)\n\n    covariates.append({\n        \"WT\": wt,\n        \"AGE\": age,\n        \"SEX\": sex,\n        \"CRCL\": crcl\n    })\n</code></pre>"},{"location":"python/population/covariates/#covariate-summary","title":"Covariate Summary","text":"<pre><code>def summarize_covariates(covariates):\n    \"\"\"Summarize population covariates.\"\"\"\n    wts = [c[\"WT\"] for c in covariates]\n    ages = [c[\"AGE\"] for c in covariates]\n    crcls = [c[\"CRCL\"] for c in covariates]\n    sexes = [c[\"SEX\"] for c in covariates]\n\n    print(\"Covariate Summary:\")\n    print(f\"  WT: {np.mean(wts):.1f} \u00b1 {np.std(wts):.1f} kg\")\n    print(f\"  AGE: {np.mean(ages):.1f} \u00b1 {np.std(ages):.1f} years\")\n    print(f\"  CRCL: {np.mean(crcls):.1f} \u00b1 {np.std(crcls):.1f} mL/min\")\n    print(f\"  Female: {np.mean(sexes)*100:.0f}%\")\n\nsummarize_covariates(covariates)\n</code></pre>"},{"location":"python/population/covariates/#common-covariate-models","title":"Common Covariate Models","text":""},{"location":"python/population/covariates/#allometric-scaling","title":"Allometric Scaling","text":"<pre><code># Standard allometry for all structural parameters\nallometric_effects = [\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V1\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0},\n    {\"param\": \"Q\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V2\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0}\n]\n</code></pre>"},{"location":"python/population/covariates/#renal-function","title":"Renal Function","text":"<pre><code># Creatinine clearance effect\nrenal_effects = [\n    {\"param\": \"CL\", \"cov\": \"CRCL\", \"ref\": 100.0, \"kind\": \"LinearCovariate\", \"beta\": 0.005}\n]\n\n# Or using eGFR\negfr_effects = [\n    {\"param\": \"CL\", \"cov\": \"EGFR\", \"ref\": 90.0, \"kind\": \"PowerCovariate\", \"beta\": 0.5}\n]\n</code></pre>"},{"location":"python/population/covariates/#age-effects","title":"Age Effects","text":"<pre><code># Linear decline with age\nage_linear = {\"param\": \"CL\", \"cov\": \"AGE\", \"ref\": 40.0, \"kind\": \"LinearCovariate\", \"beta\": -0.006}\n\n# Maturation (pediatric)\nmaturation = {\"param\": \"CL\", \"cov\": \"PMA\", \"ref\": 40.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75}\n</code></pre>"},{"location":"python/population/covariates/#sexgender","title":"Sex/Gender","text":"<pre><code># Female vs male (reference)\nsex_effect = {\"param\": \"CL\", \"cov\": \"SEX\", \"ref\": 0.0, \"kind\": \"LinearCovariate\", \"beta\": -0.12}\n# Female CL = CL_pop * (1 - 0.12) = 88% of male CL\n</code></pre>"},{"location":"python/population/covariates/#genetic-polymorphisms","title":"Genetic Polymorphisms","text":"<pre><code># CYP2D6 status as numeric score\n# PM=0, IM=0.5, EM=1.0 (ref), UM=1.5\ncyp_effect = {\"param\": \"CL\", \"cov\": \"CYP2D6\", \"ref\": 1.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0}\n</code></pre>"},{"location":"python/population/covariates/#simulation-with-covariates","title":"Simulation with Covariates","text":""},{"location":"python/population/covariates/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import simulate_population_oral\nimport numpy as np\n\n# 1. Generate population\nnp.random.seed(42)\nn = 200\n\ncovariates = []\nfor _ in range(n):\n    sex = 1 if np.random.random() &lt; 0.48 else 0\n    age = np.clip(np.random.normal(55, 14), 18, 85)\n    wt = np.clip(np.random.normal(70 + sex * -8, 15), 40, 150)\n    crcl = np.clip(130 - age * 0.9 + np.random.normal(0, 20), 15, 150)\n\n    covariates.append({\"WT\": wt, \"AGE\": age, \"SEX\": sex, \"CRCL\": crcl})\n\n# 2. Define covariate model\ncovariate_effects = [\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0},\n    {\"param\": \"CL\", \"cov\": \"AGE\", \"ref\": 45.0, \"kind\": \"LinearCovariate\", \"beta\": -0.005},\n    {\"param\": \"CL\", \"cov\": \"CRCL\", \"ref\": 100.0, \"kind\": \"LinearCovariate\", \"beta\": 0.003},\n    {\"param\": \"CL\", \"cov\": \"SEX\", \"ref\": 0.0, \"kind\": \"LinearCovariate\", \"beta\": -0.10}\n]\n\n# 3. Reduced IIV (covariates explain variability)\nomegas = {\"Ka\": 0.16, \"CL\": 0.0225, \"V\": 0.01}\n\n# 4. Simulate\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=n,\n    omegas=omegas,\n    covariates=covariates,\n    covariate_effects=covariate_effects,\n    seed=12345\n)\n\n# 5. Analyze covariate impact\ncl_vals = np.array([p[\"CL\"] for p in result.individual_params])\nwts = np.array([c[\"WT\"] for c in covariates])\nages = np.array([c[\"AGE\"] for c in covariates])\ncrcls = np.array([c[\"CRCL\"] for c in covariates])\nsexes = np.array([c[\"SEX\"] for c in covariates])\n\nprint(\"Covariate-CL Correlations:\")\nprint(f\"  WT-CL:   r = {np.corrcoef(wts, cl_vals)[0,1]:.3f}\")\nprint(f\"  AGE-CL:  r = {np.corrcoef(ages, cl_vals)[0,1]:.3f}\")\nprint(f\"  CRCL-CL: r = {np.corrcoef(crcls, cl_vals)[0,1]:.3f}\")\n</code></pre>"},{"location":"python/population/covariates/#covariate-impact-analysis","title":"Covariate Impact Analysis","text":""},{"location":"python/population/covariates/#group-comparisons","title":"Group Comparisons","text":"<pre><code># CL by sex\nmale_cl = cl_vals[sexes == 0]\nfemale_cl = cl_vals[sexes == 1]\nprint(f\"Male CL: {np.mean(male_cl):.2f} L/hr\")\nprint(f\"Female CL: {np.mean(female_cl):.2f} L/hr\")\nprint(f\"Ratio (F/M): {np.mean(female_cl)/np.mean(male_cl):.2f}\")\n\n# AUC by renal function\nauc_vals = [np.trapz(ind.concentrations, result.times) for ind in result.individuals]\n\nnormal_crcl = [auc_vals[i] for i in range(n) if crcls[i] &gt;= 90]\nmild_ri = [auc_vals[i] for i in range(n) if 60 &lt;= crcls[i] &lt; 90]\nmoderate_ri = [auc_vals[i] for i in range(n) if 30 &lt;= crcls[i] &lt; 60]\n\nprint(f\"\\nAUC by Renal Function:\")\nprint(f\"  Normal (CRCL \u226590): {np.mean(normal_crcl):.1f} mg\u00b7hr/L\")\nprint(f\"  Mild RI (60-89):   {np.mean(mild_ri):.1f} mg\u00b7hr/L\")\nprint(f\"  Moderate RI (30-59): {np.mean(moderate_ri):.1f} mg\u00b7hr/L\")\n</code></pre>"},{"location":"python/population/covariates/#quartile-analysis","title":"Quartile Analysis","text":"<pre><code># CL by weight quartiles\nwt_quartiles = np.percentile(wts, [25, 50, 75])\n\nq1_cl = cl_vals[wts &lt;= wt_quartiles[0]]\nq2_cl = cl_vals[(wts &gt; wt_quartiles[0]) &amp; (wts &lt;= wt_quartiles[1])]\nq3_cl = cl_vals[(wts &gt; wt_quartiles[1]) &amp; (wts &lt;= wt_quartiles[2])]\nq4_cl = cl_vals[wts &gt; wt_quartiles[2]]\n\nprint(\"CL by Weight Quartile:\")\nprint(f\"  Q1 (\u2264{wt_quartiles[0]:.0f} kg): {np.mean(q1_cl):.2f} L/hr\")\nprint(f\"  Q2 ({wt_quartiles[0]:.0f}-{wt_quartiles[1]:.0f} kg): {np.mean(q2_cl):.2f} L/hr\")\nprint(f\"  Q3 ({wt_quartiles[1]:.0f}-{wt_quartiles[2]:.0f} kg): {np.mean(q3_cl):.2f} L/hr\")\nprint(f\"  Q4 (&gt;{wt_quartiles[2]:.0f} kg): {np.mean(q4_cl):.2f} L/hr\")\n</code></pre>"},{"location":"python/population/covariates/#exposure-predictions","title":"Exposure Predictions","text":""},{"location":"python/population/covariates/#subgroup-exposure","title":"Subgroup Exposure","text":"<pre><code>def predict_exposure_subgroup(result, covariates, subgroup_filter):\n    \"\"\"Calculate exposure metrics for a subgroup.\"\"\"\n    indices = [i for i, c in enumerate(covariates) if subgroup_filter(c)]\n\n    if not indices:\n        return None\n\n    cmax_vals = [max(result.individuals[i].concentrations) for i in indices]\n    auc_vals = [np.trapz(result.individuals[i].concentrations, result.times)\n                for i in indices]\n\n    return {\n        \"n\": len(indices),\n        \"Cmax_mean\": np.mean(cmax_vals),\n        \"Cmax_cv\": np.std(cmax_vals) / np.mean(cmax_vals) * 100,\n        \"AUC_mean\": np.mean(auc_vals),\n        \"AUC_cv\": np.std(auc_vals) / np.mean(auc_vals) * 100\n    }\n\n# Compare subgroups\nelderly = predict_exposure_subgroup(result, covariates, lambda c: c[\"AGE\"] &gt;= 65)\nyoung = predict_exposure_subgroup(result, covariates, lambda c: c[\"AGE\"] &lt; 40)\n\nprint(\"Exposure by Age Group:\")\nprint(f\"  Young (&lt;40y): AUC = {young['AUC_mean']:.1f} mg\u00b7hr/L\")\nprint(f\"  Elderly (\u226565y): AUC = {elderly['AUC_mean']:.1f} mg\u00b7hr/L\")\nprint(f\"  Ratio (elderly/young): {elderly['AUC_mean']/young['AUC_mean']:.2f}\")\n</code></pre>"},{"location":"python/population/covariates/#visualization","title":"Visualization","text":"<pre><code>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# Weight vs CL\nax = axes[0, 0]\nax.scatter(wts, cl_vals, alpha=0.5)\n# Add regression line\nm, b = np.polyfit(wts, cl_vals, 1)\nax.plot([min(wts), max(wts)], [m*min(wts)+b, m*max(wts)+b], 'r--')\nax.set_xlabel('Weight (kg)')\nax.set_ylabel('CL (L/hr)')\nax.set_title(f'Weight vs CL (r={np.corrcoef(wts, cl_vals)[0,1]:.3f})')\n\n# Age vs CL\nax = axes[0, 1]\nax.scatter(ages, cl_vals, alpha=0.5)\nm, b = np.polyfit(ages, cl_vals, 1)\nax.plot([min(ages), max(ages)], [m*min(ages)+b, m*max(ages)+b], 'r--')\nax.set_xlabel('Age (years)')\nax.set_ylabel('CL (L/hr)')\nax.set_title(f'Age vs CL (r={np.corrcoef(ages, cl_vals)[0,1]:.3f})')\n\n# CRCL vs CL\nax = axes[1, 0]\nax.scatter(crcls, cl_vals, alpha=0.5)\nm, b = np.polyfit(crcls, cl_vals, 1)\nax.plot([min(crcls), max(crcls)], [m*min(crcls)+b, m*max(crcls)+b], 'r--')\nax.set_xlabel('CRCL (mL/min)')\nax.set_ylabel('CL (L/hr)')\nax.set_title(f'CRCL vs CL (r={np.corrcoef(crcls, cl_vals)[0,1]:.3f})')\n\n# CL by sex (box plot)\nax = axes[1, 1]\nax.boxplot([male_cl, female_cl], labels=['Male', 'Female'])\nax.set_ylabel('CL (L/hr)')\nax.set_title('CL by Sex')\n\nplt.tight_layout()\nplt.savefig('covariate_effects.png', dpi=150)\nplt.show()\n</code></pre>"},{"location":"python/population/covariates/#complete-example_1","title":"Complete Example","text":"<pre><code>from openpkpd import simulate_population_oral\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# =========================================\n# Comprehensive Covariate Analysis\n# =========================================\n\nprint(\"=== Covariate Modeling ===\\n\")\n\n# 1. Generate realistic patient population\nnp.random.seed(42)\nn = 300\n\ncovariates = []\nfor _ in range(n):\n    sex = 1 if np.random.random() &lt; 0.48 else 0\n    age = np.clip(np.random.normal(58, 15), 18, 90)\n    bmi = np.clip(np.random.normal(27, 5), 18, 45)\n    ht = np.random.normal(175 - sex * 12, 8)\n    wt = bmi * (ht / 100) ** 2\n    wt = np.clip(wt, 40, 180)\n    crcl = max(15, 140 - age + (1 - sex) * 15 + np.random.normal(0, 20))\n\n    covariates.append({\n        \"WT\": wt, \"AGE\": age, \"SEX\": sex,\n        \"HT\": ht, \"BMI\": bmi, \"CRCL\": crcl\n    })\n\n# 2. Covariate summary\nprint(\"--- Population Covariates ---\")\nfor cov in [\"WT\", \"AGE\", \"BMI\", \"CRCL\"]:\n    vals = [c[cov] for c in covariates]\n    print(f\"  {cov}: {np.mean(vals):.1f} \u00b1 {np.std(vals):.1f}\")\nsexes = [c[\"SEX\"] for c in covariates]\nprint(f\"  Female: {np.mean(sexes)*100:.0f}%\")\n\n# 3. Covariate model\ncovariate_effects = [\n    # Allometry\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0},\n    # Demographics\n    {\"param\": \"CL\", \"cov\": \"AGE\", \"ref\": 50.0, \"kind\": \"LinearCovariate\", \"beta\": -0.006},\n    {\"param\": \"CL\", \"cov\": \"SEX\", \"ref\": 0.0, \"kind\": \"LinearCovariate\", \"beta\": -0.08},\n    # Renal\n    {\"param\": \"CL\", \"cov\": \"CRCL\", \"ref\": 100.0, \"kind\": \"LinearCovariate\", \"beta\": 0.004}\n]\n\nprint(\"\\n--- Covariate Effects ---\")\nfor eff in covariate_effects:\n    print(f\"  {eff['param']} ~ {eff['cov']}: {eff['kind']} (\u03b2={eff['beta']})\")\n\n# 4. Simulate\nprint(\"\\n--- Simulation ---\")\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=48.0, saveat=0.5,\n    n=n,\n    omegas={\"Ka\": 0.16, \"CL\": 0.02, \"V\": 0.01},  # Low residual IIV\n    covariates=covariates,\n    covariate_effects=covariate_effects,\n    seed=12345\n)\nprint(f\"Simulated {result.n_subjects} subjects\")\n\n# 5. Parameter distributions\nprint(\"\\n--- Realized Parameters ---\")\ncl_vals = np.array([p[\"CL\"] for p in result.individual_params])\nv_vals = np.array([p[\"V\"] for p in result.individual_params])\nka_vals = np.array([p[\"Ka\"] for p in result.individual_params])\n\nprint(f\"CL: {np.mean(cl_vals):.2f} \u00b1 {np.std(cl_vals):.2f} L/hr (CV={np.std(cl_vals)/np.mean(cl_vals)*100:.0f}%)\")\nprint(f\"V:  {np.mean(v_vals):.1f} \u00b1 {np.std(v_vals):.1f} L (CV={np.std(v_vals)/np.mean(v_vals)*100:.0f}%)\")\n\n# 6. Covariate correlations\nprint(\"\\n--- Covariate Correlations with CL ---\")\nwts = np.array([c[\"WT\"] for c in covariates])\nages = np.array([c[\"AGE\"] for c in covariates])\ncrcls = np.array([c[\"CRCL\"] for c in covariates])\n\nfor cov, vals in [(\"WT\", wts), (\"AGE\", ages), (\"CRCL\", crcls)]:\n    r = np.corrcoef(vals, cl_vals)[0, 1]\n    print(f\"  {cov}: r = {r:.3f}\")\n\n# 7. Subgroup analysis\nprint(\"\\n--- Subgroup Exposure Analysis ---\")\nauc_vals = [np.trapz(ind.concentrations, result.times) for ind in result.individuals]\n\n# By renal function\nnormal = [auc_vals[i] for i in range(n) if covariates[i][\"CRCL\"] &gt;= 90]\nmild = [auc_vals[i] for i in range(n) if 60 &lt;= covariates[i][\"CRCL\"] &lt; 90]\nmoderate = [auc_vals[i] for i in range(n) if 30 &lt;= covariates[i][\"CRCL\"] &lt; 60]\nsevere = [auc_vals[i] for i in range(n) if covariates[i][\"CRCL\"] &lt; 30]\n\nprint(\"AUC by Renal Function:\")\nprint(f\"  Normal (n={len(normal)}): {np.mean(normal):.1f} mg\u00b7hr/L\")\nif mild: print(f\"  Mild RI (n={len(mild)}): {np.mean(mild):.1f} mg\u00b7hr/L ({np.mean(mild)/np.mean(normal):.2f}x)\")\nif moderate: print(f\"  Moderate RI (n={len(moderate)}): {np.mean(moderate):.1f} mg\u00b7hr/L ({np.mean(moderate)/np.mean(normal):.2f}x)\")\nif severe: print(f\"  Severe RI (n={len(severe)}): {np.mean(severe):.1f} mg\u00b7hr/L ({np.mean(severe)/np.mean(normal):.2f}x)\")\n\n# By age\nyoung = [auc_vals[i] for i in range(n) if covariates[i][\"AGE\"] &lt; 40]\nmiddle = [auc_vals[i] for i in range(n) if 40 &lt;= covariates[i][\"AGE\"] &lt; 65]\nelderly = [auc_vals[i] for i in range(n) if covariates[i][\"AGE\"] &gt;= 65]\n\nprint(\"\\nAUC by Age:\")\nprint(f\"  &lt;40 years (n={len(young)}): {np.mean(young):.1f} mg\u00b7hr/L\")\nprint(f\"  40-64 years (n={len(middle)}): {np.mean(middle):.1f} mg\u00b7hr/L\")\nprint(f\"  \u226565 years (n={len(elderly)}): {np.mean(elderly):.1f} mg\u00b7hr/L ({np.mean(elderly)/np.mean(young):.2f}x)\")\n\n# 8. Dosing implications\nprint(\"\\n--- Dosing Implications ---\")\n# Target AUC of 50 mg\u00b7hr/L\ntarget_auc = 50.0\ndose_adjustments = []\n\nfor i in range(n):\n    current_auc = auc_vals[i]\n    adj_factor = target_auc / current_auc\n    adjusted_dose = 500.0 * adj_factor\n    dose_adjustments.append(adjusted_dose)\n\nprint(f\"Target AUC: {target_auc} mg\u00b7hr/L\")\nprint(f\"Dose adjustments needed:\")\nprint(f\"  Range: {np.min(dose_adjustments):.0f} - {np.max(dose_adjustments):.0f} mg\")\nprint(f\"  Mean: {np.mean(dose_adjustments):.0f} mg\")\nprint(f\"  Subjects needing &lt;75% dose: {sum(1 for d in dose_adjustments if d &lt; 375)/n*100:.0f}%\")\nprint(f\"  Subjects needing &gt;125% dose: {sum(1 for d in dose_adjustments if d &gt; 625)/n*100:.0f}%\")\n</code></pre>"},{"location":"python/population/covariates/#see-also","title":"See Also","text":"<ul> <li>Population IV Bolus - IV bolus with covariates</li> <li>Population Oral - Oral models with covariates</li> <li>Julia Covariates - Detailed Julia documentation</li> <li>Estimation - Estimating covariate effects</li> </ul>"},{"location":"python/population/iv-bolus/","title":"Population IV Bolus","text":"<p>Comprehensive guide for simulating IV bolus administration with inter-individual variability.</p>"},{"location":"python/population/iv-bolus/#overview","title":"Overview","text":"<p>Population IV bolus simulation models the variability in clearance and volume across subjects following intravenous bolus administration.</p> <pre><code>from openpkpd import simulate_population_iv_bolus\n\nresult = simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/iv-bolus/#function-signature","title":"Function Signature","text":"<pre><code>def simulate_population_iv_bolus(\n    cl: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: float,\n    n: int,\n    omegas: dict[str, float] | None = None,\n    omega_matrix: np.ndarray | None = None,\n    omega_params: list[str] | None = None,\n    seed: int | None = None\n) -&gt; PopulationResult:\n    \"\"\"\n    Simulate population IV bolus pharmacokinetics.\n\n    Parameters\n    ----------\n    cl : float\n        Population clearance (L/hr)\n    v : float\n        Population volume of distribution (L)\n    doses : list[dict]\n        Dosing events [{\"time\": t, \"amount\": amt}, ...]\n    t0 : float\n        Simulation start time\n    t1 : float\n        Simulation end time\n    saveat : float\n        Output time step\n    n : int\n        Number of subjects to simulate\n    omegas : dict, optional\n        Diagonal omega values {\"CL\": \u03c9\u00b2_CL, \"V\": \u03c9\u00b2_V}\n    omega_matrix : np.ndarray, optional\n        Full omega covariance matrix\n    omega_params : list[str], optional\n        Parameter names for omega_matrix rows/columns\n    seed : int, optional\n        Random seed for reproducibility\n\n    Returns\n    -------\n    PopulationResult\n        Simulation results with individual profiles and summaries\n    \"\"\"\n</code></pre>"},{"location":"python/population/iv-bolus/#basic-usage","title":"Basic Usage","text":""},{"location":"python/population/iv-bolus/#single-dose","title":"Single Dose","text":"<pre><code>from openpkpd import simulate_population_iv_bolus\n\n# Simulate 100 subjects\nresult = simulate_population_iv_bolus(\n    cl=5.0,                     # 5 L/hr clearance\n    v=50.0,                     # 50 L volume\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04},  # 30% CV on CL, 20% on V\n    seed=42\n)\n\n# Basic output\nprint(f\"Subjects: {result.n_subjects}\")\nprint(f\"Time points: {len(result.times)}\")\n</code></pre>"},{"location":"python/population/iv-bolus/#multiple-doses","title":"Multiple Doses","text":"<pre><code># Multiple IV bolus doses\ndoses = [\n    {\"time\": 0.0, \"amount\": 100.0},\n    {\"time\": 12.0, \"amount\": 100.0},\n    {\"time\": 24.0, \"amount\": 100.0},\n    {\"time\": 36.0, \"amount\": 100.0}\n]\n\nresult = simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=48.0, saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/iv-bolus/#iiv-specification","title":"IIV Specification","text":""},{"location":"python/population/iv-bolus/#diagonal-omega-uncorrelated","title":"Diagonal Omega (Uncorrelated)","text":"<pre><code># Independent variability on CL and V\nomegas = {\n    \"CL\": 0.09,    # \u03c9\u00b2_CL (30% CV)\n    \"V\": 0.04      # \u03c9\u00b2_V (20% CV)\n}\n\nresult = simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas=omegas,\n    seed=42\n)\n</code></pre>"},{"location":"python/population/iv-bolus/#full-omega-matrix-correlated","title":"Full Omega Matrix (Correlated)","text":"<pre><code>import numpy as np\n\n# Correlated CL and V\n# Correlation = 0.5, \u03c9\u00b2_CL = 0.09, \u03c9\u00b2_V = 0.04\n# Covariance = 0.5 * sqrt(0.09) * sqrt(0.04) = 0.03\nomega_matrix = np.array([\n    [0.09, 0.03],   # CL row\n    [0.03, 0.04]    # V row\n])\n\nresult = simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omega_matrix=omega_matrix,\n    omega_params=[\"CL\", \"V\"],\n    seed=42\n)\n\n# Verify correlation\ncl_vals = [p[\"CL\"] for p in result.individual_params]\nv_vals = [p[\"V\"] for p in result.individual_params]\nprint(f\"Correlation: {np.corrcoef(cl_vals, v_vals)[0,1]:.3f}\")\n</code></pre>"},{"location":"python/population/iv-bolus/#accessing-results","title":"Accessing Results","text":""},{"location":"python/population/iv-bolus/#individual-profiles","title":"Individual Profiles","text":"<pre><code># Each subject's concentration-time profile\nfor i in range(5):\n    ind = result.individuals[i]\n    params = result.individual_params[i]\n\n    cmax = max(ind.concentrations)\n    auc = np.trapz(ind.concentrations, result.times)\n\n    print(f\"Subject {i+1}:\")\n    print(f\"  CL = {params['CL']:.2f} L/hr\")\n    print(f\"  V = {params['V']:.2f} L\")\n    print(f\"  Cmax = {cmax:.2f} mg/L\")\n    print(f\"  AUC = {auc:.1f} mg\u00b7hr/L\")\n</code></pre>"},{"location":"python/population/iv-bolus/#eta-values","title":"Eta Values","text":"<pre><code># Random effects\nprint(\"Eta distributions:\")\nfor param, etas in result.etas.items():\n    print(f\"  \u03b7_{param}: mean={np.mean(etas):.4f}, SD={np.std(etas):.4f}\")\n\n# Should be approximately N(0, \u03c9)\n</code></pre>"},{"location":"python/population/iv-bolus/#population-summaries","title":"Population Summaries","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Plot population profile with percentiles\nplt.figure(figsize=(10, 6))\nplt.fill_between(result.times, result.percentiles[5], result.percentiles[95],\n                 alpha=0.3, label='5-95th percentile')\nplt.fill_between(result.times, result.percentiles[25], result.percentiles[75],\n                 alpha=0.5, label='25-75th percentile')\nplt.plot(result.times, result.median, 'b-', linewidth=2, label='Median')\nplt.xlabel('Time (hr)')\nplt.ylabel('Concentration (mg/L)')\nplt.legend()\nplt.yscale('log')\nplt.title('Population IV Bolus Profile')\nplt.show()\n</code></pre>"},{"location":"python/population/iv-bolus/#two-compartment-iv-bolus","title":"Two-Compartment IV Bolus","text":"<pre><code>from openpkpd import simulate_population_twocomp_iv\n\n# Two-compartment model with IIV\nresult = simulate_population_twocomp_iv(\n    cl=10.0,        # Central clearance\n    v1=50.0,        # Central volume\n    q=5.0,          # Inter-compartmental clearance\n    v2=100.0,       # Peripheral volume\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=72.0, saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V1\": 0.04, \"Q\": 0.04, \"V2\": 0.04},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/iv-bolus/#pk-metric-calculation","title":"PK Metric Calculation","text":""},{"location":"python/population/iv-bolus/#basic-metrics","title":"Basic Metrics","text":"<pre><code>import numpy as np\n\n# Calculate PK metrics for each subject\npk_metrics = []\n\nfor i, ind in enumerate(result.individuals):\n    conc = np.array(ind.concentrations)\n    times = np.array(result.times)\n\n    # C0 (initial concentration)\n    c0 = conc[0]\n\n    # Half-life (from slope of log-linear phase)\n    # Use last portion of curve\n    late_idx = times &gt; times[-1] * 0.5\n    if sum(late_idx) &gt; 2:\n        log_conc = np.log(conc[late_idx])\n        slope = np.polyfit(times[late_idx], log_conc, 1)[0]\n        half_life = -np.log(2) / slope\n    else:\n        half_life = np.nan\n\n    # AUC (trapezoidal)\n    auc = np.trapz(conc, times)\n\n    # Clearance (from dose/AUC)\n    dose = 100.0\n    cl_calc = dose / auc\n\n    pk_metrics.append({\n        \"C0\": c0,\n        \"t_half\": half_life,\n        \"AUC\": auc,\n        \"CL_calc\": cl_calc\n    })\n\n# Summary\nc0_vals = [m[\"C0\"] for m in pk_metrics]\nthalf_vals = [m[\"t_half\"] for m in pk_metrics if not np.isnan(m[\"t_half\"])]\nauc_vals = [m[\"AUC\"] for m in pk_metrics]\n\nprint(\"PK Metrics Summary:\")\nprint(f\"C0: {np.mean(c0_vals):.2f} \u00b1 {np.std(c0_vals):.2f} mg/L\")\nprint(f\"t1/2: {np.mean(thalf_vals):.2f} \u00b1 {np.std(thalf_vals):.2f} hr\")\nprint(f\"AUC: {np.mean(auc_vals):.1f} \u00b1 {np.std(auc_vals):.1f} mg\u00b7hr/L\")\n</code></pre>"},{"location":"python/population/iv-bolus/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import simulate_population_iv_bolus\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# =========================================\n# Population IV Bolus Simulation\n# =========================================\n\nprint(\"=== Population IV Bolus ===\\n\")\n\n# 1. Model parameters\ncl = 5.0        # L/hr\nv = 50.0        # L\ndose = 100.0    # mg\n\nprint(f\"--- Model Parameters ---\")\nprint(f\"CL = {cl} L/hr\")\nprint(f\"V = {v} L\")\nprint(f\"t1/2 = {0.693 * v / cl:.1f} hr\")\nprint(f\"Dose = {dose} mg\")\n\n# 2. IIV\nomegas = {\"CL\": 0.09, \"V\": 0.04}\nprint(f\"\\n--- IIV ---\")\nfor p, w in omegas.items():\n    cv = np.sqrt(np.exp(w) - 1) * 100\n    print(f\"{p}: \u03c9\u00b2 = {w}, CV \u2248 {cv:.0f}%\")\n\n# 3. Simulate\nprint(f\"\\n--- Simulation ---\")\nresult = simulate_population_iv_bolus(\n    cl=cl, v=v,\n    doses=[{\"time\": 0.0, \"amount\": dose}],\n    t0=0.0, t1=24.0, saveat=0.25,\n    n=200,\n    omegas=omegas,\n    seed=42\n)\nprint(f\"Simulated {result.n_subjects} subjects\")\n\n# 4. Parameter distribution\nprint(f\"\\n--- Realized Parameters ---\")\ncl_vals = np.array([p[\"CL\"] for p in result.individual_params])\nv_vals = np.array([p[\"V\"] for p in result.individual_params])\n\nprint(f\"CL: {np.mean(cl_vals):.2f} \u00b1 {np.std(cl_vals):.2f} L/hr\")\nprint(f\"    Range: [{np.min(cl_vals):.2f}, {np.max(cl_vals):.2f}]\")\nprint(f\"V:  {np.mean(v_vals):.2f} \u00b1 {np.std(v_vals):.2f} L\")\nprint(f\"    Range: [{np.min(v_vals):.2f}, {np.max(v_vals):.2f}]\")\n\n# 5. PK metrics\nprint(f\"\\n--- PK Metrics ---\")\nc0_vals = [ind.concentrations[0] for ind in result.individuals]\nauc_vals = [np.trapz(ind.concentrations, result.times) for ind in result.individuals]\n\nprint(f\"C0: {np.mean(c0_vals):.2f} \u00b1 {np.std(c0_vals):.2f} mg/L\")\nprint(f\"CV(C0): {np.std(c0_vals)/np.mean(c0_vals)*100:.1f}%\")\nprint(f\"AUC: {np.mean(auc_vals):.1f} \u00b1 {np.std(auc_vals):.1f} mg\u00b7hr/L\")\nprint(f\"CV(AUC): {np.std(auc_vals)/np.mean(auc_vals)*100:.1f}%\")\n\n# 6. Percentiles\nprint(f\"\\n--- Population Percentiles (AUC) ---\")\nfor pct in [5, 10, 25, 50, 75, 90, 95]:\n    val = np.percentile(auc_vals, pct)\n    print(f\"  {pct}th: {val:.1f} mg\u00b7hr/L\")\n\n# 7. Visualization\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# 7a. Concentration-time profiles\nax = axes[0, 0]\nfor ind in result.individuals[:20]:\n    ax.plot(result.times, ind.concentrations, 'b-', alpha=0.3)\nax.plot(result.times, result.median, 'r-', linewidth=2, label='Median')\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Concentration (mg/L)')\nax.set_title('Individual Profiles')\nax.set_yscale('log')\nax.legend()\n\n# 7b. Population summary with CI\nax = axes[0, 1]\nax.fill_between(result.times, result.percentiles[5], result.percentiles[95],\n                alpha=0.3, color='blue', label='90% PI')\nax.plot(result.times, result.median, 'b-', linewidth=2, label='Median')\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Concentration (mg/L)')\nax.set_title('Population Summary')\nax.legend()\n\n# 7c. Parameter distributions\nax = axes[1, 0]\nax.hist(cl_vals, bins=20, density=True, alpha=0.7, label='CL')\nax.axvline(cl, color='r', linestyle='--', label=f'Typical = {cl}')\nax.set_xlabel('CL (L/hr)')\nax.set_ylabel('Density')\nax.set_title('CL Distribution')\nax.legend()\n\n# 7d. AUC distribution\nax = axes[1, 1]\nax.hist(auc_vals, bins=20, density=True, alpha=0.7)\ntheoretical_auc = dose / cl\nax.axvline(theoretical_auc, color='r', linestyle='--',\n           label=f'Typical = {theoretical_auc:.0f}')\nax.set_xlabel('AUC (mg\u00b7hr/L)')\nax.set_ylabel('Density')\nax.set_title('AUC Distribution')\nax.legend()\n\nplt.tight_layout()\nplt.savefig('population_iv_bolus.png', dpi=150)\nplt.show()\n\nprint(\"\\n\u2713 Simulation complete\")\n</code></pre>"},{"location":"python/population/iv-bolus/#dose-proportionality-analysis","title":"Dose-Proportionality Analysis","text":"<pre><code># Simulate multiple dose levels\ndose_levels = [25, 50, 100, 200, 400]\nresults_by_dose = {}\n\nfor dose in dose_levels:\n    result = simulate_population_iv_bolus(\n        cl=5.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": dose}],\n        t0=0.0, t1=24.0, saveat=0.5,\n        n=50,\n        omegas={\"CL\": 0.09, \"V\": 0.04},\n        seed=42\n    )\n\n    auc_vals = [np.trapz(ind.concentrations, result.times)\n                for ind in result.individuals]\n    results_by_dose[dose] = {\n        \"mean_auc\": np.mean(auc_vals),\n        \"sd_auc\": np.std(auc_vals)\n    }\n\n# Check linearity\nprint(\"Dose-Proportionality:\")\nprint(\"Dose (mg)  |  Mean AUC  |  AUC/Dose\")\nprint(\"-\" * 40)\nfor dose in dose_levels:\n    mean_auc = results_by_dose[dose][\"mean_auc\"]\n    ratio = mean_auc / dose\n    print(f\"{dose:8}   | {mean_auc:9.1f}  | {ratio:9.2f}\")\n</code></pre>"},{"location":"python/population/iv-bolus/#see-also","title":"See Also","text":"<ul> <li>Population Oral - Oral absorption models</li> <li>Covariates - Covariate effects</li> <li>Julia IIV - Detailed IIV documentation</li> <li>Estimation - Parameter estimation</li> </ul>"},{"location":"python/population/oral/","title":"Population Oral","text":"<p>Comprehensive guide for simulating oral absorption with inter-individual and inter-occasion variability.</p>"},{"location":"python/population/oral/#overview","title":"Overview","text":"<p>Population oral simulation models the variability in absorption, clearance, and volume across subjects following oral administration.</p> <pre><code>from openpkpd import simulate_population_oral\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"CL\": 0.09, \"V\": 0.04, \"Ka\": 0.16},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/oral/#function-signature","title":"Function Signature","text":"<pre><code>def simulate_population_oral(\n    ka: float,\n    cl: float,\n    v: float,\n    doses: list[dict],\n    t0: float,\n    t1: float,\n    saveat: float,\n    n: int,\n    omegas: dict[str, float] | None = None,\n    omega_matrix: np.ndarray | None = None,\n    omega_params: list[str] | None = None,\n    seed: int | None = None,\n    iov_pis: dict[str, float] | None = None,\n    iov_seed: int | None = None,\n    covariates: list[dict] | None = None,\n    covariate_effects: list[dict] | None = None\n) -&gt; PopulationResult:\n    \"\"\"\n    Simulate population oral pharmacokinetics.\n\n    Parameters\n    ----------\n    ka : float\n        Population absorption rate constant (/hr)\n    cl : float\n        Population clearance (L/hr)\n    v : float\n        Population volume of distribution (L)\n    doses : list[dict]\n        Dosing events [{\"time\": t, \"amount\": amt}, ...]\n    t0, t1 : float\n        Simulation time range\n    saveat : float\n        Output time step\n    n : int\n        Number of subjects\n    omegas : dict, optional\n        Diagonal omega values {\"Ka\": \u03c9\u00b2, \"CL\": \u03c9\u00b2, \"V\": \u03c9\u00b2}\n    omega_matrix : np.ndarray, optional\n        Full omega covariance matrix\n    omega_params : list[str], optional\n        Parameter names for omega_matrix\n    seed : int, optional\n        Random seed for IIV\n    iov_pis : dict, optional\n        IOV variance {\"Ka\": \u03c0\u00b2, \"CL\": \u03c0\u00b2}\n    iov_seed : int, optional\n        Random seed for IOV\n    covariates : list[dict], optional\n        Per-subject covariate values\n    covariate_effects : list[dict], optional\n        Covariate effect specifications\n\n    Returns\n    -------\n    PopulationResult\n        Simulation results\n    \"\"\"\n</code></pre>"},{"location":"python/population/oral/#basic-usage","title":"Basic Usage","text":""},{"location":"python/population/oral/#single-dose","title":"Single Dose","text":"<pre><code>from openpkpd import simulate_population_oral\n\nresult = simulate_population_oral(\n    ka=1.5,         # Absorption rate (/hr)\n    cl=10.0,        # Clearance (L/hr)\n    v=50.0,         # Volume (L)\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0,\n    t1=24.0,\n    saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\n# Summary metrics\nall_cmax = [max(ind.concentrations) for ind in result.individuals]\nall_tmax = [result.times[ind.concentrations.index(max(ind.concentrations))]\n            for ind in result.individuals]\n\nprint(f\"Cmax: {np.mean(all_cmax):.2f} \u00b1 {np.std(all_cmax):.2f} mg/L\")\nprint(f\"Tmax: {np.mean(all_tmax):.2f} \u00b1 {np.std(all_tmax):.2f} hr\")\n</code></pre>"},{"location":"python/population/oral/#multiple-doses","title":"Multiple Doses","text":"<pre><code># QD dosing for 7 days\ndoses = [{\"time\": i * 24.0, \"amount\": 500.0} for i in range(7)]\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=168.0, saveat=1.0,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\n# Steady-state metrics (day 7)\nss_start = 144.0  # Day 7 start\nfor ind in result.individuals[:5]:\n    ss_idx = [i for i, t in enumerate(result.times) if t &gt;= ss_start]\n    ss_conc = [ind.concentrations[i] for i in ss_idx]\n    print(f\"Cmax,ss={max(ss_conc):.2f}, Cmin,ss={min(ss_conc):.2f}\")\n</code></pre>"},{"location":"python/population/oral/#iiv-on-absorption","title":"IIV on Absorption","text":""},{"location":"python/population/oral/#high-variability-on-ka","title":"High Variability on Ka","text":"<p>Absorption rate often shows the highest variability:</p> <pre><code># Ka typically 30-60% CV\nomegas = {\n    \"Ka\": 0.25,    # ~50% CV - absorption highly variable\n    \"CL\": 0.09,    # ~30% CV\n    \"V\": 0.04      # ~20% CV\n}\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=200,\n    omegas=omegas,\n    seed=42\n)\n\n# Ka distribution\nka_vals = [p[\"Ka\"] for p in result.individual_params]\nprint(f\"Ka: {np.mean(ka_vals):.2f} \u00b1 {np.std(ka_vals):.2f} /hr\")\nprint(f\"Range: [{np.min(ka_vals):.2f}, {np.max(ka_vals):.2f}]\")\n</code></pre>"},{"location":"python/population/oral/#impact-on-cmax-and-tmax","title":"Impact on Cmax and Tmax","text":"<pre><code># Correlate Ka with Cmax and Tmax\nka_vals = np.array([p[\"Ka\"] for p in result.individual_params])\ncmax_vals = np.array([max(ind.concentrations) for ind in result.individuals])\ntmax_vals = np.array([result.times[ind.concentrations.index(max(ind.concentrations))]\n                      for ind in result.individuals])\n\nprint(f\"Correlation Ka-Cmax: {np.corrcoef(ka_vals, cmax_vals)[0,1]:.3f}\")\nprint(f\"Correlation Ka-Tmax: {np.corrcoef(ka_vals, tmax_vals)[0,1]:.3f}\")\n# Higher Ka \u2192 Higher Cmax, Lower Tmax\n</code></pre>"},{"location":"python/population/oral/#inter-occasion-variability-iov","title":"Inter-Occasion Variability (IOV)","text":""},{"location":"python/population/oral/#adding-iov","title":"Adding IOV","text":"<pre><code># Multiple dose with IOV\ndoses = [{\"time\": i * 24.0, \"amount\": 500.0} for i in range(4)]\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=doses,\n    t0=0.0, t1=96.0, saveat=0.5,\n    n=50,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},   # IIV\n    seed=42,\n    iov_pis={\"Ka\": 0.04, \"CL\": 0.0225},           # IOV: 20% on Ka, 15% on CL\n    iov_seed=12345\n)\n</code></pre>"},{"location":"python/population/oral/#iov-effects","title":"IOV Effects","text":"<pre><code># IOV causes occasion-to-occasion variation within subjects\n# Extract Cmax for each occasion\nfor subj_idx in range(5):\n    ind = result.individuals[subj_idx]\n    print(f\"Subject {subj_idx + 1}:\")\n\n    for occ in range(4):\n        t_start = occ * 24.0\n        t_end = (occ + 1) * 24.0\n        occ_idx = [i for i, t in enumerate(result.times) if t_start &lt;= t &lt; t_end]\n        occ_conc = [ind.concentrations[i] for i in occ_idx]\n        cmax_occ = max(occ_conc)\n        print(f\"  Occasion {occ+1}: Cmax = {cmax_occ:.2f}\")\n</code></pre>"},{"location":"python/population/oral/#two-compartment-oral","title":"Two-Compartment Oral","text":"<pre><code>from openpkpd import simulate_population_twocomp_oral\n\nresult = simulate_population_twocomp_oral(\n    ka=1.5,         # Absorption rate\n    cl=10.0,        # Central clearance\n    v1=50.0,        # Central volume\n    q=5.0,          # Inter-compartmental clearance\n    v2=100.0,       # Peripheral volume\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=72.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V1\": 0.04, \"Q\": 0.04, \"V2\": 0.04},\n    seed=42\n)\n</code></pre>"},{"location":"python/population/oral/#with-covariates","title":"With Covariates","text":""},{"location":"python/population/oral/#allometric-scaling","title":"Allometric Scaling","text":"<pre><code>import numpy as np\n\n# Generate population with weight distribution\nnp.random.seed(42)\nn = 100\nweights = np.random.normal(75, 15, n)\nweights = np.clip(weights, 45, 150)\n\ncovariates = [{\"WT\": w} for w in weights]\n\ncovariate_effects = [\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0}\n]\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=n,\n    omegas={\"Ka\": 0.16, \"CL\": 0.04, \"V\": 0.02},  # Reduced IIV (covariates explain part)\n    covariates=covariates,\n    covariate_effects=covariate_effects,\n    seed=42\n)\n\n# Verify weight effect on CL\ncl_vals = [p[\"CL\"] for p in result.individual_params]\nprint(f\"Correlation WT-CL: {np.corrcoef(weights, cl_vals)[0,1]:.3f}\")\n</code></pre>"},{"location":"python/population/oral/#multiple-covariates","title":"Multiple Covariates","text":"<pre><code># Weight, age, and renal function\nnp.random.seed(42)\nn = 200\n\ncovariates = []\nfor _ in range(n):\n    wt = np.random.normal(75, 15)\n    age = np.random.normal(50, 12)\n    crcl = max(30, 120 - age * 0.7 + np.random.normal(0, 15))\n    covariates.append({\n        \"WT\": np.clip(wt, 45, 150),\n        \"AGE\": np.clip(age, 18, 85),\n        \"CRCL\": np.clip(crcl, 15, 150)\n    })\n\ncovariate_effects = [\n    # Allometric scaling\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0},\n    # Age effect\n    {\"param\": \"CL\", \"cov\": \"AGE\", \"ref\": 45.0, \"kind\": \"LinearCovariate\", \"beta\": -0.005},\n    # Renal function\n    {\"param\": \"CL\", \"cov\": \"CRCL\", \"ref\": 100.0, \"kind\": \"LinearCovariate\", \"beta\": 0.004}\n]\n\nresult = simulate_population_oral(\n    ka=1.5, cl=10.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 500.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=n,\n    omegas={\"Ka\": 0.16, \"CL\": 0.0225, \"V\": 0.01},\n    covariates=covariates,\n    covariate_effects=covariate_effects,\n    seed=42\n)\n</code></pre>"},{"location":"python/population/oral/#pk-metric-calculation","title":"PK Metric Calculation","text":""},{"location":"python/population/oral/#comprehensive-metrics","title":"Comprehensive Metrics","text":"<pre><code>import numpy as np\n\ndef calculate_pk_metrics(times, concentrations, dose):\n    \"\"\"Calculate NCA-like PK metrics.\"\"\"\n    conc = np.array(concentrations)\n    t = np.array(times)\n\n    # Cmax and Tmax\n    cmax = np.max(conc)\n    tmax_idx = np.argmax(conc)\n    tmax = t[tmax_idx]\n\n    # AUC (trapezoidal)\n    auc = np.trapz(conc, t)\n\n    # AUC last dosing interval (for multiple dose)\n    if len(t) &gt; 24:\n        last_24_idx = t &gt;= (t[-1] - 24)\n        auc_tau = np.trapz(conc[last_24_idx], t[last_24_idx])\n    else:\n        auc_tau = auc\n\n    # Terminal half-life (from last 3 half-lives)\n    # Use points after Tmax where conc is declining\n    terminal_idx = (t &gt; tmax) &amp; (conc &gt; 0.05 * cmax)\n    if sum(terminal_idx) &gt; 3:\n        log_conc = np.log(conc[terminal_idx])\n        slope, _ = np.polyfit(t[terminal_idx], log_conc, 1)\n        t_half = -np.log(2) / slope\n    else:\n        t_half = np.nan\n\n    return {\n        \"Cmax\": cmax,\n        \"Tmax\": tmax,\n        \"AUC\": auc,\n        \"AUC_tau\": auc_tau,\n        \"t_half\": t_half,\n        \"CL_F\": dose / auc if auc &gt; 0 else np.nan\n    }\n\n# Calculate for population\nall_metrics = [\n    calculate_pk_metrics(result.times, ind.concentrations, 500.0)\n    for ind in result.individuals\n]\n\n# Summary\nprint(\"PK Metrics Summary:\")\nfor metric in [\"Cmax\", \"Tmax\", \"AUC\", \"t_half\"]:\n    vals = [m[metric] for m in all_metrics if not np.isnan(m[metric])]\n    print(f\"  {metric}: {np.mean(vals):.2f} \u00b1 {np.std(vals):.2f}\")\n</code></pre>"},{"location":"python/population/oral/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import simulate_population_oral\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# =========================================\n# Comprehensive Population Oral Simulation\n# =========================================\n\nprint(\"=== Population Oral PK ===\\n\")\n\n# 1. Parameters\nka, cl, v = 1.5, 10.0, 50.0\nprint(f\"--- Typical Parameters ---\")\nprint(f\"Ka = {ka} /hr, CL = {cl} L/hr, V = {v} L\")\nprint(f\"Tmax (typical) \u2248 {np.log(ka*v/cl) / (ka - cl/v):.1f} hr\")\n\n# 2. IIV\nomegas = {\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04}\nprint(f\"\\n--- IIV ---\")\nfor p, w in omegas.items():\n    cv = np.sqrt(np.exp(w) - 1) * 100\n    print(f\"  {p}: CV \u2248 {cv:.0f}%\")\n\n# 3. IOV\niov_pis = {\"Ka\": 0.04, \"CL\": 0.0225}\nprint(f\"\\n--- IOV ---\")\nfor p, pi in iov_pis.items():\n    cv = np.sqrt(np.exp(pi) - 1) * 100\n    print(f\"  {p}: CV \u2248 {cv:.0f}%\")\n\n# 4. Multiple dose regimen\ndoses = [{\"time\": i * 24.0, \"amount\": 500.0} for i in range(5)]\nprint(f\"\\n--- Dosing ---\")\nprint(f\"  500 mg QD \u00d7 5 days\")\n\n# 5. Covariates\nnp.random.seed(42)\nn = 150\ncovariates = []\nfor _ in range(n):\n    wt = np.clip(np.random.normal(75, 15), 45, 150)\n    age = np.clip(np.random.normal(50, 12), 18, 85)\n    covariates.append({\"WT\": wt, \"AGE\": age})\n\ncovariate_effects = [\n    {\"param\": \"CL\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 0.75},\n    {\"param\": \"V\", \"cov\": \"WT\", \"ref\": 70.0, \"kind\": \"PowerCovariate\", \"beta\": 1.0}\n]\n\nprint(f\"\\n--- Covariates ---\")\nwts = [c[\"WT\"] for c in covariates]\nages = [c[\"AGE\"] for c in covariates]\nprint(f\"  WT: {np.mean(wts):.1f} \u00b1 {np.std(wts):.1f} kg\")\nprint(f\"  AGE: {np.mean(ages):.1f} \u00b1 {np.std(ages):.1f} years\")\n\n# 6. Simulate\nprint(f\"\\n--- Simulation ---\")\nresult = simulate_population_oral(\n    ka=ka, cl=cl, v=v,\n    doses=doses,\n    t0=0.0, t1=120.0, saveat=0.5,\n    n=n,\n    omegas=omegas,\n    iov_pis=iov_pis,\n    iov_seed=12345,\n    covariates=covariates,\n    covariate_effects=covariate_effects,\n    seed=42\n)\nprint(f\"Simulated {result.n_subjects} subjects over 5 days\")\n\n# 7. First dose metrics\nprint(f\"\\n--- First Dose Metrics ---\")\nfirst_dose_idx = [i for i, t in enumerate(result.times) if t &lt;= 24]\n\nfirst_cmax = []\nfirst_tmax = []\nfor ind in result.individuals:\n    conc = [ind.concentrations[i] for i in first_dose_idx]\n    first_cmax.append(max(conc))\n    first_tmax.append(result.times[first_dose_idx[conc.index(max(conc))]])\n\nprint(f\"Cmax: {np.mean(first_cmax):.2f} \u00b1 {np.std(first_cmax):.2f} mg/L\")\nprint(f\"Tmax: {np.mean(first_tmax):.2f} \u00b1 {np.std(first_tmax):.2f} hr\")\nprint(f\"CV(Cmax): {np.std(first_cmax)/np.mean(first_cmax)*100:.1f}%\")\n\n# 8. Steady-state metrics (Day 5)\nprint(f\"\\n--- Steady-State Metrics (Day 5) ---\")\nss_idx = [i for i, t in enumerate(result.times) if 96 &lt;= t &lt;= 120]\n\nss_cmax = []\nss_cmin = []\nss_cavg = []\n\nfor ind in result.individuals:\n    conc = [ind.concentrations[i] for i in ss_idx]\n    ss_cmax.append(max(conc))\n    ss_cmin.append(min(conc))\n    ss_cavg.append(np.mean(conc))\n\nprint(f\"Cmax,ss: {np.mean(ss_cmax):.2f} \u00b1 {np.std(ss_cmax):.2f} mg/L\")\nprint(f\"Cmin,ss: {np.mean(ss_cmin):.2f} \u00b1 {np.std(ss_cmin):.2f} mg/L\")\nprint(f\"Cavg,ss: {np.mean(ss_cavg):.2f} \u00b1 {np.std(ss_cavg):.2f} mg/L\")\nprint(f\"Fluctuation: {(np.mean(ss_cmax) - np.mean(ss_cmin))/np.mean(ss_cavg)*100:.1f}%\")\n\n# 9. Within-subject variability (IOV effect)\nprint(f\"\\n--- Within-Subject Variability ---\")\ncv_within = []\nfor ind in result.individuals:\n    occasion_cmax = []\n    for occ in range(5):\n        t_start, t_end = occ * 24, (occ + 1) * 24\n        occ_idx = [i for i, t in enumerate(result.times) if t_start &lt;= t &lt; t_end]\n        if occ_idx:\n            occ_conc = [ind.concentrations[i] for i in occ_idx]\n            occasion_cmax.append(max(occ_conc))\n    if len(occasion_cmax) &gt; 1:\n        cv_within.append(np.std(occasion_cmax) / np.mean(occasion_cmax) * 100)\n\nprint(f\"Mean within-subject CV(Cmax): {np.mean(cv_within):.1f}%\")\n\n# 10. Visualization\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# 10a. All profiles\nax = axes[0, 0]\nfor ind in result.individuals[:30]:\n    ax.plot(result.times, ind.concentrations, 'b-', alpha=0.2)\nax.plot(result.times, result.median, 'r-', linewidth=2, label='Median')\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Concentration (mg/L)')\nax.set_title('Individual Profiles (n=30)')\nax.legend()\n\n# 10b. Population summary\nax = axes[0, 1]\nax.fill_between(result.times, result.percentiles[5], result.percentiles[95],\n                alpha=0.2, label='90% PI')\nax.fill_between(result.times, result.percentiles[25], result.percentiles[75],\n                alpha=0.4, label='50% PI')\nax.plot(result.times, result.median, 'b-', linewidth=2, label='Median')\nax.set_xlabel('Time (hr)')\nax.set_ylabel('Concentration (mg/L)')\nax.set_title('Population Summary')\nax.legend()\n\n# 10c. Cmax distribution\nax = axes[1, 0]\nax.hist(ss_cmax, bins=25, density=True, alpha=0.7)\nax.axvline(np.mean(ss_cmax), color='r', linestyle='--', label='Mean')\nax.axvline(np.median(ss_cmax), color='g', linestyle='--', label='Median')\nax.set_xlabel('Cmax,ss (mg/L)')\nax.set_ylabel('Density')\nax.set_title('Steady-State Cmax Distribution')\nax.legend()\n\n# 10d. Weight vs CL\nax = axes[1, 1]\ncl_vals = [p[\"CL\"] for p in result.individual_params]\nax.scatter(wts, cl_vals, alpha=0.5)\nax.set_xlabel('Weight (kg)')\nax.set_ylabel('CL (L/hr)')\nax.set_title(f'Weight-CL Relationship (r={np.corrcoef(wts, cl_vals)[0,1]:.3f})')\n\nplt.tight_layout()\nplt.savefig('population_oral.png', dpi=150)\nplt.show()\n\nprint(\"\\n\u2713 Simulation complete\")\n</code></pre>"},{"location":"python/population/oral/#see-also","title":"See Also","text":"<ul> <li>Population IV Bolus - IV bolus models</li> <li>Covariates - Covariate modeling</li> <li>Julia IOV - Detailed IOV documentation</li> <li>NCA - Non-compartmental analysis</li> </ul>"},{"location":"python/trial/","title":"Clinical Trials","text":"<p>The <code>openpkpd.trial</code> module provides comprehensive clinical trial simulation and analysis capabilities.</p>"},{"location":"python/trial/#overview","title":"Overview","text":"<ul> <li> <p> Study Designs</p> <p>Parallel, crossover, escalation</p> <p> Designs</p> </li> <li> <p> Dosing Regimens</p> <p>QD, BID, custom schedules</p> <p> Dosing</p> </li> <li> <p> Virtual Population</p> <p>Generate realistic subjects</p> <p> Population</p> </li> <li> <p> Power Analysis</p> <p>Sample size determination</p> <p> Power</p> </li> </ul>"},{"location":"python/trial/#quick-start","title":"Quick Start","text":""},{"location":"python/trial/#power-analysis","title":"Power Analysis","text":"<pre><code>from openpkpd import trial\n\n# Calculate power\npower = trial.estimate_power_analytical(\n    n_per_arm=50,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\nprint(f\"Power: {power.power:.1%}\")\n\n# Calculate required sample size\nresult = trial.estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\nprint(f\"Required n per arm: {result.n_per_arm}\")\n</code></pre>"},{"location":"python/trial/#generate-virtual-population","title":"Generate Virtual Population","text":"<pre><code># Default healthy volunteers\npop = trial.generate_virtual_population(\n    n=100,\n    spec=trial.healthy_volunteer_spec(),\n    seed=42\n)\n\n# Summarize demographics\nsummary = trial.summarize_population(pop)\nprint(f\"Age: {summary['age']['mean']:.1f} years\")\nprint(f\"Weight: {summary['weight']['mean']:.1f} kg\")\nprint(f\"Female: {summary['female_fraction']*100:.0f}%\")\n</code></pre>"},{"location":"python/trial/#study-designs","title":"Study Designs","text":""},{"location":"python/trial/#parallel-design","title":"Parallel Design","text":"<pre><code>design = trial.parallel_design(\n    n_arms=3,\n    randomization_ratio=[1, 1, 1]\n)\n</code></pre>"},{"location":"python/trial/#crossover-design","title":"Crossover Design","text":"<pre><code># 2\u00d72 crossover\ndesign = trial.crossover_2x2(washout_duration=14.0)\n\n# Williams design (3-period)\ndesign = trial.williams_design(washout_duration=7.0)\n</code></pre>"},{"location":"python/trial/#dose-escalation","title":"Dose Escalation","text":"<pre><code># 3+3 design\ndesign = trial.dose_escalation_3plus3(\n    starting_dose=10.0,\n    dose_levels=[10, 25, 50, 100, 200]\n)\n</code></pre>"},{"location":"python/trial/#bioequivalence","title":"Bioequivalence","text":"<pre><code>design = trial.bioequivalence_design(\n    n_periods=2,\n    washout_duration=14.0,\n    reference_formulation=\"tablet\",\n    test_formulation=\"capsule\"\n)\n</code></pre>"},{"location":"python/trial/#dosing-regimens","title":"Dosing Regimens","text":"<pre><code># Once daily\nregimen = trial.dosing_qd(dose=100.0, duration_days=28)\n\n# Twice daily\nregimen = trial.dosing_bid(dose=50.0, duration_days=14)\n\n# Three times daily\nregimen = trial.dosing_tid(dose=25.0, duration_days=7)\n\n# Custom schedule\nregimen = trial.dosing_custom(\n    dose=100.0,\n    times_per_day=[0.0, 8.0, 16.0],\n    duration_days=14\n)\n\n# Titration\nregimen = trial.titration_regimen(\n    start_dose=25.0,\n    target_dose=100.0,\n    steps=[25, 50, 75, 100],\n    days_per_step=7\n)\n</code></pre>"},{"location":"python/trial/#virtual-population","title":"Virtual Population","text":""},{"location":"python/trial/#demographics-specification","title":"Demographics Specification","text":"<pre><code>spec = trial.DemographicSpec(\n    age_mean=55.0,\n    age_sd=12.0,\n    age_min=18.0,\n    age_max=80.0,\n    weight_mean=85.0,\n    weight_sd=18.0,\n    weight_min=50.0,\n    weight_max=150.0,\n    female_fraction=0.45,\n    race_distribution={\n        \"white\": 0.6,\n        \"black\": 0.2,\n        \"asian\": 0.15,\n        \"other\": 0.05\n    }\n)\n\npop = trial.generate_virtual_population(n=200, spec=spec, seed=42)\n</code></pre>"},{"location":"python/trial/#built-in-populations","title":"Built-in Populations","text":"<pre><code># Healthy volunteers\nspec = trial.healthy_volunteer_spec()\n\n# Elderly patients\nspec = trial.elderly_patient_spec()\n\n# Pediatric\nspec = trial.pediatric_spec()\n</code></pre>"},{"location":"python/trial/#trial-simulation","title":"Trial Simulation","text":"<pre><code># Define trial\nspec = trial.TrialSpec(\n    name=\"Phase 2 Dose Finding\",\n    design=trial.parallel_design(3),\n    arms=[\n        trial.TreatmentArm(\"Placebo\", regimen=trial.dosing_qd(0.0, 28)),\n        trial.TreatmentArm(\"Low Dose\", regimen=trial.dosing_qd(50.0, 28)),\n        trial.TreatmentArm(\"High Dose\", regimen=trial.dosing_qd(100.0, 28)),\n    ],\n    population=trial.generate_virtual_population(150, seed=42),\n    dropout=trial.DropoutSpec(rate=0.05, pattern=\"exponential\"),\n    compliance=trial.ComplianceSpec(mean=0.90, sd=0.10)\n)\n\n# Run simulation\nresult = trial.simulate_trial(spec, seed=12345)\n\n# Analyze results\nfor arm_name, arm_result in result.arms.items():\n    print(f\"{arm_name}: n={arm_result.n_completed}\")\n</code></pre>"},{"location":"python/trial/#statistical-analysis","title":"Statistical Analysis","text":""},{"location":"python/trial/#arm-comparison","title":"Arm Comparison","text":"<pre><code>comparison = trial.compare_arms(\n    treatment_values=[1.2, 1.5, 1.1, 1.8, 1.4],\n    control_values=[0.9, 1.0, 0.8, 1.1, 0.95],\n    test=\"ttest\"\n)\n\nprint(f\"Difference: {comparison.difference:.2f}\")\nprint(f\"95% CI: ({comparison.ci_lower:.2f}, {comparison.ci_upper:.2f})\")\nprint(f\"p-value: {comparison.p_value:.4f}\")\n</code></pre>"},{"location":"python/trial/#responder-analysis","title":"Responder Analysis","text":"<pre><code>result = trial.responder_analysis(\n    values=[1.2, 0.8, 1.5, 0.6, 1.1, 2.0],\n    threshold=1.0\n)\nprint(f\"Responder rate: {result.rate:.1%}\")\n</code></pre>"},{"location":"python/trial/#power-functions","title":"Power Functions","text":"Function Description <code>estimate_power_analytical</code> Analytical power calculation <code>estimate_sample_size</code> Sample size for target power <code>alpha_spending_function</code> Interim analysis alpha spending"},{"location":"python/trial/#power-calculation","title":"Power Calculation","text":"<pre><code>power = trial.estimate_power_analytical(\n    n_per_arm=50,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    test=\"two_sample_t\"\n)\n</code></pre>"},{"location":"python/trial/#alpha-spending","title":"Alpha Spending","text":"<pre><code>alpha = trial.alpha_spending_function(\n    information_fraction=0.5,\n    total_alpha=0.05,\n    method=\"obrien_fleming\"\n)\n</code></pre>"},{"location":"python/trial/#next-steps","title":"Next Steps","text":"<ul> <li>Study Designs - Detailed design options</li> <li>Power Analysis - Sample size determination</li> <li>Trial Visualization - Power curves, Kaplan-Meier</li> </ul>"},{"location":"python/trial/designs/","title":"Study Designs","text":"<p>Comprehensive guide for clinical trial study designs in OpenPKPD Python.</p>"},{"location":"python/trial/designs/#overview","title":"Overview","text":"<p>OpenPKPD supports multiple trial design types for different clinical development phases.</p> <pre><code>from openpkpd import trial\n\n# Parallel design\ndesign = trial.parallel_design(n_arms=3, randomization_ratio=[1, 1, 1])\n\n# Crossover design\ndesign = trial.crossover_2x2(washout_duration=14.0)\n\n# Dose escalation\ndesign = trial.dose_escalation_3plus3(dose_levels=[10, 25, 50, 100])\n</code></pre>"},{"location":"python/trial/designs/#parallel-designs","title":"Parallel Designs","text":""},{"location":"python/trial/designs/#basic-parallel-design","title":"Basic Parallel Design","text":"<pre><code>from openpkpd.trial import ParallelDesign, parallel_design\n\n# Create 2-arm parallel design\ndesign = parallel_design(\n    n_arms=2,\n    randomization_ratio=[1, 1]\n)\n\n# Access design properties\nprint(f\"Arms: {design.n_arms}\")\nprint(f\"Ratio: {design.randomization_ratio}\")\n</code></pre>"},{"location":"python/trial/designs/#multi-arm-designs","title":"Multi-Arm Designs","text":"<pre><code># 4-arm dose-finding study\ndesign = ParallelDesign(\n    n_arms=4,\n    arm_names=[\"Placebo\", \"Low\", \"Medium\", \"High\"],\n    randomization_ratio=[1, 1, 1, 1],\n    stratification_factors=[\"sex\", \"age_group\"]\n)\n\n# Unequal randomization (2:1:1:1)\ndesign = ParallelDesign(\n    n_arms=4,\n    arm_names=[\"Placebo\", \"25mg\", \"50mg\", \"100mg\"],\n    randomization_ratio=[2, 1, 1, 1]\n)\n</code></pre>"},{"location":"python/trial/designs/#paralleldesign-class","title":"ParallelDesign Class","text":"<pre><code>@dataclass\nclass ParallelDesign:\n    \"\"\"Parallel group trial design.\"\"\"\n\n    n_arms: int                            # Number of treatment arms\n    arm_names: list[str] | None = None     # Names for each arm\n    randomization_ratio: list[int] | None = None  # Allocation ratio\n    stratification_factors: list[str] | None = None  # Stratification\n    block_size: int = 4                    # Block randomization size\n</code></pre>"},{"location":"python/trial/designs/#stratified-randomization","title":"Stratified Randomization","text":"<pre><code># Stratify by sex and age\ndesign = ParallelDesign(\n    n_arms=2,\n    arm_names=[\"Control\", \"Treatment\"],\n    randomization_ratio=[1, 1],\n    stratification_factors=[\"sex\", \"age_group\"],\n    block_size=4\n)\n\n# Generate balanced randomization\nassignments = trial.generate_randomization(\n    design=design,\n    n_subjects=100,\n    strata_distribution={\n        \"sex\": {\"male\": 0.5, \"female\": 0.5},\n        \"age_group\": {\"young\": 0.3, \"middle\": 0.4, \"elderly\": 0.3}\n    },\n    seed=42\n)\n</code></pre>"},{"location":"python/trial/designs/#crossover-designs","title":"Crossover Designs","text":""},{"location":"python/trial/designs/#2x2-crossover","title":"2x2 Crossover","text":"<pre><code>from openpkpd.trial import crossover_2x2, CrossoverDesign\n\n# Standard AB/BA crossover\ndesign = crossover_2x2(\n    treatments=[\"Test\", \"Reference\"],\n    washout_duration=14.0,\n    period_duration=1.0  # 1 day per period\n)\n\nprint(f\"Sequences: {design.sequences}\")\n# [['Test', 'Reference'], ['Reference', 'Test']]\n</code></pre>"},{"location":"python/trial/designs/#crossoverdesign-class","title":"CrossoverDesign Class","text":"<pre><code>@dataclass\nclass CrossoverDesign:\n    \"\"\"Crossover trial design.\"\"\"\n\n    n_periods: int                    # Number of periods\n    n_sequences: int                  # Number of sequences\n    sequences: list[list[str]]        # Treatment sequences\n    washout_duration: float           # Washout between periods (days)\n    period_duration: float = 1.0      # Duration of each period (days)\n    treatments: list[str] | None = None  # Treatment names\n</code></pre>"},{"location":"python/trial/designs/#williams-design","title":"Williams Design","text":"<pre><code># Balanced for first-order carryover\n# For 3 treatments: 6 sequences\ndesign = trial.williams_design(\n    treatments=[\"A\", \"B\", \"C\"],\n    washout_duration=7.0\n)\n\nprint(f\"Sequences: {design.sequences}\")\n# [['A', 'B', 'C'], ['B', 'C', 'A'], ['C', 'A', 'B'],\n#  ['A', 'C', 'B'], ['C', 'B', 'A'], ['B', 'A', 'C']]\n</code></pre>"},{"location":"python/trial/designs/#latin-square-design","title":"Latin Square Design","text":"<pre><code># 3\u00d73 Latin square\ndesign = trial.latin_square_design(\n    treatments=[\"A\", \"B\", \"C\"],\n    washout_duration=7.0\n)\n\n# Sequences: ABC, BCA, CAB\n</code></pre>"},{"location":"python/trial/designs/#replicate-designs","title":"Replicate Designs","text":"<pre><code># Full replicate (TRTR/RTRT)\ndesign = trial.replicate_crossover_2x4(\n    treatments=[\"Test\", \"Reference\"],\n    washout_duration=7.0\n)\n# Sequences: TRTR, RTRT\n\n# Partial replicate (TRR/RTR/RRT)\ndesign = trial.partial_replicate_3x3(\n    treatments=[\"Test\", \"Reference\"],\n    washout_duration=7.0\n)\n</code></pre>"},{"location":"python/trial/designs/#dose-escalation-designs","title":"Dose Escalation Designs","text":""},{"location":"python/trial/designs/#33-design","title":"3+3 Design","text":"<pre><code>from openpkpd.trial import DoseEscalation3plus3\n\n# Standard 3+3\ndesign = DoseEscalation3plus3(\n    dose_levels=[10.0, 25.0, 50.0, 100.0, 200.0, 400.0],\n    starting_dose_index=0,\n    target_dlt_rate=0.33\n)\n\n# Convenience function\ndesign = trial.dose_escalation_3plus3(\n    dose_levels=[10, 25, 50, 100, 200],\n    starting_dose=10.0\n)\n</code></pre>"},{"location":"python/trial/designs/#doseescalation3plus3-class","title":"DoseEscalation3plus3 Class","text":"<pre><code>@dataclass\nclass DoseEscalation3plus3:\n    \"\"\"Rule-based 3+3 dose escalation design.\"\"\"\n\n    dose_levels: list[float]         # Available doses\n    starting_dose_index: int = 0     # Starting dose (0-indexed)\n    target_dlt_rate: float = 0.33    # Target toxicity rate\n    max_patients_per_dose: int = 6   # Maximum per cohort\n\n    def next_dose_decision(\n        self,\n        n_dlt: int,\n        n_patients: int\n    ) -&gt; str:\n        \"\"\"Return decision: 'escalate', 'expand', 'deescalate', 'stop'\"\"\"\n        ...\n</code></pre>"},{"location":"python/trial/designs/#33-decision-rules","title":"3+3 Decision Rules","text":"<pre><code># Decision logic\ndef get_3plus3_decision(n_dlt: int, n_patients: int) -&gt; str:\n    \"\"\"\n    3+3 decision rules:\n    - 0/3 DLT \u2192 Escalate\n    - 1/3 DLT \u2192 Expand to 6\n    - 2-3/3 DLT \u2192 De-escalate\n    - 0-1/6 DLT \u2192 Escalate\n    - 2+/6 DLT \u2192 MTD = previous dose\n    \"\"\"\n    if n_patients == 3:\n        if n_dlt == 0:\n            return \"escalate\"\n        elif n_dlt == 1:\n            return \"expand\"\n        else:\n            return \"deescalate\"\n    elif n_patients == 6:\n        if n_dlt &lt;= 1:\n            return \"escalate\"\n        else:\n            return \"deescalate\"\n    return \"stay\"\n</code></pre>"},{"location":"python/trial/designs/#mtpi-design","title":"mTPI Design","text":"<pre><code>from openpkpd.trial import MTPI\n\ndesign = MTPI(\n    dose_levels=[10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity=0.25,\n    epsilon1=0.05,              # Lower equivalence margin\n    epsilon2=0.05,              # Upper equivalence margin\n    prior_alpha=1.0,            # Beta prior\n    prior_beta=1.0,\n    starting_dose_index=0,\n    max_sample_size=36\n)\n</code></pre>"},{"location":"python/trial/designs/#crm-design","title":"CRM Design","text":"<pre><code>from openpkpd.trial import CRM\n\ndesign = CRM(\n    dose_levels=[10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity=0.25,\n    skeleton=[0.05, 0.10, 0.25, 0.40, 0.55],  # Prior p(DLT)\n    model=\"power\",              # or \"logistic\"\n    prior_mean=0.0,\n    prior_sd=1.34,\n    cohort_size=1,\n    max_sample_size=30\n)\n\n# Get next recommended dose\nnext_dose_idx = design.recommend_dose(\n    dose_history=[0, 0, 0, 1, 1, 1],  # Dose indices\n    dlt_history=[False, False, False, False, True, False]\n)\n</code></pre>"},{"location":"python/trial/designs/#boin-design","title":"BOIN Design","text":"<pre><code>from openpkpd.trial import BOIN\n\ndesign = BOIN(\n    dose_levels=[10.0, 25.0, 50.0, 100.0, 200.0],\n    target_toxicity=0.30,\n    p1=0.25,                    # Highest acceptable rate\n    p2=0.35,                    # Lowest unacceptable rate\n    cohort_size=3,\n    max_sample_size=36\n)\n\n# BOIN boundaries\nprint(f\"Escalation boundary: {design.lambda_e:.3f}\")\nprint(f\"De-escalation boundary: {design.lambda_d:.3f}\")\n</code></pre>"},{"location":"python/trial/designs/#bioequivalence-designs","title":"Bioequivalence Designs","text":""},{"location":"python/trial/designs/#standard-be-design","title":"Standard BE Design","text":"<pre><code>from openpkpd.trial import BioequivalenceDesign\n\ndesign = BioequivalenceDesign(\n    n_periods=2,\n    test_formulation=\"Test\",\n    reference_formulation=\"Reference\",\n    washout_duration=14.0,\n    theta1=0.80,                # Lower BE limit\n    theta2=1.25,                # Upper BE limit\n    alpha=0.05\n)\n</code></pre>"},{"location":"python/trial/designs/#be-design-types","title":"BE Design Types","text":"<pre><code># 2\u00d72 crossover (standard)\ndesign = trial.be_design_2x2(washout_duration=14.0)\n\n# 2\u00d74 replicate (for HVD)\ndesign = trial.be_design_2x4(washout_duration=7.0)\n\n# 3\u00d73 partial replicate\ndesign = trial.be_design_3x3_partial(washout_duration=7.0)\n</code></pre>"},{"location":"python/trial/designs/#highly-variable-drug-designs","title":"Highly Variable Drug Designs","text":"<pre><code># RSABE design (FDA)\ndesign = trial.rsabe_design(\n    reference_cv=0.40,          # Reference CV &gt; 30%\n    washout_duration=7.0,\n    theta_s=0.8928              # Scaling factor\n)\n\n# ABEL design (EMA)\ndesign = trial.abel_design(\n    reference_cv=0.40,\n    washout_duration=7.0,\n    max_widening=0.50           # Max limit widening\n)\n</code></pre>"},{"location":"python/trial/designs/#adaptive-designs","title":"Adaptive Designs","text":""},{"location":"python/trial/designs/#group-sequential-design","title":"Group Sequential Design","text":"<pre><code>from openpkpd.trial import GroupSequentialDesign\n\ndesign = GroupSequentialDesign(\n    n_looks=3,                   # Number of interim analyses\n    information_fractions=[0.33, 0.67, 1.0],\n    alpha=0.05,\n    power=0.80,\n    spending_function=\"obrien_fleming\"\n)\n\n# Get boundaries\nboundaries = design.get_efficacy_boundaries()\nprint(f\"Stage 1 boundary: {boundaries[0]:.3f}\")\nprint(f\"Stage 2 boundary: {boundaries[1]:.3f}\")\nprint(f\"Final boundary: {boundaries[2]:.3f}\")\n</code></pre>"},{"location":"python/trial/designs/#sample-size-re-estimation","title":"Sample Size Re-estimation","text":"<pre><code>from openpkpd.trial import AdaptiveSampleSize\n\ndesign = AdaptiveSampleSize(\n    initial_n=50,\n    interim_fraction=0.5,\n    conditional_power_target=0.80,\n    max_n=150,\n    min_increase=10\n)\n\n# Re-estimate at interim\nnew_n = design.reestimate_sample_size(\n    observed_effect=0.35,\n    observed_se=0.15,\n    n_current=50\n)\n</code></pre>"},{"location":"python/trial/designs/#design-validation","title":"Design Validation","text":""},{"location":"python/trial/designs/#check-design-properties","title":"Check Design Properties","text":"<pre><code># Validate crossover design\ndesign = trial.crossover_2x2(washout_duration=14.0)\n\nvalidation = trial.validate_design(design)\nprint(f\"Valid: {validation.is_valid}\")\nprint(f\"Balanced: {validation.is_balanced}\")\nprint(f\"Warnings: {validation.warnings}\")\n</code></pre>"},{"location":"python/trial/designs/#design-summary","title":"Design Summary","text":"<pre><code># Print design summary\nsummary = trial.design_summary(design)\nprint(summary)\n\n# Example output:\n# Study Design: 2\u00d72 Crossover\n# Treatments: Test, Reference\n# Periods: 2\n# Sequences: TR, RT\n# Washout: 14.0 days\n# Balanced: Yes\n</code></pre>"},{"location":"python/trial/designs/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import trial\n\n# =====================================\n# Phase III Parallel Design Setup\n# =====================================\n\n# 1. Create design\ndesign = trial.ParallelDesign(\n    n_arms=3,\n    arm_names=[\"Placebo\", \"50mg\", \"100mg\"],\n    randomization_ratio=[1, 2, 2],  # More on active arms\n    stratification_factors=[\"sex\", \"age_group\"],\n    block_size=5\n)\n\n# 2. Define dosing regimens for each arm\nregimens = {\n    \"Placebo\": trial.dosing_qd(dose=0.0, duration_days=84),\n    \"50mg\": trial.dosing_qd(dose=50.0, duration_days=84),\n    \"100mg\": trial.dosing_qd(dose=100.0, duration_days=84)\n}\n\n# 3. Generate population\npop = trial.generate_virtual_population(\n    n=250,\n    spec=trial.patient_population_spec(),\n    seed=42\n)\n\n# 4. Define trial specification\nspec = trial.TrialSpec(\n    name=\"Phase 3 Efficacy Trial\",\n    design=design,\n    arms=[\n        trial.TreatmentArm(name, regimen=reg)\n        for name, reg in regimens.items()\n    ],\n    population=pop,\n    dropout=trial.DropoutSpec(rate=0.15, pattern=\"exponential\"),\n    compliance=trial.ComplianceSpec(mean=0.85, sd=0.10),\n    endpoints=[\"auc_ss\", \"cmax_ss\", \"cmin_ss\"]\n)\n\n# 5. Print summary\nprint(\"=== Trial Design Summary ===\")\nprint(f\"Design: {design.n_arms}-arm parallel\")\nprint(f\"Randomization: {design.randomization_ratio}\")\nprint(f\"Stratification: {design.stratification_factors}\")\nprint(f\"Total subjects: {len(pop)}\")\nprint(f\"Duration: 84 days\")\nprint(f\"Expected completers: {int(len(pop) * 0.85)}\")\n</code></pre>"},{"location":"python/trial/designs/#see-also","title":"See Also","text":"<ul> <li>Dosing Regimens - Dosing schedule configuration</li> <li>Virtual Population - Population generation</li> <li>Power Analysis - Sample size calculation</li> <li>Julia Trial Designs - Julia interface</li> </ul>"},{"location":"python/trial/dosing/","title":"Dosing Regimens","text":"<p>Comprehensive guide for configuring dosing schedules in OpenPKPD Python.</p>"},{"location":"python/trial/dosing/#overview","title":"Overview","text":"<p>The dosing module provides flexible specification of drug administration schedules.</p> <pre><code>from openpkpd import trial\n\n# Once daily dosing\nregimen = trial.dosing_qd(dose=100.0, duration_days=28)\n\n# Custom schedule\nregimen = trial.dosing_custom(\n    dose=100.0,\n    times_per_day=[0.0, 8.0, 16.0],\n    duration_days=14\n)\n</code></pre>"},{"location":"python/trial/dosing/#standard-regimens","title":"Standard Regimens","text":""},{"location":"python/trial/dosing/#once-daily-qd","title":"Once Daily (QD)","text":"<pre><code>from openpkpd.trial import dosing_qd\n\n# Basic QD dosing\nregimen = dosing_qd(\n    dose=100.0,           # Dose amount\n    duration_days=28,     # Treatment duration\n    dose_time=8.0         # Time of day (hours, default 8 AM)\n)\n\n# With loading dose\nregimen = dosing_qd(\n    dose=100.0,\n    duration_days=28,\n    loading_dose=200.0    # Double first dose\n)\n\n# Access schedule\nprint(f\"Doses per day: {regimen.doses_per_day}\")\nprint(f\"Total doses: {regimen.total_doses}\")\nprint(f\"Dose times: {regimen.dose_times}\")\n</code></pre>"},{"location":"python/trial/dosing/#twice-daily-bid","title":"Twice Daily (BID)","text":"<pre><code>from openpkpd.trial import dosing_bid\n\n# Standard BID\nregimen = dosing_bid(\n    dose=50.0,\n    duration_days=14,\n    dose_times=[8.0, 20.0]  # 8 AM and 8 PM\n)\n\n# With morning loading\nregimen = dosing_bid(\n    dose=50.0,\n    duration_days=14,\n    loading_dose=100.0,\n    loading_applies_to=\"first_only\"  # or \"morning_only\"\n)\n</code></pre>"},{"location":"python/trial/dosing/#three-times-daily-tid","title":"Three Times Daily (TID)","text":"<pre><code>from openpkpd.trial import dosing_tid\n\n# Standard TID (every 8 hours)\nregimen = dosing_tid(\n    dose=25.0,\n    duration_days=7,\n    dose_times=[6.0, 14.0, 22.0]  # 6 AM, 2 PM, 10 PM\n)\n</code></pre>"},{"location":"python/trial/dosing/#four-times-daily-qid","title":"Four Times Daily (QID)","text":"<pre><code>from openpkpd.trial import dosing_qid\n\n# Standard QID (every 6 hours)\nregimen = dosing_qid(\n    dose=20.0,\n    duration_days=7,\n    dose_times=[6.0, 12.0, 18.0, 24.0]\n)\n</code></pre>"},{"location":"python/trial/dosing/#dosingregimen-class","title":"DosingRegimen Class","text":""},{"location":"python/trial/dosing/#class-definition","title":"Class Definition","text":"<pre><code>@dataclass\nclass DosingRegimen:\n    \"\"\"Complete dosing regimen specification.\"\"\"\n\n    dose: float                      # Standard dose amount\n    duration_days: int               # Total treatment duration\n    dose_times: list[float]          # Times of day for doses (hours)\n    loading_dose: float | None = None  # Optional loading dose\n    route: str = \"oral\"              # Administration route\n    formulation: str = \"tablet\"      # Drug formulation\n\n    @property\n    def doses_per_day(self) -&gt; int:\n        \"\"\"Number of doses per day.\"\"\"\n        return len(self.dose_times)\n\n    @property\n    def total_doses(self) -&gt; int:\n        \"\"\"Total doses over regimen.\"\"\"\n        return self.doses_per_day * self.duration_days\n\n    def get_dose_schedule(self) -&gt; list[dict]:\n        \"\"\"Return complete dose schedule.\"\"\"\n        ...\n</code></pre>"},{"location":"python/trial/dosing/#creating-custom-regimens","title":"Creating Custom Regimens","text":"<pre><code>from openpkpd.trial import DosingRegimen\n\n# Manual specification\nregimen = DosingRegimen(\n    dose=100.0,\n    duration_days=28,\n    dose_times=[8.0],           # Once at 8 AM\n    loading_dose=200.0,\n    route=\"oral\",\n    formulation=\"tablet\"\n)\n\n# Get schedule as list\nschedule = regimen.get_dose_schedule()\nfor event in schedule[:5]:\n    print(f\"Day {event['day']}, Time {event['time']}: {event['dose']} mg\")\n</code></pre>"},{"location":"python/trial/dosing/#custom-schedules","title":"Custom Schedules","text":""},{"location":"python/trial/dosing/#irregular-dosing","title":"Irregular Dosing","text":"<pre><code>from openpkpd.trial import dosing_custom\n\n# Custom times\nregimen = dosing_custom(\n    dose=100.0,\n    times_per_day=[7.0, 13.0, 19.0],  # 7 AM, 1 PM, 7 PM\n    duration_days=14\n)\n\n# Variable doses per day\nregimen = dosing_custom(\n    doses=[100.0, 50.0, 50.0],  # Different amounts\n    times_per_day=[8.0, 14.0, 20.0],\n    duration_days=14\n)\n</code></pre>"},{"location":"python/trial/dosing/#weekly-dosing","title":"Weekly Dosing","text":"<pre><code># Once weekly\nregimen = trial.dosing_weekly(\n    dose=500.0,\n    duration_weeks=12,\n    dose_day=1  # Monday (1=Mon, 7=Sun)\n)\n\n# Twice weekly\nregimen = trial.dosing_twice_weekly(\n    dose=250.0,\n    duration_weeks=12,\n    dose_days=[1, 4]  # Monday and Thursday\n)\n</code></pre>"},{"location":"python/trial/dosing/#prn-as-needed","title":"PRN (As Needed)","text":"<pre><code># PRN dosing with max daily dose\nregimen = trial.dosing_prn(\n    dose=50.0,\n    max_doses_per_day=4,\n    duration_days=14,\n    min_interval_hours=4.0\n)\n</code></pre>"},{"location":"python/trial/dosing/#titration-regimens","title":"Titration Regimens","text":""},{"location":"python/trial/dosing/#linear-titration","title":"Linear Titration","text":"<pre><code>from openpkpd.trial import titration_regimen\n\n# Gradual dose increase\nregimen = titration_regimen(\n    start_dose=25.0,\n    target_dose=100.0,\n    steps=[25, 50, 75, 100],\n    days_per_step=7,\n    frequency=\"qd\",\n    maintenance_days=28\n)\n\n# Schedule:\n# Days 1-7:   25 mg QD\n# Days 8-14:  50 mg QD\n# Days 15-21: 75 mg QD\n# Days 22+:   100 mg QD (maintenance)\n</code></pre>"},{"location":"python/trial/dosing/#titrationregimen-class","title":"TitrationRegimen Class","text":"<pre><code>@dataclass\nclass TitrationRegimen:\n    \"\"\"Dose titration regimen.\"\"\"\n\n    start_dose: float               # Initial dose\n    target_dose: float              # Target maintenance dose\n    steps: list[float]              # Dose levels\n    days_per_step: int              # Days at each level\n    frequency: str = \"qd\"           # Dosing frequency\n    maintenance_days: int = 0       # Days at target dose\n    back_titration_allowed: bool = False  # Can decrease?\n\n    @property\n    def total_titration_days(self) -&gt; int:\n        return len(self.steps) * self.days_per_step\n\n    @property\n    def total_duration(self) -&gt; int:\n        return self.total_titration_days + self.maintenance_days\n</code></pre>"},{"location":"python/trial/dosing/#flexible-titration","title":"Flexible Titration","text":"<pre><code># With tolerability-based adjustment\nregimen = trial.flexible_titration(\n    start_dose=25.0,\n    target_dose=100.0,\n    step_size=25.0,\n    min_days_per_step=3,\n    max_days_per_step=14,\n    tolerability_criterion=\"ae_grade &lt; 2\"\n)\n</code></pre>"},{"location":"python/trial/dosing/#infusion-regimens","title":"Infusion Regimens","text":""},{"location":"python/trial/dosing/#iv-infusion","title":"IV Infusion","text":"<pre><code>from openpkpd.trial import dosing_infusion\n\n# Short infusion\nregimen = dosing_infusion(\n    dose=500.0,              # mg\n    infusion_duration=1.0,   # hours\n    frequency=\"qd\",\n    duration_days=5\n)\n\n# Long infusion\nregimen = dosing_infusion(\n    dose=1000.0,\n    infusion_duration=24.0,  # Continuous over 24h\n    frequency=\"qd\",\n    duration_days=7\n)\n</code></pre>"},{"location":"python/trial/dosing/#iv-bolus","title":"IV Bolus","text":"<pre><code># Bolus injection\nregimen = trial.dosing_iv_bolus(\n    dose=100.0,\n    frequency=\"qd\",\n    duration_days=3\n)\n</code></pre>"},{"location":"python/trial/dosing/#loading-maintenance-infusion","title":"Loading + Maintenance Infusion","text":"<pre><code># Loading bolus followed by infusion\nregimen = trial.dosing_loading_infusion(\n    loading_dose=500.0,\n    loading_duration=0.5,     # 30-min loading\n    maintenance_rate=50.0,    # mg/hour\n    maintenance_duration=24.0,\n    duration_days=5\n)\n</code></pre>"},{"location":"python/trial/dosing/#multiple-formulations","title":"Multiple Formulations","text":""},{"location":"python/trial/dosing/#formulation-specification","title":"Formulation Specification","text":"<pre><code>from openpkpd.trial import FormulationSpec\n\n# Define formulations\ntablet = FormulationSpec(\n    name=\"tablet\",\n    route=\"oral\",\n    bioavailability=0.80,\n    absorption_rate=1.5  # Ka\n)\n\nsolution = FormulationSpec(\n    name=\"solution\",\n    route=\"oral\",\n    bioavailability=0.95,\n    absorption_rate=2.5\n)\n\n# Use in regimen\nregimen = trial.dosing_qd(\n    dose=100.0,\n    duration_days=28,\n    formulation=tablet\n)\n</code></pre>"},{"location":"python/trial/dosing/#switching-formulations","title":"Switching Formulations","text":"<pre><code># Switch from IV to oral\nregimen = trial.sequential_formulation(\n    phase1=trial.dosing_infusion(dose=500.0, duration_days=3),\n    phase2=trial.dosing_qd(dose=250.0, duration_days=25)\n)\n</code></pre>"},{"location":"python/trial/dosing/#compliance-modeling","title":"Compliance Modeling","text":""},{"location":"python/trial/dosing/#compliancespec-class","title":"ComplianceSpec Class","text":"<pre><code>@dataclass\nclass ComplianceSpec:\n    \"\"\"Patient compliance specification.\"\"\"\n\n    mean: float = 0.90          # Mean compliance rate\n    sd: float = 0.10            # Standard deviation\n    pattern: str = \"random\"     # \"random\", \"decay\", \"weekend_miss\"\n    min_compliance: float = 0.50  # Minimum allowed\n\n    def sample_compliance(self, n: int, seed: int = None) -&gt; list[float]:\n        \"\"\"Generate individual compliance rates.\"\"\"\n        ...\n</code></pre>"},{"location":"python/trial/dosing/#compliance-patterns","title":"Compliance Patterns","text":"<pre><code># Random missing doses\ncompliance = trial.ComplianceSpec(\n    mean=0.85,\n    sd=0.10,\n    pattern=\"random\"\n)\n\n# Weekend-miss pattern\ncompliance = trial.ComplianceSpec(\n    mean=0.90,\n    pattern=\"weekend_miss\",\n    weekday_rate=0.95,\n    weekend_rate=0.70\n)\n\n# Declining compliance\ncompliance = trial.ComplianceSpec(\n    mean=0.85,\n    pattern=\"decay\",\n    initial_rate=0.95,\n    final_rate=0.75,\n    half_time_days=14\n)\n</code></pre>"},{"location":"python/trial/dosing/#apply-compliance","title":"Apply Compliance","text":"<pre><code># Apply to regimen\nactual_doses = trial.apply_compliance(\n    regimen=regimen,\n    compliance_spec=compliance,\n    n_subjects=100,\n    seed=42\n)\n\n# Each subject gets individual dose schedule\nfor subject_id, doses in actual_doses.items():\n    taken = sum(1 for d in doses if d[\"taken\"])\n    total = len(doses)\n    print(f\"Subject {subject_id}: {taken}/{total} doses taken\")\n</code></pre>"},{"location":"python/trial/dosing/#dose-modifications","title":"Dose Modifications","text":""},{"location":"python/trial/dosing/#dose-reduction-rules","title":"Dose Reduction Rules","text":"<pre><code>from openpkpd.trial import DoseModificationRule\n\n# Reduce for toxicity\nrule = DoseModificationRule(\n    trigger=\"ae_grade &gt;= 3\",\n    action=\"reduce_by_25%\",\n    min_dose=25.0,\n    max_reductions=2\n)\n\n# Skip dose for lab value\nrule = DoseModificationRule(\n    trigger=\"neutrophil_count &lt; 1000\",\n    action=\"hold_until_recovery\",\n    recovery_criterion=\"neutrophil_count &gt;= 1500\"\n)\n</code></pre>"},{"location":"python/trial/dosing/#applying-modifications","title":"Applying Modifications","text":"<pre><code># Add rules to regimen\nregimen = trial.dosing_qd(\n    dose=100.0,\n    duration_days=28,\n    modification_rules=[\n        DoseModificationRule(trigger=\"ae_grade &gt;= 3\", action=\"reduce_by_25%\"),\n        DoseModificationRule(trigger=\"ae_grade &gt;= 4\", action=\"discontinue\")\n    ]\n)\n</code></pre>"},{"location":"python/trial/dosing/#regimen-validation","title":"Regimen Validation","text":""},{"location":"python/trial/dosing/#check-regimen","title":"Check Regimen","text":"<pre><code># Validate regimen\nvalidation = trial.validate_regimen(regimen)\n\nprint(f\"Valid: {validation.is_valid}\")\nprint(f\"Warnings: {validation.warnings}\")\nprint(f\"Daily dose: {validation.daily_dose}\")\nprint(f\"Total exposure: {validation.total_dose}\")\n</code></pre>"},{"location":"python/trial/dosing/#comparison","title":"Comparison","text":"<pre><code># Compare regimens\ncomparison = trial.compare_regimens(regimen1, regimen2)\n\nprint(f\"Dose ratio: {comparison.dose_ratio}\")\nprint(f\"Frequency difference: {comparison.frequency_diff}\")\nprint(f\"Duration difference: {comparison.duration_diff}\")\n</code></pre>"},{"location":"python/trial/dosing/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import trial\n\n# ================================\n# Complex Dosing Schedule Setup\n# ================================\n\n# 1. Define titration for new patients\ntitration = trial.titration_regimen(\n    start_dose=25.0,\n    target_dose=100.0,\n    steps=[25, 50, 75, 100],\n    days_per_step=7,\n    frequency=\"qd\"\n)\n\n# 2. Define maintenance regimen\nmaintenance = trial.dosing_bid(\n    dose=50.0,\n    duration_days=56,\n    dose_times=[8.0, 20.0]\n)\n\n# 3. Combine into full treatment\nfull_regimen = trial.sequential_regimen([\n    titration,\n    maintenance\n])\n\n# 4. Define compliance\ncompliance = trial.ComplianceSpec(\n    mean=0.90,\n    sd=0.08,\n    pattern=\"decay\",\n    initial_rate=0.95,\n    final_rate=0.80,\n    half_time_days=28\n)\n\n# 5. Add modification rules\nfull_regimen = trial.add_modification_rules(\n    full_regimen,\n    rules=[\n        trial.DoseModificationRule(\n            trigger=\"ae_grade &gt;= 3\",\n            action=\"reduce_by_25%\"\n        ),\n        trial.DoseModificationRule(\n            trigger=\"discontinuation_criterion\",\n            action=\"discontinue\"\n        )\n    ]\n)\n\n# 6. Print schedule summary\nprint(\"=== Dosing Schedule Summary ===\")\nprint(f\"Titration phase: {titration.total_duration} days\")\nprint(f\"Maintenance phase: {maintenance.duration_days} days\")\nprint(f\"Total duration: {full_regimen.total_duration} days\")\nprint(f\"Total doses: {full_regimen.total_doses}\")\n\n# 7. Generate individual schedules\nschedules = trial.generate_individual_schedules(\n    regimen=full_regimen,\n    compliance=compliance,\n    n_subjects=50,\n    seed=42\n)\n\n# 8. Calculate actual exposure\nfor i, schedule in enumerate(schedules[:5]):\n    doses_taken = sum(1 for d in schedule if d[\"taken\"])\n    total_dose = sum(d[\"dose\"] for d in schedule if d[\"taken\"])\n    print(f\"Subject {i+1}: {doses_taken} doses, {total_dose:.0f} mg total\")\n</code></pre>"},{"location":"python/trial/dosing/#regimen-functions-reference","title":"Regimen Functions Reference","text":"Function Description <code>dosing_qd</code> Once daily dosing <code>dosing_bid</code> Twice daily dosing <code>dosing_tid</code> Three times daily <code>dosing_qid</code> Four times daily <code>dosing_weekly</code> Once weekly <code>dosing_custom</code> Custom schedule <code>dosing_infusion</code> IV infusion <code>titration_regimen</code> Dose escalation <code>sequential_regimen</code> Combine regimens <code>apply_compliance</code> Add missed doses <code>validate_regimen</code> Check regimen validity"},{"location":"python/trial/dosing/#see-also","title":"See Also","text":"<ul> <li>Study Designs - Trial design types</li> <li>Virtual Population - Subject generation</li> <li>Power Analysis - Sample size calculation</li> <li>Julia Dosing - Julia interface</li> </ul>"},{"location":"python/trial/population/","title":"Virtual Population","text":"<p>Comprehensive guide for generating realistic virtual patient populations in OpenPKPD Python.</p>"},{"location":"python/trial/population/#overview","title":"Overview","text":"<p>Virtual population generation creates demographically realistic subjects for trial simulation.</p> <pre><code>from openpkpd import trial\n\n# Generate healthy volunteers\npop = trial.generate_virtual_population(\n    n=100,\n    spec=trial.healthy_volunteer_spec(),\n    seed=42\n)\n\n# Access demographics\nprint(f\"Mean age: {pop.mean_age:.1f} years\")\nprint(f\"Mean weight: {pop.mean_weight:.1f} kg\")\n</code></pre>"},{"location":"python/trial/population/#demographicspec-class","title":"DemographicSpec Class","text":""},{"location":"python/trial/population/#class-definition","title":"Class Definition","text":"<pre><code>@dataclass\nclass DemographicSpec:\n    \"\"\"Specification for virtual population demographics.\"\"\"\n\n    # Age distribution\n    age_mean: float = 35.0\n    age_sd: float = 10.0\n    age_min: float = 18.0\n    age_max: float = 65.0\n\n    # Weight distribution\n    weight_mean: float = 75.0\n    weight_sd: float = 15.0\n    weight_min: float = 45.0\n    weight_max: float = 150.0\n\n    # Height distribution\n    height_mean: float = 170.0\n    height_sd: float = 10.0\n    height_min: float = 145.0\n    height_max: float = 200.0\n\n    # Sex distribution\n    female_fraction: float = 0.50\n\n    # Race distribution\n    race_distribution: dict[str, float] | None = None\n\n    # Renal function\n    egfr_distribution: dict[str, float] | None = None\n\n    # Hepatic function\n    child_pugh_distribution: dict[str, float] | None = None\n\n    # Custom covariates\n    covariates: dict[str, CovariateSpec] | None = None\n</code></pre>"},{"location":"python/trial/population/#creating-custom-specs","title":"Creating Custom Specs","text":"<pre><code>from openpkpd.trial import DemographicSpec\n\n# Custom population\nspec = DemographicSpec(\n    age_mean=55.0,\n    age_sd=12.0,\n    age_min=18.0,\n    age_max=85.0,\n    weight_mean=85.0,\n    weight_sd=18.0,\n    weight_min=50.0,\n    weight_max=150.0,\n    female_fraction=0.45,\n    race_distribution={\n        \"white\": 0.60,\n        \"black\": 0.20,\n        \"asian\": 0.15,\n        \"other\": 0.05\n    }\n)\n\npop = trial.generate_virtual_population(n=200, spec=spec, seed=42)\n</code></pre>"},{"location":"python/trial/population/#pre-built-population-specs","title":"Pre-built Population Specs","text":""},{"location":"python/trial/population/#healthy-volunteers","title":"Healthy Volunteers","text":"<pre><code># Phase I typical population\nspec = trial.healthy_volunteer_spec()\n\n# Parameters:\n# Age: 30 \u00b1 8 years (18-45)\n# Weight: 72 \u00b1 10 kg (55-90)\n# Height: 170 \u00b1 9 cm\n# 50% female\n# Normal renal/hepatic function\n</code></pre>"},{"location":"python/trial/population/#patient-populations","title":"Patient Populations","text":"<pre><code># General patient population\nspec = trial.patient_population_spec()\n\n# Diabetic patients\nspec = trial.patient_population_spec(disease=\"diabetes\")\n# Includes: HbA1c distribution, older age\n\n# Cardiac patients\nspec = trial.patient_population_spec(disease=\"cardiac\")\n# Includes: Ejection fraction, cardiac medications\n\n# Oncology patients\nspec = trial.patient_population_spec(disease=\"oncology\")\n# Includes: Performance status, prior treatments\n</code></pre>"},{"location":"python/trial/population/#special-populations","title":"Special Populations","text":"<pre><code># Elderly patients\nspec = trial.elderly_patient_spec()\n# Age: 72 \u00b1 8 years (65-90)\n# Reduced renal function\n\n# Pediatric population\nspec = trial.pediatric_spec(age_group=\"child\")  # 6-12 years\nspec = trial.pediatric_spec(age_group=\"adolescent\")  # 12-18 years\nspec = trial.pediatric_spec(age_group=\"infant\")  # 1-6 years\n\n# Renal impairment\nspec = trial.renal_impairment_spec(severity=\"moderate\")\n# Includes: eGFR 30-59 mL/min/1.73m\u00b2\n\n# Hepatic impairment\nspec = trial.hepatic_impairment_spec(child_pugh=\"B\")\n# Includes: Child-Pugh score B\n</code></pre>"},{"location":"python/trial/population/#generating-populations","title":"Generating Populations","text":""},{"location":"python/trial/population/#basic-generation","title":"Basic Generation","text":"<pre><code># Generate population\npop = trial.generate_virtual_population(\n    n=100,\n    spec=spec,\n    seed=42\n)\n\n# Access as DataFrame\ndf = pop.to_dataframe()\nprint(df.head())\n</code></pre>"},{"location":"python/trial/population/#virtualpopulation-class","title":"VirtualPopulation Class","text":"<pre><code>@dataclass\nclass VirtualPopulation:\n    \"\"\"Container for virtual population data.\"\"\"\n\n    n_subjects: int\n    subjects: list[VirtualSubject]\n\n    # Summary statistics\n    @property\n    def mean_age(self) -&gt; float: ...\n    @property\n    def mean_weight(self) -&gt; float: ...\n    @property\n    def female_fraction(self) -&gt; float: ...\n\n    def to_dataframe(self) -&gt; pd.DataFrame: ...\n    def subset(self, indices: list[int]) -&gt; VirtualPopulation: ...\n    def filter(self, criterion: Callable) -&gt; VirtualPopulation: ...\n</code></pre>"},{"location":"python/trial/population/#virtualsubject-class","title":"VirtualSubject Class","text":"<pre><code>@dataclass\nclass VirtualSubject:\n    \"\"\"Individual virtual subject.\"\"\"\n\n    id: int\n    age: float\n    weight: float\n    height: float\n    bmi: float\n    sex: str\n    race: str\n    egfr: float | None = None\n    child_pugh: str | None = None\n    covariates: dict[str, Any] | None = None\n</code></pre>"},{"location":"python/trial/population/#covariate-specification","title":"Covariate Specification","text":""},{"location":"python/trial/population/#standard-covariates","title":"Standard Covariates","text":"<pre><code>from openpkpd.trial import CovariateSpec\n\n# Continuous covariate\ncreatinine = CovariateSpec(\n    name=\"creatinine\",\n    type=\"continuous\",\n    distribution=\"normal\",\n    mean=1.0,\n    sd=0.3,\n    min=0.5,\n    max=2.5,\n    unit=\"mg/dL\"\n)\n\n# Categorical covariate\nsmoking = CovariateSpec(\n    name=\"smoking_status\",\n    type=\"categorical\",\n    categories=[\"never\", \"former\", \"current\"],\n    probabilities=[0.50, 0.30, 0.20]\n)\n</code></pre>"},{"location":"python/trial/population/#adding-covariates-to-spec","title":"Adding Covariates to Spec","text":"<pre><code># Add custom covariates\nspec = DemographicSpec(\n    age_mean=55.0,\n    age_sd=12.0,\n    covariates={\n        \"creatinine\": CovariateSpec(\n            type=\"continuous\",\n            distribution=\"lognormal\",\n            mean=1.0,\n            sd=0.3\n        ),\n        \"albumin\": CovariateSpec(\n            type=\"continuous\",\n            distribution=\"normal\",\n            mean=4.0,\n            sd=0.5,\n            min=2.5,\n            max=5.5\n        ),\n        \"genotype\": CovariateSpec(\n            type=\"categorical\",\n            categories=[\"PM\", \"IM\", \"EM\", \"UM\"],\n            probabilities=[0.05, 0.15, 0.70, 0.10]\n        )\n    }\n)\n</code></pre>"},{"location":"python/trial/population/#correlated-covariates","title":"Correlated Covariates","text":"<pre><code># Define correlations\nspec = DemographicSpec(\n    age_mean=55.0,\n    age_sd=12.0,\n    weight_mean=80.0,\n    weight_sd=15.0,\n    covariate_correlations={\n        (\"age\", \"egfr\"): -0.4,      # Age negatively correlated with eGFR\n        (\"weight\", \"bmi\"): 0.8,      # Weight positively correlated with BMI\n        (\"age\", \"creatinine\"): 0.3   # Age positively correlated with creatinine\n    }\n)\n</code></pre>"},{"location":"python/trial/population/#renal-function","title":"Renal Function","text":""},{"location":"python/trial/population/#egfr-distribution","title":"eGFR Distribution","text":"<pre><code># Normal renal function\nspec = DemographicSpec(\n    egfr_distribution={\n        \"normal\": 1.0,     # eGFR &gt;= 90\n        \"mild\": 0.0,       # eGFR 60-89\n        \"moderate\": 0.0,   # eGFR 30-59\n        \"severe\": 0.0      # eGFR 15-29\n    }\n)\n\n# Mixed population\nspec = DemographicSpec(\n    egfr_distribution={\n        \"normal\": 0.40,\n        \"mild\": 0.30,\n        \"moderate\": 0.20,\n        \"severe\": 0.10\n    }\n)\n</code></pre>"},{"location":"python/trial/population/#egfr-calculation","title":"eGFR Calculation","text":"<pre><code># eGFR calculated using CKD-EPI equation\nfor subject in pop.subjects:\n    print(f\"Subject {subject.id}: eGFR = {subject.egfr:.1f} mL/min/1.73m\u00b2\")\n</code></pre>"},{"location":"python/trial/population/#renal-impairment-study","title":"Renal Impairment Study","text":"<pre><code># Generate matched groups\ndef generate_renal_study_population(n_per_group: int, seed: int = 42):\n    populations = {}\n\n    for severity in [\"normal\", \"mild\", \"moderate\", \"severe\"]:\n        spec = trial.renal_impairment_spec(severity=severity)\n        populations[severity] = trial.generate_virtual_population(\n            n=n_per_group,\n            spec=spec,\n            seed=seed\n        )\n\n    return populations\n\npops = generate_renal_study_population(8)\n</code></pre>"},{"location":"python/trial/population/#hepatic-function","title":"Hepatic Function","text":""},{"location":"python/trial/population/#child-pugh-distribution","title":"Child-Pugh Distribution","text":"<pre><code># Hepatic impairment study\nspec = DemographicSpec(\n    child_pugh_distribution={\n        \"normal\": 0.25,    # No impairment\n        \"A\": 0.25,         # Mild (5-6 points)\n        \"B\": 0.25,         # Moderate (7-9 points)\n        \"C\": 0.25          # Severe (10-15 points)\n    }\n)\n</code></pre>"},{"location":"python/trial/population/#child-pugh-calculation","title":"Child-Pugh Calculation","text":"<pre><code># Child-Pugh score components\n@dataclass\nclass ChildPughComponents:\n    bilirubin: float      # mg/dL\n    albumin: float        # g/dL\n    inr: float            # INR\n    ascites: str          # \"none\", \"mild\", \"moderate\"\n    encephalopathy: str   # \"none\", \"grade1-2\", \"grade3-4\"\n\n    def calculate_score(self) -&gt; int:\n        \"\"\"Calculate total Child-Pugh score.\"\"\"\n        ...\n\n    def classify(self) -&gt; str:\n        \"\"\"Return A, B, or C classification.\"\"\"\n        ...\n</code></pre>"},{"location":"python/trial/population/#population-summary","title":"Population Summary","text":""},{"location":"python/trial/population/#summary-statistics","title":"Summary Statistics","text":"<pre><code># Generate summary\nsummary = trial.summarize_population(pop)\n\nprint(\"=== Population Summary ===\")\nprint(f\"N: {summary['n']}\")\nprint(f\"Age: {summary['age']['mean']:.1f} \u00b1 {summary['age']['sd']:.1f} years\")\nprint(f\"Weight: {summary['weight']['mean']:.1f} \u00b1 {summary['weight']['sd']:.1f} kg\")\nprint(f\"BMI: {summary['bmi']['mean']:.1f} \u00b1 {summary['bmi']['sd']:.1f} kg/m\u00b2\")\nprint(f\"Female: {summary['female_fraction']*100:.0f}%\")\n\n# Race breakdown\nprint(\"\\nRace Distribution:\")\nfor race, frac in summary['race_distribution'].items():\n    print(f\"  {race}: {frac*100:.0f}%\")\n</code></pre>"},{"location":"python/trial/population/#detailed-statistics","title":"Detailed Statistics","text":"<pre><code># Get detailed stats\nstats = trial.population_statistics(pop)\n\n# Continuous variables\nfor var in [\"age\", \"weight\", \"height\", \"bmi\"]:\n    s = stats[var]\n    print(f\"{var}: {s['mean']:.1f} [{s['min']:.1f}-{s['max']:.1f}]\")\n\n# Categorical variables\nfor var in [\"sex\", \"race\"]:\n    print(f\"\\n{var}:\")\n    for cat, count in stats[var].items():\n        print(f\"  {cat}: {count}\")\n</code></pre>"},{"location":"python/trial/population/#population-filtering","title":"Population Filtering","text":""},{"location":"python/trial/population/#filter-by-criteria","title":"Filter by Criteria","text":"<pre><code># Filter by age\nelderly = pop.filter(lambda s: s.age &gt;= 65)\nprint(f\"Elderly subjects: {elderly.n_subjects}\")\n\n# Filter by multiple criteria\nsubpop = pop.filter(lambda s: s.age &gt;= 50 and s.sex == \"female\")\n\n# Filter by renal function\nmoderate_ri = pop.filter(lambda s: 30 &lt;= s.egfr &lt; 60)\n</code></pre>"},{"location":"python/trial/population/#stratified-sampling","title":"Stratified Sampling","text":"<pre><code># Sample stratified by sex\nstratified = trial.stratified_sample(\n    population=pop,\n    strata_var=\"sex\",\n    n_per_stratum={\"male\": 25, \"female\": 25},\n    seed=42\n)\n\n# Sample stratified by age group\nstratified = trial.stratified_sample(\n    population=pop,\n    strata_var=\"age_group\",\n    strata_definition={\n        \"young\": lambda s: s.age &lt; 40,\n        \"middle\": lambda s: 40 &lt;= s.age &lt; 60,\n        \"elderly\": lambda s: s.age &gt;= 60\n    },\n    n_per_stratum={\"young\": 20, \"middle\": 30, \"elderly\": 20}\n)\n</code></pre>"},{"location":"python/trial/population/#randomization","title":"Randomization","text":""},{"location":"python/trial/population/#assign-to-arms","title":"Assign to Arms","text":"<pre><code># Simple randomization\nassignments = trial.randomize(\n    population=pop,\n    arms=[\"Placebo\", \"Treatment\"],\n    ratio=[1, 1],\n    seed=42\n)\n\n# Stratified randomization\nassignments = trial.stratified_randomize(\n    population=pop,\n    arms=[\"Placebo\", \"Low\", \"High\"],\n    ratio=[1, 1, 1],\n    strata=[\"sex\", \"age_group\"],\n    block_size=6,\n    seed=42\n)\n\n# Check balance\nbalance = trial.check_randomization_balance(assignments)\nprint(f\"Balance metrics: {balance}\")\n</code></pre>"},{"location":"python/trial/population/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import trial\n\n# =========================================\n# Phase III Population Generation\n# =========================================\n\n# 1. Define target population characteristics\nspec = trial.DemographicSpec(\n    # Age: typical patient population\n    age_mean=58.0,\n    age_sd=14.0,\n    age_min=18.0,\n    age_max=85.0,\n\n    # Weight: slightly overweight\n    weight_mean=82.0,\n    weight_sd=18.0,\n    weight_min=45.0,\n    weight_max=160.0,\n\n    # Sex distribution\n    female_fraction=0.48,\n\n    # Race distribution (US-based trial)\n    race_distribution={\n        \"white\": 0.65,\n        \"black\": 0.18,\n        \"asian\": 0.08,\n        \"hispanic\": 0.06,\n        \"other\": 0.03\n    },\n\n    # Include some renal impairment\n    egfr_distribution={\n        \"normal\": 0.50,\n        \"mild\": 0.35,\n        \"moderate\": 0.15,\n        \"severe\": 0.0  # Excluded\n    },\n\n    # Custom covariates\n    covariates={\n        \"baseline_hba1c\": trial.CovariateSpec(\n            type=\"continuous\",\n            distribution=\"normal\",\n            mean=8.2,\n            sd=1.2,\n            min=7.0,\n            max=12.0\n        ),\n        \"diabetes_duration\": trial.CovariateSpec(\n            type=\"continuous\",\n            distribution=\"lognormal\",\n            mean=8.0,\n            sd=5.0,\n            min=1.0,\n            max=30.0\n        ),\n        \"prior_therapy\": trial.CovariateSpec(\n            type=\"categorical\",\n            categories=[\"metformin_only\", \"dual_therapy\", \"insulin\"],\n            probabilities=[0.40, 0.45, 0.15]\n        )\n    }\n)\n\n# 2. Generate population\nprint(\"Generating virtual population...\")\npop = trial.generate_virtual_population(\n    n=300,\n    spec=spec,\n    seed=42\n)\n\n# 3. Display summary\nsummary = trial.summarize_population(pop)\n\nprint(\"\\n=== Population Summary ===\")\nprint(f\"Total subjects: {summary['n']}\")\nprint(f\"\\nDemographics:\")\nprint(f\"  Age: {summary['age']['mean']:.1f} \u00b1 {summary['age']['sd']:.1f} years\")\nprint(f\"  Weight: {summary['weight']['mean']:.1f} \u00b1 {summary['weight']['sd']:.1f} kg\")\nprint(f\"  BMI: {summary['bmi']['mean']:.1f} \u00b1 {summary['bmi']['sd']:.1f} kg/m\u00b2\")\nprint(f\"  Female: {summary['female_fraction']*100:.0f}%\")\n\nprint(f\"\\nRace Distribution:\")\nfor race, frac in summary['race_distribution'].items():\n    print(f\"  {race}: {frac*100:.0f}%\")\n\nprint(f\"\\nRenal Function:\")\nfor category, frac in summary['egfr_distribution'].items():\n    print(f\"  {category}: {frac*100:.0f}%\")\n\nprint(f\"\\nBaseline Characteristics:\")\nprint(f\"  HbA1c: {summary['covariates']['baseline_hba1c']['mean']:.1f}%\")\nprint(f\"  Diabetes duration: {summary['covariates']['diabetes_duration']['mean']:.1f} years\")\n\n# 4. Randomize to treatment arms\nassignments = trial.stratified_randomize(\n    population=pop,\n    arms=[\"Placebo\", \"Low Dose\", \"High Dose\"],\n    ratio=[1, 1, 1],\n    strata=[\"sex\"],\n    block_size=6,\n    seed=42\n)\n\nprint(f\"\\nRandomization:\")\nfor arm, subjects in assignments.items():\n    n = len(subjects)\n    print(f\"  {arm}: {n} subjects\")\n\n# 5. Check covariate balance\nbalance = trial.check_covariate_balance(\n    population=pop,\n    assignments=assignments,\n    covariates=[\"age\", \"weight\", \"baseline_hba1c\"]\n)\n\nprint(f\"\\nCovariate Balance (p-values):\")\nfor cov, p in balance.items():\n    status = \"\u2713\" if p &gt; 0.05 else \"\u26a0\"\n    print(f\"  {cov}: p={p:.3f} {status}\")\n</code></pre>"},{"location":"python/trial/population/#see-also","title":"See Also","text":"<ul> <li>Study Designs - Trial design types</li> <li>Dosing Regimens - Dosing schedules</li> <li>Power Analysis - Sample size calculation</li> <li>Julia Population - Julia interface</li> </ul>"},{"location":"python/trial/power/","title":"Power Analysis","text":"<p>Comprehensive guide for sample size calculation and power analysis in OpenPKPD Python.</p>"},{"location":"python/trial/power/#overview","title":"Overview","text":"<p>Power analysis determines the sample size needed to detect effects with adequate statistical power.</p> <pre><code>from openpkpd import trial\n\n# Calculate required sample size\nresult = trial.estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05\n)\n\nprint(f\"Required n per arm: {result.n_per_arm}\")\n</code></pre>"},{"location":"python/trial/power/#analytical-power","title":"Analytical Power","text":""},{"location":"python/trial/power/#two-sample-t-test","title":"Two-Sample t-Test","text":"<pre><code>from openpkpd.trial import estimate_power_analytical\n\n# Calculate power for given sample size\npower = estimate_power_analytical(\n    n_per_arm=50,\n    effect_size=0.5,        # Cohen's d\n    sd=1.0,\n    alpha=0.05,\n    test=\"two_sample_t\"\n)\n\nprint(f\"Power: {power.power:.1%}\")\nprint(f\"Effect size: {power.effect_size}\")\n</code></pre>"},{"location":"python/trial/power/#one-sample-t-test","title":"One-Sample t-Test","text":"<pre><code>power = estimate_power_analytical(\n    n=30,\n    effect_size=0.6,\n    sd=1.0,\n    alpha=0.05,\n    test=\"one_sample_t\"\n)\n</code></pre>"},{"location":"python/trial/power/#paired-t-test","title":"Paired t-Test","text":"<pre><code>power = estimate_power_analytical(\n    n_pairs=25,\n    effect_size=0.5,\n    sd=1.0,                 # SD of differences\n    alpha=0.05,\n    test=\"paired_t\"\n)\n</code></pre>"},{"location":"python/trial/power/#sample-size-estimation","title":"Sample Size Estimation","text":""},{"location":"python/trial/power/#basic-estimation","title":"Basic Estimation","text":"<pre><code>from openpkpd.trial import estimate_sample_size\n\n# Find n for target power\nresult = estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    test=\"two_sample_t\"\n)\n\nprint(f\"Required n per arm: {result.n_per_arm}\")\nprint(f\"Total N: {result.n_total}\")\nprint(f\"Achieved power: {result.achieved_power:.1%}\")\n</code></pre>"},{"location":"python/trial/power/#samplesizeresult-class","title":"SampleSizeResult Class","text":"<pre><code>@dataclass\nclass SampleSizeResult:\n    \"\"\"Result of sample size calculation.\"\"\"\n\n    n_per_arm: int              # Sample size per arm\n    n_total: int                # Total sample size\n    achieved_power: float       # Actual power achieved\n    effect_size: float          # Effect size used\n    alpha: float                # Alpha level\n    test: str                   # Statistical test used\n</code></pre>"},{"location":"python/trial/power/#with-dropout-adjustment","title":"With Dropout Adjustment","text":"<pre><code># Account for anticipated dropout\nresult = estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    dropout_rate=0.15           # 15% dropout\n)\n\nprint(f\"Enrollment needed: {result.n_to_enroll}\")\nprint(f\"Expected completers: {result.n_per_arm}\")\n</code></pre>"},{"location":"python/trial/power/#bioequivalence-power","title":"Bioequivalence Power","text":""},{"location":"python/trial/power/#standard-be-22-crossover","title":"Standard BE (2\u00d72 Crossover)","text":"<pre><code>from openpkpd.trial import be_sample_size\n\n# Calculate sample size for BE study\nresult = be_sample_size(\n    gmr=0.95,                   # Expected geometric mean ratio\n    cv_within=0.25,             # Within-subject CV\n    theta1=0.80,                # Lower BE limit\n    theta2=1.25,                # Upper BE limit\n    alpha=0.05,\n    power=0.80\n)\n\nprint(f\"Required N: {result.n_total}\")\nprint(f\"Power: {result.power:.1%}\")\n</code></pre>"},{"location":"python/trial/power/#be-power-calculation","title":"BE Power Calculation","text":"<pre><code>from openpkpd.trial import be_power\n\n# Calculate power for given sample size\npower = be_power(\n    n=24,\n    gmr=0.95,\n    cv_within=0.25,\n    theta1=0.80,\n    theta2=1.25,\n    alpha=0.05\n)\n\nprint(f\"Power: {power:.1%}\")\n</code></pre>"},{"location":"python/trial/power/#replicate-design-sample-size","title":"Replicate Design Sample Size","text":"<pre><code># 2\u00d74 replicate design (for HVD)\nresult = be_sample_size(\n    gmr=0.95,\n    cv_within=0.35,             # Higher CV\n    theta1=0.80,\n    theta2=1.25,\n    alpha=0.05,\n    power=0.80,\n    design=\"replicate_2x4\"\n)\n\n# Partial replicate (3\u00d73)\nresult = be_sample_size(\n    gmr=0.95,\n    cv_within=0.35,\n    power=0.80,\n    design=\"partial_replicate\"\n)\n</code></pre>"},{"location":"python/trial/power/#highly-variable-drug-power","title":"Highly Variable Drug Power","text":""},{"location":"python/trial/power/#rsabe-sample-size-fda","title":"RSABE Sample Size (FDA)","text":"<pre><code>from openpkpd.trial import rsabe_sample_size\n\n# Reference-scaled average bioequivalence\nresult = rsabe_sample_size(\n    gmr=0.95,\n    cv_reference=0.40,          # Reference CV &gt; 30%\n    theta_s=0.8928,             # Scaling factor\n    sigma_w0=0.25,              # Regulatory cutoff\n    alpha=0.05,\n    power=0.80\n)\n\nprint(f\"Required N: {result.n_total}\")\nprint(f\"Scaling applied: {result.scaling_applied}\")\nprint(f\"Effective limits: [{result.lower_limit:.2f}, {result.upper_limit:.2f}]\")\n</code></pre>"},{"location":"python/trial/power/#abel-sample-size-ema","title":"ABEL Sample Size (EMA)","text":"<pre><code>from openpkpd.trial import abel_sample_size\n\n# Average bioequivalence with expanding limits\nresult = abel_sample_size(\n    gmr=0.95,\n    cv_reference=0.40,\n    cv_cutoff=0.30,\n    max_widening=0.50,          # Maximum expansion\n    alpha=0.05,\n    power=0.80\n)\n\nprint(f\"Required N: {result.n_total}\")\nprint(f\"Widened limits: [{result.lower_limit:.2%}, {result.upper_limit:.2%}]\")\n</code></pre>"},{"location":"python/trial/power/#power-curves","title":"Power Curves","text":""},{"location":"python/trial/power/#generate-power-curve","title":"Generate Power Curve","text":"<pre><code>from openpkpd.trial import power_curve\n\n# Power vs sample size\ncurve = power_curve(\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    n_range=range(10, 101, 5),\n    test=\"two_sample_t\"\n)\n\n# Find minimum N for 80% power\nmin_n = next(n for n, p in zip(curve.n, curve.power) if p &gt;= 0.80)\nprint(f\"Minimum N for 80% power: {min_n}\")\n</code></pre>"},{"location":"python/trial/power/#effect-size-sensitivity","title":"Effect Size Sensitivity","text":"<pre><code># Power for different effect sizes at fixed N\nsensitivity = trial.effect_sensitivity(\n    n=50,\n    alpha=0.05,\n    effect_sizes=[0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],\n    test=\"two_sample_t\"\n)\n\nfor es, pow in zip(sensitivity.effect_sizes, sensitivity.powers):\n    print(f\"Effect size {es:.1f}: Power = {pow:.1%}\")\n</code></pre>"},{"location":"python/trial/power/#minimum-detectable-effect","title":"Minimum Detectable Effect","text":"<pre><code># What effect can we detect with given N and power?\nmde = trial.minimum_detectable_effect(\n    n_per_arm=50,\n    alpha=0.05,\n    power=0.80,\n    sd=1.0\n)\n\nprint(f\"Minimum detectable effect: d = {mde:.3f}\")\n</code></pre>"},{"location":"python/trial/power/#simulation-based-power","title":"Simulation-Based Power","text":""},{"location":"python/trial/power/#monte-carlo-power-estimation","title":"Monte Carlo Power Estimation","text":"<pre><code>from openpkpd.trial import simulate_power\n\n# Power via simulation\nresult = simulate_power(\n    n_per_arm=50,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    n_simulations=1000,\n    seed=42\n)\n\nprint(f\"Simulated power: {result.power:.1%}\")\nprint(f\"95% CI: ({result.ci_lower:.1%}, {result.ci_upper:.1%})\")\n</code></pre>"},{"location":"python/trial/power/#be-study-simulation","title":"BE Study Simulation","text":"<pre><code># Simulate BE study power\nresult = trial.simulate_be_power(\n    n=24,\n    gmr=0.95,\n    cv_within=0.25,\n    n_simulations=1000,\n    seed=42\n)\n\nprint(f\"BE power: {result.power:.1%}\")\nprint(f\"Pass rate: {result.pass_rate:.1%}\")\n</code></pre>"},{"location":"python/trial/power/#trial-simulation-power","title":"Trial Simulation Power","text":"<pre><code># Full trial simulation\npower = trial.simulate_trial_power(\n    trial_spec=trial_spec,\n    n_per_arm=50,\n    endpoint=\"auc_comparison\",\n    success_criterion=lambda r: r.p_value &lt; 0.05 and r.effect &gt; 0,\n    n_simulations=1000,\n    seed=42\n)\n</code></pre>"},{"location":"python/trial/power/#multi-arm-trials","title":"Multi-Arm Trials","text":""},{"location":"python/trial/power/#dunnetts-test","title":"Dunnett's Test","text":"<pre><code>from openpkpd.trial import multiarm_sample_size\n\n# Multiple treatment arms vs placebo\nresult = multiarm_sample_size(\n    n_arms=4,                   # 1 placebo + 3 active\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    power=0.80,\n    comparison=\"dunnett\"        # Many-to-one\n)\n\nprint(f\"N per arm: {result.n_per_arm}\")\nprint(f\"Total N: {result.n_total}\")\nprint(f\"Adjusted alpha: {result.adjusted_alpha:.4f}\")\n</code></pre>"},{"location":"python/trial/power/#anova","title":"ANOVA","text":"<pre><code># Overall group difference\nresult = multiarm_sample_size(\n    n_arms=4,\n    effect_size=0.3,            # f-statistic\n    alpha=0.05,\n    power=0.80,\n    comparison=\"anova\"\n)\n</code></pre>"},{"location":"python/trial/power/#pairwise-comparisons","title":"Pairwise Comparisons","text":"<pre><code># All pairwise with Bonferroni correction\nresult = multiarm_sample_size(\n    n_arms=4,\n    effect_size=0.5,\n    alpha=0.05,\n    power=0.80,\n    comparison=\"bonferroni\"\n)\n</code></pre>"},{"location":"python/trial/power/#adaptive-designs","title":"Adaptive Designs","text":""},{"location":"python/trial/power/#group-sequential-power","title":"Group Sequential Power","text":"<pre><code>from openpkpd.trial import group_sequential_power\n\n# O'Brien-Fleming boundaries\nresult = group_sequential_power(\n    n_per_arm=100,\n    effect_size=0.4,\n    sd=1.0,\n    alpha=0.05,\n    n_looks=3,\n    information_fractions=[0.33, 0.67, 1.0],\n    spending_function=\"obrien_fleming\"\n)\n\nprint(f\"Overall power: {result.power:.1%}\")\nprint(f\"P(stop at look 1): {result.stop_probs[0]:.1%}\")\nprint(f\"P(stop at look 2): {result.stop_probs[1]:.1%}\")\n</code></pre>"},{"location":"python/trial/power/#sample-size-re-estimation","title":"Sample Size Re-estimation","text":"<pre><code>from openpkpd.trial import ssr_sample_size\n\n# Initial sample size with interim re-estimation\nresult = ssr_sample_size(\n    initial_n=50,\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    interim_fraction=0.5,\n    max_n=150\n)\n\nprint(f\"Initial N: {result.initial_n}\")\nprint(f\"Expected final N: {result.expected_n}\")\nprint(f\"Max N: {result.max_n}\")\n</code></pre>"},{"location":"python/trial/power/#special-populations","title":"Special Populations","text":""},{"location":"python/trial/power/#pediatric-studies","title":"Pediatric Studies","text":"<pre><code># Pediatric with higher variability\nresult = estimate_sample_size(\n    target_power=0.80,\n    effect_size=0.5,\n    sd=1.0,\n    alpha=0.05,\n    variability_inflation=1.2   # 20% higher variability\n)\n</code></pre>"},{"location":"python/trial/power/#rare-disease","title":"Rare Disease","text":"<pre><code># Small population constraints\nresult = trial.rare_disease_power(\n    available_patients=50,\n    effect_size=0.8,            # Expect large effect\n    sd=1.0,\n    alpha=0.10                  # Relaxed alpha\n)\n\nprint(f\"Achievable power: {result.power:.1%}\")\nprint(f\"Recommended design: {result.recommended_design}\")\n</code></pre>"},{"location":"python/trial/power/#alpha-spending","title":"Alpha Spending","text":""},{"location":"python/trial/power/#obrien-fleming","title":"O'Brien-Fleming","text":"<pre><code>from openpkpd.trial import alpha_spending\n\n# O'Brien-Fleming spending\nalpha = alpha_spending(\n    information_fraction=0.5,\n    total_alpha=0.05,\n    method=\"obrien_fleming\"\n)\n\nprint(f\"Alpha spent at 50%: {alpha:.4f}\")\n</code></pre>"},{"location":"python/trial/power/#pocock","title":"Pocock","text":"<pre><code>alpha = alpha_spending(\n    information_fraction=0.5,\n    total_alpha=0.05,\n    method=\"pocock\"\n)\n</code></pre>"},{"location":"python/trial/power/#lan-demets","title":"Lan-DeMets","text":"<pre><code># Flexible spending function\nalpha = alpha_spending(\n    information_fraction=0.5,\n    total_alpha=0.05,\n    method=\"lan_demets\",\n    rho=1.0                     # Parameter\n)\n</code></pre>"},{"location":"python/trial/power/#complete-example","title":"Complete Example","text":"<pre><code>from openpkpd import trial\n\n# ==========================================\n# Comprehensive Power Analysis\n# ==========================================\n\nprint(\"=== Power Analysis for Phase III Trial ===\\n\")\n\n# Study parameters\neffect_size = 0.40              # Expected treatment effect\nsd = 1.0                        # Population SD\nalpha = 0.05                    # Two-sided alpha\ntarget_power = 0.80             # Target power\ndropout_rate = 0.15             # Expected dropout\n\n# 1. Calculate base sample size\nprint(\"--- Sample Size Calculation ---\")\nresult = trial.estimate_sample_size(\n    target_power=target_power,\n    effect_size=effect_size,\n    sd=sd,\n    alpha=alpha,\n    dropout_rate=dropout_rate\n)\n\nprint(f\"Required completers: {result.n_per_arm} per arm\")\nprint(f\"Enrollment needed: {result.n_to_enroll} per arm\")\nprint(f\"Total enrollment: {result.n_to_enroll * 2}\")\nprint(f\"Achieved power: {result.achieved_power:.1%}\")\n\n# 2. Power curve\nprint(\"\\n--- Power by Sample Size ---\")\ncurve = trial.power_curve(\n    effect_size=effect_size,\n    sd=sd,\n    alpha=alpha,\n    n_range=range(30, 101, 10)\n)\n\nprint(\"N/arm    Power\")\nprint(\"-\" * 20)\nfor n, power in zip(curve.n, curve.power):\n    marker = \"*\" if power &gt;= 0.80 else \"\"\n    print(f\"{n:5d}    {power:.1%}{marker}\")\n\n# 3. Effect size sensitivity\nprint(\"\\n--- Detectable Effect Sizes ---\")\nprint(f\"With N = {result.n_per_arm} per arm:\")\n\nfor power_target in [0.70, 0.80, 0.90]:\n    mde = trial.minimum_detectable_effect(\n        n_per_arm=result.n_per_arm,\n        alpha=alpha,\n        power=power_target,\n        sd=sd\n    )\n    print(f\"  {int(power_target*100)}% power: d = {mde:.3f}\")\n\n# 4. Simulation verification\nprint(\"\\n--- Simulation Verification ---\")\nsim_result = trial.simulate_power(\n    n_per_arm=result.n_per_arm,\n    effect_size=effect_size,\n    sd=sd,\n    alpha=alpha,\n    n_simulations=1000,\n    seed=42\n)\n\nprint(f\"Simulated power: {sim_result.power:.1%}\")\nprint(f\"95% CI: ({sim_result.ci_lower:.1%}, {sim_result.ci_upper:.1%})\")\n\n# 5. Group sequential design\nprint(\"\\n--- Group Sequential Design ---\")\ngs_result = trial.group_sequential_power(\n    n_per_arm=result.n_per_arm,\n    effect_size=effect_size,\n    sd=sd,\n    alpha=alpha,\n    n_looks=2,\n    information_fractions=[0.5, 1.0],\n    spending_function=\"obrien_fleming\"\n)\n\nprint(f\"Overall power: {gs_result.power:.1%}\")\nprint(f\"Efficacy boundaries: {gs_result.boundaries}\")\nprint(f\"P(stop at interim): {gs_result.stop_probs[0]:.1%}\")\nprint(f\"Expected sample size: {gs_result.expected_n:.0f}\")\n\n# 6. Summary\nprint(\"\\n\" + \"=\" * 50)\nprint(\"RECOMMENDATION\")\nprint(\"=\" * 50)\nprint(f\"\\nEnroll {result.n_to_enroll * 2} subjects total\")\nprint(f\"({result.n_to_enroll} per arm)\")\nprint(f\"\\nWith {int(dropout_rate*100)}% dropout:\")\nprint(f\"  Expected completers: {result.n_per_arm * 2}\")\nprint(f\"  Power: {result.achieved_power:.1%}\")\nprint(f\"\\nTo detect effect size d = {effect_size}\")\nprint(f\"At alpha = {alpha} (two-sided)\")\n</code></pre>"},{"location":"python/trial/power/#power-tables","title":"Power Tables","text":""},{"location":"python/trial/power/#parallel-design-reference","title":"Parallel Design Reference","text":"Effect Size CV N per Arm (80%) N per Arm (90%) 0.3 30% 176 235 0.4 30% 99 132 0.5 30% 64 85 0.6 30% 44 59 0.7 30% 33 44"},{"location":"python/trial/power/#be-crossover-reference","title":"BE Crossover Reference","text":"CV Within GMR N (80%) N (90%) 15% 0.95 10 14 20% 0.95 16 22 25% 0.95 24 32 30% 0.95 36 48 25% 1.00 18 24"},{"location":"python/trial/power/#function-reference","title":"Function Reference","text":"Function Description <code>estimate_power_analytical</code> Analytical power calculation <code>estimate_sample_size</code> Sample size for target power <code>be_sample_size</code> BE study sample size <code>be_power</code> BE study power <code>power_curve</code> Power vs sample size curve <code>simulate_power</code> Monte Carlo power <code>multiarm_sample_size</code> Multi-arm trial sample size <code>alpha_spending</code> Alpha spending functions <code>minimum_detectable_effect</code> MDE calculation"},{"location":"python/trial/power/#see-also","title":"See Also","text":"<ul> <li>Study Designs - Trial design types</li> <li>Dosing Regimens - Dosing schedules</li> <li>Virtual Population - Subject generation</li> <li>Julia Power Analysis - Julia interface</li> </ul>"},{"location":"python/viz/","title":"Visualization","text":"<p>OpenPKPD provides 55+ professional visualization functions with dual matplotlib and plotly backend support.</p>"},{"location":"python/viz/#overview","title":"Overview","text":"<p>The visualization module (<code>openpkpd.viz</code>) offers:</p> <ul> <li>Dual Backends: Static (matplotlib) and interactive (plotly)</li> <li>Consistent API: Same function signatures across backends</li> <li>Publication Quality: Professional styling and themes</li> <li>Complete Coverage: All analysis types supported</li> </ul>"},{"location":"python/viz/#visualization-categories","title":"Visualization Categories","text":"<ul> <li> <p> Backends &amp; Themes</p> <p>Configure visualization backend and styling</p> <p> Backends</p> </li> <li> <p> PK Plots</p> <p>Concentration-time profiles</p> <p> PK Plots</p> </li> <li> <p> NCA Plots</p> <p>Lambda-z fit, AUC visualization</p> <p> NCA Plots</p> </li> <li> <p> PKPD Plots</p> <p>Effect-concentration, hysteresis</p> <p> PKPD Plots</p> </li> <li> <p> VPC Plots</p> <p>Visual predictive checks</p> <p> VPC Plots</p> </li> <li> <p> Estimation Diagnostics</p> <p>Convergence, shrinkage, correlations</p> <p> Estimation</p> </li> <li> <p> Bootstrap Plots</p> <p>Distribution and CI visualization</p> <p> Bootstrap</p> </li> <li> <p> Sensitivity Plots</p> <p>Tornado, spider, heatmap</p> <p> Sensitivity</p> </li> <li> <p> Population Plots</p> <p>Forest plots, distributions</p> <p> Population</p> </li> <li> <p> Trial Plots</p> <p>Power curves, Kaplan-Meier</p> <p> Trial</p> </li> </ul>"},{"location":"python/viz/#quick-start","title":"Quick Start","text":""},{"location":"python/viz/#backend-selection","title":"Backend Selection","text":"<pre><code>from openpkpd import viz\n\n# Set matplotlib backend (default)\nviz.set_backend(\"matplotlib\")\n\n# Or use plotly for interactive plots\nviz.set_backend(\"plotly\")\n\n# Check current backend\nprint(viz.get_backend())\n\n# List available backends\nprint(viz.available_backends())  # [\"matplotlib\", \"plotly\"]\n</code></pre>"},{"location":"python/viz/#basic-plotting","title":"Basic Plotting","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Run simulation\nresult = openpkpd.simulate_pk_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[t * 0.5 for t in range(49)]\n)\n\n# Create plot\nfig = viz.plot_conc_time(result, title=\"PK Profile\")\nfig.savefig(\"pk_profile.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/#complete-function-list","title":"Complete Function List","text":""},{"location":"python/viz/#pk-plots-5-functions","title":"PK Plots (5 functions)","text":"Function Description <code>plot_conc_time</code> Single concentration-time profile <code>plot_multi_conc_time</code> Multiple profiles overlay <code>plot_spaghetti</code> Population spaghetti plot <code>plot_mean_ribbon</code> Mean with confidence ribbon <code>plot_individual_fits</code> Grid of individual fits"},{"location":"python/viz/#nca-plots-3-functions","title":"NCA Plots (3 functions)","text":"Function Description <code>plot_lambda_z_fit</code> Terminal phase regression <code>plot_auc_visualization</code> AUC shaded area <code>plot_dose_proportionality</code> Dose vs exposure"},{"location":"python/viz/#pkpd-plots-3-functions","title":"PKPD Plots (3 functions)","text":"Function Description <code>plot_effect_conc</code> Effect vs concentration <code>plot_hysteresis</code> Hysteresis loop <code>plot_dose_response</code> Dose-response curve"},{"location":"python/viz/#vpc-plots-5-functions","title":"VPC Plots (5 functions)","text":"Function Description <code>plot_vpc_detailed</code> Full VPC with percentiles and CI <code>plot_pcvpc</code> Prediction-corrected VPC <code>plot_stratified_vpc</code> VPC by strata <code>plot_vpc_with_blq</code> VPC with BLQ handling <code>plot_vpc_ci</code> VPC confidence intervals"},{"location":"python/viz/#estimation-diagnostics-10-functions","title":"Estimation Diagnostics (10 functions)","text":"Function Description <code>plot_parameter_estimates</code> Forest plot of theta <code>plot_omega_matrix</code> Omega covariance heatmap <code>plot_convergence</code> OFV vs iteration <code>plot_parameter_convergence</code> Parameter traces <code>plot_shrinkage</code> Eta shrinkage bars <code>plot_eta_distributions</code> Eta histograms <code>plot_individual_parameters</code> EBE distributions <code>plot_ofv_comparison</code> Model OFV comparison <code>plot_correlation_matrix</code> Parameter correlations <code>plot_sigma_residuals</code> Residual error"},{"location":"python/viz/#bootstrap-plots-4-functions","title":"Bootstrap Plots (4 functions)","text":"Function Description <code>plot_bootstrap_distributions</code> Parameter histograms <code>plot_bootstrap_ci</code> CI comparison <code>plot_bootstrap_stability</code> Stability over runs <code>plot_bootstrap_correlation</code> Inter-parameter correlation"},{"location":"python/viz/#sensitivity-plots-5-functions","title":"Sensitivity Plots (5 functions)","text":"Function Description <code>plot_tornado</code> Tornado diagram <code>plot_spider</code> Spider/radar plot <code>plot_sensitivity_heatmap</code> Parameter-metric heatmap <code>plot_waterfall</code> Ranked sensitivities <code>plot_one_at_a_time</code> OFAT curves"},{"location":"python/viz/#population-plots-8-functions","title":"Population Plots (8 functions)","text":"Function Description <code>plot_vpc</code> Basic VPC <code>plot_parameter_distributions</code> Parameter histograms <code>plot_forest</code> Forest plot <code>plot_boxplot</code> Box plot comparison <code>plot_goodness_of_fit</code> GOF panel <code>plot_estimation_summary</code> Summary dashboard <code>plot_sensitivity</code> Parameter sensitivity <code>plot_sensitivity_tornado</code> Sensitivity tornado"},{"location":"python/viz/#trial-plots-4-functions","title":"Trial Plots (4 functions)","text":"Function Description <code>plot_power_curve</code> Power vs sample size <code>plot_trial_tornado</code> Trial sensitivity <code>plot_kaplan_meier</code> Survival curves <code>plot_endpoint_distribution</code> Endpoint histograms"},{"location":"python/viz/#common-parameters","title":"Common Parameters","text":"<p>All visualization functions share these parameters:</p> Parameter Type Default Description <code>backend</code> <code>str</code> Current \"matplotlib\" or \"plotly\" <code>title</code> <code>str</code> None Plot title <code>xlabel</code> <code>str</code> Auto X-axis label <code>ylabel</code> <code>str</code> Auto Y-axis label <code>figsize</code> <code>tuple</code> (10, 6) Figure size (inches) <code>theme</code> <code>str</code> \"openpkpd\" Color theme <code>save_path</code> <code>str</code> None Path to save figure"},{"location":"python/viz/#themes","title":"Themes","text":"<pre><code>from openpkpd import viz\n\n# Set theme\nviz.set_theme(\"openpkpd\")      # Default professional theme\nviz.set_theme(\"publication\")    # Minimal for publications\nviz.set_theme(\"presentation\")   # Bold for slides\n\n# Available themes\nprint(viz.available_themes())\n\n# Access color palette\ncolors = viz.OPENPKPD_COLORS\nprint(colors)\n# {\"primary\": \"#3498DB\", \"secondary\": \"#2ECC71\", ...}\n</code></pre>"},{"location":"python/viz/#examples","title":"Examples","text":""},{"location":"python/viz/#population-spaghetti-with-mean","title":"Population Spaghetti with Mean","text":"<pre><code>pop_result = openpkpd.simulate_population_iv_bolus(\n    cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0,\n    saveat=[float(t) for t in range(25)],\n    n=100, seed=42,\n    omegas={\"CL\": 0.3, \"V\": 0.2}\n)\n\n# Spaghetti plot\nfig = viz.plot_spaghetti(pop_result, alpha=0.2, n_subjects=50)\nfig.savefig(\"spaghetti.png\", dpi=300)\n\n# Mean with 90% prediction interval\nfig = viz.plot_mean_ribbon(\n    pop_result,\n    ci_levels=[0.05, 0.95],\n    show_median=True,\n    show_individual=False\n)\nfig.savefig(\"mean_ribbon.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/#vpc-plot","title":"VPC Plot","text":"<pre><code>fig = viz.plot_vpc_detailed(\n    simulated_data,\n    observed_data,\n    prediction_intervals=[0.05, 0.50, 0.95],\n    show_ci=True,\n    show_binning=True\n)\nfig.savefig(\"vpc.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/#tornado-plot","title":"Tornado Plot","text":"<pre><code>sensitivity_results = [\n    {\"parameter\": \"CL\", \"low\": -0.3, \"high\": 0.25},\n    {\"parameter\": \"V\", \"low\": -0.15, \"high\": 0.18},\n    {\"parameter\": \"Ka\", \"low\": -0.4, \"high\": 0.35},\n]\n\nfig = viz.plot_tornado(\n    sensitivity_results,\n    baseline_value=0.0,\n    title=\"Parameter Sensitivity\"\n)\nfig.savefig(\"tornado.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/#saving-plots","title":"Saving Plots","text":""},{"location":"python/viz/#matplotlib","title":"Matplotlib","text":"<pre><code>viz.set_backend(\"matplotlib\")\nfig = viz.plot_conc_time(result)\n\n# PNG (raster)\nfig.savefig(\"plot.png\", dpi=300, bbox_inches=\"tight\")\n\n# PDF (vector)\nfig.savefig(\"plot.pdf\", bbox_inches=\"tight\")\n\n# SVG (vector)\nfig.savefig(\"plot.svg\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"python/viz/#plotly","title":"Plotly","text":"<pre><code>viz.set_backend(\"plotly\")\nfig = viz.plot_conc_time(result)\n\n# Interactive HTML\nfig.write_html(\"plot.html\")\n\n# Static image (requires kaleido)\nfig.write_image(\"plot.png\", scale=2)\nfig.write_image(\"plot.pdf\")\nfig.write_image(\"plot.svg\")\n</code></pre>"},{"location":"python/viz/#next-steps","title":"Next Steps","text":"<ul> <li>Backends &amp; Themes - Detailed configuration</li> <li>PK Plots - Concentration-time visualization</li> <li>VPC Plots - Visual predictive checks</li> <li>Estimation Plots - Diagnostic plots</li> </ul>"},{"location":"python/viz/backends/","title":"Backends &amp; Themes","text":"<p>Configure visualization backends and styling for OpenPKPD plots.</p>"},{"location":"python/viz/backends/#overview","title":"Overview","text":"<p>OpenPKPD supports dual visualization backends:</p> <ul> <li>Matplotlib: Static, publication-quality figures</li> <li>Plotly: Interactive, web-embeddable plots</li> </ul> <pre><code>from openpkpd import viz\n\n# Set backend globally\nviz.set_backend(\"matplotlib\")  # or \"plotly\"\n\n# Check current backend\nprint(viz.get_backend())\n\n# List available backends\nprint(viz.available_backends())  # [\"matplotlib\", \"plotly\"]\n</code></pre>"},{"location":"python/viz/backends/#backend-selection","title":"Backend Selection","text":""},{"location":"python/viz/backends/#matplotlib-default","title":"Matplotlib (Default)","text":"<p>Best for publication-quality static figures:</p> <pre><code>viz.set_backend(\"matplotlib\")\n\nfig = viz.plot_conc_time(result)\nfig.savefig(\"plot.pdf\", bbox_inches=\"tight\")  # Vector format\nfig.savefig(\"plot.png\", dpi=300)              # Raster format\n</code></pre> <p>Advantages: - Publication-quality output - Vector format support (PDF, SVG, EPS) - Fine-grained customization - Familiar API for scientists</p>"},{"location":"python/viz/backends/#plotly","title":"Plotly","text":"<p>Best for interactive exploration:</p> <pre><code>viz.set_backend(\"plotly\")\n\nfig = viz.plot_conc_time(result)\nfig.write_html(\"plot.html\")           # Interactive HTML\nfig.write_image(\"plot.png\", scale=2)  # Static image (requires kaleido)\n</code></pre> <p>Advantages: - Interactive zoom/pan - Hover tooltips - Web embedding - Animation support</p>"},{"location":"python/viz/backends/#themes","title":"Themes","text":""},{"location":"python/viz/backends/#available-themes","title":"Available Themes","text":"<pre><code># Set theme\nviz.set_theme(\"openpkpd\")      # Default professional theme\nviz.set_theme(\"publication\")    # Minimal for publications\nviz.set_theme(\"presentation\")   # Bold for slides\n\n# List available themes\nprint(viz.available_themes())\n</code></pre>"},{"location":"python/viz/backends/#theme-properties","title":"Theme Properties","text":"Theme Use Case Font Size Line Width <code>openpkpd</code> General use Medium Medium <code>publication</code> Journal figures Small Thin <code>presentation</code> Slides Large Thick"},{"location":"python/viz/backends/#color-palette","title":"Color Palette","text":"<pre><code># Access color palette\ncolors = viz.OPENPKPD_COLORS\n\nprint(colors)\n# {\n#     \"primary\": \"#3498DB\",\n#     \"secondary\": \"#2ECC71\",\n#     \"accent\": \"#E74C3C\",\n#     \"neutral\": \"#95A5A6\",\n#     \"dark\": \"#2C3E50\",\n#     \"light\": \"#ECF0F1\"\n# }\n\n# Use in custom plots\nimport matplotlib.pyplot as plt\nplt.plot(x, y, color=colors[\"primary\"])\n</code></pre>"},{"location":"python/viz/backends/#per-function-backend-override","title":"Per-Function Backend Override","text":"<p>Override backend for individual function calls:</p> <pre><code># Global backend is matplotlib\nviz.set_backend(\"matplotlib\")\n\n# But use plotly for this specific plot\nfig = viz.plot_conc_time(result, backend=\"plotly\")\n</code></pre>"},{"location":"python/viz/backends/#saving-figures","title":"Saving Figures","text":""},{"location":"python/viz/backends/#matplotlib","title":"Matplotlib","text":"<pre><code>viz.set_backend(\"matplotlib\")\nfig = viz.plot_conc_time(result)\n\n# PNG (raster)\nfig.savefig(\"plot.png\", dpi=300, bbox_inches=\"tight\")\n\n# PDF (vector)\nfig.savefig(\"plot.pdf\", bbox_inches=\"tight\")\n\n# SVG (vector, web-friendly)\nfig.savefig(\"plot.svg\", bbox_inches=\"tight\")\n\n# Using save_path parameter\nfig = viz.plot_conc_time(result, save_path=\"plot.png\")\n</code></pre>"},{"location":"python/viz/backends/#plotly_1","title":"Plotly","text":"<pre><code>viz.set_backend(\"plotly\")\nfig = viz.plot_conc_time(result)\n\n# Interactive HTML\nfig.write_html(\"plot.html\")\n\n# Static image (requires kaleido: pip install kaleido)\nfig.write_image(\"plot.png\", scale=2)\nfig.write_image(\"plot.pdf\")\nfig.write_image(\"plot.svg\")\n</code></pre>"},{"location":"python/viz/backends/#custom-styling","title":"Custom Styling","text":""},{"location":"python/viz/backends/#matplotlib-customization","title":"Matplotlib Customization","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Custom rcParams\nplt.rcParams.update({\n    'font.family': 'Arial',\n    'font.size': 12,\n    'axes.linewidth': 1.5,\n    'axes.labelsize': 14,\n    'xtick.labelsize': 11,\n    'ytick.labelsize': 11,\n    'legend.fontsize': 11,\n})\n\n# Apply to plot\nfig = viz.plot_conc_time(result)\n</code></pre>"},{"location":"python/viz/backends/#plotly-customization","title":"Plotly Customization","text":"<pre><code>fig = viz.plot_conc_time(result, backend=\"plotly\")\n\n# Update layout\nfig.update_layout(\n    font=dict(family=\"Arial\", size=14),\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Update traces\nfig.update_traces(line=dict(width=2))\n</code></pre>"},{"location":"python/viz/backends/#see-also","title":"See Also","text":"<ul> <li>PK Plots - Concentration-time visualization</li> <li>VPC Plots - Visual predictive checks</li> <li>Visualization Index - All visualization functions</li> </ul>"},{"location":"python/viz/bootstrap/","title":"Bootstrap Plots","text":"<p>Bootstrap analysis visualization for parameter uncertainty.</p>"},{"location":"python/viz/bootstrap/#overview","title":"Overview","text":"<p>Bootstrap plots visualize parameter distributions and confidence intervals from resampling analysis.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_bootstrap_distributions(bootstrap_result)\n</code></pre>"},{"location":"python/viz/bootstrap/#functions","title":"Functions","text":""},{"location":"python/viz/bootstrap/#plot_bootstrap_distributions","title":"plot_bootstrap_distributions","text":"<p>Histograms of bootstrap parameter estimates:</p> <pre><code>def plot_bootstrap_distributions(\n    bootstrap_result: BootstrapResult | dict,\n    params: list[str] | None = None,\n    *,\n    show_original: bool = True,\n    show_ci: bool = True,\n    ci_level: float = 0.95,\n    n_cols: int = 3,\n    title: str | None = None,\n    figsize: tuple | None = None,\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Bootstrap parameter distributions\nfig = viz.plot_bootstrap_distributions(\n    bootstrap_result,\n    show_original=True,\n    show_ci=True,\n    ci_level=0.95,\n    title=\"Parameter Distributions (1000 bootstraps)\"\n)\n</code></pre>"},{"location":"python/viz/bootstrap/#plot_bootstrap_ci","title":"plot_bootstrap_ci","text":"<p>Confidence interval comparison:</p> <pre><code>def plot_bootstrap_ci(\n    bootstrap_result: BootstrapResult | dict,\n    params: list[str] | None = None,\n    *,\n    methods: list[str] = [\"percentile\", \"bca\"],\n    ci_level: float = 0.95,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Compare CI methods\nfig = viz.plot_bootstrap_ci(\n    bootstrap_result,\n    methods=[\"percentile\", \"bca\"],\n    ci_level=0.95,\n    title=\"Bootstrap CI Comparison\"\n)\n</code></pre>"},{"location":"python/viz/bootstrap/#plot_bootstrap_stability","title":"plot_bootstrap_stability","text":"<p>Parameter stability over bootstrap runs:</p> <pre><code>def plot_bootstrap_stability(\n    bootstrap_result: BootstrapResult | dict,\n    params: list[str] | None = None,\n    *,\n    show_cumulative_mean: bool = True,\n    title: str | None = None,\n    figsize: tuple = (12, 8),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Stability assessment\nfig = viz.plot_bootstrap_stability(\n    bootstrap_result,\n    show_cumulative_mean=True,\n    title=\"Bootstrap Stability\"\n)\n</code></pre>"},{"location":"python/viz/bootstrap/#plot_bootstrap_correlation","title":"plot_bootstrap_correlation","text":"<p>Inter-parameter correlations:</p> <pre><code>def plot_bootstrap_correlation(\n    bootstrap_result: BootstrapResult | dict,\n    *,\n    annotate: bool = True,\n    title: str | None = None,\n    figsize: tuple = (10, 10),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Correlation matrix from bootstrap\nfig = viz.plot_bootstrap_correlation(\n    bootstrap_result,\n    annotate=True,\n    title=\"Parameter Correlations\"\n)\n</code></pre>"},{"location":"python/viz/bootstrap/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Run bootstrap analysis\nbootstrap_result = openpkpd.bootstrap_estimation(\n    observed_data=data,\n    model_spec=model,\n    n_bootstrap=1000,\n    seed=42\n)\n\n# Parameter distributions\nfig = viz.plot_bootstrap_distributions(\n    bootstrap_result,\n    show_original=True,\n    ci_level=0.95,\n    n_cols=3,\n    title=\"Bootstrap Parameter Distributions\"\n)\nfig.savefig(\"bootstrap_dist.png\", dpi=300)\n\n# CI comparison\nfig = viz.plot_bootstrap_ci(\n    bootstrap_result,\n    methods=[\"percentile\", \"bca\"],\n    title=\"Confidence Interval Methods\"\n)\nfig.savefig(\"bootstrap_ci.png\", dpi=300)\n\n# Stability\nfig = viz.plot_bootstrap_stability(bootstrap_result)\nfig.savefig(\"bootstrap_stability.png\", dpi=300)\n\n# Correlations\nfig = viz.plot_bootstrap_correlation(bootstrap_result)\nfig.savefig(\"bootstrap_corr.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/bootstrap/#see-also","title":"See Also","text":"<ul> <li>Bootstrap Analysis - Bootstrap computation</li> <li>Estimation Diagnostics - More diagnostic plots</li> <li>Population Plots - Population visualizations</li> </ul>"},{"location":"python/viz/estimation/","title":"Estimation Diagnostics","text":"<p>Parameter estimation diagnostic visualization.</p>"},{"location":"python/viz/estimation/#overview","title":"Overview","text":"<p>Estimation diagnostics help assess model fit quality and parameter uncertainty.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_convergence(est_result, title=\"FOCE Convergence\")\n</code></pre>"},{"location":"python/viz/estimation/#functions","title":"Functions","text":""},{"location":"python/viz/estimation/#plot_convergence","title":"plot_convergence","text":"<p>OFV vs iteration trace:</p> <pre><code>def plot_convergence(\n    est_result: EstimationResult | dict,\n    *,\n    show_final: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Iteration\",\n    ylabel: str = \"Objective Function Value\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_parameter_estimates","title":"plot_parameter_estimates","text":"<p>Forest plot of parameter estimates with CI:</p> <pre><code>def plot_parameter_estimates(\n    est_result: EstimationResult | dict,\n    *,\n    show_ci: bool = True,\n    ci_level: float = 0.95,\n    reference_line: float | None = None,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_omega_matrix","title":"plot_omega_matrix","text":"<p>Omega covariance matrix heatmap:</p> <pre><code>def plot_omega_matrix(\n    est_result: EstimationResult | dict,\n    *,\n    annotate: bool = True,\n    title: str | None = None,\n    figsize: tuple = (8, 8),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_parameter_convergence","title":"plot_parameter_convergence","text":"<p>Individual parameter traces:</p> <pre><code>def plot_parameter_convergence(\n    est_result: EstimationResult | dict,\n    params: list[str] | None = None,\n    *,\n    title: str | None = None,\n    figsize: tuple = (12, 8),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_shrinkage","title":"plot_shrinkage","text":"<p>Eta shrinkage bar chart:</p> <pre><code>def plot_shrinkage(\n    est_result: EstimationResult | dict,\n    *,\n    threshold: float = 0.3,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_eta_distributions","title":"plot_eta_distributions","text":"<p>Histograms of random effects:</p> <pre><code>def plot_eta_distributions(\n    est_result: EstimationResult | dict,\n    *,\n    show_normal: bool = True,\n    n_cols: int = 3,\n    title: str | None = None,\n    figsize: tuple | None = None,\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_individual_parameters","title":"plot_individual_parameters","text":"<p>EBE distributions vs population:</p> <pre><code>def plot_individual_parameters(\n    est_result: EstimationResult | dict,\n    *,\n    show_typical: bool = True,\n    n_cols: int = 3,\n    title: str | None = None,\n    figsize: tuple | None = None,\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_correlation_matrix","title":"plot_correlation_matrix","text":"<p>Parameter correlation heatmap:</p> <pre><code>def plot_correlation_matrix(\n    est_result: EstimationResult | dict,\n    *,\n    annotate: bool = True,\n    title: str | None = None,\n    figsize: tuple = (10, 10),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_ofv_comparison","title":"plot_ofv_comparison","text":"<p>Model comparison by OFV:</p> <pre><code>def plot_ofv_comparison(\n    results: list[EstimationResult | dict],\n    labels: list[str],\n    *,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#plot_sigma_residuals","title":"plot_sigma_residuals","text":"<p>Residual error visualization:</p> <pre><code>def plot_sigma_residuals(\n    est_result: EstimationResult | dict,\n    *,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/estimation/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Run estimation (example)\nest_result = openpkpd.estimate_foce(\n    observed_data=data,\n    model_spec=model,\n    initial_params=init_params\n)\n\n# Convergence plot\nfig = viz.plot_convergence(est_result, title=\"FOCE-I Convergence\")\nfig.savefig(\"convergence.png\", dpi=300)\n\n# Parameter estimates with CI\nfig = viz.plot_parameter_estimates(est_result, title=\"Parameter Estimates\")\nfig.savefig(\"parameters.png\", dpi=300)\n\n# Omega matrix\nfig = viz.plot_omega_matrix(est_result, title=\"Random Effects Covariance\")\nfig.savefig(\"omega.png\", dpi=300)\n\n# Shrinkage\nfig = viz.plot_shrinkage(est_result, threshold=0.3)\nfig.savefig(\"shrinkage.png\", dpi=300)\n\n# Eta distributions\nfig = viz.plot_eta_distributions(est_result)\nfig.savefig(\"etas.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/estimation/#see-also","title":"See Also","text":"<ul> <li>FOCE Method - FOCE estimation</li> <li>SAEM Algorithm - SAEM estimation</li> <li>Bootstrap Plots - Uncertainty visualization</li> </ul>"},{"location":"python/viz/nca/","title":"NCA Plots","text":"<p>Non-compartmental analysis visualization functions.</p>"},{"location":"python/viz/nca/#overview","title":"Overview","text":"<p>NCA plots visualize pharmacokinetic parameters derived from concentration-time data without assuming a specific model.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_lambda_z_fit(nca_result, title=\"Terminal Phase\")\n</code></pre>"},{"location":"python/viz/nca/#functions","title":"Functions","text":""},{"location":"python/viz/nca/#plot_lambda_z_fit","title":"plot_lambda_z_fit","text":"<p>Terminal phase regression visualization:</p> <pre><code>def plot_lambda_z_fit(\n    nca_result: NCAResult | dict,\n    *,\n    show_regression: bool = True,\n    show_r2: bool = True,\n    log_scale: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Concentration\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>nca_result = openpkpd.run_nca(\n    times=[0, 0.5, 1, 2, 4, 8, 12, 24],\n    concentrations=[0, 5.2, 8.1, 6.3, 3.8, 1.9, 0.9, 0.2],\n    dose=100.0,\n    route=\"oral\"\n)\n\n# Lambda-z regression plot\nfig = viz.plot_lambda_z_fit(nca_result, title=\"Terminal Phase Analysis\")\n</code></pre>"},{"location":"python/viz/nca/#plot_auc_visualization","title":"plot_auc_visualization","text":"<p>AUC with shaded area:</p> <pre><code>def plot_auc_visualization(\n    nca_result: NCAResult | dict,\n    *,\n    show_auc_last: bool = True,\n    show_auc_extrap: bool = True,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Show AUC components\nfig = viz.plot_auc_visualization(\n    nca_result,\n    show_auc_last=True,\n    show_auc_extrap=True,\n    title=\"AUC Breakdown\"\n)\n</code></pre>"},{"location":"python/viz/nca/#plot_dose_proportionality","title":"plot_dose_proportionality","text":"<p>Dose vs exposure relationship:</p> <pre><code>def plot_dose_proportionality(\n    nca_results: list[NCAResult | dict],\n    doses: list[float],\n    metric: str = \"auc\",\n    *,\n    show_regression: bool = True,\n    log_scale: bool = False,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Multiple dose NCA results\ndoses = [25, 50, 100, 200, 400]\nnca_results = [run_nca_for_dose(d) for d in doses]\n\n# Dose proportionality plot\nfig = viz.plot_dose_proportionality(\n    nca_results,\n    doses=doses,\n    metric=\"auc\",\n    title=\"Dose Proportionality\"\n)\n</code></pre>"},{"location":"python/viz/nca/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\nimport numpy as np\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Sample PK data\ntimes = [0, 0.25, 0.5, 1, 2, 4, 6, 8, 12, 24]\nconc = [0, 3.2, 6.8, 9.1, 7.5, 4.2, 2.8, 1.9, 0.8, 0.15]\n\n# Run NCA\nnca_result = openpkpd.run_nca(\n    times=times,\n    concentrations=conc,\n    dose=100.0,\n    route=\"oral\"\n)\n\n# Lambda-z fit\nfig = viz.plot_lambda_z_fit(\n    nca_result,\n    title=f\"Terminal Phase (t1/2 = {nca_result['half_life']:.1f} hr)\"\n)\nfig.savefig(\"lambda_z.png\", dpi=300)\n\n# AUC visualization\nfig = viz.plot_auc_visualization(nca_result, title=\"AUC Components\")\nfig.savefig(\"auc_viz.png\", dpi=300)\n\nprint(f\"AUC0-inf: {nca_result['auc_inf']:.1f} mg*hr/L\")\nprint(f\"Cmax: {nca_result['cmax']:.2f} mg/L\")\nprint(f\"t1/2: {nca_result['half_life']:.1f} hr\")\n</code></pre>"},{"location":"python/viz/nca/#see-also","title":"See Also","text":"<ul> <li>NCA Module - NCA computation</li> <li>Bioequivalence - BE analysis</li> <li>PK Plots - Concentration-time plots</li> </ul>"},{"location":"python/viz/pk/","title":"PK Plots","text":"<p>Concentration-time profile visualization functions.</p>"},{"location":"python/viz/pk/#overview","title":"Overview","text":"<p>PK plots display drug concentration over time, the fundamental visualization in pharmacokinetics.</p> <pre><code>from openpkpd import viz\n\n# Basic concentration-time plot\nfig = viz.plot_conc_time(result, title=\"PK Profile\")\n</code></pre>"},{"location":"python/viz/pk/#functions","title":"Functions","text":""},{"location":"python/viz/pk/#plot_conc_time","title":"plot_conc_time","text":"<p>Single subject concentration-time profile:</p> <pre><code>def plot_conc_time(\n    result: SimResult | dict,\n    *,\n    log_scale: bool = False,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Concentration\",\n    figsize: tuple = (10, 6),\n    color: str | None = None,\n    marker: str | None = None,\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>result = openpkpd.simulate_pk_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5\n)\n\n# Linear scale\nfig = viz.plot_conc_time(result, title=\"Oral PK\")\n\n# Semi-log scale\nfig = viz.plot_conc_time(result, log_scale=True)\n\n# With markers\nfig = viz.plot_conc_time(result, marker=\"o\")\n</code></pre>"},{"location":"python/viz/pk/#plot_multi_conc_time","title":"plot_multi_conc_time","text":"<p>Multiple profiles overlay:</p> <pre><code>def plot_multi_conc_time(\n    results: list[SimResult | dict],\n    labels: list[str] | None = None,\n    *,\n    log_scale: bool = False,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Compare different doses\nresults = []\nlabels = []\nfor dose in [50, 100, 200]:\n    r = openpkpd.simulate_pk_oral(\n        ka=1.5, cl=5.0, v=50.0,\n        doses=[{\"time\": 0.0, \"amount\": float(dose)}],\n        t0=0.0, t1=24.0, saveat=0.5\n    )\n    results.append(r)\n    labels.append(f\"{dose} mg\")\n\nfig = viz.plot_multi_conc_time(results, labels=labels, title=\"Dose Comparison\")\n</code></pre>"},{"location":"python/viz/pk/#plot_spaghetti","title":"plot_spaghetti","text":"<p>Population spaghetti plot:</p> <pre><code>def plot_spaghetti(\n    pop_result: PopulationResult | dict,\n    *,\n    n_subjects: int | None = None,\n    alpha: float = 0.3,\n    show_mean: bool = True,\n    log_scale: bool = False,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>pop_result = openpkpd.simulate_population_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100, omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\n# All subjects\nfig = viz.plot_spaghetti(pop_result, title=\"Population Profiles\")\n\n# First 20 subjects only\nfig = viz.plot_spaghetti(pop_result, n_subjects=20, alpha=0.5)\n</code></pre>"},{"location":"python/viz/pk/#plot_mean_ribbon","title":"plot_mean_ribbon","text":"<p>Mean with confidence ribbon:</p> <pre><code>def plot_mean_ribbon(\n    pop_result: PopulationResult | dict,\n    *,\n    ci_levels: list[float] = [0.05, 0.95],\n    show_median: bool = True,\n    show_individual: bool = False,\n    log_scale: bool = False,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># 90% prediction interval\nfig = viz.plot_mean_ribbon(pop_result, ci_levels=[0.05, 0.95])\n\n# 50% and 90% intervals\nfig = viz.plot_mean_ribbon(\n    pop_result,\n    ci_levels=[0.25, 0.75],  # Inner ribbon\n    show_median=True\n)\n</code></pre>"},{"location":"python/viz/pk/#plot_individual_fits","title":"plot_individual_fits","text":"<p>Grid of individual subject fits:</p> <pre><code>def plot_individual_fits(\n    pop_result: PopulationResult | dict,\n    observed: dict | None = None,\n    *,\n    n_subjects: int = 9,\n    n_cols: int = 3,\n    figsize: tuple | None = None,\n    log_scale: bool = False,\n    title: str | None = None,\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Grid of 9 subjects (3x3)\nfig = viz.plot_individual_fits(pop_result, n_subjects=9, n_cols=3)\n\n# With observed data overlay\nfig = viz.plot_individual_fits(pop_result, observed=observed_data)\n</code></pre>"},{"location":"python/viz/pk/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Single simulation\nresult = openpkpd.simulate_pk_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5\n)\n\n# Basic plot\nfig = viz.plot_conc_time(result, title=\"One-Compartment Oral PK\")\nfig.savefig(\"pk_single.png\", dpi=300)\n\n# Population simulation\npop_result = openpkpd.simulate_population_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\n# Spaghetti plot\nfig = viz.plot_spaghetti(pop_result, n_subjects=50, alpha=0.2)\nfig.savefig(\"pk_spaghetti.png\", dpi=300)\n\n# Mean with ribbon\nfig = viz.plot_mean_ribbon(pop_result, ci_levels=[0.05, 0.95])\nfig.savefig(\"pk_ribbon.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/pk/#see-also","title":"See Also","text":"<ul> <li>Backends &amp; Themes - Styling options</li> <li>Population Plots - More population visualizations</li> <li>VPC Plots - Model validation plots</li> </ul>"},{"location":"python/viz/pkpd/","title":"PKPD Plots","text":"<p>Pharmacokinetic-pharmacodynamic relationship visualization.</p>"},{"location":"python/viz/pkpd/#overview","title":"Overview","text":"<p>PKPD plots visualize the relationship between drug concentration and effect.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_effect_conc(result, title=\"Concentration-Effect\")\n</code></pre>"},{"location":"python/viz/pkpd/#functions","title":"Functions","text":""},{"location":"python/viz/pkpd/#plot_effect_conc","title":"plot_effect_conc","text":"<p>Effect vs concentration relationship:</p> <pre><code>def plot_effect_conc(\n    result: PKPDResult | dict,\n    *,\n    show_emax_fit: bool = True,\n    show_ec50: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Concentration\",\n    ylabel: str = \"Effect\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>result = openpkpd.simulate_pkpd_emax(\n    cl=5.0, v=50.0,\n    emax=100.0, ec50=5.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5\n)\n\nfig = viz.plot_effect_conc(result, title=\"Emax Model\")\n</code></pre>"},{"location":"python/viz/pkpd/#plot_hysteresis","title":"plot_hysteresis","text":"<p>Hysteresis loop (effect compartment):</p> <pre><code>def plot_hysteresis(\n    result: PKPDResult | dict,\n    *,\n    show_arrows: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Concentration\",\n    ylabel: str = \"Effect\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Effect compartment model with hysteresis\nresult = openpkpd.simulate_pkpd_effect_compartment(\n    cl=5.0, v=50.0, ke0=0.5,\n    emax=100.0, ec50=5.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5\n)\n\nfig = viz.plot_hysteresis(result, show_arrows=True, title=\"Hysteresis Loop\")\n</code></pre>"},{"location":"python/viz/pkpd/#plot_dose_response","title":"plot_dose_response","text":"<p>Dose-response curve:</p> <pre><code>def plot_dose_response(\n    results: list[PKPDResult | dict],\n    doses: list[float],\n    metric: str = \"emax\",\n    *,\n    show_fit: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Dose\",\n    ylabel: str = \"Effect\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Simulate multiple doses\ndoses = [10, 25, 50, 100, 200, 400]\nresults = []\nfor dose in doses:\n    r = openpkpd.simulate_pkpd_emax(\n        cl=5.0, v=50.0, emax=100.0, ec50=5.0,\n        doses=[{\"time\": 0.0, \"amount\": float(dose)}],\n        t0=0.0, t1=24.0, saveat=0.5\n    )\n    results.append(r)\n\nfig = viz.plot_dose_response(results, doses, title=\"Dose-Response\")\n</code></pre>"},{"location":"python/viz/pkpd/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Emax model simulation\nresult = openpkpd.simulate_pkpd_emax(\n    cl=5.0, v=50.0,\n    emax=100.0, ec50=5.0,\n    e0=10.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.25\n)\n\n# Concentration-effect plot\nfig = viz.plot_effect_conc(\n    result,\n    show_ec50=True,\n    title=\"Direct Emax Model\"\n)\nfig.savefig(\"effect_conc.png\", dpi=300)\n\n# Effect compartment with hysteresis\nresult_ec = openpkpd.simulate_pkpd_effect_compartment(\n    cl=5.0, v=50.0, ke0=0.3,\n    emax=100.0, ec50=5.0, e0=10.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.25\n)\n\nfig = viz.plot_hysteresis(result_ec, title=\"Counter-Clockwise Hysteresis\")\nfig.savefig(\"hysteresis.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/pkpd/#see-also","title":"See Also","text":"<ul> <li>PD Models - PD model documentation</li> <li>PK Plots - Concentration-time plots</li> <li>Population Plots - Population PKPD</li> </ul>"},{"location":"python/viz/population/","title":"Population Plots","text":"<p>Population modeling visualization functions.</p>"},{"location":"python/viz/population/#overview","title":"Overview","text":"<p>Population plots visualize inter-individual variability, parameter distributions, and model diagnostics.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_parameter_distributions(pop_result)\n</code></pre>"},{"location":"python/viz/population/#functions","title":"Functions","text":""},{"location":"python/viz/population/#plot_vpc","title":"plot_vpc","text":"<p>Basic Visual Predictive Check:</p> <pre><code>def plot_vpc(\n    vpc_result: VPCResult | dict,\n    *,\n    log_scale: bool = False,\n    show_ci: bool = True,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>See VPC Plots for detailed VPC visualization.</p>"},{"location":"python/viz/population/#plot_parameter_distributions","title":"plot_parameter_distributions","text":"<p>Parameter distribution histograms:</p> <pre><code>def plot_parameter_distributions(\n    pop_result: PopulationResult | dict,\n    params: list[str] | None = None,\n    *,\n    show_typical: bool = True,\n    n_cols: int = 3,\n    title: str | None = None,\n    figsize: tuple | None = None,\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>pop_result = openpkpd.simulate_population_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\nfig = viz.plot_parameter_distributions(\n    pop_result,\n    show_typical=True,\n    title=\"Individual Parameter Distributions\"\n)\n</code></pre>"},{"location":"python/viz/population/#plot_forest","title":"plot_forest","text":"<p>Forest plot of parameter effects:</p> <pre><code>def plot_forest(\n    forest_data: list[dict],\n    *,\n    reference_line: float = 1.0,\n    show_ci: bool = True,\n    ci_level: float = 0.95,\n    title: str | None = None,\n    xlabel: str = \"Effect\",\n    figsize: tuple = (10, 8),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>forest_data = [\n    {\"label\": \"Age (per 10 yr)\", \"estimate\": 0.95, \"lower\": 0.88, \"upper\": 1.02},\n    {\"label\": \"Weight (per 10 kg)\", \"estimate\": 1.12, \"lower\": 1.05, \"upper\": 1.20},\n    {\"label\": \"Sex (Female)\", \"estimate\": 0.85, \"lower\": 0.75, \"upper\": 0.96},\n    {\"label\": \"Renal Impairment\", \"estimate\": 0.72, \"lower\": 0.58, \"upper\": 0.89},\n]\n\nfig = viz.plot_forest(\n    forest_data,\n    reference_line=1.0,\n    title=\"Covariate Effects on Clearance\"\n)\n</code></pre>"},{"location":"python/viz/population/#plot_boxplot","title":"plot_boxplot","text":"<p>Box plot comparison:</p> <pre><code>def plot_boxplot(\n    data: dict[str, list[float]],\n    *,\n    show_points: bool = False,\n    title: str | None = None,\n    xlabel: str = \"Group\",\n    ylabel: str = \"Value\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Compare AUC by group\ndata = {\n    \"Low Dose\": [85, 92, 78, 95, 88],\n    \"Medium Dose\": [150, 165, 142, 158, 170],\n    \"High Dose\": [280, 310, 265, 295, 320],\n}\n\nfig = viz.plot_boxplot(data, ylabel=\"AUC (mg*hr/L)\")\n</code></pre>"},{"location":"python/viz/population/#plot_goodness_of_fit","title":"plot_goodness_of_fit","text":"<p>4-panel GOF diagnostic:</p> <pre><code>def plot_goodness_of_fit(\n    est_result: EstimationResult | dict,\n    *,\n    log_scale: bool = False,\n    title: str | None = None,\n    figsize: tuple = (12, 10),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># 4-panel GOF: DV vs PRED, DV vs IPRED, CWRES vs TIME, CWRES vs PRED\nfig = viz.plot_goodness_of_fit(\n    est_result,\n    log_scale=False,\n    title=\"Goodness of Fit\"\n)\n</code></pre>"},{"location":"python/viz/population/#plot_estimation_summary","title":"plot_estimation_summary","text":"<p>Summary dashboard:</p> <pre><code>def plot_estimation_summary(\n    est_result: EstimationResult | dict,\n    *,\n    title: str | None = None,\n    figsize: tuple = (16, 12),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/population/#plot_sensitivity","title":"plot_sensitivity","text":"<p>Parameter sensitivity:</p> <pre><code>def plot_sensitivity(\n    pop_result: PopulationResult | dict,\n    param: str,\n    metric: str = \"auc\",\n    *,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/population/#plot_sensitivity_tornado","title":"plot_sensitivity_tornado","text":"<p>Sensitivity tornado plot:</p> <pre><code>def plot_sensitivity_tornado(\n    sensitivity_results: list[dict],\n    *,\n    title: str | None = None,\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/population/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Population simulation\npop_result = openpkpd.simulate_population_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\n# Parameter distributions\nfig = viz.plot_parameter_distributions(\n    pop_result,\n    show_typical=True,\n    n_cols=3,\n    title=\"Individual Parameters\"\n)\nfig.savefig(\"param_dist.png\", dpi=300)\n\n# Forest plot (example data)\nforest_data = [\n    {\"label\": \"Weight\", \"estimate\": 1.15, \"lower\": 1.08, \"upper\": 1.23},\n    {\"label\": \"Age\", \"estimate\": 0.92, \"lower\": 0.85, \"upper\": 0.99},\n    {\"label\": \"Sex\", \"estimate\": 0.88, \"lower\": 0.78, \"upper\": 0.99},\n]\nfig = viz.plot_forest(forest_data, title=\"Covariate Effects on CL\")\nfig.savefig(\"forest.png\", dpi=300)\n\n# Box plot\nimport numpy as np\ncmax_by_group = {\n    \"Young\": np.random.lognormal(2.0, 0.3, 30).tolist(),\n    \"Elderly\": np.random.lognormal(2.2, 0.35, 25).tolist(),\n}\nfig = viz.plot_boxplot(cmax_by_group, ylabel=\"Cmax (mg/L)\")\nfig.savefig(\"boxplot.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/population/#see-also","title":"See Also","text":"<ul> <li>VPC Plots - Visual predictive checks</li> <li>PK Plots - Concentration-time profiles</li> <li>Estimation Diagnostics - Fitting diagnostics</li> </ul>"},{"location":"python/viz/sensitivity/","title":"Sensitivity Plots","text":"<p>Sensitivity analysis visualization functions.</p>"},{"location":"python/viz/sensitivity/#overview","title":"Overview","text":"<p>Sensitivity plots visualize how model outputs change with parameter variations.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_tornado(sensitivity_results, title=\"Parameter Sensitivity\")\n</code></pre>"},{"location":"python/viz/sensitivity/#functions","title":"Functions","text":""},{"location":"python/viz/sensitivity/#plot_tornado","title":"plot_tornado","text":"<p>Tornado diagram of parameter sensitivity:</p> <pre><code>def plot_tornado(\n    sensitivity_results: list[dict],\n    *,\n    baseline_value: float = 0.0,\n    sort_by: str = \"range\",\n    title: str | None = None,\n    xlabel: str = \"Change from Baseline\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>sensitivity_results = [\n    {\"parameter\": \"CL\", \"low\": -0.30, \"high\": 0.25},\n    {\"parameter\": \"V\", \"low\": -0.15, \"high\": 0.18},\n    {\"parameter\": \"Ka\", \"low\": -0.40, \"high\": 0.35},\n]\n\nfig = viz.plot_tornado(\n    sensitivity_results,\n    baseline_value=0.0,\n    title=\"AUC Sensitivity to Parameters\"\n)\n</code></pre>"},{"location":"python/viz/sensitivity/#plot_spider","title":"plot_spider","text":"<p>Spider/radar plot of parameter effects:</p> <pre><code>def plot_spider(\n    sensitivity_results: dict[str, list[float]],\n    parameter_values: list[float],\n    *,\n    title: str | None = None,\n    figsize: tuple = (10, 10),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Metric values at different parameter multipliers\nsensitivity_results = {\n    \"CL\": [1.5, 1.2, 1.0, 0.8, 0.6],\n    \"V\": [0.9, 0.95, 1.0, 1.05, 1.1],\n    \"Ka\": [1.3, 1.1, 1.0, 0.9, 0.7],\n}\nparam_values = [0.5, 0.75, 1.0, 1.25, 1.5]\n\nfig = viz.plot_spider(sensitivity_results, param_values)\n</code></pre>"},{"location":"python/viz/sensitivity/#plot_sensitivity_heatmap","title":"plot_sensitivity_heatmap","text":"<p>Parameter-metric sensitivity matrix:</p> <pre><code>def plot_sensitivity_heatmap(\n    sensitivity_matrix: np.ndarray | list[list[float]],\n    parameters: list[str],\n    metrics: list[str],\n    *,\n    annotate: bool = True,\n    title: str | None = None,\n    figsize: tuple = (10, 8),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>import numpy as np\n\n# Sensitivity matrix: parameters x metrics\nmatrix = np.array([\n    [0.8, -0.3, 0.1],   # CL effect on [AUC, Cmax, Tmax]\n    [-0.2, 0.5, 0.0],   # V effect\n    [0.1, 0.4, -0.6],   # Ka effect\n])\n\nfig = viz.plot_sensitivity_heatmap(\n    matrix,\n    parameters=[\"CL\", \"V\", \"Ka\"],\n    metrics=[\"AUC\", \"Cmax\", \"Tmax\"],\n    title=\"Parameter-Metric Sensitivity\"\n)\n</code></pre>"},{"location":"python/viz/sensitivity/#plot_waterfall","title":"plot_waterfall","text":"<p>Waterfall chart of ranked sensitivities:</p> <pre><code>def plot_waterfall(\n    sensitivities: dict[str, float],\n    *,\n    title: str | None = None,\n    xlabel: str = \"Sensitivity\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>sensitivities = {\n    \"CL\": -0.85,\n    \"Ka\": 0.72,\n    \"V\": -0.45,\n    \"F\": 0.38,\n    \"Ke0\": 0.15,\n}\n\nfig = viz.plot_waterfall(sensitivities, title=\"Ranked Sensitivities\")\n</code></pre>"},{"location":"python/viz/sensitivity/#plot_one_at_a_time","title":"plot_one_at_a_time","text":"<p>OFAT sensitivity curves:</p> <pre><code>def plot_one_at_a_time(\n    ofat_results: dict[str, tuple[list[float], list[float]]],\n    *,\n    baseline_value: float = 1.0,\n    title: str | None = None,\n    xlabel: str = \"Parameter Multiplier\",\n    ylabel: str = \"Metric Value\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># OFAT results: param -&gt; (multipliers, metric_values)\nofat_results = {\n    \"CL\": ([0.5, 0.75, 1.0, 1.25, 1.5], [150, 120, 100, 85, 72]),\n    \"V\": ([0.5, 0.75, 1.0, 1.25, 1.5], [98, 99, 100, 101, 102]),\n    \"Ka\": ([0.5, 0.75, 1.0, 1.25, 1.5], [85, 92, 100, 108, 115]),\n}\n\nfig = viz.plot_one_at_a_time(ofat_results, baseline_value=100)\n</code></pre>"},{"location":"python/viz/sensitivity/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\nimport numpy as np\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Run sensitivity analysis\nsensitivity = openpkpd.run_sensitivity(\n    model_spec=model,\n    parameters=[\"CL\", \"V\", \"Ka\"],\n    ranges={\"CL\": (0.5, 1.5), \"V\": (0.5, 1.5), \"Ka\": (0.5, 1.5)},\n    metric=\"auc\"\n)\n\n# Tornado plot\nfig = viz.plot_tornado(\n    sensitivity[\"tornado\"],\n    title=\"AUC Sensitivity\"\n)\nfig.savefig(\"tornado.png\", dpi=300)\n\n# Heatmap\nfig = viz.plot_sensitivity_heatmap(\n    sensitivity[\"matrix\"],\n    parameters=[\"CL\", \"V\", \"Ka\"],\n    metrics=[\"AUC\", \"Cmax\", \"t1/2\"],\n    title=\"Sensitivity Matrix\"\n)\nfig.savefig(\"heatmap.png\", dpi=300)\n\n# Waterfall\nfig = viz.plot_waterfall(\n    sensitivity[\"ranked\"],\n    title=\"Ranked Parameter Sensitivities\"\n)\nfig.savefig(\"waterfall.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/sensitivity/#see-also","title":"See Also","text":"<ul> <li>Population Plots - Population sensitivity</li> <li>Estimation Diagnostics - Parameter uncertainty</li> <li>Backends &amp; Themes - Styling options</li> </ul>"},{"location":"python/viz/trial/","title":"Trial Plots","text":"<p>Clinical trial visualization functions.</p>"},{"location":"python/viz/trial/#overview","title":"Overview","text":"<p>Trial plots visualize study designs, power analyses, and endpoint distributions.</p> <pre><code>from openpkpd import viz\n\nfig = viz.plot_power_curve(power_results, title=\"Power Analysis\")\n</code></pre>"},{"location":"python/viz/trial/#functions","title":"Functions","text":""},{"location":"python/viz/trial/#plot_power_curve","title":"plot_power_curve","text":"<p>Power vs sample size curve:</p> <pre><code>def plot_power_curve(\n    power_results: dict | list[dict],\n    *,\n    target_power: float = 0.8,\n    show_target: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Sample Size (per arm)\",\n    ylabel: str = \"Power\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code># Power analysis results\npower_results = {\n    \"n\": [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n    \"power\": [0.25, 0.45, 0.62, 0.75, 0.83, 0.89, 0.93, 0.95, 0.97, 0.98]\n}\n\nfig = viz.plot_power_curve(\n    power_results,\n    target_power=0.8,\n    title=\"Sample Size Calculation\"\n)\n</code></pre>"},{"location":"python/viz/trial/#plot_trial_tornado","title":"plot_trial_tornado","text":"<p>Trial design sensitivity:</p> <pre><code>def plot_trial_tornado(\n    sensitivity_results: list[dict],\n    *,\n    baseline: float = 0.8,\n    title: str | None = None,\n    xlabel: str = \"Power\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>sensitivity_results = [\n    {\"parameter\": \"Effect Size\", \"low\": 0.65, \"high\": 0.92},\n    {\"parameter\": \"Variability\", \"low\": 0.70, \"high\": 0.88},\n    {\"parameter\": \"Dropout Rate\", \"low\": 0.75, \"high\": 0.82},\n]\n\nfig = viz.plot_trial_tornado(\n    sensitivity_results,\n    baseline=0.80,\n    title=\"Power Sensitivity\"\n)\n</code></pre>"},{"location":"python/viz/trial/#plot_kaplan_meier","title":"plot_kaplan_meier","text":"<p>Survival curves with confidence intervals:</p> <pre><code>def plot_kaplan_meier(\n    survival_data: dict | list[dict],\n    *,\n    show_ci: bool = True,\n    show_censored: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Survival Probability\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>survival_data = [\n    {\n        \"label\": \"Treatment\",\n        \"times\": [1, 3, 5, 7, 10, 12, 15, 18, 20, 24],\n        \"survival\": [0.98, 0.95, 0.90, 0.85, 0.78, 0.72, 0.65, 0.60, 0.55, 0.50],\n        \"ci_lower\": [0.95, 0.90, 0.82, 0.75, 0.65, 0.58, 0.50, 0.45, 0.40, 0.35],\n        \"ci_upper\": [1.00, 0.98, 0.96, 0.92, 0.88, 0.83, 0.78, 0.73, 0.68, 0.63],\n    },\n    {\n        \"label\": \"Control\",\n        \"times\": [1, 3, 5, 7, 10, 12, 15, 18, 20, 24],\n        \"survival\": [0.96, 0.88, 0.78, 0.68, 0.55, 0.45, 0.38, 0.32, 0.28, 0.25],\n    }\n]\n\nfig = viz.plot_kaplan_meier(survival_data, title=\"Overall Survival\")\n</code></pre>"},{"location":"python/viz/trial/#plot_endpoint_distribution","title":"plot_endpoint_distribution","text":"<p>Endpoint histogram by group:</p> <pre><code>def plot_endpoint_distribution(\n    endpoint_data: dict[str, list[float]],\n    *,\n    show_stats: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Endpoint\",\n    ylabel: str = \"Frequency\",\n    figsize: tuple = (10, 6),\n    backend: str | None = None\n) -&gt; Figure:\n</code></pre> <p>Usage:</p> <pre><code>endpoint_data = {\n    \"Treatment\": [12.5, 15.2, 11.8, 14.0, 13.5, 16.1, 12.0, 14.8],\n    \"Placebo\": [8.2, 9.5, 7.8, 10.1, 8.9, 9.2, 8.0, 9.8],\n}\n\nfig = viz.plot_endpoint_distribution(\n    endpoint_data,\n    show_stats=True,\n    title=\"Primary Endpoint Distribution\"\n)\n</code></pre>"},{"location":"python/viz/trial/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\nimport numpy as np\n\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\n# Power analysis\npower_results = openpkpd.calculate_power(\n    effect_size=0.5,\n    variability=0.8,\n    alpha=0.05,\n    n_range=range(10, 101, 10)\n)\n\nfig = viz.plot_power_curve(\n    power_results,\n    target_power=0.8,\n    title=\"Sample Size for 80% Power\"\n)\nfig.savefig(\"power_curve.png\", dpi=300)\n\n# Trial sensitivity\nsensitivity = [\n    {\"parameter\": \"Effect Size \u00b120%\", \"low\": 0.62, \"high\": 0.91},\n    {\"parameter\": \"CV \u00b125%\", \"low\": 0.68, \"high\": 0.88},\n    {\"parameter\": \"Dropout 10% vs 20%\", \"low\": 0.75, \"high\": 0.82},\n]\nfig = viz.plot_trial_tornado(sensitivity, baseline=0.80)\nfig.savefig(\"trial_tornado.png\", dpi=300)\n\n# Simulated endpoint distribution\nnp.random.seed(42)\nendpoints = {\n    \"Active\": np.random.normal(15, 3, 50).tolist(),\n    \"Placebo\": np.random.normal(12, 3, 50).tolist(),\n}\nfig = viz.plot_endpoint_distribution(\n    endpoints,\n    title=\"Simulated AUC Response\"\n)\nfig.savefig(\"endpoint_dist.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/trial/#see-also","title":"See Also","text":"<ul> <li>Clinical Trials - Trial design module</li> <li>Power Analysis - Sample size calculation</li> <li>Population Plots - Population visualizations</li> </ul>"},{"location":"python/viz/vpc/","title":"VPC Visualization","text":"<p>Comprehensive guide to Visual Predictive Check visualization in Python with dual matplotlib and plotly backend support.</p>"},{"location":"python/viz/vpc/#overview","title":"Overview","text":"<p>OpenPKPD provides 5 specialized VPC visualization functions:</p> Function Description <code>plot_vpc</code> Standard VPC with percentile ribbons <code>plot_pcvpc</code> Prediction-corrected VPC <code>plot_stratified_vpc</code> Multi-panel faceted VPC <code>plot_vpc_with_blq</code> VPC with BLQ statistics panel <code>plot_vpc_ci</code> Detailed confidence interval visualization <pre><code>from openpkpd import viz\n\n# Set backend\nviz.set_backend(\"matplotlib\")  # or \"plotly\"\n\n# All VPC functions follow same pattern\nfig = viz.plot_vpc(vpc_result, title=\"Model Validation\")\n</code></pre>"},{"location":"python/viz/vpc/#vpc-data-structures","title":"VPC Data Structures","text":""},{"location":"python/viz/vpc/#vpcresult","title":"VPCResult","text":"<pre><code>from dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\n@dataclass\nclass VPCResult:\n    \"\"\"Result of VPC computation.\"\"\"\n    config: VPCConfig                    # Configuration used\n    bins: List[VPCBin]                   # Computed bins\n    n_subjects_observed: int             # Number of subjects\n    n_observations_observed: int         # Total observations\n    n_simulations: int                   # Simulations performed\n    strata: str                          # Strata label\n    simulation_seed: int                 # Seed used\n\n@dataclass\nclass VPCBin:\n    \"\"\"Data for a single time bin.\"\"\"\n    bin_id: int                          # Bin identifier\n    time_min: float                      # Lower bound\n    time_max: float                      # Upper bound\n    time_midpoint: float                 # Midpoint for plotting\n    n_observed: int                      # Observations in bin\n    n_simulated: int                     # Simulated per replicate\n    percentiles: List[VPCPercentileData]\n\n@dataclass\nclass VPCPercentileData:\n    \"\"\"Percentile data for a bin.\"\"\"\n    percentile: float                    # Level (e.g., 0.50)\n    observed: float                      # Observed percentile\n    simulated_median: float              # Median of simulations\n    simulated_lower: float               # Lower CI\n    simulated_upper: float               # Upper CI\n</code></pre>"},{"location":"python/viz/vpc/#accessor-functions","title":"Accessor Functions","text":"<pre><code>from openpkpd.vpc import (\n    get_bin_midpoints,\n    get_observed_percentile,\n    get_simulated_median,\n    get_simulated_ci,\n    get_blq_observed,\n    get_blq_simulated\n)\n\n# Extract data for custom plotting\ntimes = get_bin_midpoints(vpc_result)                    # np.ndarray\nobs_median = get_observed_percentile(vpc_result, 0.50)   # np.ndarray\nsim_median = get_simulated_median(vpc_result, 0.50)      # np.ndarray\nsim_lower, sim_upper = get_simulated_ci(vpc_result, 0.50)  # tuple\n\n# BLQ data (if available)\nblq_obs = get_blq_observed(vpc_result)\nblq_sim_med, blq_sim_lo, blq_sim_hi = get_blq_simulated(vpc_result)\n</code></pre>"},{"location":"python/viz/vpc/#plot_vpc","title":"plot_vpc","text":"<p>Standard VPC visualization with observed percentiles and simulated confidence ribbons.</p>"},{"location":"python/viz/vpc/#function-signature","title":"Function Signature","text":"<pre><code>def plot_vpc(\n    vpc_result: VPCResult,\n    *,\n    log_scale: bool = False,\n    show_observed: bool = True,\n    show_simulated_median: bool = True,\n    show_ci: bool = True,\n    pi_levels: list[float] | None = None,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Concentration\",\n    figsize: tuple[float, float] = (10, 6),\n    obs_color: str | None = None,\n    sim_color: str | None = None,\n    ci_alpha: float = 0.2,\n    median_alpha: float = 0.5,\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/vpc/#basic-usage","title":"Basic Usage","text":"<pre><code>from openpkpd import viz\nimport openpkpd\n\n# Initialize Julia connection\nopenpkpd.init_julia()\n\n# Compute VPC (example)\nvpc_result = openpkpd.compute_vpc(\n    observed_data=observed,\n    population_spec=pop_spec,\n    grid={\"t0\": 0.0, \"t1\": 24.0, \"saveat\": 0.5},\n    config={\"n_simulations\": 500, \"pi_levels\": [0.05, 0.50, 0.95]}\n)\n\n# Create VPC plot\nfig = viz.plot_vpc(\n    vpc_result,\n    title=\"Visual Predictive Check\",\n    xlabel=\"Time (hours)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n\nfig.savefig(\"vpc.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/vpc/#customization-options","title":"Customization Options","text":"<pre><code># Linear scale (default)\nfig = viz.plot_vpc(vpc_result, log_scale=False)\n\n# Semi-log scale\nfig = viz.plot_vpc(vpc_result, log_scale=True)\n\n# Show only specific elements\nfig = viz.plot_vpc(\n    vpc_result,\n    show_observed=True,\n    show_simulated_median=False,  # Hide simulated median lines\n    show_ci=True\n)\n\n# Custom percentile levels display\nfig = viz.plot_vpc(\n    vpc_result,\n    pi_levels=[0.10, 0.50, 0.90]  # Override displayed levels\n)\n\n# Custom colors\nfig = viz.plot_vpc(\n    vpc_result,\n    obs_color=\"#E74C3C\",    # Red for observed\n    sim_color=\"#3498DB\",    # Blue for simulated\n    ci_alpha=0.3            # More opaque ribbons\n)\n</code></pre>"},{"location":"python/viz/vpc/#plot-elements","title":"Plot Elements","text":"<p>The standard VPC plot shows:</p> <ol> <li>Observed percentiles - Solid lines at each PI level</li> <li>Simulated CI ribbons - Shaded areas showing simulation uncertainty</li> <li>Simulated median - Dashed lines (optional)</li> </ol> <pre><code>Y-axis: Concentration\nX-axis: Time\nLegend:\n  - Observed P5/P50/P95 (solid lines)\n  - Simulated 95% CI (shaded ribbons)\n  - Simulated median (dashed lines)\n</code></pre>"},{"location":"python/viz/vpc/#plot_pcvpc","title":"plot_pcvpc","text":"<p>Prediction-corrected VPC for variable dosing or covariate-adjusted data.</p>"},{"location":"python/viz/vpc/#function-signature_1","title":"Function Signature","text":"<pre><code>def plot_pcvpc(\n    vpc_result: VPCResult,\n    *,\n    log_scale: bool = False,\n    show_observed: bool = True,\n    show_ci: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Prediction-Corrected Concentration\",\n    figsize: tuple[float, float] = (10, 6),\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/vpc/#usage","title":"Usage","text":"<pre><code># Compute pcVPC\npcvpc_result = openpkpd.compute_pcvpc(\n    observed_data=observed,\n    population_spec=pop_spec,\n    grid=grid,\n    config={\"n_simulations\": 500}\n)\n\n# Plot pcVPC\nfig = viz.plot_pcvpc(\n    pcvpc_result,\n    title=\"Prediction-Corrected VPC\",\n    ylabel=\"Prediction-Corrected Concentration\"\n)\n\nfig.savefig(\"pcvpc.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/vpc/#when-to-use-pcvpc","title":"When to Use pcVPC","text":"<ul> <li>Variable dosing across subjects</li> <li>Significant covariate effects on PK</li> <li>Dose escalation studies</li> <li>Different formulations/routes</li> </ul> <pre><code># Example: Dose escalation study\n# Doses: 50, 100, 200, 400 mg\n\n# Standard VPC would show dose-related variability\nfig_standard = viz.plot_vpc(standard_vpc, title=\"Standard VPC\")\n\n# pcVPC normalizes by dose, showing only IIV\nfig_pc = viz.plot_pcvpc(pcvpc_result, title=\"pcVPC (dose-normalized)\")\n</code></pre>"},{"location":"python/viz/vpc/#plot_stratified_vpc","title":"plot_stratified_vpc","text":"<p>Multi-panel VPC faceted by covariate strata.</p>"},{"location":"python/viz/vpc/#function-signature_2","title":"Function Signature","text":"<pre><code>def plot_stratified_vpc(\n    stratified_result: StratifiedVPCResult,\n    *,\n    log_scale: bool = False,\n    n_cols: int = 2,\n    subplot_size: tuple[float, float] = (5, 4),\n    share_y: bool = True,\n    show_observed: bool = True,\n    show_ci: bool = True,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Concentration\",\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/vpc/#usage_1","title":"Usage","text":"<pre><code># Compute stratified VPC\nstratified_result = openpkpd.compute_stratified_vpc(\n    observed_data=observed,\n    population_spec=pop_spec,\n    grid=grid,\n    strata_data=strata_data,\n    config={\"stratify_by\": [\"DOSE\"], \"n_simulations\": 500}\n)\n\n# Plot multi-panel VPC\nfig = viz.plot_stratified_vpc(\n    stratified_result,\n    n_cols=3,                    # 3 columns layout\n    subplot_size=(4, 3),         # Size per subplot\n    title=\"VPC by Dose Group\"\n)\n\nfig.savefig(\"stratified_vpc.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"python/viz/vpc/#layout-options","title":"Layout Options","text":"<pre><code># Vertical layout (1 column)\nfig = viz.plot_stratified_vpc(\n    stratified_result,\n    n_cols=1,\n    subplot_size=(8, 3)\n)\n\n# Grid layout\nfig = viz.plot_stratified_vpc(\n    stratified_result,\n    n_cols=2,\n    share_y=True  # Same Y-axis scale across panels\n)\n\n# Independent Y-axes (for very different concentrations)\nfig = viz.plot_stratified_vpc(\n    stratified_result,\n    share_y=False\n)\n</code></pre>"},{"location":"python/viz/vpc/#stratum-labels","title":"Stratum Labels","text":"<p>Stratum names from the result are used as subplot titles:</p> <pre><code># Example output layout:\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n# \u2502   50 mg         \u2502   150 mg        \u2502\n# \u2502   [VPC plot]    \u2502   [VPC plot]    \u2502\n# \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n# \u2502   300 mg        \u2502   600 mg        \u2502\n# \u2502   [VPC plot]    \u2502   [VPC plot]    \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"python/viz/vpc/#plot_vpc_with_blq","title":"plot_vpc_with_blq","text":"<p>VPC with Below Limit of Quantification statistics panel.</p>"},{"location":"python/viz/vpc/#function-signature_3","title":"Function Signature","text":"<pre><code>def plot_vpc_with_blq(\n    vpc_result: VPCResult,\n    blq_stats: list[BLQBinStats] | None = None,\n    *,\n    log_scale: bool = False,\n    blq_panel_height: float = 0.25,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Concentration\",\n    blq_ylabel: str = \"% BLQ\",\n    figsize: tuple[float, float] = (10, 8),\n    obs_color: str | None = None,\n    blq_color: str | None = None,\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/vpc/#usage_2","title":"Usage","text":"<pre><code>from openpkpd.vpc import BLQMethod\n\n# Compute VPC with BLQ handling\nvpc_result, blq_stats = openpkpd.compute_vpc_with_blq(\n    observed_data=observed,\n    population_spec=pop_spec,\n    grid=grid,\n    config={\n        \"lloq\": 0.1,  # Lower limit of quantification\n        \"n_simulations\": 500\n    },\n    blq_method=BLQMethod.M4  # Replace with LLOQ/2\n)\n\n# Two-panel plot: VPC + BLQ fraction\nfig = viz.plot_vpc_with_blq(\n    vpc_result,\n    blq_stats=blq_stats,\n    title=\"VPC with BLQ Analysis\",\n    blq_ylabel=\"% Below LOQ\"\n)\n\nfig.savefig(\"vpc_blq.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/vpc/#blq-panel","title":"BLQ Panel","text":"<p>The lower panel shows:</p> <ul> <li>Observed %BLQ - Solid line/markers</li> <li>Simulated %BLQ CI - Shaded ribbon</li> <li>Simulated %BLQ median - Dashed line</li> </ul> <pre><code>Upper panel: Standard VPC (75% height)\nLower panel: %BLQ comparison (25% height)\n</code></pre>"},{"location":"python/viz/vpc/#blq-methods","title":"BLQ Methods","text":"<pre><code>from openpkpd.vpc import BLQMethod\n\n# Available methods (Beal 2001)\nBLQMethod.M1  # Discard all BLQ observations\nBLQMethod.M3  # Treat as censored (keep original)\nBLQMethod.M4  # Replace with LLOQ/2 (default)\nBLQMethod.M5  # 0 before Tmax, LLOQ/2 after\nBLQMethod.M6  # LLOQ/2 before Tmax, discard after\nBLQMethod.M7  # 0 before Tmax, discard after\n</code></pre>"},{"location":"python/viz/vpc/#plot_vpc_ci","title":"plot_vpc_ci","text":"<p>Detailed confidence interval visualization with nested ribbons.</p>"},{"location":"python/viz/vpc/#function-signature_4","title":"Function Signature","text":"<pre><code>def plot_vpc_ci(\n    vpc_result: VPCResult,\n    *,\n    log_scale: bool = False,\n    ci_levels: list[float] = [0.05, 0.95],\n    show_bin_boundaries: bool = False,\n    title: str | None = None,\n    xlabel: str = \"Time\",\n    ylabel: str = \"Concentration\",\n    figsize: tuple[float, float] = (10, 6),\n    backend: str | None = None,\n    save_path: str | None = None\n) -&gt; Figure:\n</code></pre>"},{"location":"python/viz/vpc/#usage_3","title":"Usage","text":"<pre><code># Detailed CI visualization\nfig = viz.plot_vpc_ci(\n    vpc_result,\n    ci_levels=[0.05, 0.95],      # 5th and 95th percentile CIs\n    show_bin_boundaries=True,    # Show vertical bin lines\n    title=\"VPC Confidence Intervals\"\n)\n\nfig.savefig(\"vpc_ci.png\", dpi=300)\n</code></pre>"},{"location":"python/viz/vpc/#features","title":"Features","text":"<ul> <li>Nested ribbons - Inner (median) and outer (5th/95th) CIs</li> <li>Thicker observed lines - Stand out from simulated</li> <li>Bin boundaries - Optional vertical lines at bin edges</li> </ul> <pre><code># Show bin structure\nfig = viz.plot_vpc_ci(\n    vpc_result,\n    show_bin_boundaries=True\n)\n# Helps assess if binning is appropriate\n</code></pre>"},{"location":"python/viz/vpc/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\nfrom openpkpd.vpc import VPCConfig, QuantileBinning\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# ================================================\n# Complete VPC Visualization Example\n# ================================================\n\n# 1. Initialize\nopenpkpd.init_julia()\nviz.set_backend(\"matplotlib\")\n\nprint(\"=== VPC Visualization Example ===\\n\")\n\n# 2. Simulate population data (for demonstration)\npop_result = openpkpd.simulate_population_oral(\n    ka=1.5, cl=5.0, v=50.0,\n    doses=[{\"time\": 0.0, \"amount\": 100.0}],\n    t0=0.0, t1=24.0, saveat=0.5,\n    n=100,\n    omegas={\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    seed=42\n)\n\n# 3. Create observed data from population (subset)\nobserved_data = {\n    \"subject_ids\": [f\"S{i}\" for i in range(100) for _ in range(7)],\n    \"times\": [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0] * 100,\n    \"dv\": [],  # Extract from pop_result\n    \"dvid\": [\"conc\"] * 700\n}\n\n# Extract concentrations at specific times\nsampling_idx = [1, 2, 4, 8, 16, 24, 48]  # indices for 0.5, 1, 2, 4, 8, 12, 24 hr\nfor ind in pop_result[\"individuals\"]:\n    for idx in sampling_idx:\n        observed_data[\"dv\"].append(ind[\"concentrations\"][idx] * (1 + 0.1 * np.random.randn()))\n\n# 4. Define population model specification\npop_spec = {\n    \"model\": \"OneCompOral\",\n    \"params\": {\"Ka\": 1.5, \"CL\": 5.0, \"V\": 50.0},\n    \"omega\": {\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    \"doses\": [{\"time\": 0.0, \"amount\": 100.0}],\n    \"n\": 100\n}\n\ngrid = {\"t0\": 0.0, \"t1\": 24.0, \"saveat\": 0.5}\n\n# 5. Compute VPC variants\nprint(\"Computing standard VPC...\")\nvpc_config = {\n    \"pi_levels\": [0.05, 0.50, 0.95],\n    \"n_simulations\": 500,\n    \"binning\": \"quantile\",\n    \"n_bins\": 7\n}\n\nvpc_result = openpkpd.compute_vpc(\n    observed_data=observed_data,\n    population_spec=pop_spec,\n    grid=grid,\n    config=vpc_config\n)\n\n# 6. Create visualization panels\nfig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# 6a. Standard VPC\nplt.sca(axes[0, 0])\nviz.plot_vpc(\n    vpc_result,\n    title=\"Standard VPC\",\n    xlabel=\"Time (hr)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n\n# 6b. Semi-log VPC\nplt.sca(axes[0, 1])\nviz.plot_vpc(\n    vpc_result,\n    log_scale=True,\n    title=\"VPC (Semi-log)\",\n    xlabel=\"Time (hr)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n\n# 6c. VPC with CI details\nplt.sca(axes[1, 0])\nviz.plot_vpc_ci(\n    vpc_result,\n    show_bin_boundaries=True,\n    title=\"VPC with Bin Boundaries\",\n    xlabel=\"Time (hr)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n\n# 6d. Custom styled VPC\nplt.sca(axes[1, 1])\nviz.plot_vpc(\n    vpc_result,\n    obs_color=\"#E74C3C\",\n    sim_color=\"#2980B9\",\n    ci_alpha=0.25,\n    title=\"Custom Styled VPC\",\n    xlabel=\"Time (hr)\",\n    ylabel=\"Concentration (mg/L)\"\n)\n\nplt.tight_layout()\nplt.savefig(\"vpc_panel.png\", dpi=300, bbox_inches=\"tight\")\nprint(\"Saved: vpc_panel.png\")\n\n# 7. Individual VPC plots\nprint(\"\\nCreating individual plots...\")\n\n# Standard VPC\nfig = viz.plot_vpc(\n    vpc_result,\n    title=\"Visual Predictive Check - Final Model\",\n    xlabel=\"Time (hours)\",\n    ylabel=\"Concentration (mg/L)\",\n    figsize=(10, 6)\n)\nfig.savefig(\"vpc_standard.png\", dpi=300, bbox_inches=\"tight\")\nprint(\"Saved: vpc_standard.png\")\n\n# Interactive plotly version\nviz.set_backend(\"plotly\")\nfig = viz.plot_vpc(\n    vpc_result,\n    title=\"Interactive VPC\",\n    xlabel=\"Time (hours)\",\n    ylabel=\"Concentration (mg/L)\"\n)\nfig.write_html(\"vpc_interactive.html\")\nprint(\"Saved: vpc_interactive.html\")\n\nprint(\"\\n\u2713 VPC visualization complete\")\n</code></pre>"},{"location":"python/viz/vpc/#plotting-parameters-reference","title":"Plotting Parameters Reference","text":""},{"location":"python/viz/vpc/#common-parameters","title":"Common Parameters","text":"Parameter Type Default Description <code>log_scale</code> <code>bool</code> <code>False</code> Semi-log Y-axis <code>title</code> <code>str</code> <code>None</code> Plot title <code>xlabel</code> <code>str</code> <code>\"Time\"</code> X-axis label <code>ylabel</code> <code>str</code> <code>\"Concentration\"</code> Y-axis label <code>figsize</code> <code>tuple</code> <code>(10, 6)</code> Figure size (inches) <code>backend</code> <code>str</code> Current <code>\"matplotlib\"</code> or <code>\"plotly\"</code> <code>save_path</code> <code>str</code> <code>None</code> Auto-save path"},{"location":"python/viz/vpc/#style-parameters","title":"Style Parameters","text":"Parameter Type Default Description <code>obs_color</code> <code>str</code> Theme default Observed line color <code>sim_color</code> <code>str</code> Theme default Simulated ribbon color <code>ci_alpha</code> <code>float</code> <code>0.2</code> Ribbon transparency <code>median_alpha</code> <code>float</code> <code>0.5</code> Median line transparency"},{"location":"python/viz/vpc/#behavior-parameters","title":"Behavior Parameters","text":"Parameter Type Default Description <code>show_observed</code> <code>bool</code> <code>True</code> Show observed percentiles <code>show_simulated_median</code> <code>bool</code> <code>True</code> Show simulated medians <code>show_ci</code> <code>bool</code> <code>True</code> Show CI ribbons <code>pi_levels</code> <code>list</code> From result Percentile levels to display"},{"location":"python/viz/vpc/#backend-comparison","title":"Backend Comparison","text":""},{"location":"python/viz/vpc/#matplotlib","title":"Matplotlib","text":"<pre><code>viz.set_backend(\"matplotlib\")\n\n# Advantages:\n# - Publication-quality static figures\n# - PDF/SVG vector output\n# - Fine-grained customization\n# - Familiar matplotlib API\n\nfig = viz.plot_vpc(vpc_result)\nfig.savefig(\"vpc.pdf\", bbox_inches=\"tight\")\n</code></pre>"},{"location":"python/viz/vpc/#plotly","title":"Plotly","text":"<pre><code>viz.set_backend(\"plotly\")\n\n# Advantages:\n# - Interactive zoom/pan\n# - Hover information\n# - Web embedding\n# - Animation support\n\nfig = viz.plot_vpc(vpc_result)\nfig.write_html(\"vpc.html\")\n</code></pre>"},{"location":"python/viz/vpc/#interpretation-guide","title":"Interpretation Guide","text":""},{"location":"python/viz/vpc/#good-model-fit","title":"Good Model Fit","text":"<pre><code>\u2713 Observed percentiles within shaded CI regions\n\u2713 No systematic deviation over time\n\u2713 Similar fit at early and late times\n\u2713 Variability captured (5th/95th within bounds)\n</code></pre>"},{"location":"python/viz/vpc/#potential-issues","title":"Potential Issues","text":"Visual Pattern Interpretation Action Median above upper CI Under-prediction Check structural model 95th above CI Under-estimated variability Increase omega Early times offset Absorption issue Consider transit model Late times offset Elimination issue Check clearance Widening deviation Time-varying misfit Add time-varying effect"},{"location":"python/viz/vpc/#see-also","title":"See Also","text":"<ul> <li>Julia Standard VPC - VPC methodology</li> <li>Julia pcVPC - Prediction correction</li> <li>Julia Stratified VPC - Stratification</li> <li>Backends &amp; Themes - Backend configuration</li> <li>Population Plots - Related visualizations</li> </ul>"},{"location":"python/vpc/","title":"Visual Predictive Check (VPC)","text":"<p>Comprehensive guide to VPC computation and analysis in Python.</p>"},{"location":"python/vpc/#overview","title":"Overview","text":"<p>Visual Predictive Checks (VPCs) compare observed data distributions to model simulations, providing a visual diagnostic for population model adequacy.</p> <pre><code>from openpkpd import compute_vpc, compute_pcvpc, compute_stratified_vpc\nfrom openpkpd.vpc import VPCConfig, QuantileBinning\n\n# Basic VPC computation\nvpc_result = compute_vpc(\n    observed_data=observed,\n    population_spec=pop_spec,\n    grid={\"t0\": 0.0, \"t1\": 24.0, \"saveat\": 0.5},\n    config=VPCConfig(n_simulations=500)\n)\n</code></pre>"},{"location":"python/vpc/#vpc-types","title":"VPC Types","text":"<ul> <li> <p> Standard VPC</p> <p>Compare observed vs simulated percentiles</p> <p> Standard VPC</p> </li> <li> <p> Prediction-Corrected VPC</p> <p>Normalize for variable dosing and covariates</p> <p> pcVPC</p> </li> <li> <p> Stratified VPC</p> <p>Separate VPC by covariate subgroups</p> <p> Stratified</p> </li> <li> <p> VPC with BLQ</p> <p>Handle below-quantification data</p> <p> BLQ Handling</p> </li> </ul>"},{"location":"python/vpc/#vpcconfig","title":"VPCConfig","text":"<p>Configuration dataclass for VPC computation:</p> <pre><code>from openpkpd.vpc import VPCConfig, QuantileBinning\n\n@dataclass\nclass VPCConfig:\n    \"\"\"VPC configuration parameters.\"\"\"\n    pi_levels: list[float] = field(default_factory=lambda: [0.05, 0.50, 0.95])\n    ci_level: float = 0.95\n    binning: BinningStrategy = field(default_factory=lambda: QuantileBinning(10))\n    prediction_corrected: bool = False\n    stratify_by: list[str] = field(default_factory=list)\n    lloq: float | None = None\n    n_simulations: int = 200\n    n_bootstrap: int = 500\n    seed: int = 12345\n</code></pre>"},{"location":"python/vpc/#configuration-examples","title":"Configuration Examples","text":"<pre><code># Default configuration\nconfig = VPCConfig()\n\n# Custom configuration\nconfig = VPCConfig(\n    pi_levels=[0.10, 0.50, 0.90],     # 10th, 50th, 90th percentiles\n    ci_level=0.90,                     # 90% confidence interval\n    binning=QuantileBinning(8),        # 8 bins with equal obs\n    n_simulations=500,                 # 500 simulation replicates\n    n_bootstrap=1000,                  # 1000 bootstrap samples\n    seed=42                            # Reproducibility\n)\n\n# pcVPC configuration\nconfig = VPCConfig(\n    prediction_corrected=True,\n    n_simulations=500\n)\n\n# Stratified VPC configuration\nconfig = VPCConfig(\n    stratify_by=[\"DOSE_GROUP\"],\n    n_simulations=500\n)\n\n# VPC with BLQ\nconfig = VPCConfig(\n    lloq=0.1,                         # Lower limit of quantification\n    n_simulations=500\n)\n</code></pre>"},{"location":"python/vpc/#parameter-details","title":"Parameter Details","text":"Parameter Type Default Description <code>pi_levels</code> <code>list[float]</code> <code>[0.05, 0.50, 0.95]</code> Prediction interval percentile levels <code>ci_level</code> <code>float</code> <code>0.95</code> Confidence interval level <code>binning</code> <code>BinningStrategy</code> <code>QuantileBinning(10)</code> Binning strategy <code>prediction_corrected</code> <code>bool</code> <code>False</code> Enable prediction correction <code>stratify_by</code> <code>list[str]</code> <code>[]</code> Stratification variables <code>lloq</code> <code>float | None</code> <code>None</code> Lower limit of quantification <code>n_simulations</code> <code>int</code> <code>200</code> Number of simulation replicates <code>n_bootstrap</code> <code>int</code> <code>500</code> Bootstrap samples for CI <code>seed</code> <code>int</code> <code>12345</code> Random seed"},{"location":"python/vpc/#standard-vpc","title":"Standard VPC","text":""},{"location":"python/vpc/#compute_vpc","title":"compute_vpc","text":"<pre><code>def compute_vpc(\n    observed_data: dict[str, Any],\n    population_spec: dict[str, Any],\n    grid: dict[str, Any],\n    config: VPCConfig | None = None,\n    solver: dict[str, Any] | None = None,\n    error_spec: dict[str, Any] | None = None\n) -&gt; VPCResult:\n    \"\"\"\n    Compute standard Visual Predictive Check.\n\n    Parameters\n    ----------\n    observed_data : dict\n        Observed data with keys: subject_ids, times, dv, dvid\n    population_spec : dict\n        Population model specification\n    grid : dict\n        Simulation grid {t0, t1, saveat}\n    config : VPCConfig, optional\n        VPC configuration\n    solver : dict, optional\n        ODE solver specification\n    error_spec : dict, optional\n        Residual error model\n\n    Returns\n    -------\n    VPCResult\n        VPC computation results\n    \"\"\"\n</code></pre>"},{"location":"python/vpc/#usage","title":"Usage","text":"<pre><code>import openpkpd\nfrom openpkpd.vpc import VPCConfig, QuantileBinning\n\nopenpkpd.init_julia()\n\n# Observed data structure\nobserved_data = {\n    \"subject_ids\": [\"S1\", \"S1\", \"S1\", \"S2\", \"S2\", \"S2\", ...],\n    \"times\": [0.5, 2.0, 8.0, 0.5, 2.0, 8.0, ...],\n    \"dv\": [10.5, 5.2, 1.1, 12.3, 6.1, 1.3, ...],\n    \"dvid\": [\"conc\"] * len(times)\n}\n\n# Population model\npopulation_spec = {\n    \"model\": \"OneCompOral\",\n    \"params\": {\"Ka\": 1.5, \"CL\": 5.0, \"V\": 50.0},\n    \"omega\": {\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    \"doses\": [{\"time\": 0.0, \"amount\": 100.0}],\n    \"n\": 50  # Number of subjects\n}\n\n# Simulation grid\ngrid = {\"t0\": 0.0, \"t1\": 24.0, \"saveat\": 0.5}\n\n# VPC configuration\nconfig = VPCConfig(\n    pi_levels=[0.05, 0.50, 0.95],\n    binning=QuantileBinning(7),\n    n_simulations=500,\n    seed=42\n)\n\n# Compute VPC\nvpc_result = openpkpd.compute_vpc(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    config=config\n)\n\n# Access results\nprint(f\"Bins: {len(vpc_result.bins)}\")\nprint(f\"Simulations: {vpc_result.n_simulations}\")\n</code></pre>"},{"location":"python/vpc/#with-residual-error","title":"With Residual Error","text":"<pre><code># Add residual error model\nerror_spec = {\n    \"kind\": \"combined\",\n    \"sigma_add\": 0.1,\n    \"sigma_prop\": 0.1\n}\n\nvpc_result = openpkpd.compute_vpc(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    config=config,\n    error_spec=error_spec\n)\n</code></pre>"},{"location":"python/vpc/#prediction-corrected-vpc","title":"Prediction-Corrected VPC","text":""},{"location":"python/vpc/#compute_pcvpc","title":"compute_pcvpc","text":"<pre><code>def compute_pcvpc(\n    observed_data: dict[str, Any],\n    population_spec: dict[str, Any],\n    grid: dict[str, Any],\n    config: VPCConfig | None = None,\n    solver: dict[str, Any] | None = None,\n    error_spec: dict[str, Any] | None = None\n) -&gt; VPCResult:\n    \"\"\"\n    Compute prediction-corrected Visual Predictive Check.\n\n    Normalizes observations by population prediction:\n        pcDV = DV \u00d7 (PRED_bin / PRED_individual)\n\n    Use when:\n    - Variable dosing across subjects\n    - Significant covariate effects\n    - Dose escalation studies\n    \"\"\"\n</code></pre>"},{"location":"python/vpc/#usage_1","title":"Usage","text":"<pre><code>from openpkpd.vpc import VPCConfig\n\n# pcVPC for variable-dose study\nconfig = VPCConfig(\n    pi_levels=[0.05, 0.50, 0.95],\n    n_simulations=500\n)\n\npcvpc_result = openpkpd.compute_pcvpc(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    config=config\n)\n\n# Results are prediction-corrected\n# Y-axis represents deviation from population prediction\n</code></pre>"},{"location":"python/vpc/#when-to-use-pcvpc","title":"When to Use pcVPC","text":"Scenario Use pcVPC? Reason Fixed dose study No Standard VPC sufficient Variable dosing Yes Normalize dose differences Weight-based dosing Yes Normalize covariate effects Dose escalation Yes Compare across dose levels Multiple formulations Consider If bioavailability differs"},{"location":"python/vpc/#stratified-vpc","title":"Stratified VPC","text":""},{"location":"python/vpc/#compute_stratified_vpc","title":"compute_stratified_vpc","text":"<pre><code>def compute_stratified_vpc(\n    observed_data: dict[str, Any],\n    population_spec: dict[str, Any],\n    grid: dict[str, Any],\n    strata_data: dict[str, dict[str, Any]],\n    config: VPCConfig | None = None,\n    solver: dict[str, Any] | None = None,\n    error_spec: dict[str, Any] | None = None\n) -&gt; StratifiedVPCResult:\n    \"\"\"\n    Compute stratified Visual Predictive Check.\n\n    Computes separate VPC for each stratum defined by\n    stratification variables.\n\n    Parameters\n    ----------\n    strata_data : dict\n        Maps subject ID to stratum values\n        {\"S1\": {\"DOSE\": \"100mg\"}, \"S2\": {\"DOSE\": \"200mg\"}, ...}\n    \"\"\"\n</code></pre>"},{"location":"python/vpc/#usage_2","title":"Usage","text":"<pre><code>from openpkpd.vpc import VPCConfig\n\n# Define strata for each subject\nstrata_data = {\n    \"S1\": {\"DOSE_GROUP\": \"Low\"},\n    \"S2\": {\"DOSE_GROUP\": \"Low\"},\n    \"S3\": {\"DOSE_GROUP\": \"Medium\"},\n    \"S4\": {\"DOSE_GROUP\": \"Medium\"},\n    \"S5\": {\"DOSE_GROUP\": \"High\"},\n    \"S6\": {\"DOSE_GROUP\": \"High\"},\n    # ...\n}\n\n# Configuration with stratification\nconfig = VPCConfig(\n    stratify_by=[\"DOSE_GROUP\"],\n    pi_levels=[0.05, 0.50, 0.95],\n    n_simulations=500\n)\n\n# Compute stratified VPC\nstratified_result = openpkpd.compute_stratified_vpc(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    strata_data=strata_data,\n    config=config\n)\n\n# Access results by stratum\nfor i, vpc in enumerate(stratified_result.results):\n    stratum = stratified_result.strata_names[i]\n    print(f\"{stratum}: {vpc.n_subjects_observed} subjects\")\n</code></pre>"},{"location":"python/vpc/#multiple-stratification-variables","title":"Multiple Stratification Variables","text":"<pre><code># Stratify by dose AND formulation\nstrata_data = {\n    \"S1\": {\"DOSE\": \"100mg\", \"FORM\": \"tablet\"},\n    \"S2\": {\"DOSE\": \"100mg\", \"FORM\": \"capsule\"},\n    \"S3\": {\"DOSE\": \"200mg\", \"FORM\": \"tablet\"},\n    # ...\n}\n\nconfig = VPCConfig(\n    stratify_by=[\"DOSE\", \"FORM\"],  # Creates combined strata\n    n_simulations=500\n)\n</code></pre>"},{"location":"python/vpc/#vpcresult-structure","title":"VPCResult Structure","text":"<pre><code>@dataclass\nclass VPCResult:\n    \"\"\"Complete VPC computation result.\"\"\"\n    config: VPCConfig                    # Configuration used\n    bins: list[VPCBin]                   # Computed bins\n    n_subjects_observed: int             # Number of subjects\n    n_observations_observed: int         # Total observations\n    n_simulations: int                   # Simulations performed\n    strata: str                          # Strata label\n    simulation_seed: int                 # Seed used\n\n@dataclass\nclass VPCBin:\n    \"\"\"Data for a single time bin.\"\"\"\n    bin_id: int\n    time_min: float\n    time_max: float\n    time_midpoint: float\n    n_observed: int\n    n_simulated: int\n    percentiles: list[VPCPercentileData]\n\n@dataclass\nclass VPCPercentileData:\n    \"\"\"Percentile data within a bin.\"\"\"\n    percentile: float                    # Level (0.05, 0.50, 0.95)\n    observed: float                      # Observed percentile\n    simulated_median: float              # Median of simulated\n    simulated_lower: float               # Lower CI\n    simulated_upper: float               # Upper CI\n\n@dataclass\nclass StratifiedVPCResult:\n    \"\"\"Stratified VPC results.\"\"\"\n    results: list[VPCResult]             # VPC per stratum\n    stratify_by: list[str]               # Stratification variables\n    strata_names: list[str]              # Stratum labels\n</code></pre>"},{"location":"python/vpc/#accessor-functions","title":"Accessor Functions","text":"<p>Convenient functions to extract data from VPCResult:</p> <pre><code>from openpkpd.vpc import (\n    get_bin_midpoints,\n    get_observed_percentile,\n    get_simulated_median,\n    get_simulated_ci\n)\n\n# Extract arrays for plotting\ntimes = get_bin_midpoints(vpc_result)           # np.ndarray of midpoints\nobs_p50 = get_observed_percentile(vpc_result, 0.50)  # Observed median\nsim_p50 = get_simulated_median(vpc_result, 0.50)     # Simulated median\nsim_lo, sim_hi = get_simulated_ci(vpc_result, 0.50)  # CI bounds\n</code></pre>"},{"location":"python/vpc/#pure-python-vpc","title":"Pure Python VPC","text":"<p>For standalone use without Julia:</p> <pre><code>from openpkpd.vpc import compute_vpc_python\n\n# Compute VPC from pre-simulated data\nvpc_result = compute_vpc_python(\n    observed_times=obs_times,           # np.ndarray\n    observed_values=obs_values,         # np.ndarray\n    simulated_data=[                    # List of (times, values) tuples\n        (sim_times_1, sim_values_1),\n        (sim_times_2, sim_values_2),\n        # ... n_simulations tuples\n    ],\n    config=VPCConfig(n_bins=8)\n)\n</code></pre>"},{"location":"python/vpc/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\nfrom openpkpd.vpc import VPCConfig, QuantileBinning\nimport numpy as np\n\n# ================================================\n# Complete VPC Workflow\n# ================================================\n\n# 1. Initialize\nopenpkpd.init_julia()\n\nprint(\"=== VPC Computation Example ===\\n\")\n\n# 2. Generate observed data (from clinical study)\nnp.random.seed(42)\nn_subjects = 50\nsampling_times = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\n\n# Simulate \"observed\" data\nsubject_ids = []\ntimes = []\ndv = []\n\ntrue_ka, true_cl, true_v = 1.5, 5.0, 50.0\nomega_ka, omega_cl, omega_v = 0.16, 0.09, 0.04\ndose = 100.0\n\nfor i in range(n_subjects):\n    # Individual parameters\n    ka_i = true_ka * np.exp(np.random.randn() * np.sqrt(omega_ka))\n    cl_i = true_cl * np.exp(np.random.randn() * np.sqrt(omega_cl))\n    v_i = true_v * np.exp(np.random.randn() * np.sqrt(omega_v))\n\n    for t in sampling_times:\n        # One-compartment oral\n        conc = dose * ka_i / (v_i * (ka_i - cl_i/v_i)) * \\\n               (np.exp(-cl_i/v_i * t) - np.exp(-ka_i * t))\n\n        # Add residual error\n        conc_obs = conc * (1 + 0.1 * np.random.randn())\n        conc_obs = max(0.01, conc_obs)\n\n        subject_ids.append(f\"S{i+1}\")\n        times.append(t)\n        dv.append(conc_obs)\n\nobserved_data = {\n    \"subject_ids\": subject_ids,\n    \"times\": times,\n    \"dv\": dv,\n    \"dvid\": [\"conc\"] * len(dv)\n}\n\nprint(f\"Observed data: {n_subjects} subjects, {len(dv)} observations\")\n\n# 3. Define population model (final estimates)\npopulation_spec = {\n    \"model\": \"OneCompOral\",\n    \"params\": {\"Ka\": true_ka, \"CL\": true_cl, \"V\": true_v},\n    \"omega\": {\"Ka\": omega_ka, \"CL\": omega_cl, \"V\": omega_v},\n    \"doses\": [{\"time\": 0.0, \"amount\": dose}],\n    \"n\": n_subjects\n}\n\ngrid = {\"t0\": 0.0, \"t1\": 24.0, \"saveat\": 0.5}\n\n# 4. Compute standard VPC\nprint(\"\\nComputing standard VPC...\")\nconfig = VPCConfig(\n    pi_levels=[0.05, 0.50, 0.95],\n    binning=QuantileBinning(7),\n    n_simulations=500,\n    seed=42\n)\n\nvpc_result = openpkpd.compute_vpc(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    config=config\n)\n\nprint(f\"  Bins: {len(vpc_result.bins)}\")\nprint(f\"  Simulations: {vpc_result.n_simulations}\")\n\n# 5. Analyze results\nprint(\"\\n--- Bin Analysis ---\")\nfor bin in vpc_result.bins:\n    p50 = next(p for p in bin.percentiles if p.percentile == 0.50)\n    in_ci = p50.simulated_lower &lt;= p50.observed &lt;= p50.simulated_upper\n    status = \"\u2713\" if in_ci else \"\u2717\"\n    print(f\"  t={bin.time_midpoint:5.1f}: obs={p50.observed:6.2f}, \"\n          f\"CI=[{p50.simulated_lower:6.2f}, {p50.simulated_upper:6.2f}] {status}\")\n\n# 6. Compute coverage\ndef compute_coverage(result, level):\n    n_in = sum(\n        1 for bin in result.bins\n        for p in bin.percentiles\n        if p.percentile == level and\n           p.simulated_lower &lt;= p.observed &lt;= p.simulated_upper\n    )\n    return n_in / len(result.bins)\n\nprint(\"\\n--- Coverage ---\")\nfor level in [0.05, 0.50, 0.95]:\n    cov = compute_coverage(vpc_result, level)\n    print(f\"  P{int(level*100)}: {cov*100:.1f}%\")\n\n# 7. Visualize\nviz.set_backend(\"matplotlib\")\nfig = viz.plot_vpc(\n    vpc_result,\n    title=\"Visual Predictive Check\",\n    xlabel=\"Time (hours)\",\n    ylabel=\"Concentration (mg/L)\"\n)\nfig.savefig(\"vpc_result.png\", dpi=300, bbox_inches=\"tight\")\nprint(\"\\nSaved: vpc_result.png\")\n\nprint(\"\\n\u2713 VPC computation complete\")\n</code></pre>"},{"location":"python/vpc/#next-steps","title":"Next Steps","text":"<ul> <li>Binning Strategies - Binning methods and selection</li> <li>BLQ Handling - Below quantification data</li> <li>VPC Visualization - Plotting VPC results</li> <li>Julia VPC - Julia implementation details</li> </ul>"},{"location":"python/vpc/binning/","title":"Binning Strategies","text":"<p>Comprehensive guide to VPC binning methods for optimal time stratification.</p>"},{"location":"python/vpc/binning/#overview","title":"Overview","text":"<p>Binning groups observations by time for percentile calculation. The choice of binning strategy significantly affects VPC interpretability.</p> <pre><code>from openpkpd.vpc import (\n    QuantileBinning,\n    EqualWidthBinning,\n    KMeansBinning,\n    BinDefinition\n)\n\n# Default binning\nbinning = QuantileBinning(10)  # 10 bins with equal obs count\n</code></pre>"},{"location":"python/vpc/binning/#binning-classes","title":"Binning Classes","text":""},{"location":"python/vpc/binning/#quantilebinning","title":"QuantileBinning","text":"<p>Creates bins with approximately equal numbers of observations:</p> <pre><code>from openpkpd.vpc import QuantileBinning\n\n# 10 bins with equal observation count\nbinning = QuantileBinning(n_bins=10)\n\n# Fewer bins for sparse data\nbinning = QuantileBinning(n_bins=5)\n</code></pre> <p>Algorithm: 1. Sort observations by time 2. Divide into n_bins groups with equal count 3. Bin boundaries at group transitions</p> <p>Best for: - Sparse or uneven sampling designs - Rich sampling at specific times - Most population PK studies</p> <p>Properties: - Stable percentile estimates (equal n per bin) - May have uneven time coverage - Robust to outliers</p>"},{"location":"python/vpc/binning/#equalwidthbinning","title":"EqualWidthBinning","text":"<p>Creates bins with equal time ranges:</p> <pre><code>from openpkpd.vpc import EqualWidthBinning\n\n# 10 bins with equal time width\nbinning = EqualWidthBinning(n_bins=10)\n\n# For 24-hour study: each bin covers 2.4 hours\n# Bin 1: 0.0 - 2.4 hr\n# Bin 2: 2.4 - 4.8 hr\n# ...\n</code></pre> <p>Algorithm: 1. Determine time range [t_min, t_max] 2. Divide into n_bins equal intervals 3. Width = (t_max - t_min) / n_bins</p> <p>Best for: - Dense, uniformly sampled data - Steady-state trough sampling - When time coverage matters</p> <p>Properties: - Even time coverage - Variable observations per bin - May have empty bins if sampling sparse</p>"},{"location":"python/vpc/binning/#kmeansbinning","title":"KMeansBinning","text":"<p>Uses k-means clustering to find natural time groupings:</p> <pre><code>from openpkpd.vpc import KMeansBinning\n\n# K-means with 8 clusters\nbinning = KMeansBinning(n_bins=8)\n\n# With custom max iterations\nbinning = KMeansBinning(n_bins=8, max_iter=200)\n</code></pre> <p>Algorithm: 1. Initialize k cluster centers 2. Assign times to nearest center 3. Update centers as cluster means 4. Repeat until convergence or max_iter</p> <p>Best for: - Data with natural time clusters - Sparse PK sampling designs - When observation times cluster naturally</p> <p>Properties: - Adaptive to data structure - May find unintuitive boundaries - Results can vary with initialization</p>"},{"location":"python/vpc/binning/#bindefinition","title":"BinDefinition","text":"<p>Structure representing a computed bin:</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass BinDefinition:\n    \"\"\"Definition of a time bin.\"\"\"\n    bin_id: int              # Bin identifier (1-indexed)\n    time_min: float          # Lower bound (inclusive)\n    time_max: float          # Upper bound (exclusive)\n    time_midpoint: float     # Midpoint for plotting\n</code></pre>"},{"location":"python/vpc/binning/#accessing-bin-definitions","title":"Accessing Bin Definitions","text":"<pre><code>from openpkpd.vpc import compute_bins\n\n# Compute bins from times\ntimes = [0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0]\nbinning = QuantileBinning(5)\nbins = compute_bins(times, binning)\n\nfor bin_def in bins:\n    print(f\"Bin {bin_def.bin_id}: [{bin_def.time_min:.1f}, {bin_def.time_max:.1f})\")\n    print(f\"  Midpoint: {bin_def.time_midpoint:.1f}\")\n</code></pre>"},{"location":"python/vpc/binning/#choosing-binning-strategy","title":"Choosing Binning Strategy","text":""},{"location":"python/vpc/binning/#decision-guide","title":"Decision Guide","text":"Data Characteristic Recommended Binning Reason Sparse sampling QuantileBinning(5-8) Ensures sufficient obs per bin Dense sampling EqualWidthBinning(8-12) Even time coverage Natural clusters KMeansBinning Adaptive to structure Mixed (sparse + dense) QuantileBinning More robust Steady-state only EqualWidthBinning Regular intervals"},{"location":"python/vpc/binning/#sample-size-considerations","title":"Sample Size Considerations","text":"Subjects Obs/Subject Recommended n_bins &lt; 20 5-7 3-5 bins 20-50 5-7 5-7 bins 50-100 5-10 7-10 bins &gt; 100 7-15 8-12 bins <p>Rule of thumb: Minimum 10-20 observations per bin for stable percentiles.</p>"},{"location":"python/vpc/binning/#comparison-example","title":"Comparison Example","text":"<pre><code>from openpkpd.vpc import QuantileBinning, EqualWidthBinning, KMeansBinning\nimport numpy as np\n\n# Sparse PK sampling times (typical clinical design)\ntimes = np.array([\n    # Pre-dose and absorption phase (dense)\n    0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0,\n    # Distribution/elimination phase (sparse)\n    6.0, 8.0, 12.0, 24.0\n] * 50)  # 50 subjects\n\nprint(\"=== Binning Strategy Comparison ===\\n\")\n\n# QuantileBinning\nprint(\"QuantileBinning(7):\")\nfrom openpkpd.vpc import compute_bins\nbins_q = compute_bins(times, QuantileBinning(7))\nfor b in bins_q:\n    n_in_bin = sum(1 for t in times if b.time_min &lt;= t &lt; b.time_max)\n    print(f\"  [{b.time_min:5.1f}, {b.time_max:5.1f}): n={n_in_bin}\")\n\n# EqualWidthBinning\nprint(\"\\nEqualWidthBinning(7):\")\nbins_e = compute_bins(times, EqualWidthBinning(7))\nfor b in bins_e:\n    n_in_bin = sum(1 for t in times if b.time_min &lt;= t &lt; b.time_max)\n    print(f\"  [{b.time_min:5.1f}, {b.time_max:5.1f}): n={n_in_bin}\")\n\n# KMeansBinning\nprint(\"\\nKMeansBinning(7):\")\nbins_k = compute_bins(times, KMeansBinning(7))\nfor b in bins_k:\n    n_in_bin = sum(1 for t in times if b.time_min &lt;= t &lt; b.time_max)\n    print(f\"  [{b.time_min:5.1f}, {b.time_max:5.1f}): n={n_in_bin}\")\n</code></pre> <p>Expected output patterns: - QuantileBinning: Even n per bin, uneven time widths - EqualWidthBinning: Even time widths, highly variable n - KMeansBinning: Adapts to dense early sampling</p>"},{"location":"python/vpc/binning/#advanced-custom-binning","title":"Advanced: Custom Binning","text":"<p>For special requirements, you can create custom bin definitions:</p> <pre><code>from openpkpd.vpc import BinDefinition\n\n# Manual bin boundaries matching sampling design\nmanual_bins = [\n    BinDefinition(1, 0.0, 0.75, 0.375),      # Pre-Cmax\n    BinDefinition(2, 0.75, 2.5, 1.625),      # Around Cmax\n    BinDefinition(3, 2.5, 5.0, 3.75),        # Early elimination\n    BinDefinition(4, 5.0, 10.0, 7.5),        # Mid elimination\n    BinDefinition(5, 10.0, 25.0, 17.5),      # Terminal phase\n]\n\n# Use in VPC computation\n# (Implementation depends on VPC function accepting custom bins)\n</code></pre>"},{"location":"python/vpc/binning/#bin-boundary-recommendations","title":"Bin Boundary Recommendations","text":"Sampling Design Suggested Boundaries Rich PK (0-24h) 0, 0.5, 1, 2, 4, 8, 12, 24 Sparse PK 0, 2, 8, 24 Steady-state QD 0, 4, 8, 12, 16, 20, 24 Steady-state BID 0, 2, 4, 6, 8, 10, 12"},{"location":"python/vpc/binning/#binning-effect-on-vpc","title":"Binning Effect on VPC","text":""},{"location":"python/vpc/binning/#too-few-bins","title":"Too Few Bins","text":"<pre><code>Problem: Wide time ranges, mixed populations\nVisual: Smooth but may miss local misfit\nRisk: Masks time-varying model errors\n</code></pre>"},{"location":"python/vpc/binning/#too-many-bins","title":"Too Many Bins","text":"<pre><code>Problem: Few observations per bin\nVisual: Noisy percentiles, wide CIs\nRisk: False positive model misfit\n</code></pre>"},{"location":"python/vpc/binning/#optimal-binning","title":"Optimal Binning","text":"<pre><code>Goal: Balance precision and resolution\nTarget: 15-30 observations per bin (minimum 10)\nVisual: Clear percentile trends, reasonable CI width\n</code></pre>"},{"location":"python/vpc/binning/#visualization","title":"Visualization","text":"<pre><code>from openpkpd import viz\nfrom openpkpd.vpc import VPCConfig, QuantileBinning, EqualWidthBinning\nimport matplotlib.pyplot as plt\n\n# Compare VPCs with different binning\nconfigs = [\n    (\"Quantile (5 bins)\", VPCConfig(binning=QuantileBinning(5))),\n    (\"Quantile (10 bins)\", VPCConfig(binning=QuantileBinning(10))),\n    (\"Equal Width (10 bins)\", VPCConfig(binning=EqualWidthBinning(10))),\n]\n\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\nfor ax, (name, config) in zip(axes, configs):\n    vpc_result = openpkpd.compute_vpc(\n        observed_data=observed_data,\n        population_spec=pop_spec,\n        grid=grid,\n        config=config\n    )\n    plt.sca(ax)\n    viz.plot_vpc(vpc_result, title=name)\n\nplt.tight_layout()\nplt.savefig(\"binning_comparison.png\", dpi=300)\n</code></pre>"},{"location":"python/vpc/binning/#best-practices","title":"Best Practices","text":"<ol> <li>Start with QuantileBinning - Most robust choice</li> <li>Match bins to sampling - Consider nominal times</li> <li>Check observations per bin - Minimum 10-20</li> <li>Avoid empty bins - Reduce n_bins if needed</li> <li>Use VPC CI plot - Visualize bin boundaries</li> </ol> <pre><code># Recommended workflow\nfrom openpkpd.vpc import VPCConfig, QuantileBinning\n\n# 1. Estimate optimal bins\nn_obs = len(observed_data[\"times\"])\nn_bins = max(5, min(12, n_obs // 50))  # ~50 obs per bin\n\n# 2. Configure VPC\nconfig = VPCConfig(\n    binning=QuantileBinning(n_bins),\n    n_simulations=500\n)\n\n# 3. Compute and visualize\nvpc_result = openpkpd.compute_vpc(...)\nfig = viz.plot_vpc_ci(vpc_result, show_bin_boundaries=True)\n</code></pre>"},{"location":"python/vpc/binning/#see-also","title":"See Also","text":"<ul> <li>VPC Index - VPC overview</li> <li>BLQ Handling - Below quantification data</li> <li>VPC Visualization - Plotting options</li> </ul>"},{"location":"python/vpc/blq/","title":"BLQ Handling","text":"<p>Comprehensive guide to handling Below Limit of Quantification (BLQ) data in VPC.</p>"},{"location":"python/vpc/blq/#overview","title":"Overview","text":"<p>BLQ observations occur when drug concentrations fall below the assay's Lower Limit of Quantification (LLOQ). Proper handling is essential for accurate VPC interpretation.</p> <pre><code>from openpkpd.vpc import BLQMethod, handle_blq\nfrom openpkpd import compute_vpc_with_blq\n\n# Compute VPC with BLQ handling\nvpc_result, blq_stats = compute_vpc_with_blq(\n    observed_data=observed,\n    population_spec=pop_spec,\n    grid=grid,\n    config={\"lloq\": 0.1}  # LLOQ = 0.1 mg/L\n)\n</code></pre>"},{"location":"python/vpc/blq/#blq-methods","title":"BLQ Methods","text":"<p>Seven methods for handling BLQ data (Beal 2001):</p> <pre><code>from openpkpd.vpc import BLQMethod\n\nclass BLQMethod(Enum):\n    M1 = \"M1\"  # Discard all BLQ\n    M3 = \"M3\"  # Treat as censored (keep original)\n    M4 = \"M4\"  # Replace with LLOQ/2\n    M5 = \"M5\"  # 0 before Tmax, LLOQ/2 after\n    M6 = \"M6\"  # LLOQ/2 before Tmax, discard after\n    M7 = \"M7\"  # 0 before Tmax, discard after\n</code></pre>"},{"location":"python/vpc/blq/#method-comparison","title":"Method Comparison","text":"Method Before Tmax After Tmax Use Case M1 Discard Discard Simple exclusion M3 Keep original Keep original Censored likelihood M4 LLOQ/2 LLOQ/2 Default, general use M5 0 LLOQ/2 Pre-dose zeros expected M6 LLOQ/2 Discard Late BLQ uninformative M7 0 Discard Strict late exclusion"},{"location":"python/vpc/blq/#method-selection-guide","title":"Method Selection Guide","text":"<pre><code># General recommendation\nblq_method = BLQMethod.M4  # LLOQ/2 substitution\n\n# When pre-dose should be zero\nblq_method = BLQMethod.M5  # or M7\n\n# When late-phase BLQ is uninformative\nblq_method = BLQMethod.M6  # or M7\n\n# For censored likelihood estimation\nblq_method = BLQMethod.M3  # Keep for special handling\n</code></pre>"},{"location":"python/vpc/blq/#handle_blq-function","title":"handle_blq Function","text":"<p>Apply BLQ handling to concentration data:</p> <pre><code>from openpkpd.vpc import handle_blq, BLQMethod\nimport numpy as np\n\ndef handle_blq(\n    values: np.ndarray,\n    times: np.ndarray,\n    lloq: float,\n    method: BLQMethod = BLQMethod.M4,\n    tmax: float | None = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Handle BLQ observations.\n\n    Parameters\n    ----------\n    values : np.ndarray\n        Concentration values\n    times : np.ndarray\n        Observation times\n    lloq : float\n        Lower limit of quantification\n    method : BLQMethod\n        BLQ handling method\n    tmax : float, optional\n        Time of maximum concentration (auto-detected if None)\n\n    Returns\n    -------\n    np.ndarray\n        Handled values (NaN for discarded, modified for others)\n    \"\"\"\n</code></pre>"},{"location":"python/vpc/blq/#usage","title":"Usage","text":"<pre><code>from openpkpd.vpc import handle_blq, BLQMethod\nimport numpy as np\n\n# Sample data with BLQ\ntimes = np.array([0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0])\nvalues = np.array([0.05, 2.5, 5.0, 3.2, 1.5, 0.8, 0.3, 0.08])\nlloq = 0.1\n\n# Original BLQ values\nblq_mask = values &lt; lloq\nprint(f\"BLQ observations: {times[blq_mask]}\")  # [0.0, 24.0]\n\n# Method M4: Replace with LLOQ/2\nvalues_m4 = handle_blq(values, times, lloq, BLQMethod.M4)\nprint(f\"M4 result: {values_m4}\")\n# [0.05, 2.5, 5.0, 3.2, 1.5, 0.8, 0.3, 0.05]\n\n# Method M5: 0 before Tmax, LLOQ/2 after\nvalues_m5 = handle_blq(values, times, lloq, BLQMethod.M5)\nprint(f\"M5 result: {values_m5}\")\n# [0.0, 2.5, 5.0, 3.2, 1.5, 0.8, 0.3, 0.05]\n\n# Method M7: 0 before Tmax, discard after\nvalues_m7 = handle_blq(values, times, lloq, BLQMethod.M7)\nprint(f\"M7 result: {values_m7}\")\n# [0.0, 2.5, 5.0, 3.2, 1.5, 0.8, 0.3, nan]\n</code></pre>"},{"location":"python/vpc/blq/#compute_vpc_with_blq","title":"compute_vpc_with_blq","text":"<p>Compute VPC with BLQ statistics:</p> <pre><code>from openpkpd import compute_vpc_with_blq\nfrom openpkpd.vpc import VPCConfig, BLQMethod\n\ndef compute_vpc_with_blq(\n    observed_data: dict,\n    population_spec: dict,\n    grid: dict,\n    config: VPCConfig | None = None,\n    solver: dict | None = None,\n    error_spec: dict | None = None,\n    blq_method: BLQMethod = BLQMethod.M4\n) -&gt; tuple[VPCResult, list[BLQBinStats]]:\n    \"\"\"\n    Compute VPC with BLQ handling.\n\n    Returns\n    -------\n    vpc_result : VPCResult\n        Standard VPC result\n    blq_stats : list[BLQBinStats]\n        BLQ statistics per bin\n    \"\"\"\n</code></pre>"},{"location":"python/vpc/blq/#usage_1","title":"Usage","text":"<pre><code>import openpkpd\nfrom openpkpd.vpc import VPCConfig, BLQMethod\n\nopenpkpd.init_julia()\n\n# Configuration with LLOQ\nconfig = VPCConfig(\n    lloq=0.1,                    # 0.1 mg/L\n    pi_levels=[0.05, 0.50, 0.95],\n    n_simulations=500\n)\n\n# Compute VPC with BLQ\nvpc_result, blq_stats = openpkpd.compute_vpc_with_blq(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    config=config,\n    blq_method=BLQMethod.M4\n)\n\n# Access BLQ statistics\nfor stat in blq_stats:\n    print(f\"Bin {stat.bin_id}:\")\n    print(f\"  Total: {stat.n_total}\")\n    print(f\"  BLQ: {stat.n_blq} ({stat.pct_blq_observed:.1f}%)\")\n    print(f\"  Sim BLQ: {stat.pct_blq_simulated_median:.1f}% \"\n          f\"[{stat.pct_blq_simulated_lower:.1f}, {stat.pct_blq_simulated_upper:.1f}]\")\n</code></pre>"},{"location":"python/vpc/blq/#blqbinstats-structure","title":"BLQBinStats Structure","text":"<pre><code>from dataclasses import dataclass\n\n@dataclass\nclass BLQBinStats:\n    \"\"\"BLQ statistics for a time bin.\"\"\"\n    bin_id: int                          # Bin identifier\n    n_total: int                         # Total observations in bin\n    n_blq: int                           # Number of BLQ observations\n    pct_blq_observed: float              # Observed %BLQ\n    pct_blq_simulated_median: float      # Simulated median %BLQ\n    pct_blq_simulated_lower: float       # Lower CI bound\n    pct_blq_simulated_upper: float       # Upper CI bound\n</code></pre>"},{"location":"python/vpc/blq/#accessing-blq-data","title":"Accessing BLQ Data","text":"<pre><code>from openpkpd.vpc import get_blq_observed, get_blq_simulated\n\n# Extract BLQ data for plotting\nblq_obs = get_blq_observed(vpc_result)  # np.ndarray of observed %BLQ\nblq_sim_med, blq_sim_lo, blq_sim_hi = get_blq_simulated(vpc_result)\n</code></pre>"},{"location":"python/vpc/blq/#visualization","title":"Visualization","text":""},{"location":"python/vpc/blq/#vpc-with-blq-panel","title":"VPC with BLQ Panel","text":"<pre><code>from openpkpd import viz\n\n# Two-panel plot: VPC + BLQ fraction\nfig = viz.plot_vpc_with_blq(\n    vpc_result,\n    blq_stats=blq_stats,\n    title=\"VPC with BLQ Analysis\",\n    blq_ylabel=\"% Below LOQ\",\n    figsize=(10, 8)\n)\n\nfig.savefig(\"vpc_blq.png\", dpi=300)\n</code></pre>"},{"location":"python/vpc/blq/#custom-blq-plot","title":"Custom BLQ Plot","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create BLQ comparison plot\nfig, ax = plt.subplots(figsize=(10, 4))\n\ntimes = [stat.bin_id for stat in blq_stats]  # Or use midpoints\nobs_blq = [stat.pct_blq_observed for stat in blq_stats]\nsim_med = [stat.pct_blq_simulated_median for stat in blq_stats]\nsim_lo = [stat.pct_blq_simulated_lower for stat in blq_stats]\nsim_hi = [stat.pct_blq_simulated_upper for stat in blq_stats]\n\n# Simulated CI ribbon\nax.fill_between(times, sim_lo, sim_hi, alpha=0.3, color='blue', label='Sim 95% CI')\nax.plot(times, sim_med, 'b--', label='Sim Median')\nax.plot(times, obs_blq, 'ko-', label='Observed')\n\nax.set_xlabel('Bin')\nax.set_ylabel('% BLQ')\nax.set_title('BLQ Fraction Comparison')\nax.legend()\nax.set_ylim(0, max(max(sim_hi), max(obs_blq)) * 1.1)\n\nplt.tight_layout()\nplt.savefig(\"blq_comparison.png\", dpi=300)\n</code></pre>"},{"location":"python/vpc/blq/#interpretation","title":"Interpretation","text":""},{"location":"python/vpc/blq/#good-model-fit","title":"Good Model Fit","text":"<pre><code>\u2713 Observed %BLQ within simulated CI\n\u2713 Similar %BLQ patterns over time\n\u2713 No systematic over/under-prediction of BLQ\n</code></pre>"},{"location":"python/vpc/blq/#potential-issues","title":"Potential Issues","text":"Pattern Interpretation Action Obs %BLQ &gt; Sim CI Model over-predicts concentrations Check elimination model Obs %BLQ &lt; Sim CI Model under-predicts concentrations Check absorption/bioavailability Early BLQ mismatch Pre-systemic or lag issues Consider lag time model Late BLQ mismatch Terminal phase misspecification Check terminal half-life"},{"location":"python/vpc/blq/#complete-example","title":"Complete Example","text":"<pre><code>import openpkpd\nfrom openpkpd import viz\nfrom openpkpd.vpc import VPCConfig, BLQMethod, handle_blq\nimport numpy as np\n\n# ================================================\n# VPC with BLQ Handling Example\n# ================================================\n\nopenpkpd.init_julia()\n\nprint(\"=== VPC with BLQ Analysis ===\\n\")\n\n# 1. Generate data with BLQ\nnp.random.seed(42)\nn_subjects = 60\nlloq = 0.5  # mg/L\n\n# Simulate concentrations\ntimes_per_subj = [0.0, 0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 24.0, 36.0, 48.0]\nsubject_ids = []\ntimes = []\ndv = []\n\ntrue_ka, true_cl, true_v = 1.2, 8.0, 60.0\ndose = 100.0\n\nfor i in range(n_subjects):\n    ka_i = true_ka * np.exp(0.4 * np.random.randn())\n    cl_i = true_cl * np.exp(0.3 * np.random.randn())\n    v_i = true_v * np.exp(0.2 * np.random.randn())\n\n    for t in times_per_subj:\n        if t == 0:\n            conc = 0.0\n        else:\n            conc = dose * ka_i / (v_i * (ka_i - cl_i/v_i)) * \\\n                   (np.exp(-cl_i/v_i * t) - np.exp(-ka_i * t))\n\n        conc_obs = conc * (1 + 0.15 * np.random.randn())\n        conc_obs = max(0.0, conc_obs)\n\n        subject_ids.append(f\"S{i+1}\")\n        times.append(t)\n        dv.append(conc_obs)\n\n# Count BLQ\nn_blq = sum(1 for c in dv if c &lt; lloq)\nprint(f\"Total observations: {len(dv)}\")\nprint(f\"BLQ observations: {n_blq} ({100*n_blq/len(dv):.1f}%)\")\nprint(f\"LLOQ: {lloq} mg/L\")\n\n# 2. Prepare observed data\nobserved_data = {\n    \"subject_ids\": subject_ids,\n    \"times\": times,\n    \"dv\": dv,\n    \"dvid\": [\"conc\"] * len(dv)\n}\n\n# 3. Population model\npopulation_spec = {\n    \"model\": \"OneCompOral\",\n    \"params\": {\"Ka\": true_ka, \"CL\": true_cl, \"V\": true_v},\n    \"omega\": {\"Ka\": 0.16, \"CL\": 0.09, \"V\": 0.04},\n    \"doses\": [{\"time\": 0.0, \"amount\": dose}],\n    \"n\": n_subjects\n}\n\ngrid = {\"t0\": 0.0, \"t1\": 48.0, \"saveat\": 0.5}\n\n# 4. VPC configuration with LLOQ\nconfig = VPCConfig(\n    lloq=lloq,\n    pi_levels=[0.05, 0.50, 0.95],\n    n_simulations=500,\n    seed=42\n)\n\n# 5. Compute VPC with BLQ handling\nprint(\"\\nComputing VPC with BLQ handling (M4)...\")\nvpc_result, blq_stats = openpkpd.compute_vpc_with_blq(\n    observed_data=observed_data,\n    population_spec=population_spec,\n    grid=grid,\n    config=config,\n    blq_method=BLQMethod.M4\n)\n\n# 6. Report BLQ statistics\nprint(\"\\n--- BLQ Statistics by Bin ---\")\nprint(\"Bin | Time Range  | N Tot | N BLQ | Obs%BLQ | Sim%BLQ CI\")\nprint(\"-\" * 70)\n\nfor stat in blq_stats:\n    bin_vpc = vpc_result.bins[stat.bin_id - 1]\n    time_range = f\"[{bin_vpc.time_min:5.1f}, {bin_vpc.time_max:5.1f}]\"\n    ci_str = f\"[{stat.pct_blq_simulated_lower:4.1f}, {stat.pct_blq_simulated_upper:4.1f}]\"\n\n    # Check if observed within CI\n    in_ci = stat.pct_blq_simulated_lower &lt;= stat.pct_blq_observed &lt;= stat.pct_blq_simulated_upper\n    status = \"\u2713\" if in_ci else \"\u2717\"\n\n    print(f\"{stat.bin_id:3} | {time_range} | {stat.n_total:5} | {stat.n_blq:5} | \"\n          f\"{stat.pct_blq_observed:6.1f}% | {ci_str} {status}\")\n\n# 7. Assess overall BLQ handling\nprint(\"\\n--- BLQ Assessment ---\")\nn_bins_ok = sum(\n    1 for stat in blq_stats\n    if stat.pct_blq_simulated_lower &lt;= stat.pct_blq_observed &lt;= stat.pct_blq_simulated_upper\n)\nprint(f\"Bins with BLQ within CI: {n_bins_ok}/{len(blq_stats)}\")\n\n# 8. Visualize\nviz.set_backend(\"matplotlib\")\nfig = viz.plot_vpc_with_blq(\n    vpc_result,\n    blq_stats=blq_stats,\n    title=f\"VPC with BLQ (LLOQ={lloq} mg/L, M4)\",\n    blq_ylabel=\"% Below LOQ\"\n)\nfig.savefig(\"vpc_with_blq.png\", dpi=300, bbox_inches=\"tight\")\nprint(\"\\nSaved: vpc_with_blq.png\")\n\nprint(\"\\n\u2713 BLQ analysis complete\")\n</code></pre>"},{"location":"python/vpc/blq/#references","title":"References","text":"<ul> <li>Beal SL. Ways to fit a PK model with some data below the quantification limit. J Pharmacokinet Pharmacodyn. 2001;28(5):481-504.</li> <li>Bergstrand M, Karlsson MO. Handling data below the limit of quantification in mixed effect models. AAPS J. 2009;11(2):371-380.</li> </ul>"},{"location":"python/vpc/blq/#see-also","title":"See Also","text":"<ul> <li>VPC Index - VPC overview</li> <li>Binning Strategies - Binning methods</li> <li>VPC Visualization - Plot options</li> <li>Julia VPC - Julia implementation</li> </ul>"},{"location":"reference/glossary/","title":"Glossary","text":"<p>Common pharmacometrics and OpenPKPD terminology.</p>"},{"location":"reference/glossary/#a","title":"A","text":"<p>Absorption Rate Constant (Ka) : First-order rate constant describing the rate of drug absorption from the gut to systemic circulation. Units: 1/h.</p> <p>AUC (Area Under the Curve) : Total drug exposure over time, calculated as the integral of concentration over time. Units: mg\u00b7h/L.</p> <p>AUC0-t : Area under the concentration-time curve from time zero to the last measurable concentration.</p> <p>AUC0-inf : Area under the concentration-time curve extrapolated to infinity.</p>"},{"location":"reference/glossary/#b","title":"B","text":"<p>Bioavailability (F) : Fraction of administered dose that reaches systemic circulation unchanged. Range: 0-1.</p> <p>Bioequivalence (BE) : Demonstration that two formulations have similar bioavailability within defined limits (typically 80-125% for the 90% CI of the geometric mean ratio).</p> <p>BLQ (Below Limit of Quantification) : Concentration measurement below the lower limit of quantification of the analytical assay.</p>"},{"location":"reference/glossary/#c","title":"C","text":"<p>Clearance (CL) : Volume of plasma from which drug is completely removed per unit time. Units: L/h.</p> <p>Cmax : Maximum observed concentration. Units: mg/L.</p> <p>Compartment : Theoretical space in which drug is assumed to distribute uniformly and instantaneously.</p> <p>CWRES (Conditional Weighted Residuals) : Residuals weighted by the conditional variance, used for model diagnostics.</p>"},{"location":"reference/glossary/#d","title":"D","text":"<p>Distribution : Process by which drug reversibly transfers between blood and tissues.</p> <p>Dose Event : A single drug administration with time, amount, and optional duration (for infusions).</p>"},{"location":"reference/glossary/#e","title":"E","text":"<p>EBE (Empirical Bayes Estimate) : Individual parameter estimates derived using Bayesian estimation with population parameters as priors.</p> <p>EC50 : Concentration producing 50% of maximum effect. Units: mg/L.</p> <p>Effect Compartment : Hypothetical compartment representing the site of drug action, used to model PK-PD delays.</p> <p>Emax : Maximum achievable drug effect.</p> <p>Eta (\u03b7) : Random effect representing individual deviation from the typical population parameter value.</p>"},{"location":"reference/glossary/#f","title":"F","text":"<p>FOCE (First-Order Conditional Estimation) : NLME estimation method that linearizes the model around individual parameter estimates.</p> <p>FOCE-I (FOCE with Interaction) : FOCE method that accounts for the interaction between random effects and residual error.</p>"},{"location":"reference/glossary/#g","title":"G","text":"<p>Gamma (\u03b3) : Hill coefficient in the sigmoid Emax model, controlling the steepness of the concentration-response curve.</p>"},{"location":"reference/glossary/#h","title":"H","text":"<p>Half-life (t\u00bd) : Time required for drug concentration to decrease by 50%. Calculated as ln(2)/\u03bbz.</p> <p>Hill Coefficient : See Gamma.</p>"},{"location":"reference/glossary/#i","title":"I","text":"<p>IIV (Inter-Individual Variability) : Random variability in pharmacokinetic or pharmacodynamic parameters between subjects in a population.</p> <p>Indirect Response Model : PD model where drug affects the rate of production or elimination of a response variable rather than the response directly.</p> <p>IOV (Inter-Occasion Variability) : Random variability in parameters within the same subject across different occasions.</p>"},{"location":"reference/glossary/#k","title":"K","text":"<p>Km (Michaelis Constant) : Concentration at which the elimination rate is half of Vmax in saturable kinetics. Units: mg/L.</p>"},{"location":"reference/glossary/#l","title":"L","text":"<p>Lambda_z (\u03bbz) : Terminal elimination rate constant, estimated from the terminal log-linear phase of the concentration-time curve. Units: 1/h.</p> <p>LLOQ (Lower Limit of Quantification) : Lowest concentration that can be reliably measured with acceptable precision and accuracy.</p>"},{"location":"reference/glossary/#m","title":"M","text":"<p>MRT (Mean Residence Time) : Average time a drug molecule spends in the body. Calculated as AUMC/AUC.</p> <p>Michaelis-Menten : Nonlinear elimination kinetics characterized by Vmax and Km, where elimination rate saturates at high concentrations.</p>"},{"location":"reference/glossary/#n","title":"N","text":"<p>NCA (Non-Compartmental Analysis) : Model-independent method for calculating PK parameters directly from concentration-time data.</p> <p>NLME (Nonlinear Mixed Effects) : Statistical framework for analyzing population data with both fixed and random effects.</p> <p>NPDE (Normalized Prediction Distribution Errors) : Diagnostic metric based on the cumulative distribution of observations relative to simulations.</p>"},{"location":"reference/glossary/#o","title":"O","text":"<p>OFV (Objective Function Value) : Negative twice the log-likelihood; minimized during parameter estimation. Lower is better for nested models.</p> <p>Omega (\u03a9) : Variance-covariance matrix of inter-individual random effects.</p>"},{"location":"reference/glossary/#p","title":"P","text":"<p>pcVPC (Prediction-Corrected VPC) : VPC variant that corrects predictions for differences in independent variables across bins.</p> <p>Population PK : Approach to characterize typical PK parameters and their variability in a population.</p>"},{"location":"reference/glossary/#q","title":"Q","text":"<p>Q (Inter-compartmental Clearance) : Rate of drug transfer between compartments. Units: L/h.</p>"},{"location":"reference/glossary/#r","title":"R","text":"<p>Residual Error : Unexplained variability between model predictions and observations, including measurement error and model misspecification.</p> <p>RSE (Relative Standard Error) : Standard error expressed as a percentage of the parameter estimate.</p>"},{"location":"reference/glossary/#s","title":"S","text":"<p>SAEM (Stochastic Approximation EM) : NLME estimation algorithm using stochastic approximation for robust parameter estimation.</p> <p>Shrinkage : Phenomenon where individual parameter estimates are pulled toward population values due to limited individual data.</p> <p>Sigma (\u03c3) : Variance of residual error.</p>"},{"location":"reference/glossary/#t","title":"T","text":"<p>Theta (\u03b8) : Fixed-effect (typical population) parameter values.</p> <p>Tmax : Time at which Cmax occurs. Units: h.</p> <p>TMDD (Target-Mediated Drug Disposition) : PK behavior where drug binding to target significantly affects its disposition.</p> <p>Transit Compartment : Series of compartments used to model delayed or complex absorption processes.</p>"},{"location":"reference/glossary/#v","title":"V","text":"<p>Vmax : Maximum rate of saturable elimination. Units: mg/h.</p> <p>Volume of Distribution (V) : Apparent volume into which drug distributes at steady state. Units: L.</p> <p>VPC (Visual Predictive Check) : Graphical method for assessing model adequacy by comparing observed data percentiles to simulated prediction intervals.</p> <p>Vss (Volume of Distribution at Steady State) : Volume relating amount of drug in body to plasma concentration at steady state.</p>"},{"location":"reference/glossary/#w","title":"W","text":"<p>Washout Period : Time between treatment periods in crossover studies to allow drug elimination before the next period.</p>"},{"location":"reference/glossary/#abbreviations","title":"Abbreviations","text":"Abbreviation Full Term AUC Area Under the Curve BE Bioequivalence BID Twice Daily BLQ Below Limit of Quantification CDISC Clinical Data Interchange Standards Consortium CI Confidence Interval CL Clearance CV Coefficient of Variation EBE Empirical Bayes Estimate FDA Food and Drug Administration FOCE First-Order Conditional Estimation GOF Goodness of Fit IIV Inter-Individual Variability IOV Inter-Occasion Variability IV Intravenous NCA Non-Compartmental Analysis NLME Nonlinear Mixed Effects NPDE Normalized Prediction Distribution Error ODE Ordinary Differential Equation OFV Objective Function Value PD Pharmacodynamics PK Pharmacokinetics QD Once Daily RSE Relative Standard Error SAEM Stochastic Approximation EM SDTM Study Data Tabulation Model SE Standard Error TID Three Times Daily TMDD Target-Mediated Drug Disposition TOST Two One-Sided Tests VPC Visual Predictive Check"}]}